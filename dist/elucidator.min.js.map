{"version":3,"sources":["node_modules/browser-pack/_prelude.js","node_modules/decimal.js/decimal.js","elucidator.min.js","node_modules/manyfest/source/Manyfest-HashTranslation.js","node_modules/manyfest/source/Manyfest-LogToConsole.js","node_modules/manyfest/source/Manyfest-ObjectAddressGeneration.js","node_modules/manyfest/source/Manyfest-ObjectAddressResolver.js","node_modules/manyfest/source/Manyfest-SchemaManipulation.js","node_modules/manyfest/source/Manyfest.js","node_modules/precedent/source/Precedent.js","node_modules/precedent/source/StringParser.js","node_modules/precedent/source/WordTree.js","source/Elucidator-Browser-Shim.js","source/Elucidator-InstructionSet.js","source/Elucidator-LogToConsole.js","source/Elucidator.js","source/InstructionSets/Geometry.js","source/InstructionSets/Logic.js","source/InstructionSets/Math-Javascript.js","source/InstructionSets/Operations/Geometry-RectangleArea.json","source/InstructionSets/Operations/Logic-Execute.json","source/InstructionSets/Operations/Logic-If.json","source/InstructionSets/Operations/Math-Add.json","source/InstructionSets/Operations/Math-Aggregate.json","source/InstructionSets/Operations/Math-Divide.json","source/InstructionSets/Operations/Math-Multiply.json","source/InstructionSets/Operations/Math-Subtract.json","source/InstructionSets/Operations/PreciseMath-Add.json","source/InstructionSets/Operations/PreciseMath-Aggregate.json","source/InstructionSets/Operations/PreciseMath-Divide.json","source/InstructionSets/Operations/PreciseMath-Multiply.json","source/InstructionSets/Operations/PreciseMath-Subtract.json","source/InstructionSets/Operations/String-Replace.json","source/InstructionSets/Operations/String-Substring.json","source/InstructionSets/Operations/String-Trim.json","source/InstructionSets/PreciseMath-Decimal.js","source/InstructionSets/String.js"],"names":["f","exports","module","define","amd","window","global","self","this","Elucidator","r","e","n","t","o","i","c","require","u","a","Error","code","p","call","length","globalScope","Decimal","inexact","noConflict","quadrant","EXP_LIMIT","MAX_DIGITS","NUMERALS","LN10","PI","DEFAULTS","precision","rounding","modulo","toExpNeg","toExpPos","minE","maxE","crypto","external","decimalError","invalidArgument","precisionLimitExceeded","cryptoUnavailable","tag","mathfloor","Math","floor","mathpow","pow","isBinary","isHex","isOctal","isDecimal","BASE","LN10_PRECISION","PI_PRECISION","P","toStringTag","digitsToString","d","k","ws","indexOfLastWord","str","w","getZeroString","checkInt32","min","max","checkRoundingDigits","rm","repeating","di","rd","ceil","convertBase","baseIn","baseOut","j","arrL","arr","strL","indexOf","charAt","reverse","absoluteValue","abs","x","constructor","s","finalise","clampedTo","clamp","Ctor","NaN","gt","cmp","comparedTo","y","xdL","ydL","xd","yd","xs","ys","cosine","cos","pr","sd","len","isZero","tinyPow","toString","taylorSeries","times","cos2x","minus","plus","toLessThanHalfPi","neg","cubeRoot","cbrt","m","rep","t3","t3plusx","isFinite","toExponential","slice","divide","eq","decimalPlaces","dp","dividedBy","div","dividedToIntegerBy","divToInt","equals","greaterThan","greaterThanOrEqualTo","gte","hyperbolicCosine","cosh","one","cosh2_x","d8","hyperbolicSine","sinh","sqrt","sinh2_x","d5","d16","d20","hyperbolicTangent","tanh","inverseCosine","acos","halfPi","isNeg","getPi","asin","inverseHyperbolicCosine","acosh","lte","ln","inverseHyperbolicSine","asinh","inverseHyperbolicTangent","atanh","wpr","xsd","inverseSine","atan","inverseTangent","px","x2","isInteger","isInt","isNaN","isNegative","isPositive","isPos","lessThan","lt","lessThanOrEqualTo","logarithm","log","base","isBase10","denominator","inf","num","arg","naturalLogarithm","getLn10","sub","xe","xLTy","push","pop","shift","getBase10Exponent","mod","q","naturalExponential","exp","negated","add","carry","unshift","z","getPrecision","round","sine","sin","sin2_x","squareRoot","tangent","tan","mul","rL","toBinary","toStringBinary","toDecimalPlaces","toDP","finiteToString","toFixed","toFraction","maxD","d0","d1","d2","n0","n1","toHexadecimal","toHex","toNearest","toNumber","toOctal","toPower","yn","intPow","toPrecision","toSignificantDigits","toSD","truncated","trunc","valueOf","toJSON","multiplyInteger","temp","compare","b","aL","bL","subtract","logBase","more","prod","prodL","qd","rem","remL","rem0","xi","xL","yd0","yL","yz","sign","isTruncated","digits","roundUp","xdi","out","isExp","nonFiniteToString","zs","truncate","isOdd","maxOrMin","args","ltgt","guard","sum","c0","numerator","x1","String","parseDecimal","replace","search","substring","charCodeAt","parseOther","divisor","isFloat","test","toLowerCase","isHyperbolic","pi","atan2","config","obj","v","useDefaults","defaults","ps","getRandomValues","randomBytes","hypot","arguments","isDecimalInstance","log2","log10","random","Uint32Array","copy","clone","prototype","ROUND_UP","ROUND_DOWN","ROUND_CEIL","ROUND_FLOOR","ROUND_HALF_UP","ROUND_HALF_DOWN","ROUND_HALF_EVEN","ROUND_HALF_CEIL","ROUND_HALF_FLOOR","EUCLID","set","hasOwnProperty","Symbol","iterator","libSimpleLog","pInfoLog","pErrorLog","logInfo","logError","translationTable","translationCount","Object","keys","addTranslation","pTranslation","forEach","pTranslationSource","removeTranslationHash","pTranslationHash","removeTranslation","clearTranslations","translate","pLogLine","pLogObject","tmpLogLine","console","JSON","stringify","generateAddressses","pObject","pBaseAddress","pSchema","tmpBaseAddress","tmpSchema","tmpSchemaObjectEntry","Address","Hash","Name","InSchema","DataType","Default","Array","isArray","tmpObjectProperties","cleanWrapCharacters","pCharacter","pString","startsWith","endsWith","checkAddressExists","pAddress","tmpSeparatorIndex","tmpBracketStartIndex","tmpBracketStopIndex","tmpBoxedPropertyName","trim","tmpBoxedPropertyReference","tmpBoxedPropertyNumber","parseInt","tmpSubObjectName","tmpNewAddress","getValueAtAddress","pParentAddress","tmpParentAddress","tmpObjectTypeMarkerIndex","tmpObjectPropertyName","tmpArrayProperty","tmpContainerObject","tmpPropertyParentAddress","tmpValue","tmpObjectProperty","tmpObjectPropertyKeys","setValueAtAddress","pValue","resolveAddressMappings","pManyfestSchemaDescriptors","pAddressMapping","tmpManyfestAddresses","tmpHashMapping","pInputAddress","tmpNewDescriptorAddress","tmpOldDescriptorAddress","tmpDescriptor","safeResolveAddressMappings","tmpManyfestSchemaDescriptors","parse","mergeAddressMappings","pManyfestSchemaDescriptorsDestination","pManyfestSchemaDescriptorsSource","tmpSource","tmpNewManyfestSchemaDescriptors","pDescriptorAddress","libHashTranslation","libObjectAddressResolver","libObjectAddressGeneration","libSchemaManipulation","Manyfest","pManifest","pOptions","objectAddressResolver","options","strict","defaultValues","Number","Float","Integer","Boolean","Binary","DateTime","Null","scope","undefined","elementAddresses","elementHashes","elementDescriptors","reset","loadManifest","schemaManipulations","objectAddressGeneration","hashTranslations","tmpNewOptions","tmpNewManyfest","getManifest","deserialize","pManifestString","Scope","tmpDescriptionAddresses","Descriptors","addDescriptor","serialize","pDescriptor","getDescriptorByHash","pHash","getDescriptor","resolveHashAddress","checkAddressExistsByHash","tmpAddress","tmpInElementHashTable","tmpInTranslationTable","getValueByHash","getDefaultValue","setValueByHash","validate","tmpValidationData","Errors","MissingElements","addValidationError","pErrorMessage","tmpValueExists","Required","tmpElementType","Date","tmpDataType","populateDefaults","pOverwriteProperties","populateObject","fFilter","tmpObject","tmpOverwriteProperties","tmpFilterFunction","libWordTree","libStringParser","WordTree","StringParser","ParseTree","addPattern","pPatternStart","pPatternEnd","pParser","parseString","newParserState","pParseTree","Output","OutputBuffer","Pattern","PatternMatch","PatternMatchOutputBuffer","assignNode","pNode","pParserState","appendOutputBuffer","flushOutputBuffer","checkPatternEnd","PatternEnd","PatternStart","substr","Parse","parseCharacter","tmpParserState","addChild","pTree","pPattern","pIndex","tmpLeaf","pData","libElucidator","pElucidator","elucidator","namespace","initializeNamespace","pNamespace","instructionSets","operationSets","addInstruction","pInstructionHash","fInstructionFunction","initializeInstructions","pOperation","addOperation","pOperationHash","Description","Operation","Namespace","Summary","Inputs","Outputs","Steps","initializeOperations","logToConsole","pLogLevel","tmpLogLevel","info","warning","error","libManyfest","libPrecedent","libElucidatorInstructionSet","pOperations","fInfoLog","fErrorLog","logWarning","fWarningLog","UUID","loadDefaultInstructionSets","tmpSolverHashes","loadInstructionSet","cInstructionSet","tmpInstructionSet","operationExists","tmpNamespace","tmpOperationInjector","solveInternalOperation","pInputObject","pOutputObject","pDescriptionManyfest","pInputAddressMapping","pOutputAddressMapping","pSolutionContext","tmpOperation","solveOperation","pOperationObject","tmpInputObject","tmpOutputObject","tmpSolutionContext","SolutionGUID","SolutionBaseNamespace","SolutionBaseOperation","SolutionLog","InputHashMapping","InputHashTranslationTable","OutputHashMapping","OutputHashTranslationTable","tmpDescriptionManyfest","SolutionContext","Synopsys","tmpPrecedent","tmpHash","Log","PreOperation","tmpStep","tmpInputSchema","InputHashAddressMap","tmpInputManyfest","tmpOutputSchema","OutputHashAddressMap","tmpOutputManyfest","tmpInstructionState","Instruction","DescriptionManyfest","InputObject","InputManyfest","OutputObject","OutputManyfest","pMessage","fInstruction","PostOperation","manyfest","precedent","super","ifInstruction","tmpLeftValue","tmpRightValue","tmpComparator","tmpComparisonOperator","tmpComparisonOperatorMapping","equal","noteq","notequal","id","identity","greaterthan","greaterthanorequal","lessthan","lessthanorequal","tmpTrueNamespace","tmpTrueOperation","tmpFalseNamespace","tmpFalseOperation","tmpTruthiness","executeOperation","tmpA","tmpB","multiply","aggregate","tmpAggregationValue","tmpObjectKeys","Synopsis","Width","Type","Height","Area","Ratio","operation","leftValue","rightValue","comparator","trueNamespace","trueOperation","falseNamespace","falseOperation","truthinessResult","inputString","searchFor","replaceWith","outputString","indexStart","indexEnd","libDecimal","tmpObjectType","tmpInputString","tmpSearchFor","tmpReplaceWith"],"mappings":"CAAA,SAAAA,GAAA,GAAA,iBAAAC,SAAA,oBAAAC,OAAAA,OAAAD,QAAAD,SAAA,GAAA,mBAAAG,QAAAA,OAAAC,IAAAD,OAAA,GAAAH,OAAA,EAAA,oBAAAK,OAAAA,OAAA,oBAAAC,OAAAA,OAAA,oBAAAC,KAAAA,KAAAC,MAAAC,WAAAT,GAAA,CAAA,CAAA,EAAA,WAAA,OAAA,SAAAU,EAAAC,EAAAC,EAAAC,GAAA,SAAAC,EAAAC,EAAAf,GAAA,IAAAY,EAAAG,GAAA,CAAA,IAAAJ,EAAAI,GAAA,CAAA,IAAAC,EAAA,mBAAAC,SAAAA,QAAA,IAAAjB,GAAAgB,EAAA,OAAAA,EAAAD,GAAA,GAAA,GAAAG,EAAA,OAAAA,EAAAH,GAAA,GAAA,IAAAI,EAAA,IAAAC,MAAA,uBAAAL,EAAA,KAAA,MAAAI,EAAAE,KAAA,mBAAAF,CAAA,CAAA,IAAAG,EAAAV,EAAAG,GAAA,CAAAd,QAAA,CAAA,GAAAU,EAAAI,GAAA,GAAAQ,KAAAD,EAAArB,SAAA,SAAAS,GAAA,OAAAI,EAAAH,EAAAI,GAAA,GAAAL,IAAAA,EAAA,GAAAY,EAAAA,EAAArB,QAAAS,EAAAC,EAAAC,EAAAC,EAAA,CAAA,OAAAD,EAAAG,GAAAd,OAAA,CAAA,IAAA,IAAAiB,EAAA,mBAAAD,SAAAA,QAAAF,EAAA,EAAAA,EAAAF,EAAAW,OAAAT,IAAAD,EAAAD,EAAAE,IAAA,OAAAD,CAAA,CAAA,CAAA,CAAA,EAAA,CAAA,SAAAG,EAAAf,EAAAD,ICAA,SAAAwB,GACA;;;;;;;KAiBA,IAkFAC,EAAAC,EAAAC,EAAAC,EAlFAC,EAAA,KAIAC,EAAA,IAGAC,EAAA,mBAGAC,EAAA,qgCAGAC,EAAA,qgCAIAC,EAAA,CAOAC,UAAA,GAiBAC,SAAA,EAeAC,OAAA,EAIAC,UAAA,EAIAC,SAAA,GAIAC,MAAAX,EAIAY,KAAAZ,EAGAa,QAAA,GAQAC,GAAA,EAEAC,EAAA,kBACAC,EAAAD,EAAA,qBACAE,EAAAF,EAAA,2BACAG,EAAAH,EAAA,qBACAI,EAAA,mBAEAC,EAAAC,KAAAC,MACAC,EAAAF,KAAAG,IAEAC,EAAA,6CACAC,EAAA,yDACAC,EAAA,gDACAC,EAAA,qCAEAC,EAAA,IAIAC,EAAA3B,EAAAT,OAAA,EACAqC,EAAA3B,EAAAV,OAAA,EAGAsC,EAAA,CAAAC,YAAAd,GA01EA,SAAAe,EAAAC,GACA,IAAAlD,EAAAmD,EAAAC,EACAC,EAAAH,EAAAzC,OAAA,EACA6C,EAAA,GACAC,EAAAL,EAAA,GAEA,GAAAG,EAAA,EAAA,CAEA,IADAC,GAAAC,EACAvD,EAAA,EAAAA,EAAAqD,EAAArD,KAEAmD,EA32EA,GA02EAC,EAAAF,EAAAlD,GAAA,IACAS,UACA6C,GAAAE,EAAAL,IACAG,GAAAF,GAKAD,EAl3EA,GAi3EAC,GADAG,EAAAL,EAAAlD,IACA,IACAS,UACA6C,GAAAE,EAAAL,GACA,MAAA,GAAA,IAAAI,EACA,MAAA,IAIA,KAAAA,EAAA,IAAA,GAAAA,GAAA,GAEA,OAAAD,EAAAC,CACA,CAGA,SAAAE,EAAAzD,EAAA0D,EAAAC,GACA,GAAA3D,MAAAA,GAAAA,EAAA0D,GAAA1D,EAAA2D,EACA,MAAAtD,MAAA0B,EAAA/B,EAEA,CAQA,SAAA4D,EAAAV,EAAAlD,EAAA6D,EAAAC,GACA,IAAAC,EAAAZ,EAAAxD,EAAAqE,EAGA,IAAAb,EAAAD,EAAA,GAAAC,GAAA,GAAAA,GAAA,KAAAnD,EAwCA,QArCAA,EAAA,GACAA,GAn5EA,EAo5EA+D,EAAA,IAEAA,EAAA3B,KAAA6B,MAAAjE,EAAA,GAt5EA,GAu5EAA,GAv5EA,GA65EAmD,EAAAb,EAAA,GA75EA,EA65EAtC,GACAgE,EAAAd,EAAAa,GAAAZ,EAAA,EAEA,MAAAW,EACA9D,EAAA,GACA,GAAAA,EAAAgE,EAAAA,EAAA,IAAA,EACA,GAAAhE,IAAAgE,EAAAA,EAAA,GAAA,GACArE,EAAAkE,EAAA,GAAA,OAAAG,GAAAH,EAAA,GAAA,OAAAG,GAAA,KAAAA,GAAA,GAAAA,GAEArE,GAAAkE,EAAA,GAAAG,EAAA,GAAAb,GAAAU,EAAA,GAAAG,EAAA,GAAAb,EAAA,KACAD,EAAAa,EAAA,GAAAZ,EAAA,IAAA,IAAAb,EAAA,GAAAtC,EAAA,GAAA,IACAgE,GAAAb,EAAA,GAAA,GAAAa,IAAA,IAAAd,EAAAa,EAAA,GAAAZ,EAAA,IAAA,GAGAnD,EAAA,GACA,GAAAA,EAAAgE,EAAAA,EAAA,IAAA,EACA,GAAAhE,EAAAgE,EAAAA,EAAA,IAAA,EACA,GAAAhE,IAAAgE,EAAAA,EAAA,GAAA,GACArE,GAAAmE,GAAAD,EAAA,IAAA,MAAAG,IAAAF,GAAAD,EAAA,GAAA,MAAAG,GAEArE,IAAAmE,GAAAD,EAAA,IAAAG,EAAA,GAAAb,IACAW,GAAAD,EAAA,GAAAG,EAAA,GAAAb,EAAA,KACAD,EAAAa,EAAA,GAAAZ,EAAA,IAAA,IAAAb,EAAA,GAAAtC,EAAA,GAAA,EAIAL,CACA,CAMA,SAAAuE,EAAAZ,EAAAa,EAAAC,GAOA,IANA,IAAAC,EAEAC,EADAC,EAAA,CAAA,GAEAvE,EAAA,EACAwE,EAAAlB,EAAA7C,OAEAT,EAAAwE,GAAA,CACA,IAAAF,EAAAC,EAAA9D,OAAA6D,KAAAC,EAAAD,IAAAH,EAEA,IADAI,EAAA,IAAAtD,EAAAwD,QAAAnB,EAAAoB,OAAA1E,MACAqE,EAAA,EAAAA,EAAAE,EAAA9D,OAAA4D,IACAE,EAAAF,GAAAD,EAAA,SACA,IAAAG,EAAAF,EAAA,KAAAE,EAAAF,EAAA,GAAA,GACAE,EAAAF,EAAA,IAAAE,EAAAF,GAAAD,EAAA,EACAG,EAAAF,IAAAD,EAGA,CAEA,OAAAG,EAAAI,SACA,CAj4EA5B,EAAA6B,cAAA7B,EAAA8B,IAAA,WACA,IAAAC,EAAA,IAAArF,KAAAsF,YAAAtF,MAEA,OADAqF,EAAAE,EAAA,IAAAF,EAAAE,EAAA,GACAC,EAAAH,EACA,EAQA/B,EAAAkB,KAAA,WACA,OAAAgB,EAAA,IAAAxF,KAAAsF,YAAAtF,MAAAA,KAAAG,EAAA,EAAA,EACA,EAWAmD,EAAAmC,UAAAnC,EAAAoC,MAAA,SAAAzB,EAAAC,GACA,IACAmB,EAAArF,KACA2F,EAAAN,EAAAC,YAGA,GAFArB,EAAA,IAAA0B,EAAA1B,GACAC,EAAA,IAAAyB,EAAAzB,IACAD,EAAAsB,IAAArB,EAAAqB,EAAA,OAAA,IAAAI,EAAAC,KACA,GAAA3B,EAAA4B,GAAA3B,GAAA,MAAAtD,MAAA0B,EAAA4B,GAEA,OADAmB,EAAAS,IAAA7B,GACA,EAAAA,EAAAoB,EAAAS,IAAA5B,GAAA,EAAAA,EAAA,IAAAyB,EAAAN,EACA,EAWA/B,EAAAyC,WAAAzC,EAAAwC,IAAA,SAAAE,GACA,IAAAzF,EAAAqE,EAAAqB,EAAAC,EACAb,EAAArF,KACAmG,EAAAd,EAAA5B,EACA2C,GAAAJ,EAAA,IAAAX,EAAAC,YAAAU,IAAAvC,EACA4C,EAAAhB,EAAAE,EACAe,EAAAN,EAAAT,EAGA,IAAAY,IAAAC,EACA,OAAAC,GAAAC,EAAAD,IAAAC,EAAAD,EAAAF,IAAAC,EAAA,GAAAD,EAAAE,EAAA,EAAA,GAAA,EAAAT,IAIA,IAAAO,EAAA,KAAAC,EAAA,GAAA,OAAAD,EAAA,GAAAE,EAAAD,EAAA,IAAAE,EAAA,EAGA,GAAAD,IAAAC,EAAA,OAAAD,EAGA,GAAAhB,EAAAlF,IAAA6F,EAAA7F,EAAA,OAAAkF,EAAAlF,EAAA6F,EAAA7F,EAAAkG,EAAA,EAAA,GAAA,EAMA,IAAA9F,EAAA,EAAAqE,GAJAqB,EAAAE,EAAAnF,SACAkF,EAAAE,EAAApF,QAGAiF,EAAAC,EAAA3F,EAAAqE,IAAArE,EACA,GAAA4F,EAAA5F,KAAA6F,EAAA7F,GAAA,OAAA4F,EAAA5F,GAAA6F,EAAA7F,GAAA8F,EAAA,EAAA,GAAA,EAIA,OAAAJ,IAAAC,EAAA,EAAAD,EAAAC,EAAAG,EAAA,EAAA,GAAA,CACA,EAgBA/C,EAAAiD,OAAAjD,EAAAkD,IAAA,WACA,IAAAC,EAAArC,EACAiB,EAAArF,KACA2F,EAAAN,EAAAC,YAEA,OAAAD,EAAA5B,EAGA4B,EAAA5B,EAAA,IAEAgD,EAAAd,EAAA/D,UACAwC,EAAAuB,EAAA9D,SACA8D,EAAA/D,UAAA6E,EAAA9D,KAAAuB,IAAAmB,EAAAlF,EAAAkF,EAAAqB,MA3LA,EA4LAf,EAAA9D,SAAA,EAEAwD,EA4xEA,SAAAM,EAAAN,GACA,IAAA3B,EAAAiD,EAAAX,EAEA,GAAAX,EAAAuB,SAAA,OAAAvB,GAMAsB,EAAAtB,EAAA5B,EAAAzC,QACA,GAEAgF,GAAA,EAAAa,EAAA,EADAnD,EAAAf,KAAA6B,KAAAmC,EAAA,KACAG,YAEApD,EAAA,GACAsC,EAAA,gCAGAL,EAAA/D,WAAA8B,EAEA2B,EAAA0B,EAAApB,EAAA,EAAAN,EAAA2B,MAAAhB,GAAA,IAAAL,EAAA,IAGA,IAAA,IAAApF,EAAAmD,EAAAnD,KAAA,CACA,IAAA0G,EAAA5B,EAAA2B,MAAA3B,GACAA,EAAA4B,EAAAD,MAAAC,GAAAC,MAAAD,GAAAD,MAAA,GAAAG,KAAA,EACA,CAIA,OAFAxB,EAAA/D,WAAA8B,EAEA2B,CACA,CA3zEAkB,CAAAZ,EAAAyB,EAAAzB,EAAAN,IAEAM,EAAA/D,UAAA6E,EACAd,EAAA9D,SAAAuC,EAEAoB,EAAA,GAAAnE,GAAA,GAAAA,EAAAgE,EAAAgC,MAAAhC,EAAAoB,EAAArC,GAAA,IAZA,IAAAuB,EAAA,GAHA,IAAAA,EAAAC,IAgBA,EAmBAtC,EAAAgE,SAAAhE,EAAAiE,KAAA,WACA,IAAApH,EAAAqH,EAAApH,EAAAF,EAAAuH,EAAAlC,EAAAmB,EAAArG,EAAAqH,EAAAC,EACAtC,EAAArF,KACA2F,EAAAN,EAAAC,YAEA,IAAAD,EAAAuC,YAAAvC,EAAAuB,SAAA,OAAA,IAAAjB,EAAAN,GAoCA,IAnCAjD,GAAA,GAGAmD,EAAAF,EAAAE,EAAA1C,EAAAwC,EAAAE,EAAAF,EAAA,EAAA,KAIA1C,KAAAyC,IAAAG,IAAA,IAqBArF,EAAA,IAAAyF,EAAAJ,EAAAuB,aApBA1G,EAAAoD,EAAA6B,EAAA5B,IAIA8B,IAHApF,EAAAkF,EAAAlF,GAGAC,EAAAY,OAAA,GAAA,KAAAZ,GAAA,GAAAmF,IAAA,GAAAA,EAAA,IAAA,MACAA,EAAA1C,EAAAzC,EAAA,EAAA,GAGAD,EAAAuC,GAAAvC,EAAA,GAAA,IAAAA,EAAA,IAAAA,EAAA,GAAA,EAAA,KASAD,EAAA,IAAAyF,EANAvF,EADAmF,GAAA,IACA,KAAApF,GAEAC,EAAAmF,EAAAsC,iBACAC,MAAA,EAAA1H,EAAA4E,QAAA,KAAA,GAAA7E,IAIAoF,EAAAF,EAAAE,GAKAmB,GAAAvG,EAAAwF,EAAA/D,WAAA,IAWA,GAJA+F,GADAD,GADArH,EAAAH,GACA8G,MAAA3G,GAAA2G,MAAA3G,IACA8G,KAAA9B,GACAnF,EAAA6H,EAAAJ,EAAAR,KAAA9B,GAAA2B,MAAA3G,GAAAsH,EAAAR,KAAAO,GAAAhB,EAAA,EAAA,GAGAlD,EAAAnD,EAAAoD,GAAAqE,MAAA,EAAApB,MAAAtG,EAAAoD,EAAAtD,EAAAuD,IAAAqE,MAAA,EAAApB,GAAA,CAKA,GAAA,SAJAtG,EAAAA,EAAA0H,MAAApB,EAAA,EAAAA,EAAA,MAIAe,GAAA,QAAArH,GAeA,EAIAA,KAAAA,EAAA0H,MAAA,IAAA,KAAA1H,EAAA6E,OAAA,MAGAO,EAAAtF,EAAAC,EAAA,EAAA,GACAqH,GAAAtH,EAAA8G,MAAA9G,GAAA8G,MAAA9G,GAAA8H,GAAA3C,IAGA,KACA,CAvBA,IAAAoC,IACAjC,EAAAnF,EAAAF,EAAA,EAAA,GAEAE,EAAA2G,MAAA3G,GAAA2G,MAAA3G,GAAA2H,GAAA3C,IAAA,CACAnF,EAAAG,EACA,KACA,CAGAqG,GAAA,EACAe,EAAA,CAcA,CAKA,OAFArF,GAAA,EAEAoD,EAAAtF,EAAAC,EAAAwF,EAAA9D,SAAA2F,EACA,EAOAlE,EAAA2E,cAAA3E,EAAA4E,GAAA,WACA,IAAApE,EACAL,EAAAzD,KAAAyD,EACArD,EAAAwF,IAEA,GAAAnC,EAAA,CAMA,GAJArD,EA5TA,IA2TA0D,EAAAL,EAAAzC,OAAA,GACA0B,EAAA1C,KAAAG,EA5TA,IA+TA2D,EAAAL,EAAAK,GACA,KAAAA,EAAA,IAAA,EAAAA,GAAA,GAAA1D,IACAA,EAAA,IAAAA,EAAA,EACA,CAEA,OAAAA,CACA,EAwBAkD,EAAA6E,UAAA7E,EAAA8E,IAAA,SAAApC,GACA,OAAA+B,EAAA/H,KAAA,IAAAA,KAAAsF,YAAAU,GACA,EAQA1C,EAAA+E,mBAAA/E,EAAAgF,SAAA,SAAAtC,GACA,IACAL,EADA3F,KACAsF,YACA,OAAAE,EAAAuC,EAFA/H,KAEA,IAAA2F,EAAAK,GAAA,EAAA,EAAA,GAAAL,EAAA/D,UAAA+D,EAAA9D,SACA,EAOAyB,EAAAiF,OAAAjF,EAAA0E,GAAA,SAAAhC,GACA,OAAA,IAAAhG,KAAA8F,IAAAE,EACA,EAQA1C,EAAAV,MAAA,WACA,OAAA4C,EAAA,IAAAxF,KAAAsF,YAAAtF,MAAAA,KAAAG,EAAA,EAAA,EACA,EAQAmD,EAAAkF,YAAAlF,EAAAuC,GAAA,SAAAG,GACA,OAAAhG,KAAA8F,IAAAE,GAAA,CACA,EAQA1C,EAAAmF,qBAAAnF,EAAAoF,IAAA,SAAA1C,GACA,IAAAtC,EAAA1D,KAAA8F,IAAAE,GACA,OAAA,GAAAtC,GAAA,IAAAA,CACA,EA4BAJ,EAAAqF,iBAAArF,EAAAsF,KAAA,WACA,IAAAlF,EAAAtD,EAAAqG,EAAArC,EAAAuC,EACAtB,EAAArF,KACA2F,EAAAN,EAAAC,YACAuD,EAAA,IAAAlD,EAAA,GAEA,IAAAN,EAAAuC,WAAA,OAAA,IAAAjC,EAAAN,EAAAE,EAAA,IAAAK,KACA,GAAAP,EAAAuB,SAAA,OAAAiC,EAEApC,EAAAd,EAAA/D,UACAwC,EAAAuB,EAAA9D,SACA8D,EAAA/D,UAAA6E,EAAA9D,KAAAuB,IAAAmB,EAAAlF,EAAAkF,EAAAqB,MAAA,EACAf,EAAA9D,SAAA,GACA8E,EAAAtB,EAAA5B,EAAAzC,QAOA,GAEAZ,GAAA,EAAAyG,EAAA,EADAnD,EAAAf,KAAA6B,KAAAmC,EAAA,KACAG,YAEApD,EAAA,GACAtD,EAAA,gCAGAiF,EAAA0B,EAAApB,EAAA,EAAAN,EAAA2B,MAAA5G,GAAA,IAAAuF,EAAA,IAAA,GAMA,IAHA,IAAAmD,EACAvI,EAAAmD,EACAqF,EAAA,IAAApD,EAAA,GACApF,KACAuI,EAAAzD,EAAA2B,MAAA3B,GACAA,EAAAwD,EAAA3B,MAAA4B,EAAA9B,MAAA+B,EAAA7B,MAAA4B,EAAA9B,MAAA+B,MAGA,OAAAvD,EAAAH,EAAAM,EAAA/D,UAAA6E,EAAAd,EAAA9D,SAAAuC,GAAA,EACA,EAiCAd,EAAA0F,eAAA1F,EAAA2F,KAAA,WACA,IAAAvF,EAAA+C,EAAArC,EAAAuC,EACAtB,EAAArF,KACA2F,EAAAN,EAAAC,YAEA,IAAAD,EAAAuC,YAAAvC,EAAAuB,SAAA,OAAA,IAAAjB,EAAAN,GAQA,GANAoB,EAAAd,EAAA/D,UACAwC,EAAAuB,EAAA9D,SACA8D,EAAA/D,UAAA6E,EAAA9D,KAAAuB,IAAAmB,EAAAlF,EAAAkF,EAAAqB,MAAA,EACAf,EAAA9D,SAAA,GACA8E,EAAAtB,EAAA5B,EAAAzC,QAEA,EACAqE,EAAA0B,EAAApB,EAAA,EAAAN,EAAAA,GAAA,OACA,CAYA3B,GADAA,EAAA,IAAAf,KAAAuG,KAAAvC,IACA,GAAA,GAAA,EAAAjD,EAGA2B,EAAA0B,EAAApB,EAAA,EADAN,EAAAA,EAAA2B,MAAA,EAAAH,EAAA,EAAAnD,IACA2B,GAAA,GAOA,IAJA,IAAA8D,EACAC,EAAA,IAAAzD,EAAA,GACA0D,EAAA,IAAA1D,EAAA,IACA2D,EAAA,IAAA3D,EAAA,IACAjC,KACAyF,EAAA9D,EAAA2B,MAAA3B,GACAA,EAAAA,EAAA2B,MAAAoC,EAAAjC,KAAAgC,EAAAnC,MAAAqC,EAAArC,MAAAmC,GAAAhC,KAAAmC,KAEA,CAKA,OAHA3D,EAAA/D,UAAA6E,EACAd,EAAA9D,SAAAuC,EAEAoB,EAAAH,EAAAoB,EAAArC,GAAA,EACA,EAmBAd,EAAAiG,kBAAAjG,EAAAkG,KAAA,WACA,IAAA/C,EAAArC,EACAiB,EAAArF,KACA2F,EAAAN,EAAAC,YAEA,OAAAD,EAAAuC,WACAvC,EAAAuB,SAAA,IAAAjB,EAAAN,IAEAoB,EAAAd,EAAA/D,UACAwC,EAAAuB,EAAA9D,SACA8D,EAAA/D,UAAA6E,EAAA,EACAd,EAAA9D,SAAA,EAEAkG,EAAA1C,EAAA4D,OAAA5D,EAAAuD,OAAAjD,EAAA/D,UAAA6E,EAAAd,EAAA9D,SAAAuC,IARA,IAAAuB,EAAAN,EAAAE,EASA,EAsBAjC,EAAAmG,cAAAnG,EAAAoG,KAAA,WACA,IAAAC,EACAtE,EAAArF,KACA2F,EAAAN,EAAAC,YACA5B,EAAA2B,EAAAD,MAAAU,IAAA,GACAW,EAAAd,EAAA/D,UACAwC,EAAAuB,EAAA9D,SAEA,OAAA,IAAA6B,EACA,IAAAA,EAEA2B,EAAAuE,QAAAC,EAAAlE,EAAAc,EAAArC,GAAA,IAAAuB,EAAA,GAEA,IAAAA,EAAAC,KAGAP,EAAAuB,SAAAiD,EAAAlE,EAAAc,EAAA,EAAArC,GAAA4C,MAAA,KAIArB,EAAA/D,UAAA6E,EAAA,EACAd,EAAA9D,SAAA,EAEAwD,EAAAA,EAAAyE,OACAH,EAAAE,EAAAlE,EAAAc,EAAA,EAAArC,GAAA4C,MAAA,IAEArB,EAAA/D,UAAA6E,EACAd,EAAA9D,SAAAuC,EAEAuF,EAAAzC,MAAA7B,GACA,EAsBA/B,EAAAyG,wBAAAzG,EAAA0G,MAAA,WACA,IAAAvD,EAAArC,EACAiB,EAAArF,KACA2F,EAAAN,EAAAC,YAEA,OAAAD,EAAA4E,IAAA,GAAA,IAAAtE,EAAAN,EAAA2C,GAAA,GAAA,EAAApC,KACAP,EAAAuC,YAEAnB,EAAAd,EAAA/D,UACAwC,EAAAuB,EAAA9D,SACA8D,EAAA/D,UAAA6E,EAAA9D,KAAAuB,IAAAvB,KAAAyC,IAAAC,EAAAlF,GAAAkF,EAAAqB,MAAA,EACAf,EAAA9D,SAAA,EACAO,GAAA,EAEAiD,EAAAA,EAAA2B,MAAA3B,GAAA6B,MAAA,GAAAgC,OAAA/B,KAAA9B,GAEAjD,GAAA,EACAuD,EAAA/D,UAAA6E,EACAd,EAAA9D,SAAAuC,EAEAiB,EAAA6E,MAdA,IAAAvE,EAAAN,EAeA,EAmBA/B,EAAA6G,sBAAA7G,EAAA8G,MAAA,WACA,IAAA3D,EAAArC,EACAiB,EAAArF,KACA2F,EAAAN,EAAAC,YAEA,OAAAD,EAAAuC,YAAAvC,EAAAuB,SAAA,IAAAjB,EAAAN,IAEAoB,EAAAd,EAAA/D,UACAwC,EAAAuB,EAAA9D,SACA8D,EAAA/D,UAAA6E,EAAA,EAAA9D,KAAAuB,IAAAvB,KAAAyC,IAAAC,EAAAlF,GAAAkF,EAAAqB,MAAA,EACAf,EAAA9D,SAAA,EACAO,GAAA,EAEAiD,EAAAA,EAAA2B,MAAA3B,GAAA8B,KAAA,GAAA+B,OAAA/B,KAAA9B,GAEAjD,GAAA,EACAuD,EAAA/D,UAAA6E,EACAd,EAAA9D,SAAAuC,EAEAiB,EAAA6E,KACA,EAsBA5G,EAAA+G,yBAAA/G,EAAAgH,MAAA,WACA,IAAA7D,EAAArC,EAAAmG,EAAAC,EACAnF,EAAArF,KACA2F,EAAAN,EAAAC,YAEA,OAAAD,EAAAuC,WACAvC,EAAAlF,GAAA,EAAA,IAAAwF,EAAAN,EAAAD,MAAA4C,GAAA,GAAA3C,EAAAE,EAAA,EAAAF,EAAAuB,SAAAvB,EAAAO,MAEAa,EAAAd,EAAA/D,UACAwC,EAAAuB,EAAA9D,SACA2I,EAAAnF,EAAAqB,KAEA/D,KAAAuB,IAAAsG,EAAA/D,GAAA,GAAApB,EAAAlF,EAAA,EAAAqF,EAAA,IAAAG,EAAAN,GAAAoB,EAAArC,GAAA,IAEAuB,EAAA/D,UAAA2I,EAAAC,EAAAnF,EAAAlF,EAEAkF,EAAA0C,EAAA1C,EAAA8B,KAAA,GAAA,IAAAxB,EAAA,GAAAuB,MAAA7B,GAAAkF,EAAA9D,EAAA,GAEAd,EAAA/D,UAAA6E,EAAA,EACAd,EAAA9D,SAAA,EAEAwD,EAAAA,EAAA6E,KAEAvE,EAAA/D,UAAA6E,EACAd,EAAA9D,SAAAuC,EAEAiB,EAAA2B,MAAA,MArBA,IAAArB,EAAAC,IAsBA,EAwBAtC,EAAAmH,YAAAnH,EAAAwG,KAAA,WACA,IAAAH,EAAAjG,EACA+C,EAAArC,EACAiB,EAAArF,KACA2F,EAAAN,EAAAC,YAEA,OAAAD,EAAAuB,SAAA,IAAAjB,EAAAN,IAEA3B,EAAA2B,EAAAD,MAAAU,IAAA,GACAW,EAAAd,EAAA/D,UACAwC,EAAAuB,EAAA9D,UAEA,IAAA6B,EAGA,IAAAA,IACAiG,EAAAE,EAAAlE,EAAAc,EAAA,EAAArC,GAAA4C,MAAA,KACAzB,EAAAF,EAAAE,EACAoE,GAIA,IAAAhE,EAAAC,MAKAD,EAAA/D,UAAA6E,EAAA,EACAd,EAAA9D,SAAA,EAEAwD,EAAAA,EAAA+C,IAAA,IAAAzC,EAAA,GAAAuB,MAAA7B,EAAA2B,MAAA3B,IAAA6D,OAAA/B,KAAA,IAAAuD,OAEA/E,EAAA/D,UAAA6E,EACAd,EAAA9D,SAAAuC,EAEAiB,EAAA2B,MAAA,IACA,EAqBA1D,EAAAqH,eAAArH,EAAAoH,KAAA,WACA,IAAAnK,EAAAqE,EAAAlB,EAAAtD,EAAAwK,EAAAvK,EAAAH,EAAAqK,EAAAM,EACAxF,EAAArF,KACA2F,EAAAN,EAAAC,YACAmB,EAAAd,EAAA/D,UACAwC,EAAAuB,EAAA9D,SAEA,GAAAwD,EAAAuC,WAOA,IAAAvC,EAAAuB,SACA,OAAA,IAAAjB,EAAAN,GACA,GAAAA,EAAAD,MAAA4C,GAAA,IAAAvB,EAAA,GAAApD,EAGA,OAFAnD,EAAA2J,EAAAlE,EAAAc,EAAA,EAAArC,GAAA4C,MAAA,MACAzB,EAAAF,EAAAE,EACArF,CACA,KAbA,CACA,IAAAmF,EAAAE,EAAA,OAAA,IAAAI,EAAAC,KACA,GAAAa,EAAA,GAAApD,EAGA,OAFAnD,EAAA2J,EAAAlE,EAAAc,EAAA,EAAArC,GAAA4C,MAAA,KACAzB,EAAAF,EAAAE,EACArF,CAEA,CAmBA,IAXAyF,EAAA/D,UAAA2I,EAAA9D,EAAA,GACAd,EAAA9D,SAAA,EAUAtB,EAFAmD,EAAAf,KAAAsB,IAAA,GAAAsG,EA/2BA,EA+2BA,EAAA,GAEAhK,IAAAA,EAAA8E,EAAAA,EAAA+C,IAAA/C,EAAA2B,MAAA3B,GAAA8B,KAAA,GAAA+B,OAAA/B,KAAA,IAWA,IATA/E,GAAA,EAEAwC,EAAAjC,KAAA6B,KAAA+F,EAr3BA,GAs3BAnK,EAAA,EACAyK,EAAAxF,EAAA2B,MAAA3B,GACAnF,EAAA,IAAAyF,EAAAN,GACAuF,EAAAvF,GAGA,IAAA9E,GAOA,GANAqK,EAAAA,EAAA5D,MAAA6D,GACAxK,EAAAH,EAAAgH,MAAA0D,EAAAxC,IAAAhI,GAAA,IAEAwK,EAAAA,EAAA5D,MAAA6D,QAGA,KAFA3K,EAAAG,EAAA8G,KAAAyD,EAAAxC,IAAAhI,GAAA,KAEAqD,EAAAmB,GAAA,IAAArE,EAAAqE,EAAA1E,EAAAuD,EAAAlD,KAAAF,EAAAoD,EAAAlD,IAAAA,MAOA,OAJAmD,IAAAxD,EAAAA,EAAA8G,MAAA,GAAAtD,EAAA,IAEAtB,GAAA,EAEAoD,EAAAtF,EAAAyF,EAAA/D,UAAA6E,EAAAd,EAAA9D,SAAAuC,GAAA,EACA,EAOAd,EAAAsE,SAAA,WACA,QAAA5H,KAAAyD,CACA,EAOAH,EAAAwH,UAAAxH,EAAAyH,MAAA,WACA,QAAA/K,KAAAyD,GAAAf,EAAA1C,KAAAG,EA55BA,GA45BAH,KAAAyD,EAAAzC,OAAA,CACA,EAOAsC,EAAA0H,MAAA,WACA,OAAAhL,KAAAuF,CACA,EAOAjC,EAAA2H,WAAA3H,EAAAsG,MAAA,WACA,OAAA5J,KAAAuF,EAAA,CACA,EAOAjC,EAAA4H,WAAA5H,EAAA6H,MAAA,WACA,OAAAnL,KAAAuF,EAAA,CACA,EAOAjC,EAAAsD,OAAA,WACA,QAAA5G,KAAAyD,GAAA,IAAAzD,KAAAyD,EAAA,EACA,EAOAH,EAAA8H,SAAA9H,EAAA+H,GAAA,SAAArF,GACA,OAAAhG,KAAA8F,IAAAE,GAAA,CACA,EAOA1C,EAAAgI,kBAAAhI,EAAA2G,IAAA,SAAAjE,GACA,OAAAhG,KAAA8F,IAAAE,GAAA,CACA,EAiCA1C,EAAAiI,UAAAjI,EAAAkI,IAAA,SAAAC,GACA,IAAAC,EAAAjI,EAAAkI,EAAAjI,EAAAkI,EAAAC,EAAAnF,EAAAxG,EACA4L,EAAA9L,KACA2F,EAAAmG,EAAAxG,YACAmB,EAAAd,EAAA/D,UACAwC,EAAAuB,EAAA9D,SAIA,GAAA,MAAA4J,EACAA,EAAA,IAAA9F,EAAA,IACA+F,GAAA,MACA,CAKA,GAHAjI,GADAgI,EAAA,IAAA9F,EAAA8F,IACAhI,EAGAgI,EAAAlG,EAAA,IAAA9B,IAAAA,EAAA,IAAAgI,EAAAzD,GAAA,GAAA,OAAA,IAAArC,EAAAC,KAEA8F,EAAAD,EAAAzD,GAAA,GACA,CAKA,GAHAvE,EAAAqI,EAAArI,EAGAqI,EAAAvG,EAAA,IAAA9B,IAAAA,EAAA,IAAAqI,EAAA9D,GAAA,GACA,OAAA,IAAArC,EAAAlC,IAAAA,EAAA,IAAA,IAAA,GAAAqI,EAAAvG,EAAAK,IAAAnC,EAAA,EAAA,KAKA,GAAAiI,EACA,GAAAjI,EAAAzC,OAAA,EACA4K,GAAA,MACA,CACA,IAAAlI,EAAAD,EAAA,GAAAC,EAAA,IAAA,GAAAA,GAAA,GACAkI,EAAA,IAAAlI,CACA,CAyBA,GAtBAtB,GAAA,EAEAyJ,EAAAE,EAAAD,EADApF,EAAAD,EAnCA,GAqCAkF,EAAAD,EAAAM,EAAArG,EAAAe,EAAA,IAAAqF,EAAAN,EAAA/E,GAmBAvC,GAhBAjE,EAAA6H,EAAA8D,EAAAF,EAAAjF,EAAA,IAgBAjD,EAAAC,EAAA+C,EAAArC,GAEA,GAMA,GAJAyH,EAAAE,EAAAD,EADApF,GAAA,IAEAiF,EAAAD,EAAAM,EAAArG,EAAAe,EAAA,IAAAqF,EAAAN,EAAA/E,GACAxG,EAAA6H,EAAA8D,EAAAF,EAAAjF,EAAA,IAEAkF,EAAA,EAGApI,EAAAtD,EAAAuD,GAAAqE,MAAApE,EAAA,EAAAA,EAAA,IAAA,GAAA,OACAxD,EAAAsF,EAAAtF,EAAAuG,EAAA,EAAA,IAGA,KACA,QACAtC,EAAAjE,EAAAuD,EAAAC,GAAA,GAAAU,IAKA,OAFAhC,GAAA,EAEAoD,EAAAtF,EAAAuG,EAAArC,EACA,EAgDAd,EAAA4D,MAAA5D,EAAA2I,IAAA,SAAAjG,GACA,IAAAvC,EAAAtD,EAAAI,EAAAqE,EAAAlB,EAAAiD,EAAAF,EAAArC,EAAA+B,EAAA+F,EAAAC,EAAA/F,EACAf,EAAArF,KACA2F,EAAAN,EAAAC,YAKA,GAHAU,EAAA,IAAAL,EAAAK,IAGAX,EAAA5B,IAAAuC,EAAAvC,EAaA,OAVA4B,EAAAE,GAAAS,EAAAT,EAGAF,EAAA5B,EAAAuC,EAAAT,GAAAS,EAAAT,EAKAS,EAAA,IAAAL,EAAAK,EAAAvC,GAAA4B,EAAAE,IAAAS,EAAAT,EAAAF,EAAAO,KARAI,EAAA,IAAAL,EAAAC,KAUAI,EAIA,GAAAX,EAAAE,GAAAS,EAAAT,EAEA,OADAS,EAAAT,GAAAS,EAAAT,EACAF,EAAA8B,KAAAnB,GASA,GANAG,EAAAd,EAAA5B,EACA2C,EAAAJ,EAAAvC,EACAgD,EAAAd,EAAA/D,UACAwC,EAAAuB,EAAA9D,UAGAsE,EAAA,KAAAC,EAAA,GAAA,CAGA,GAAAA,EAAA,GAAAJ,EAAAT,GAAAS,EAAAT,MAGA,KAAAY,EAAA,GAIA,OAAA,IAAAR,EAAA,IAAAvB,GAAA,EAAA,GAJA4B,EAAA,IAAAL,EAAAN,EAIA,CAEA,OAAAjD,EAAAoD,EAAAQ,EAAAS,EAAArC,GAAA4B,CACA,CAYA,GAPA7F,EAAAuC,EAAAsD,EAAA7F,EA/qCA,GAgrCA+L,EAAAxJ,EAAA2C,EAAAlF,EAhrCA,GAkrCAgG,EAAAA,EAAA2B,QACApE,EAAAwI,EAAA/L,EAGA,CAyBA,KAxBAgM,EAAAzI,EAAA,IAGAD,EAAA0C,EACAzC,GAAAA,EACAiD,EAAAP,EAAApF,SAEAyC,EAAA2C,EACAjG,EAAA+L,EACAvF,EAAAR,EAAAnF,QAQA0C,GAFAnD,EAAAoC,KAAAuB,IAAAvB,KAAA6B,KAAAiC,EAtsCA,GAssCAE,GAAA,KAGAjD,EAAAnD,EACAkD,EAAAzC,OAAA,GAIAyC,EAAAyB,UACA3E,EAAAmD,EAAAnD,KAAAkD,EAAA2I,KAAA,GACA3I,EAAAyB,SAGA,KAAA,CASA,KAHAiH,GAFA5L,EAAA4F,EAAAnF,SACA2F,EAAAP,EAAApF,WAEA2F,EAAApG,GAEAA,EAAA,EAAAA,EAAAoG,EAAApG,IACA,GAAA4F,EAAA5F,IAAA6F,EAAA7F,GAAA,CACA4L,EAAAhG,EAAA5F,GAAA6F,EAAA7F,GACA,KACA,CAGAmD,EAAA,CACA,CAaA,IAXAyI,IACA1I,EAAA0C,EACAA,EAAAC,EACAA,EAAA3C,EACAuC,EAAAT,GAAAS,EAAAT,GAGAoB,EAAAR,EAAAnF,OAIAT,EAAA6F,EAAApF,OAAA2F,EAAApG,EAAA,IAAAA,EAAA4F,EAAAQ,KAAA,EAGA,IAAApG,EAAA6F,EAAApF,OAAAT,EAAAmD,GAAA,CAEA,GAAAyC,IAAA5F,GAAA6F,EAAA7F,GAAA,CACA,IAAAqE,EAAArE,EAAAqE,GAAA,IAAAuB,IAAAvB,IAAAuB,EAAAvB,GAAAzB,EAAA,IACAgD,EAAAvB,GACAuB,EAAA5F,IAAA4C,CACA,CAEAgD,EAAA5F,IAAA6F,EAAA7F,EACA,CAGA,KAAA,IAAA4F,IAAAQ,IAAAR,EAAAkG,MAGA,KAAA,IAAAlG,EAAA,GAAAA,EAAAmG,UAAAnM,EAGA,OAAAgG,EAAA,IAEAH,EAAAvC,EAAA0C,EACAH,EAAA7F,EAAAoM,EAAApG,EAAAhG,GAEAiC,EAAAoD,EAAAQ,EAAAS,EAAArC,GAAA4B,GALA,IAAAL,EAAA,IAAAvB,GAAA,EAAA,EAMA,EA2BAd,EAAAxB,OAAAwB,EAAAkJ,IAAA,SAAAxG,GACA,IAAAyG,EACApH,EAAArF,KACA2F,EAAAN,EAAAC,YAKA,OAHAU,EAAA,IAAAL,EAAAK,IAGAX,EAAA5B,IAAAuC,EAAAT,GAAAS,EAAAvC,IAAAuC,EAAAvC,EAAA,GAAA,IAAAkC,EAAAC,MAGAI,EAAAvC,GAAA4B,EAAA5B,IAAA4B,EAAA5B,EAAA,GACA+B,EAAA,IAAAG,EAAAN,GAAAM,EAAA/D,UAAA+D,EAAA9D,WAIAO,GAAA,EAEA,GAAAuD,EAAA7D,QAIA2K,EAAA1E,EAAA1C,EAAAW,EAAAZ,MAAA,EAAA,EAAA,IACAG,GAAAS,EAAAT,EAEAkH,EAAA1E,EAAA1C,EAAAW,EAAA,EAAAL,EAAA7D,OAAA,GAGA2K,EAAAA,EAAAzF,MAAAhB,GAEA5D,GAAA,EAEAiD,EAAA6B,MAAAuF,GACA,EASAnJ,EAAAoJ,mBAAApJ,EAAAqJ,IAAA,WACA,OAAAD,EAAA1M,KACA,EAQAsD,EAAAyI,iBAAAzI,EAAA4G,GAAA,WACA,OAAA6B,EAAA/L,KACA,EAQAsD,EAAAsJ,QAAAtJ,EAAA+D,IAAA,WACA,IAAAhC,EAAA,IAAArF,KAAAsF,YAAAtF,MAEA,OADAqF,EAAAE,GAAAF,EAAAE,EACAC,EAAAH,EACA,EAwBA/B,EAAA6D,KAAA7D,EAAAuJ,IAAA,SAAA7G,GACA,IAAA8G,EAAArJ,EAAAtD,EAAAI,EAAAmD,EAAAiD,EAAAF,EAAArC,EAAA+B,EAAAC,EACAf,EAAArF,KACA2F,EAAAN,EAAAC,YAKA,GAHAU,EAAA,IAAAL,EAAAK,IAGAX,EAAA5B,IAAAuC,EAAAvC,EAWA,OARA4B,EAAAE,GAAAS,EAAAT,EAMAF,EAAA5B,IAAAuC,EAAA,IAAAL,EAAAK,EAAAvC,GAAA4B,EAAAE,IAAAS,EAAAT,EAAAF,EAAAO,MANAI,EAAA,IAAAL,EAAAC,KAQAI,EAIA,GAAAX,EAAAE,GAAAS,EAAAT,EAEA,OADAS,EAAAT,GAAAS,EAAAT,EACAF,EAAA6B,MAAAlB,GASA,GANAG,EAAAd,EAAA5B,EACA2C,EAAAJ,EAAAvC,EACAgD,EAAAd,EAAA/D,UACAwC,EAAAuB,EAAA9D,UAGAsE,EAAA,KAAAC,EAAA,GAMA,OAFAA,EAAA,KAAAJ,EAAA,IAAAL,EAAAN,IAEAjD,EAAAoD,EAAAQ,EAAAS,EAAArC,GAAA4B,EAaA,GAPAtC,EAAAhB,EAAA2C,EAAAlF,EA/6CA,GAg7CAA,EAAAuC,EAAAsD,EAAA7F,EAh7CA,GAk7CAgG,EAAAA,EAAA2B,QACAvH,EAAAmD,EAAAvD,EAGA,CAuBA,IArBAI,EAAA,GACAkD,EAAA0C,EACA5F,GAAAA,EACAoG,EAAAP,EAAApF,SAEAyC,EAAA2C,EACAjG,EAAAuD,EACAiD,EAAAR,EAAAnF,QAOAT,GAFAoG,GADAjD,EAAAf,KAAA6B,KAAAiC,EAn8CA,IAo8CAE,EAAAjD,EAAA,EAAAiD,EAAA,KAGApG,EAAAoG,EACAlD,EAAAzC,OAAA,GAIAyC,EAAAyB,UACA3E,KAAAkD,EAAA2I,KAAA,GACA3I,EAAAyB,SACA,CAcA,KAZAyB,EAAAR,EAAAnF,SACAT,EAAA6F,EAAApF,QAGA,IACAT,EAAAoG,EACAlD,EAAA2C,EACAA,EAAAD,EACAA,EAAA1C,GAIAqJ,EAAA,EAAAvM,GACAuM,GAAA3G,IAAA5F,GAAA4F,EAAA5F,GAAA6F,EAAA7F,GAAAuM,GAAA3J,EAAA,EACAgD,EAAA5F,IAAA4C,EAUA,IAPA2J,IACA3G,EAAA4G,QAAAD,KACA3M,GAKAwG,EAAAR,EAAAnF,OAAA,GAAAmF,IAAAQ,IAAAR,EAAAkG,MAKA,OAHArG,EAAAvC,EAAA0C,EACAH,EAAA7F,EAAAoM,EAAApG,EAAAhG,GAEAiC,EAAAoD,EAAAQ,EAAAS,EAAArC,GAAA4B,CACA,EASA1C,EAAA1B,UAAA0B,EAAAoD,GAAA,SAAAsG,GACA,IAAAtJ,EACA2B,EAAArF,KAEA,QAAA,IAAAgN,GAAAA,MAAAA,GAAA,IAAAA,GAAA,IAAAA,EAAA,MAAApM,MAAA0B,EAAA0K,GASA,OAPA3H,EAAA5B,GACAC,EAAAuJ,EAAA5H,EAAA5B,GACAuJ,GAAA3H,EAAAlF,EAAA,EAAAuD,IAAAA,EAAA2B,EAAAlF,EAAA,IAEAuD,EAAAkC,IAGAlC,CACA,EAQAJ,EAAA4J,MAAA,WACA,IAAA7H,EAAArF,KACA2F,EAAAN,EAAAC,YAEA,OAAAE,EAAA,IAAAG,EAAAN,GAAAA,EAAAlF,EAAA,EAAAwF,EAAA9D,SACA,EAkBAyB,EAAA6J,KAAA7J,EAAA8J,IAAA,WACA,IAAA3G,EAAArC,EACAiB,EAAArF,KACA2F,EAAAN,EAAAC,YAEA,OAAAD,EAAAuC,WACAvC,EAAAuB,SAAA,IAAAjB,EAAAN,IAEAoB,EAAAd,EAAA/D,UACAwC,EAAAuB,EAAA9D,SACA8D,EAAA/D,UAAA6E,EAAA9D,KAAAuB,IAAAmB,EAAAlF,EAAAkF,EAAAqB,MA/iDA,EAgjDAf,EAAA9D,SAAA,EAEAwD,EAs7DA,SAAAM,EAAAN,GACA,IAAA3B,EACAiD,EAAAtB,EAAA5B,EAAAzC,OAEA,GAAA2F,EAAA,EACA,OAAAtB,EAAAuB,SAAAvB,EAAA0B,EAAApB,EAAA,EAAAN,EAAAA,GASA3B,GADAA,EAAA,IAAAf,KAAAuG,KAAAvC,IACA,GAAA,GAAA,EAAAjD,EAEA2B,EAAAA,EAAA2B,MAAA,EAAAH,EAAA,EAAAnD,IACA2B,EAAA0B,EAAApB,EAAA,EAAAN,EAAAA,GAOA,IAJA,IAAAgI,EACAjE,EAAA,IAAAzD,EAAA,GACA0D,EAAA,IAAA1D,EAAA,IACA2D,EAAA,IAAA3D,EAAA,IACAjC,KACA2J,EAAAhI,EAAA2B,MAAA3B,GACAA,EAAAA,EAAA2B,MAAAoC,EAAAjC,KAAAkG,EAAArG,MAAAqC,EAAArC,MAAAqG,GAAAnG,MAAAoC,MAGA,OAAAjE,CACA,CAp9DA8H,CAAAxH,EAAAyB,EAAAzB,EAAAN,IAEAM,EAAA/D,UAAA6E,EACAd,EAAA9D,SAAAuC,EAEAoB,EAAAnE,EAAA,EAAAgE,EAAAgC,MAAAhC,EAAAoB,EAAArC,GAAA,IAbA,IAAAuB,EAAAC,IAcA,EAeAtC,EAAAgK,WAAAhK,EAAA4F,KAAA,WACA,IAAA1B,EAAApH,EAAAsG,EAAAxG,EAAAuH,EAAApH,EACAgF,EAAArF,KACAyD,EAAA4B,EAAA5B,EACAtD,EAAAkF,EAAAlF,EACAoF,EAAAF,EAAAE,EACAI,EAAAN,EAAAC,YAGA,GAAA,IAAAC,IAAA9B,IAAAA,EAAA,GACA,OAAA,IAAAkC,GAAAJ,GAAAA,EAAA,KAAA9B,GAAAA,EAAA,IAAAmC,IAAAnC,EAAA4B,EAAA,KAgCA,IA7BAjD,GAAA,EAOA,IAJAmD,EAAA5C,KAAAuG,MAAA7D,KAIAE,GAAA,OACAnF,EAAAoD,EAAAC,IAEAzC,OAAAb,GAAA,GAAA,IAAAC,GAAA,KACAmF,EAAA5C,KAAAuG,KAAA9I,GACAD,EAAAuC,GAAAvC,EAAA,GAAA,IAAAA,EAAA,GAAAA,EAAA,GASAD,EAAA,IAAAyF,EANAvF,EADAmF,GAAA,IACA,KAAApF,GAEAC,EAAAmF,EAAAsC,iBACAC,MAAA,EAAA1H,EAAA4E,QAAA,KAAA,GAAA7E,IAKAD,EAAA,IAAAyF,EAAAJ,EAAAuB,YAGAJ,GAAAvG,EAAAwF,EAAA/D,WAAA,IAQA,GAHA1B,GADAG,EAAAH,GACAiH,KAAAY,EAAA1C,EAAAhF,EAAAqG,EAAA,EAAA,IAAAM,MAAA,IAGAxD,EAAAnD,EAAAoD,GAAAqE,MAAA,EAAApB,MAAAtG,EAAAoD,EAAAtD,EAAAuD,IAAAqE,MAAA,EAAApB,GAAA,CAKA,GAAA,SAJAtG,EAAAA,EAAA0H,MAAApB,EAAA,EAAAA,EAAA,MAIAe,GAAA,QAAArH,GAeA,EAIAA,KAAAA,EAAA0H,MAAA,IAAA,KAAA1H,EAAA6E,OAAA,MAGAO,EAAAtF,EAAAC,EAAA,EAAA,GACAqH,GAAAtH,EAAA8G,MAAA9G,GAAA8H,GAAA3C,IAGA,KACA,CAvBA,IAAAoC,IACAjC,EAAAnF,EAAAF,EAAA,EAAA,GAEAE,EAAA2G,MAAA3G,GAAA2H,GAAA3C,IAAA,CACAnF,EAAAG,EACA,KACA,CAGAqG,GAAA,EACAe,EAAA,CAcA,CAKA,OAFArF,GAAA,EAEAoD,EAAAtF,EAAAC,EAAAwF,EAAA9D,SAAA2F,EACA,EAgBAlE,EAAAiK,QAAAjK,EAAAkK,IAAA,WACA,IAAA/G,EAAArC,EACAiB,EAAArF,KACA2F,EAAAN,EAAAC,YAEA,OAAAD,EAAAuC,WACAvC,EAAAuB,SAAA,IAAAjB,EAAAN,IAEAoB,EAAAd,EAAA/D,UACAwC,EAAAuB,EAAA9D,SACA8D,EAAA/D,UAAA6E,EAAA,GACAd,EAAA9D,SAAA,GAEAwD,EAAAA,EAAA+H,OACA7H,EAAA,EACAF,EAAA0C,EAAA1C,EAAA,IAAAM,EAAA,GAAAuB,MAAA7B,EAAA2B,MAAA3B,IAAA6D,OAAAzC,EAAA,GAAA,GAEAd,EAAA/D,UAAA6E,EACAd,EAAA9D,SAAAuC,EAEAoB,EAAA,GAAAnE,GAAA,GAAAA,EAAAgE,EAAAgC,MAAAhC,EAAAoB,EAAArC,GAAA,IAfA,IAAAuB,EAAAC,IAgBA,EAwBAtC,EAAA0D,MAAA1D,EAAAmK,IAAA,SAAAzH,GACA,IAAA8G,EAAA3M,EAAAI,EAAAmD,EAAAxD,EAAAwN,EAAArN,EAAA4F,EAAAC,EACAb,EAAArF,KACA2F,EAAAN,EAAAC,YACAa,EAAAd,EAAA5B,EACA2C,GAAAJ,EAAA,IAAAL,EAAAK,IAAAvC,EAKA,GAHAuC,EAAAT,GAAAF,EAAAE,IAGAY,GAAAA,EAAA,IAAAC,GAAAA,EAAA,IAEA,OAAA,IAAAT,GAAAK,EAAAT,GAAAY,IAAAA,EAAA,KAAAC,GAAAA,IAAAA,EAAA,KAAAD,EAIAP,IAIAO,GAAAC,EAAA,EAAAJ,EAAAT,EAAAS,EAAAT,EAAA,GAoBA,IAjBApF,EAAAuC,EAAA2C,EAAAlF,EAjvDA,GAivDAuC,EAAAsD,EAAA7F,EAjvDA,IAkvDA8F,EAAAE,EAAAnF,SACAkF,EAAAE,EAAApF,UAIAd,EAAAiG,EACAA,EAAAC,EACAA,EAAAlG,EACAwN,EAAAzH,EACAA,EAAAC,EACAA,EAAAwH,GAIAxN,EAAA,GAEAK,EADAmN,EAAAzH,EAAAC,EACA3F,KAAAL,EAAAkM,KAAA,GAGA,IAAA7L,EAAA2F,IAAA3F,GAAA,GAAA,CAEA,IADAuM,EAAA,EACApJ,EAAAuC,EAAA1F,EAAAmD,EAAAnD,GACAF,EAAAH,EAAAwD,GAAA0C,EAAA7F,GAAA4F,EAAAzC,EAAAnD,EAAA,GAAAuM,EACA5M,EAAAwD,KAAArD,EAAA8C,EAAA,EACA2J,EAAAzM,EAAA8C,EAAA,EAGAjD,EAAAwD,IAAAxD,EAAAwD,GAAAoJ,GAAA3J,EAAA,CACA,CAGA,MAAAjD,IAAAwN,IAAAxN,EAAAmM,MAQA,OANAS,IAAA3M,EACAD,EAAAoM,QAEAtG,EAAAvC,EAAAvD,EACA8F,EAAA7F,EAAAoM,EAAArM,EAAAC,GAEAiC,EAAAoD,EAAAQ,EAAAL,EAAA/D,UAAA+D,EAAA9D,UAAAmE,CACA,EAaA1C,EAAAqK,SAAA,SAAAjH,EAAAtC,GACA,OAAAwJ,EAAA5N,KAAA,EAAA0G,EAAAtC,EACA,EAaAd,EAAAuK,gBAAAvK,EAAAwK,KAAA,SAAA5F,EAAA9D,GACA,IAAAiB,EAAArF,KACA2F,EAAAN,EAAAC,YAGA,OADAD,EAAA,IAAAM,EAAAN,QACA,IAAA6C,EAAA7C,GAEArB,EAAAkE,EAAA,EAAA3G,QAEA,IAAA6C,EAAAA,EAAAuB,EAAA9D,SACAmC,EAAAI,EAAA,EAAA,GAEAoB,EAAAH,EAAA6C,EAAA7C,EAAAlF,EAAA,EAAAiE,GACA,EAWAd,EAAAuE,cAAA,SAAAK,EAAA9D,GACA,IAAAP,EACAwB,EAAArF,KACA2F,EAAAN,EAAAC,YAcA,YAZA,IAAA4C,EACArE,EAAAkK,EAAA1I,GAAA,IAEArB,EAAAkE,EAAA,EAAA3G,QAEA,IAAA6C,EAAAA,EAAAuB,EAAA9D,SACAmC,EAAAI,EAAA,EAAA,GAGAP,EAAAkK,EADA1I,EAAAG,EAAA,IAAAG,EAAAN,GAAA6C,EAAA,EAAA9D,IACA,EAAA8D,EAAA,IAGA7C,EAAAuE,UAAAvE,EAAAuB,SAAA,IAAA/C,EAAAA,CACA,EAmBAP,EAAA0K,QAAA,SAAA9F,EAAA9D,GACA,IAAAP,EAAAmC,EACAX,EAAArF,KACA2F,EAAAN,EAAAC,YAgBA,YAdA,IAAA4C,EACArE,EAAAkK,EAAA1I,IAEArB,EAAAkE,EAAA,EAAA3G,QAEA,IAAA6C,EAAAA,EAAAuB,EAAA9D,SACAmC,EAAAI,EAAA,EAAA,GAGAP,EAAAkK,EADA/H,EAAAR,EAAA,IAAAG,EAAAN,GAAA6C,EAAA7C,EAAAlF,EAAA,EAAAiE,IACA,EAAA8D,EAAAlC,EAAA7F,EAAA,IAKAkF,EAAAuE,UAAAvE,EAAAuB,SAAA,IAAA/C,EAAAA,CACA,EAcAP,EAAA2K,WAAA,SAAAC,GACA,IAAAzK,EAAA0K,EAAAC,EAAAC,EAAAlO,EAAAuD,EAAAtD,EAAAkO,EAAAC,EAAA9H,EAAAgG,EAAAvM,EACAmF,EAAArF,KACAmG,EAAAd,EAAA5B,EACAkC,EAAAN,EAAAC,YAEA,IAAAa,EAAA,OAAA,IAAAR,EAAAN,GAUA,GARAkJ,EAAAJ,EAAA,IAAAxI,EAAA,GACAyI,EAAAE,EAAA,IAAA3I,EAAA,GAIAjC,GADAvD,GADAsD,EAAA,IAAAkC,EAAAyI,IACAjO,EAAA8M,EAAA9G,GAAAd,EAAAlF,EAAA,GAj6DA,EAm6DAsD,EAAAA,EAAA,GAAAZ,EAAA,GAAAa,EAAA,EAn6DA,EAm6DAA,EAAAA,GAEA,MAAAwK,EAGAA,EAAA/N,EAAA,EAAAsD,EAAA8K,MACA,CAEA,KADAnO,EAAA,IAAAuF,EAAAuI,IACAnD,SAAA3K,EAAAiL,GAAAkD,GAAA,MAAA3N,MAAA0B,EAAAlC,GACA8N,EAAA9N,EAAAyF,GAAApC,GAAAtD,EAAA,EAAAsD,EAAA8K,EAAAnO,CACA,CAOA,IALAgC,GAAA,EACAhC,EAAA,IAAAuF,EAAAnC,EAAA2C,IACAM,EAAAd,EAAA/D,UACA+D,EAAA/D,UAAAzB,EAl7DA,EAk7DAgG,EAAAnF,OAAA,EAGAyL,EAAA1E,EAAA3H,EAAAqD,EAAA,EAAA,EAAA,GAEA,IADA4K,EAAAF,EAAAhH,KAAAsF,EAAAzF,MAAAoH,KACAtI,IAAAoI,IACAC,EAAAC,EACAA,EAAAC,EACAA,EAAAE,EACAA,EAAAD,EAAAnH,KAAAsF,EAAAzF,MAAAqH,IACAC,EAAAD,EACAA,EAAA5K,EACAA,EAAArD,EAAA8G,MAAAuF,EAAAzF,MAAAqH,IACAjO,EAAAiO,EAeA,OAZAA,EAAAtG,EAAAmG,EAAAhH,MAAAiH,GAAAC,EAAA,EAAA,EAAA,GACAE,EAAAA,EAAAnH,KAAAkH,EAAArH,MAAAuH,IACAJ,EAAAA,EAAAhH,KAAAkH,EAAArH,MAAAoH,IACAE,EAAA/I,EAAAgJ,EAAAhJ,EAAAF,EAAAE,EAGArF,EAAA6H,EAAAwG,EAAAH,EAAAjO,EAAA,GAAA+G,MAAA7B,GAAAD,MAAAU,IAAAiC,EAAAuG,EAAAH,EAAAhO,EAAA,GAAA+G,MAAA7B,GAAAD,OAAA,EACA,CAAAmJ,EAAAH,GAAA,CAAAE,EAAAH,GAEAxI,EAAA/D,UAAA6E,EACArE,GAAA,EAEAlC,CACA,EAaAoD,EAAAkL,cAAAlL,EAAAmL,MAAA,SAAA/H,EAAAtC,GACA,OAAAwJ,EAAA5N,KAAA,GAAA0G,EAAAtC,EACA,EAmBAd,EAAAoL,UAAA,SAAA1I,EAAA5B,GACA,IAAAiB,EAAArF,KACA2F,EAAAN,EAAAC,YAIA,GAFAD,EAAA,IAAAM,EAAAN,GAEA,MAAAW,EAAA,CAGA,IAAAX,EAAA5B,EAAA,OAAA4B,EAEAW,EAAA,IAAAL,EAAA,GACAvB,EAAAuB,EAAA9D,QACA,KAAA,CASA,GARAmE,EAAA,IAAAL,EAAAK,QACA,IAAA5B,EACAA,EAAAuB,EAAA9D,SAEAmC,EAAAI,EAAA,EAAA,IAIAiB,EAAA5B,EAAA,OAAAuC,EAAAT,EAAAF,EAAAW,EAGA,IAAAA,EAAAvC,EAEA,OADAuC,EAAAT,IAAAS,EAAAT,EAAAF,EAAAE,GACAS,CAEA,CAeA,OAZAA,EAAAvC,EAAA,IACArB,GAAA,EACAiD,EAAA0C,EAAA1C,EAAAW,EAAA,EAAA5B,EAAA,GAAA4C,MAAAhB,GACA5D,GAAA,EACAoD,EAAAH,KAIAW,EAAAT,EAAAF,EAAAE,EACAF,EAAAW,GAGAX,CACA,EAQA/B,EAAAqL,SAAA,WACA,OAAA3O,IACA,EAaAsD,EAAAsL,QAAA,SAAAlI,EAAAtC,GACA,OAAAwJ,EAAA5N,KAAA,EAAA0G,EAAAtC,EACA,EA8CAd,EAAAuL,QAAAvL,EAAAR,IAAA,SAAAkD,GACA,IAAA7F,EAAAuD,EAAA+C,EAAAvG,EAAAkE,EAAAmB,EACAF,EAAArF,KACA2F,EAAAN,EAAAC,YACAwJ,IAAA9I,EAAA,IAAAL,EAAAK,IAGA,KAAAX,EAAA5B,GAAAuC,EAAAvC,GAAA4B,EAAA5B,EAAA,IAAAuC,EAAAvC,EAAA,IAAA,OAAA,IAAAkC,EAAA9C,GAAAwC,EAAAyJ,IAIA,IAFAzJ,EAAA,IAAAM,EAAAN,IAEA2C,GAAA,GAAA,OAAA3C,EAKA,GAHAoB,EAAAd,EAAA/D,UACAwC,EAAAuB,EAAA9D,SAEAmE,EAAAgC,GAAA,GAAA,OAAAxC,EAAAH,EAAAoB,EAAArC,GAMA,IAHAjE,EAAAuC,EAAAsD,EAAA7F,EAxnEA,KA2nEA6F,EAAAvC,EAAAzC,OAAA,IAAA0C,EAAAoL,EAAA,GAAAA,EAAAA,IA1nEA,iBA4nEA,OADA5O,EAAA6O,EAAApJ,EAAAN,EAAA3B,EAAA+C,GACAT,EAAAT,EAAA,EAAA,IAAAI,EAAA,GAAAyC,IAAAlI,GAAAsF,EAAAtF,EAAAuG,EAAArC,GAMA,IAHAmB,EAAAF,EAAAE,GAGA,EAAA,CAGA,GAAApF,EAAA6F,EAAAvC,EAAAzC,OAAA,EAAA,OAAA,IAAA2E,EAAAC,KAMA,GAHA,IAAA,EAAAI,EAAAvC,EAAAtD,MAAAoF,EAAA,GAGA,GAAAF,EAAAlF,GAAA,GAAAkF,EAAA5B,EAAA,IAAA,GAAA4B,EAAA5B,EAAAzC,OAEA,OADAqE,EAAAE,EAAAA,EACAF,CAEA,CAcA,OAPAlF,EAAA,IADAuD,EAAAb,GAAAwC,EAAAyJ,KACAlH,SAAAlE,GAEA,IAAAiC,EAAAjC,EAAA,IAAAvD,EADAuC,EAAAoM,GAAAnM,KAAA6I,IAAA,KAAAhI,EAAA6B,EAAA5B,IAAAd,KAAAlB,KAAA4D,EAAAlF,EAAA,KAMAwF,EAAAzD,KAAA,GAAA/B,EAAAwF,EAAA1D,KAAA,EAAA,IAAA0D,EAAAxF,EAAA,EAAAoF,EAAA,EAAA,IAEAnD,GAAA,EACAuD,EAAA9D,SAAAwD,EAAAE,EAAA,EAMA7B,EAAAf,KAAAsB,IAAA,IAAA9D,EAAA,IAAAa,SAGAd,EAAAwM,EAAA1G,EAAAgB,MAAA+E,EAAA1G,EAAAoB,EAAA/C,IAAA+C,IAGAhD,GAOAU,GAJAjE,EAAAsF,EAAAtF,EAAAuG,EAAA,EAAA,IAIAhD,EAAAgD,EAAArC,KACAjE,EAAAsG,EAAA,IAMAjD,GAHAtD,EAAAsF,EAAAkH,EAAA1G,EAAAgB,MAAA+E,EAAA1G,EAAAlF,EAAAuD,IAAAvD,GAAAA,EAAA,EAAA,IAGAsD,GAAAqE,MAAArB,EAAA,EAAAA,EAAA,IAAA,GAAA,OACAvG,EAAAsF,EAAAtF,EAAAuG,EAAA,EAAA,KAKAvG,EAAAqF,EAAAA,EACAnD,GAAA,EACAuD,EAAA9D,SAAAuC,EAEAoB,EAAAtF,EAAAuG,EAAArC,GACA,EAcAd,EAAA0L,YAAA,SAAAtI,EAAAtC,GACA,IAAAP,EACAwB,EAAArF,KACA2F,EAAAN,EAAAC,YAcA,YAZA,IAAAoB,EACA7C,EAAAkK,EAAA1I,EAAAA,EAAAlF,GAAAwF,EAAA5D,UAAAsD,EAAAlF,GAAAwF,EAAA3D,WAEAgC,EAAA0C,EAAA,EAAAnF,QAEA,IAAA6C,EAAAA,EAAAuB,EAAA9D,SACAmC,EAAAI,EAAA,EAAA,GAGAP,EAAAkK,EADA1I,EAAAG,EAAA,IAAAG,EAAAN,GAAAqB,EAAAtC,GACAsC,GAAArB,EAAAlF,GAAAkF,EAAAlF,GAAAwF,EAAA5D,SAAA2E,IAGArB,EAAAuE,UAAAvE,EAAAuB,SAAA,IAAA/C,EAAAA,CACA,EAiBAP,EAAA2L,oBAAA3L,EAAA4L,KAAA,SAAAxI,EAAAtC,GACA,IACAuB,EADA3F,KACAsF,YAYA,YAVA,IAAAoB,GACAA,EAAAf,EAAA/D,UACAwC,EAAAuB,EAAA9D,WAEAmC,EAAA0C,EAAA,EAAAnF,QAEA,IAAA6C,EAAAA,EAAAuB,EAAA9D,SACAmC,EAAAI,EAAA,EAAA,IAGAoB,EAAA,IAAAG,EAbA3F,MAaA0G,EAAAtC,EACA,EAUAd,EAAAwD,SAAA,WACA,IAAAzB,EAAArF,KACA2F,EAAAN,EAAAC,YACAzB,EAAAkK,EAAA1I,EAAAA,EAAAlF,GAAAwF,EAAA5D,UAAAsD,EAAAlF,GAAAwF,EAAA3D,UAEA,OAAAqD,EAAAuE,UAAAvE,EAAAuB,SAAA,IAAA/C,EAAAA,CACA,EAOAP,EAAA6L,UAAA7L,EAAA8L,MAAA,WACA,OAAA5J,EAAA,IAAAxF,KAAAsF,YAAAtF,MAAAA,KAAAG,EAAA,EAAA,EACA,EAQAmD,EAAA+L,QAAA/L,EAAAgM,OAAA,WACA,IAAAjK,EAAArF,KACA2F,EAAAN,EAAAC,YACAzB,EAAAkK,EAAA1I,EAAAA,EAAAlF,GAAAwF,EAAA5D,UAAAsD,EAAAlF,GAAAwF,EAAA3D,UAEA,OAAAqD,EAAAuE,QAAA,IAAA/F,EAAAA,CACA,EAkNA,IAAAkE,EAAA,WAGA,SAAAwH,EAAAlK,EAAA3B,EAAA+H,GACA,IAAA+D,EACA1C,EAAA,EACAvM,EAAA8E,EAAArE,OAEA,IAAAqE,EAAAA,EAAAyC,QAAAvH,KACAiP,EAAAnK,EAAA9E,GAAAmD,EAAAoJ,EACAzH,EAAA9E,GAAAiP,EAAA/D,EAAA,EACAqB,EAAA0C,EAAA/D,EAAA,EAKA,OAFAqB,GAAAzH,EAAA0H,QAAAD,GAEAzH,CACA,CAEA,SAAAoK,EAAA9O,EAAA+O,EAAAC,EAAAC,GACA,IAAArP,EAAAL,EAEA,GAAAyP,GAAAC,EACA1P,EAAAyP,EAAAC,EAAA,GAAA,OAEA,IAAArP,EAAAL,EAAA,EAAAK,EAAAoP,EAAApP,IACA,GAAAI,EAAAJ,IAAAmP,EAAAnP,GAAA,CACAL,EAAAS,EAAAJ,GAAAmP,EAAAnP,GAAA,GAAA,EACA,KACA,CAIA,OAAAL,CACA,CAEA,SAAA2P,EAAAlP,EAAA+O,EAAAC,EAAAlE,GAIA,IAHA,IAAAlL,EAAA,EAGAoP,KACAhP,EAAAgP,IAAApP,EACAA,EAAAI,EAAAgP,GAAAD,EAAAC,GAAA,EAAA,EACAhP,EAAAgP,GAAApP,EAAAkL,EAAA9K,EAAAgP,GAAAD,EAAAC,GAIA,MAAAhP,EAAA,IAAAA,EAAAK,OAAA,GAAAL,EAAA2L,OACA,CAEA,OAAA,SAAAjH,EAAAW,EAAAS,EAAArC,EAAA8D,EAAAuD,GACA,IAAA3F,EAAA3F,EAAAI,EAAAmD,EAAAoM,EAAAC,EAAAC,EAAAC,EAAAxD,EAAAyD,EAAAC,EAAAC,EAAAC,EAAA3J,EAAArG,EAAAiQ,EAAAC,EAAAC,EACAC,EAAAC,EACA/K,EAAAN,EAAAC,YACAqL,EAAAtL,EAAAE,GAAAS,EAAAT,EAAA,GAAA,EACAY,EAAAd,EAAA5B,EACA2C,EAAAJ,EAAAvC,EAGA,KAAA0C,GAAAA,EAAA,IAAAC,GAAAA,EAAA,IAEA,OAAA,IAAAT,EACAN,EAAAE,GAAAS,EAAAT,IAAAY,GAAAC,GAAAD,EAAA,IAAAC,EAAA,GAAAA,GAGAD,GAAA,GAAAA,EAAA,KAAAC,EAAA,EAAAuK,EAAAA,EAAA,EAHA/K,KAsBA,IAhBA6F,GACAqE,EAAA,EACA3P,EAAAkF,EAAAlF,EAAA6F,EAAA7F,IAEAsL,EAAAtI,EACA2M,EAxkFA,EAykFA3P,EAAAuC,EAAA2C,EAAAlF,EAAA2P,GAAApN,EAAAsD,EAAA7F,EAAA2P,IAGAW,EAAArK,EAAApF,OACAuP,EAAApK,EAAAnF,OAEAkP,GADAzD,EAAA,IAAA9G,EAAAgL,IACAlN,EAAA,GAIAlD,EAAA,EAAA6F,EAAA7F,KAAA4F,EAAA5F,IAAA,GAAAA,KAaA,GAXA6F,EAAA7F,IAAA4F,EAAA5F,IAAA,IAAAJ,IAEA,MAAAsG,GACAC,EAAAD,EAAAd,EAAA/D,UACAwC,EAAAuB,EAAA9D,UAEA6E,EADAwB,EACAzB,GAAApB,EAAAlF,EAAA6F,EAAA7F,GAAA,EAEAsG,EAGAC,EAAA,EACAwJ,EAAA9D,KAAA,GACA2D,GAAA,MACA,CAOA,GAJArJ,EAAAA,EAAAoJ,EAAA,EAAA,EACAvP,EAAA,EAGA,GAAAkQ,EAAA,CAMA,IALA/M,EAAA,EACA0C,EAAAA,EAAA,GACAM,KAGAnG,EAAAgQ,GAAA7M,IAAAgD,IAAAnG,IACAF,EAAAqD,EAAA+H,GAAAtF,EAAA5F,IAAA,GACA2P,EAAA3P,GAAAF,EAAA+F,EAAA,EACA1C,EAAArD,EAAA+F,EAAA,EAGA2J,EAAArM,GAAAnD,EAAAgQ,CAGA,KAAA,CAiBA,KAdA7M,EAAA+H,GAAArF,EAAA,GAAA,GAAA,GAEA,IACAA,EAAAmJ,EAAAnJ,EAAA1C,EAAA+H,GACAtF,EAAAoJ,EAAApJ,EAAAzC,EAAA+H,GACAgF,EAAArK,EAAApF,OACAuP,EAAApK,EAAAnF,QAGAsP,EAAAG,EAEAL,GADAD,EAAAhK,EAAA2B,MAAA,EAAA2I,IACAzP,OAGAoP,EAAAK,GAAAN,EAAAC,KAAA,GAEAM,EAAAtK,EAAA0B,SACAiF,QAAA,GACAyD,EAAApK,EAAA,GAEAA,EAAA,IAAAqF,EAAA,KAAA+E,EAEA,GACA9M,EAAA,GAGAoC,EAAA2J,EAAArJ,EAAA+J,EAAAM,EAAAL,IAGA,GAGAC,EAAAF,EAAA,GACAM,GAAAL,IAAAC,EAAAA,EAAA5E,GAAA0E,EAAA,IAAA,KAGAzM,EAAA2M,EAAAG,EAAA,GAUA,GACA9M,GAAA+H,IAAA/H,EAAA+H,EAAA,GAWA,IAHA3F,EAAA2J,EALAO,EAAAT,EAAAnJ,EAAA1C,EAAA+H,GAKA0E,EAJAF,EAAAD,EAAAhP,OACAoP,EAAAD,EAAAnP,WAOA0C,IAGAmM,EAAAG,EAAAS,EAAAR,EAAAS,EAAAtK,EAAA6J,EAAAxE,MAOA,GAAA/H,IAAAoC,EAAApC,EAAA,GACAsM,EAAA5J,EAAA0B,UAGAmI,EAAAD,EAAAhP,QACAoP,GAAAJ,EAAAjD,QAAA,GAGA8C,EAAAM,EAAAH,EAAAI,EAAA3E,IAGA,GAAA3F,IAIAA,EAAA2J,EAAArJ,EAAA+J,EAAAM,EAHAL,EAAAD,EAAAnP,SAMA,IACA0C,IAGAmM,EAAAM,EAAAM,EAAAL,EAAAM,EAAAtK,EAAAgK,EAAA3E,IAIA2E,EAAAD,EAAAnP,QACA,IAAA8E,IACApC,IACAyM,EAAA,CAAA,IAIAD,EAAA3P,KAAAmD,EAGAoC,GAAAqK,EAAA,GACAA,EAAAC,KAAAjK,EAAAmK,IAAA,GAEAH,EAAA,CAAAhK,EAAAmK,IACAF,EAAA,UAGAE,IAAAC,QAAA,IAAAJ,EAAA,KAAAzJ,KAEAqJ,OAAA,IAAAI,EAAA,EACA,CAGAD,EAAA,IAAAA,EAAA5D,OACA,CAGA,GAAA,GAAAwD,EACArD,EAAAtM,EAAAA,EACAgB,EAAA4O,MACA,CAGA,IAAAxP,EAAA,EAAAmD,EAAAwM,EAAA,GAAAxM,GAAA,GAAAA,GAAA,GAAAnD,IACAkM,EAAAtM,EAAAI,EAAAJ,EAAA2P,EAAA,EAEAtK,EAAAiH,EAAAvE,EAAAzB,EAAAgG,EAAAtM,EAAA,EAAAsG,EAAArC,EAAA2L,EACA,CAEA,OAAAtD,CACA,CACA,CArQA,GA4QA,SAAAjH,EAAAH,EAAAqB,EAAAtC,EAAAwM,GACA,IAAAC,EAAAtQ,EAAAqE,EAAAlB,EAAAa,EAAAuM,EAAAhN,EAAAqC,EAAA4K,EACApL,EAAAN,EAAAC,YAGA0L,EAAA,GAAA,MAAAtK,EAAA,CAIA,KAHAP,EAAAd,EAAA5B,GAGA,OAAA4B,EAWA,IAAAwL,EAAA,EAAAnN,EAAAyC,EAAA,GAAAzC,GAAA,GAAAA,GAAA,GAAAmN,IAIA,IAHAtQ,EAAAmG,EAAAmK,GAGA,EACAtQ,GApyFA,EAqyFAqE,EAAA8B,EAIAnC,GAHAT,EAAAqC,EAAA4K,EAAA,IAGAlO,EAAA,GAAAgO,EAAAjM,EAAA,GAAA,GAAA,OAIA,IAFAmM,EAAApO,KAAA6B,MAAAjE,EAAA,GA3yFA,MA4yFAmD,EAAAyC,EAAAnF,QACA,CACA,IAAA4P,EASA,MAAAI,EANA,KAAAtN,KAAAqN,GAAA5K,EAAAiG,KAAA,GACAtI,EAAAS,EAAA,EACAsM,EAAA,EAEAjM,GADArE,GApzFA,KAqzFA,CAIA,KAAA,CAIA,IAHAuD,EAAAJ,EAAAyC,EAAA4K,GAGAF,EAAA,EAAAnN,GAAA,GAAAA,GAAA,GAAAmN,IAUAtM,GAHAK,GAJArE,GAh0FA,KAo0FAsQ,GAGA,EAAA,EAAA/M,EAAAjB,EAAA,GAAAgO,EAAAjM,EAAA,GAAA,GAAA,CACA,CAmBA,GAfAgM,EAAAA,GAAAlK,EAAA,QACA,IAAAP,EAAA4K,EAAA,KAAAnM,EAAA,EAAAd,EAAAA,EAAAjB,EAAA,GAAAgO,EAAAjM,EAAA,IAMAkM,EAAA1M,EAAA,GACAG,GAAAqM,KAAA,GAAAxM,GAAAA,IAAAiB,EAAAE,EAAA,EAAA,EAAA,IACAhB,EAAA,GAAA,GAAAA,IAAA,GAAAH,GAAAwM,GAAA,GAAAxM,IAGA7D,EAAA,EAAAqE,EAAA,EAAAd,EAAAjB,EAAA,GAAAgO,EAAAjM,GAAA,EAAAuB,EAAA4K,EAAA,IAAA,GAAA,GACA3M,IAAAiB,EAAAE,EAAA,EAAA,EAAA,IAEAmB,EAAA,IAAAP,EAAA,GAgBA,OAfAA,EAAAnF,OAAA,EACA8P,GAGApK,GAAArB,EAAAlF,EAAA,EAGAgG,EAAA,GAAAtD,EAAA,IAn2FA,EAm2FA6D,EAn2FA,MAo2FArB,EAAAlF,GAAAuG,GAAA,GAIAP,EAAA,GAAAd,EAAAlF,EAAA,EAGAkF,EAiBA,GAbA,GAAA9E,GACA4F,EAAAnF,OAAA+P,EACArN,EAAA,EACAqN,MAEA5K,EAAAnF,OAAA+P,EAAA,EACArN,EAAAb,EAAA,GAr3FA,EAq3FAtC,GAIA4F,EAAA4K,GAAAnM,EAAA,GAAAd,EAAAjB,EAAA,GAAAgO,EAAAjM,GAAA/B,EAAA,GAAA+B,GAAA,GAAAlB,EAAA,GAGAoN,EACA,OAAA,CAGA,GAAA,GAAAC,EAAA,CAGA,IAAAxQ,EAAA,EAAAqE,EAAAuB,EAAA,GAAAvB,GAAA,GAAAA,GAAA,GAAArE,IAEA,IADAqE,EAAAuB,EAAA,IAAAzC,EACAA,EAAA,EAAAkB,GAAA,GAAAA,GAAA,GAAAlB,IAGAnD,GAAAmD,IACA2B,EAAAlF,IACAgG,EAAA,IAAAhD,IAAAgD,EAAA,GAAA,IAGA,KACA,CAEA,GADAA,EAAA4K,IAAArN,EACAyC,EAAA4K,IAAA5N,EAAA,MACAgD,EAAA4K,KAAA,EACArN,EAAA,CAEA,CAIA,IAAAnD,EAAA4F,EAAAnF,OAAA,IAAAmF,IAAA5F,IAAA4F,EAAAkG,KACA,CAqBA,OAnBAjK,IAGAiD,EAAAlF,EAAAwF,EAAAzD,MAGAmD,EAAA5B,EAAA,KACA4B,EAAAlF,EAAAyF,KAGAP,EAAAlF,EAAAwF,EAAA1D,OAGAoD,EAAAlF,EAAA,EACAkF,EAAA5B,EAAA,CAAA,KAKA4B,CACA,CAGA,SAAA0I,EAAA1I,EAAA4L,EAAAvK,GACA,IAAArB,EAAAuC,WAAA,OAAAsJ,EAAA7L,GACA,IAAA3B,EACAvD,EAAAkF,EAAAlF,EACA0D,EAAAL,EAAA6B,EAAA5B,GACAkD,EAAA9C,EAAA7C,OAwBA,OAtBAiQ,GACAvK,IAAAhD,EAAAgD,EAAAC,GAAA,EACA9C,EAAAA,EAAAoB,OAAA,GAAA,IAAApB,EAAAiE,MAAA,GAAA/D,EAAAL,GACAiD,EAAA,IACA9C,EAAAA,EAAAoB,OAAA,GAAA,IAAApB,EAAAiE,MAAA,IAGAjE,EAAAA,GAAAwB,EAAAlF,EAAA,EAAA,IAAA,MAAAkF,EAAAlF,GACAA,EAAA,GACA0D,EAAA,KAAAE,GAAA5D,EAAA,GAAA0D,EACA6C,IAAAhD,EAAAgD,EAAAC,GAAA,IAAA9C,GAAAE,EAAAL,KACAvD,GAAAwG,GACA9C,GAAAE,EAAA5D,EAAA,EAAAwG,GACAD,IAAAhD,EAAAgD,EAAAvG,EAAA,GAAA,IAAA0D,EAAAA,EAAA,IAAAE,EAAAL,OAEAA,EAAAvD,EAAA,GAAAwG,IAAA9C,EAAAA,EAAAiE,MAAA,EAAApE,GAAA,IAAAG,EAAAiE,MAAApE,IACAgD,IAAAhD,EAAAgD,EAAAC,GAAA,IACAxG,EAAA,IAAAwG,IAAA9C,GAAA,KACAA,GAAAE,EAAAL,KAIAG,CACA,CAIA,SAAA0I,EAAAsE,EAAA1Q,GACA,IAAA2D,EAAA+M,EAAA,GAGA,IAAA1Q,GAx9FA,EAw9FA2D,GAAA,GAAAA,GAAA,GAAA3D,IACA,OAAAA,CACA,CAGA,SAAA6L,EAAArG,EAAAe,EAAAD,GACA,GAAAC,EAAAtD,EAKA,MAFAhB,GAAA,EACAqE,IAAAd,EAAA/D,UAAA6E,GACA7F,MAAA2B,GAEA,OAAAiD,EAAA,IAAAG,EAAAlE,GAAAiF,EAAA,GAAA,EACA,CAGA,SAAAmD,EAAAlE,EAAAe,EAAAtC,GACA,GAAAsC,EAAArD,EAAA,MAAAzC,MAAA2B,GACA,OAAAiD,EAAA,IAAAG,EAAAjE,GAAAgF,EAAAtC,GAAA,EACA,CAGA,SAAA6I,EAAA4D,GACA,IAAA/M,EAAA+M,EAAA7P,OAAA,EACA2F,EAj/FA,EAi/FA7C,EAAA,EAKA,GAHAA,EAAA+M,EAAA/M,GAGA,CAGA,KAAAA,EAAA,IAAA,EAAAA,GAAA,GAAA6C,IAGA,IAAA7C,EAAA+M,EAAA,GAAA/M,GAAA,GAAAA,GAAA,GAAA6C,GACA,CAEA,OAAAA,CACA,CAGA,SAAA5C,EAAAL,GAEA,IADA,IAAAyN,EAAA,GACAzN,KAAAyN,GAAA,IACA,OAAAA,CACA,CAUA,SAAApC,EAAApJ,EAAAN,EAAAjF,EAAAqG,GACA,IAAAmK,EACA1Q,EAAA,IAAAyF,EAAA,GAIAjC,EAAAf,KAAA6B,KAAAiC,EAvhGA,EAuhGA,GAIA,IAFArE,GAAA,IAEA,CAOA,GANAhC,EAAA,GAEAgR,GADAlR,EAAAA,EAAA8G,MAAA3B,IACA5B,EAAAC,KAAAkN,GAAA,GAIA,KADAxQ,EAAAsC,EAAAtC,EAAA,IACA,CAGAA,EAAAF,EAAAuD,EAAAzC,OAAA,EACA4P,GAAA,IAAA1Q,EAAAuD,EAAArD,MAAAF,EAAAuD,EAAArD,GACA,KACA,CAGAgR,GADA/L,EAAAA,EAAA2B,MAAA3B,IACA5B,EAAAC,EACA,CAIA,OAFAtB,GAAA,EAEAlC,CACA,CAGA,SAAAmR,EAAAjR,GACA,OAAA,EAAAA,EAAAqD,EAAArD,EAAAqD,EAAAzC,OAAA,EACA,CAMA,SAAAsQ,EAAA3L,EAAA4L,EAAAC,GAKA,IAJA,IAAAxL,EACAX,EAAA,IAAAM,EAAA4L,EAAA,IACAhR,EAAA,IAEAA,EAAAgR,EAAAvQ,QAAA,CAEA,KADAgF,EAAA,IAAAL,EAAA4L,EAAAhR,KACAgF,EAAA,CACAF,EAAAW,EACA,KACA,CAAAX,EAAAmM,GAAAxL,KACAX,EAAAW,EAEA,CAEA,OAAAX,CACA,CAkCA,SAAAqH,EAAArH,EAAAqB,GACA,IAAAiF,EAAA8F,EAAA7M,EAAA9B,EAAA4O,EAAArR,EAAAkK,EACA9C,EAAA,EACAlH,EAAA,EACAmD,EAAA,EACAiC,EAAAN,EAAAC,YACAlB,EAAAuB,EAAA9D,SACA4E,EAAAd,EAAA/D,UAGA,IAAAyD,EAAA5B,IAAA4B,EAAA5B,EAAA,IAAA4B,EAAAlF,EAAA,GAEA,OAAA,IAAAwF,EAAAN,EAAA5B,EACA4B,EAAA5B,EAAA,GAAA4B,EAAAE,EAAA,EAAA,EAAA,IAAA,EACAF,EAAAE,EAAAF,EAAAE,EAAA,EAAA,EAAAF,EAAA,KAaA,IAVA,MAAAqB,GACAtE,GAAA,EACAmI,EAAA9D,GAEA8D,EAAA7D,EAGArG,EAAA,IAAAsF,EAAA,QAGAN,EAAAlF,GAAA,GAGAkF,EAAAA,EAAA2B,MAAA3G,GACAqD,GAAA,EAUA,IAJA6G,GADAkH,EAAA9O,KAAA6I,IAAA3I,EAAA,EAAAa,IAAAf,KAAAlB,KAAA,EAAA,EAAA,EAEAkK,EAAA7I,EAAA4O,EAAA,IAAA/L,EAAA,GACAA,EAAA/D,UAAA2I,IAEA,CAKA,GAJAzH,EAAA0C,EAAA1C,EAAAkE,MAAA3B,GAAAkF,EAAA,GACAoB,EAAAA,EAAA3E,QAAAzG,GAGAiD,GAFAnD,EAAAqR,EAAAvK,KAAAY,EAAAjF,EAAA6I,EAAApB,EAAA,KAEA9G,GAAAqE,MAAA,EAAAyC,KAAA/G,EAAAkO,EAAAjO,GAAAqE,MAAA,EAAAyC,GAAA,CAEA,IADA3F,EAAAlB,EACAkB,KAAA8M,EAAAlM,EAAAkM,EAAA1K,MAAA0K,GAAAnH,EAAA,GAOA,GAAA,MAAA7D,EAYA,OADAf,EAAA/D,UAAA6E,EACAiL,EAVA,KAAAjK,EAAA,GAAAtD,EAAAuN,EAAAjO,EAAA8G,EAAAkH,EAAArN,EAAAqD,IAMA,OAAAjC,EAAAkM,EAAA/L,EAAA/D,UAAA6E,EAAArC,EAAAhC,GAAA,GALAuD,EAAA/D,UAAA2I,GAAA,GACAoB,EAAA7I,EAAAzC,EAAA,IAAAsF,EAAA,GACApF,EAAA,EACAkH,GAQA,CAEAiK,EAAArR,CACA,CACA,CAkBA,SAAA0L,EAAA/F,EAAAU,GACA,IAAAlG,EAAAmR,EAAAhG,EAAAxL,EAAAyR,EAAAnK,EAAAiK,EAAArR,EAAAkK,EAAAsH,EAAAhH,EACAzK,EAAA,EAEAiF,EAAAW,EACAG,EAAAd,EAAA5B,EACAkC,EAAAN,EAAAC,YACAlB,EAAAuB,EAAA9D,SACA4E,EAAAd,EAAA/D,UAGA,GAAAyD,EAAAE,EAAA,IAAAY,IAAAA,EAAA,KAAAd,EAAAlF,GAAA,GAAAgG,EAAA,IAAA,GAAAA,EAAAnF,OACA,OAAA,IAAA2E,EAAAQ,IAAAA,EAAA,IAAA,IAAA,GAAAd,EAAAE,EAAAK,IAAAO,EAAA,EAAAd,GAcA,GAXA,MAAAqB,GACAtE,GAAA,EACAmI,EAAA9D,GAEA8D,EAAA7D,EAGAf,EAAA/D,UAAA2I,GAnBA,GAqBAoH,GADAnR,EAAAgD,EAAA2C,IACAlB,OAAA,KAEAtC,KAAAyC,IAAAjF,EAAAkF,EAAAlF,GAAA,OAqCA,OAJAE,EAAA2L,EAAArG,EAAA4E,EAAA,EAAA9D,GAAAO,MAAA7G,EAAA,IACAkF,EAAA0G,EAAA,IAAApG,EAAAgM,EAAA,IAAAnR,EAAAsH,MAAA,IAAAyC,EAzDA,IAyDApD,KAAA9G,GACAsF,EAAA/D,UAAA6E,EAEA,MAAAC,EAAAlB,EAAAH,EAAAoB,EAAArC,EAAAhC,GAAA,GAAAiD,EAxBA,KAAAsM,EAAA,GAAA,GAAAA,GAAA,GAAAA,GAAAnR,EAAAyE,OAAA,GAAA,GAGA0M,GADAnR,EAAAgD,GADA6B,EAAAA,EAAA2B,MAAAhB,IACAvC,IACAwB,OAAA,GACA7E,IAiCA,IA9BAD,EAAAkF,EAAAlF,EAEAwR,EAAA,GACAtM,EAAA,IAAAM,EAAA,KAAAnF,GACAL,KAEAkF,EAAA,IAAAM,EAAAgM,EAAA,IAAAnR,EAAAsH,MAAA,IAeA+J,EAAAxM,EAKAqM,EAAAE,EAAAvM,EAAA0C,EAAA1C,EAAA6B,MAAA,GAAA7B,EAAA8B,KAAA,GAAAoD,EAAA,GACAM,EAAArF,EAAAH,EAAA2B,MAAA3B,GAAAkF,EAAA,GACAoB,EAAA,IAEA,CAIA,GAHAiG,EAAApM,EAAAoM,EAAA5K,MAAA6D,GAAAN,EAAA,GAGA/G,GAFAnD,EAAAqR,EAAAvK,KAAAY,EAAA6J,EAAA,IAAAjM,EAAAgG,GAAApB,EAAA,KAEA9G,GAAAqE,MAAA,EAAAyC,KAAA/G,EAAAkO,EAAAjO,GAAAqE,MAAA,EAAAyC,GAAA,CAcA,GAbAmH,EAAAA,EAAA1K,MAAA,GAIA,IAAA7G,IAAAuR,EAAAA,EAAAvK,KAAA6E,EAAArG,EAAA4E,EAAA,EAAA9D,GAAAO,MAAA7G,EAAA,MACAuR,EAAA3J,EAAA2J,EAAA,IAAA/L,EAAAvF,GAAAmK,EAAA,GAQA,MAAA7D,EAWA,OADAf,EAAA/D,UAAA6E,EACAiL,EAVA,IAAAvN,EAAAuN,EAAAjO,EAAA8G,EA5FA,GA4FAnG,EAAAqD,GAMA,OAAAjC,EAAAkM,EAAA/L,EAAA/D,UAAA6E,EAAArC,EAAAhC,GAAA,GALAuD,EAAA/D,UAAA2I,GA7FA,GA8FAlK,EAAAuR,EAAAvM,EAAA0C,EAAA8J,EAAA3K,MAAA,GAAA2K,EAAA1K,KAAA,GAAAoD,EAAA,GACAM,EAAArF,EAAAH,EAAA2B,MAAA3B,GAAAkF,EAAA,GACAoB,EAAAlE,EAAA,CAQA,CAEAiK,EAAArR,EACAsL,GAAA,CACA,CACA,CAIA,SAAAuF,EAAA7L,GAEA,OAAAyM,OAAAzM,EAAAE,EAAAF,EAAAE,EAAA,EACA,CAMA,SAAAwM,EAAA1M,EAAAxB,GACA,IAAA1D,EAAAI,EAAAoG,EAmBA,KAhBAxG,EAAA0D,EAAAmB,QAAA,OAAA,IAAAnB,EAAAA,EAAAmO,QAAA,IAAA,MAGAzR,EAAAsD,EAAAoO,OAAA,OAAA,GAGA9R,EAAA,IAAAA,EAAAI,GACAJ,IAAA0D,EAAAiE,MAAAvH,EAAA,GACAsD,EAAAA,EAAAqO,UAAA,EAAA3R,IACAJ,EAAA,IAGAA,EAAA0D,EAAA7C,QAIAT,EAAA,EAAA,KAAAsD,EAAAsO,WAAA5R,GAAAA,KAGA,IAAAoG,EAAA9C,EAAA7C,OAAA,KAAA6C,EAAAsO,WAAAxL,EAAA,KAAAA,GAGA,GAFA9C,EAAAA,EAAAiE,MAAAvH,EAAAoG,GAEA,CAYA,GAXAA,GAAApG,EACA8E,EAAAlF,EAAAA,EAAAA,EAAAI,EAAA,EACA8E,EAAA5B,EAAA,GAMAlD,GAAAJ,EAAA,GAz2GA,EA02GAA,EAAA,IAAAI,GA12GA,GA42GAA,EAAAoG,EAAA,CAEA,IADApG,GAAA8E,EAAA5B,EAAA2I,MAAAvI,EAAAiE,MAAA,EAAAvH,IACAoG,GA92GA,EA82GApG,EAAAoG,GAAAtB,EAAA5B,EAAA2I,MAAAvI,EAAAiE,MAAAvH,EAAAA,GA92GA,IAg3GAA,EAh3GA,GA+2GAsD,EAAAA,EAAAiE,MAAAvH,IACAS,MACA,MACAT,GAAAoG,EAGA,KAAApG,KAAAsD,GAAA,IACAwB,EAAA5B,EAAA2I,MAAAvI,GAEAzB,IAGAiD,EAAAlF,EAAAkF,EAAAC,YAAApD,MAGAmD,EAAA5B,EAAA,KACA4B,EAAAlF,EAAAyF,KAGAP,EAAAlF,EAAAkF,EAAAC,YAAArD,OAGAoD,EAAAlF,EAAA,EACAkF,EAAA5B,EAAA,CAAA,IAIA,MAGA4B,EAAAlF,EAAA,EACAkF,EAAA5B,EAAA,CAAA,GAGA,OAAA4B,CACA,CAMA,SAAA+M,EAAA/M,EAAAxB,GACA,IAAA4H,EAAA9F,EAAA0M,EAAA9R,EAAA+R,EAAA3L,EAAA7F,EAAAqF,EAAA+F,EAEA,GAAArI,EAAAmB,QAAA,MAAA,GAEA,GADAnB,EAAAA,EAAAmO,QAAA,eAAA,MACA9O,EAAAqP,KAAA1O,GAAA,OAAAkO,EAAA1M,EAAAxB,QACA,GAAA,aAAAA,GAAA,QAAAA,EAIA,OAHAA,IAAAwB,EAAAE,EAAAK,KACAP,EAAAlF,EAAAyF,IACAP,EAAA5B,EAAA,KACA4B,EAGA,GAAArC,EAAAuP,KAAA1O,GACA4H,EAAA,GACA5H,EAAAA,EAAA2O,mBACA,GAAAzP,EAAAwP,KAAA1O,GACA4H,EAAA,MACA,KAAAxI,EAAAsP,KAAA1O,GAGA,MAAAjD,MAAA0B,EAAAuB,GAFA4H,EAAA,CAGA,CA+BA,KA5BAlL,EAAAsD,EAAAoO,OAAA,OAEA,GACAnR,GAAA+C,EAAAiE,MAAAvH,EAAA,GACAsD,EAAAA,EAAAqO,UAAA,EAAA3R,IAEAsD,EAAAA,EAAAiE,MAAA,GAMAwK,GADA/R,EAAAsD,EAAAmB,QAAA,OACA,EACAW,EAAAN,EAAAC,YAEAgN,IAGA/R,GADAoG,GADA9C,EAAAA,EAAAmO,QAAA,IAAA,KACAhR,QACAT,EAGA8R,EAAAtD,EAAApJ,EAAA,IAAAA,EAAA8F,GAAAlL,EAAA,EAAAA,IAOAA,EAHA2L,GADA/F,EAAA1B,EAAAZ,EAAA4H,EAAAtI,IACAnC,OAAA,EAGA,IAAAmF,EAAA5F,KAAAA,EAAA4F,EAAAkG,MACA,OAAA9L,EAAA,EAAA,IAAAoF,EAAA,EAAAN,EAAAE,IACAF,EAAAlF,EAAAoM,EAAApG,EAAA+F,GACA7G,EAAA5B,EAAA0C,EACA/D,GAAA,EAQAkQ,IAAAjN,EAAA0C,EAAA1C,EAAAgN,EAAA,EAAA1L,IAGA7F,IAAAuE,EAAAA,EAAA2B,MAAArE,KAAAyC,IAAAtE,GAAA,GAAA+B,EAAA,EAAA/B,GAAAI,EAAA4B,IAAA,EAAAhC,KACAsB,GAAA,EAEAiD,EACA,CA0CA,SAAA0B,EAAApB,EAAAvF,EAAAiF,EAAAW,EAAAyM,GACA,IAAA7N,EAAAvE,EAAAK,EAAAmK,EAEApE,EAAAd,EAAA/D,UACA8B,EAAAf,KAAA6B,KAAAiC,EA9gHA,GAohHA,IAJArE,GAAA,EACAyI,EAAAxF,EAAA2B,MAAA3B,GACA3E,EAAA,IAAAiF,EAAAK,KAEA,CAMA,GALA3F,EAAA0H,EAAArH,EAAAsG,MAAA6D,GAAA,IAAAlF,EAAAvF,IAAAA,KAAAqG,EAAA,GACA/F,EAAA+R,EAAAzM,EAAAmB,KAAA9G,GAAA2F,EAAAkB,MAAA7G,GACA2F,EAAA+B,EAAA1H,EAAA2G,MAAA6D,GAAA,IAAAlF,EAAAvF,IAAAA,KAAAqG,EAAA,QAGA,KAFApG,EAAAK,EAAAyG,KAAAnB,IAEAvC,EAAAC,GAAA,CACA,IAAAkB,EAAAlB,EAAArD,EAAAoD,EAAAmB,KAAAlE,EAAA+C,EAAAmB,IAAAA,MACA,IAAA,GAAAA,EAAA,KACA,CAEAA,EAAAlE,EACAA,EAAAsF,EACAA,EAAA3F,EACAA,EAAAuE,CAEA,CAKA,OAHAxC,GAAA,EACA/B,EAAAoD,EAAAzC,OAAA0C,EAAA,EAEArD,CACA,CAIA,SAAAwG,EAAA6I,EAAAvP,GAEA,IADA,IAAAC,EAAAsP,IACAvP,GAAAC,GAAAsP,EACA,OAAAtP,CACA,CAIA,SAAAgH,EAAAzB,EAAAN,GACA,IAAAhF,EACAuJ,EAAAvE,EAAAE,EAAA,EACAmN,EAAA7I,EAAAlE,EAAAA,EAAA/D,UAAA,GACA+H,EAAA+I,EAAA1L,MAAA,IAIA,IAFA3B,EAAAA,EAAAD,OAEA6E,IAAAN,GAEA,OADAtI,EAAAuI,EAAA,EAAA,EACAvE,EAKA,IAFAhF,EAAAgF,EAAAiD,SAAAoK,IAEA9L,SACAvF,EAAAuI,EAAA,EAAA,MACA,CAIA,IAHAvE,EAAAA,EAAA6B,MAAA7G,EAAA2G,MAAA0L,KAGAzI,IAAAN,GAEA,OADAtI,EAAAgQ,EAAAhR,GAAAuJ,EAAA,EAAA,EAAAA,EAAA,EAAA,EACAvE,EAGAhE,EAAAgQ,EAAAhR,GAAAuJ,EAAA,EAAA,EAAAA,EAAA,EAAA,CACA,CAEA,OAAAvE,EAAA6B,MAAAwL,GAAAtN,KACA,CAQA,SAAAwI,EAAAvI,EAAAV,EAAA+B,EAAAtC,GACA,IAAAqH,EAAAtL,EAAAI,EAAAmD,EAAAiD,EAAAmK,EAAAjN,EAAAsC,EAAAH,EACAL,EAAAN,EAAAC,YACA2L,OAAA,IAAAvK,EAWA,GATAuK,GACAjN,EAAA0C,EAAA,EAAAnF,QACA,IAAA6C,EAAAA,EAAAuB,EAAA9D,SACAmC,EAAAI,EAAA,EAAA,KAEAsC,EAAAf,EAAA/D,UACAwC,EAAAuB,EAAA9D,UAGAwD,EAAAuC,WAEA,CAoCA,IA3BAqJ,GACAxF,EAAA,EACA,IAAA9G,EACA+B,EAAA,EAAAA,EAAA,EACA,GAAA/B,IACA+B,EAAA,EAAAA,EAAA,IAGA+E,EAAA9G,GAfApE,GADAsD,EAAAkK,EAAA1I,IACAL,QAAA,OAsBA,IACAnB,EAAAA,EAAAmO,QAAA,IAAA,KACAhM,EAAA,IAAAL,EAAA,IACAxF,EAAA0D,EAAA7C,OAAAT,EACAyF,EAAAvC,EAAAgB,EAAAsJ,EAAA/H,GAAA,GAAAyF,GACAzF,EAAA7F,EAAA6F,EAAAvC,EAAAzC,QAIAb,EAAAwG,GADAR,EAAA1B,EAAAZ,EAAA,GAAA4H,IACAzK,OAGA,GAAAmF,IAAAQ,IAAAR,EAAAkG,MAEA,GAAAlG,EAAA,GAEA,CAyBA,GAxBA5F,EAAA,EACAJ,MAEAkF,EAAA,IAAAM,EAAAN,IACA5B,EAAA0C,EACAd,EAAAlF,EAAAA,EAEAgG,GADAd,EAAA0C,EAAA1C,EAAAW,EAAAU,EAAAtC,EAAA,EAAAqH,IACAhI,EACAtD,EAAAkF,EAAAlF,EACA2Q,EAAA3P,GAIAZ,EAAA4F,EAAAO,GACAhD,EAAA+H,EAAA,EACAqF,EAAAA,QAAA,IAAA3K,EAAAO,EAAA,GAEAoK,EAAA1M,EAAA,QACA,IAAA7D,GAAAuQ,KAAA,IAAA1M,GAAAA,KAAAiB,EAAAE,EAAA,EAAA,EAAA,IACAhF,EAAAmD,GAAAnD,IAAAmD,IAAA,IAAAU,GAAA0M,GAAA,IAAA1M,GAAA,EAAA+B,EAAAO,EAAA,IACAtC,KAAAiB,EAAAE,EAAA,EAAA,EAAA,IAEAY,EAAAnF,OAAA0F,EAEAoK,EAGA,OAAA3K,IAAAO,GAAA+E,EAAA,GACAtF,EAAAO,GAAA,EACAA,MACAvG,EACAgG,EAAA4G,QAAA,IAMA,IAAApG,EAAAR,EAAAnF,QAAAmF,EAAAQ,EAAA,KAAAA,GAGA,IAAApG,EAAA,EAAAsD,EAAA,GAAAtD,EAAAoG,EAAApG,IAAAsD,GAAArC,EAAAyD,OAAAkB,EAAA5F,IAGA,GAAA0Q,EAAA,CACA,GAAAtK,EAAA,EACA,GAAA,IAAAhC,GAAA,GAAAA,EAAA,CAEA,IADApE,EAAA,IAAAoE,EAAA,EAAA,IACAgC,EAAAA,EAAApG,EAAAoG,IAAA9C,GAAA,IAEA,IAAA8C,GADAR,EAAA1B,EAAAZ,EAAA4H,EAAA9G,IACA3D,QAAAmF,EAAAQ,EAAA,KAAAA,GAGA,IAAApG,EAAA,EAAAsD,EAAA,KAAAtD,EAAAoG,EAAApG,IAAAsD,GAAArC,EAAAyD,OAAAkB,EAAA5F,GACA,MACAsD,EAAAA,EAAAoB,OAAA,GAAA,IAAApB,EAAAiE,MAAA,GAIAjE,EAAAA,GAAA1D,EAAA,EAAA,IAAA,MAAAA,CACA,MAAA,GAAAA,EAAA,EAAA,CACA,OAAAA,GAAA0D,EAAA,IAAAA,EACAA,EAAA,KAAAA,CACA,MACA,KAAA1D,EAAAwG,EAAA,IAAAxG,GAAAwG,EAAAxG,KAAA0D,GAAA,SACA1D,EAAAwG,IAAA9C,EAAAA,EAAAiE,MAAA,EAAA3H,GAAA,IAAA0D,EAAAiE,MAAA3H,GAEA,MApEA0D,EAAAoN,EAAA,OAAA,IAsEApN,GAAA,IAAAc,EAAA,KAAA,GAAAA,EAAA,KAAA,GAAAA,EAAA,KAAA,IAAAd,CACA,MA/GAA,EAAAqN,EAAA7L,GAiHA,OAAAA,EAAAE,EAAA,EAAA,IAAA1B,EAAAA,CACA,CAIA,SAAAuN,EAAAtM,EAAA6B,GACA,GAAA7B,EAAA9D,OAAA2F,EAEA,OADA7B,EAAA9D,OAAA2F,GACA,CAEA,CAyDA,SAAAvB,EAAAC,GACA,OAAA,IAAArF,KAAAqF,GAAAD,KACA,CASA,SAAAsE,GAAArE,GACA,OAAA,IAAArF,KAAAqF,GAAAqE,MACA,CAUA,SAAAM,GAAA3E,GACA,OAAA,IAAArF,KAAAqF,GAAA2E,OACA,CAWA,SAAA6C,GAAAxH,EAAAW,GACA,OAAA,IAAAhG,KAAAqF,GAAA8B,KAAAnB,EACA,CAUA,SAAA8D,GAAAzE,GACA,OAAA,IAAArF,KAAAqF,GAAAyE,MACA,CAUA,SAAAM,GAAA/E,GACA,OAAA,IAAArF,KAAAqF,GAAA+E,OACA,CAUA,SAAAM,GAAArF,GACA,OAAA,IAAArF,KAAAqF,GAAAqF,MACA,CAUA,SAAAJ,GAAAjF,GACA,OAAA,IAAArF,KAAAqF,GAAAiF,OACA,CA4BA,SAAAqI,GAAA3M,EAAAX,GACAW,EAAA,IAAAhG,KAAAgG,GACAX,EAAA,IAAArF,KAAAqF,GACA,IAAAnF,EACAuG,EAAAzG,KAAA4B,UACAwC,EAAApE,KAAA6B,SACA0I,EAAA9D,EAAA,EAkCA,OA/BAT,EAAAT,GAAAF,EAAAE,EAIAS,EAAAvC,GAAA4B,EAAA5B,GAKA4B,EAAA5B,GAAAuC,EAAAY,UACA1G,EAAAmF,EAAAE,EAAA,EAAAsE,EAAA7J,KAAAyG,EAAArC,GAAA,IAAApE,KAAA,IACAuF,EAAAS,EAAAT,GAGAS,EAAAvC,GAAA4B,EAAAuB,UACA1G,EAAA2J,EAAA7J,KAAAuK,EAAA,GAAAvD,MAAA,KACAzB,EAAAS,EAAAT,EAGAF,EAAAE,EAAA,GACAvF,KAAA4B,UAAA2I,EACAvK,KAAA6B,SAAA,EACA3B,EAAAF,KAAA0K,KAAA3C,EAAA/B,EAAAX,EAAAkF,EAAA,IACAlF,EAAAwE,EAAA7J,KAAAuK,EAAA,GACAvK,KAAA4B,UAAA6E,EACAzG,KAAA6B,SAAAuC,EACAlE,EAAA8F,EAAAT,EAAA,EAAArF,EAAAgH,MAAA7B,GAAAnF,EAAAiH,KAAA9B,IAEAnF,EAAAF,KAAA0K,KAAA3C,EAAA/B,EAAAX,EAAAkF,EAAA,KAvBArK,EAAA2J,EAAA7J,KAAAuK,EAAA,GAAAvD,MAAA3B,EAAAE,EAAA,EAAA,IAAA,MACAA,EAAAS,EAAAT,EALArF,EAAA,IAAAF,KAAA4F,KA8BA1F,CACA,CAUA,SAAAqH,GAAAlC,GACA,OAAA,IAAArF,KAAAqF,GAAAkC,MACA,CASA,SAAA/C,GAAAa,GACA,OAAAG,EAAAH,EAAA,IAAArF,KAAAqF,GAAAA,EAAAlF,EAAA,EAAA,EACA,CAWA,SAAAuF,GAAAL,EAAApB,EAAAC,GACA,OAAA,IAAAlE,KAAAqF,GAAAK,MAAAzB,EAAAC,EACA,CAqBA,SAAA0O,GAAAC,GACA,IAAAA,GAAA,iBAAAA,EAAA,MAAAjS,MAAAyB,EAAA,mBACA,IAAA9B,EAAAO,EAAAgS,EACAC,GAAA,IAAAF,EAAAG,SACAC,EAAA,CACA,YAAA,EAAA1R,EACA,WAAA,EAAA,EACA,YAAAD,EAAA,EACA,WAAA,EAAAA,EACA,OAAA,EAAAA,EACA,QAAAA,EAAA,EACA,SAAA,EAAA,GAGA,IAAAf,EAAA,EAAAA,EAAA0S,EAAAjS,OAAAT,GAAA,EAEA,GADAO,EAAAmS,EAAA1S,GAAAwS,IAAA/S,KAAAc,GAAAa,EAAAb,SACA,KAAAgS,EAAAD,EAAA/R,IAAA,CACA,KAAA4B,EAAAoQ,KAAAA,GAAAA,GAAAG,EAAA1S,EAAA,IAAAuS,GAAAG,EAAA1S,EAAA,IACA,MAAAK,MAAA0B,EAAAxB,EAAA,KAAAgS,GADA9S,KAAAc,GAAAgS,CAEA,CAIA,GADAhS,EAAA,SAAAiS,IAAA/S,KAAAc,GAAAa,EAAAb,SACA,KAAAgS,EAAAD,EAAA/R,IAAA,CACA,IAAA,IAAAgS,IAAA,IAAAA,GAAA,IAAAA,GAAA,IAAAA,EAYA,MAAAlS,MAAA0B,EAAAxB,EAAA,KAAAgS,GAXA,GAAAA,EAAA,CACA,GAAA,oBAAA3Q,SAAAA,SACAA,OAAA+Q,kBAAA/Q,OAAAgR,YAGA,MAAAvS,MAAA4B,GAFAxC,KAAAc,IAAA,CAIA,MACAd,KAAAc,IAAA,CAKA,CAEA,OAAAd,IACA,CAUA,SAAAwG,GAAAnB,GACA,OAAA,IAAArF,KAAAqF,GAAAmB,KACA,CAUA,SAAAoC,GAAAvD,GACA,OAAA,IAAArF,KAAAqF,GAAAuD,MACA,CAwMA,SAAAR,GAAA/C,EAAAW,GACA,OAAA,IAAAhG,KAAAqF,GAAA+C,IAAApC,EACA,CAUA,SAAA2G,GAAAtH,GACA,OAAA,IAAArF,KAAAqF,GAAAsH,KACA,CASA,SAAA/J,GAAAyC,GACA,OAAAG,EAAAH,EAAA,IAAArF,KAAAqF,GAAAA,EAAAlF,EAAA,EAAA,EACA,CAYA,SAAAiT,KACA,IAAA7S,EAAAH,EACAC,EAAA,IAAAL,KAAA,GAIA,IAFAoC,GAAA,EAEA7B,EAAA,EAAAA,EAAA8S,UAAArS,QAEA,IADAZ,EAAA,IAAAJ,KAAAqT,UAAA9S,OACAkD,EAMApD,EAAAoD,IACApD,EAAAA,EAAA8G,KAAA/G,EAAA4G,MAAA5G,SAPA,CACA,GAAAA,EAAAmF,EAEA,OADAnD,GAAA,EACA,IAAApC,KAAA,KAEAK,EAAAD,CACA,CAOA,OAFAgC,GAAA,EAEA/B,EAAA6I,MACA,CAQA,SAAAoK,GAAAT,GACA,OAAAA,aAAA3R,GAAA2R,GAAAA,EAAAtP,cAAAd,IAAA,CACA,CAUA,SAAAyH,GAAA7E,GACA,OAAA,IAAArF,KAAAqF,GAAA6E,IACA,CAaA,SAAAsB,GAAAnG,EAAAW,GACA,OAAA,IAAAhG,KAAAqF,GAAAmG,IAAAxF,EACA,CAUA,SAAAuN,GAAAlO,GACA,OAAA,IAAArF,KAAAqF,GAAAmG,IAAA,EACA,CAUA,SAAAgI,GAAAnO,GACA,OAAA,IAAArF,KAAAqF,GAAAmG,IAAA,GACA,CASA,SAAAtH,KACA,OAAAoN,EAAAtR,KAAAqT,UAAA,KACA,CASA,SAAApP,KACA,OAAAqN,EAAAtR,KAAAqT,UAAA,KACA,CAWA,SAAA7G,GAAAnH,EAAAW,GACA,OAAA,IAAAhG,KAAAqF,GAAAmH,IAAAxG,EACA,CAWA,SAAAyH,GAAApI,EAAAW,GACA,OAAA,IAAAhG,KAAAqF,GAAAoI,IAAAzH,EACA,CAWA,SAAAlD,GAAAuC,EAAAW,GACA,OAAA,IAAAhG,KAAAqF,GAAAvC,IAAAkD,EACA,CAWA,SAAAyN,GAAA/M,GACA,IAAAjD,EAAAtD,EAAAuD,EAAAtD,EACAG,EAAA,EACAL,EAAA,IAAAF,KAAA,GACAuE,EAAA,GAOA,QALA,IAAAmC,EAAAA,EAAA1G,KAAA4B,UACAoC,EAAA0C,EAAA,EAAAnF,GAEAmC,EAAAf,KAAA6B,KAAAkC,EAr8IA,GAu8IA1G,KAAAmC,OAIA,GAAAA,OAAA+Q,gBAGA,IAFAzP,EAAAtB,OAAA+Q,gBAAA,IAAAQ,YAAAhQ,IAEAnD,EAAAmD,IACAtD,EAAAqD,EAAAlD,KAIA,MACAkD,EAAAlD,GAAA4B,OAAA+Q,gBAAA,IAAAQ,YAAA,IAAA,GAKAnP,EAAAhE,KAAAH,EAAA,QAKA,KAAA+B,OAAAgR,YAwBA,MAAAvS,MAAA4B,GAnBA,IAFAiB,EAAAtB,OAAAgR,YAAAzP,GAAA,GAEAnD,EAAAmD,IAGAtD,EAAAqD,EAAAlD,IAAAkD,EAAAlD,EAAA,IAAA,IAAAkD,EAAAlD,EAAA,IAAA,MAAA,IAAAkD,EAAAlD,EAAA,KAAA,MAGA,MACA4B,OAAAgR,YAAA,GAAAQ,KAAAlQ,EAAAlD,IAKAgE,EAAA6H,KAAAhM,EAAA,KACAG,GAAA,GAIAA,EAAAmD,EAAA,CAGA,MA/CA,KAAAnD,EAAAmD,GAAAa,EAAAhE,KAAA,IAAAoC,KAAA8Q,SAAA,EA2DA,IATA/M,GA1/IA,GAy/IAhD,EAAAa,IAAAhE,KAIAmG,IACAtG,EAAAyC,EAAA,GA9/IA,EA8/IA6D,GACAnC,EAAAhE,IAAAmD,EAAAtD,EAAA,GAAAA,GAIA,IAAAmE,EAAAhE,GAAAA,IAAAgE,EAAA8H,MAGA,GAAA9L,EAAA,EACAJ,EAAA,EACAoE,EAAA,CAAA,OACA,CAIA,IAHApE,GAAA,EAGA,IAAAoE,EAAA,GAAApE,GA7gJA,EA6gJAoE,EAAA+H,QAGA,IAAA5I,EAAA,EAAAtD,EAAAmE,EAAA,GAAAnE,GAAA,GAAAA,GAAA,GAAAsD,IAGAA,EAnhJA,IAmhJAvD,GAnhJA,EAmhJAuD,EACA,CAKA,OAHAxD,EAAAC,EAAAA,EACAD,EAAAuD,EAAAc,EAEArE,CACA,CAWA,SAAAgN,GAAA7H,GACA,OAAAG,EAAAH,EAAA,IAAArF,KAAAqF,GAAAA,EAAAlF,EAAA,EAAAH,KAAA6B,SACA,CAcA,SAAA8O,GAAAtL,GAEA,OADAA,EAAA,IAAArF,KAAAqF,IACA5B,EAAA4B,EAAA5B,EAAA,GAAA4B,EAAAE,EAAA,EAAAF,EAAAE,EAAAF,EAAAE,GAAAK,GACA,CAUA,SAAAwH,GAAA/H,GACA,OAAA,IAAArF,KAAAqF,GAAA+H,KACA,CAUA,SAAAnE,GAAA5D,GACA,OAAA,IAAArF,KAAAqF,GAAA4D,MACA,CAUA,SAAAC,GAAA7D,GACA,OAAA,IAAArF,KAAAqF,GAAA6D,MACA,CAWA,SAAA+C,GAAA5G,EAAAW,GACA,OAAA,IAAAhG,KAAAqF,GAAA4G,IAAAjG,EACA,CAYA,SAAA0L,KACA,IAAAnR,EAAA,EACAgR,EAAA8B,UACAhO,EAAA,IAAArF,KAAAuR,EAAAhR,IAGA,IADA6B,GAAA,EACAiD,EAAAE,KAAAhF,EAAAgR,EAAAvQ,QAAAqE,EAAAA,EAAA8B,KAAAoK,EAAAhR,IAGA,OAFA6B,GAAA,EAEAoD,EAAAH,EAAArF,KAAA4B,UAAA5B,KAAA6B,SACA,CAUA,SAAA2L,GAAAnI,GACA,OAAA,IAAArF,KAAAqF,GAAAmI,KACA,CAUA,SAAAhE,GAAAnE,GACA,OAAA,IAAArF,KAAAqF,GAAAmE,MACA,CASA,SAAA4F,GAAA/J,GACA,OAAAG,EAAAH,EAAA,IAAArF,KAAAqF,GAAAA,EAAAlF,EAAA,EAAA,EACA,CAIAe,EA1mBA,SAAA0S,EAAAf,GACA,IAAAtS,EAAAO,EAAAmS,EASA,SAAA/R,EAAA4R,GACA,IAAA3S,EAAAI,EAAAF,EACAgF,EAAArF,KAGA,KAAAqF,aAAAnE,GAAA,OAAA,IAAAA,EAAA4R,GAOA,GAHAzN,EAAAC,YAAApE,EAGAoS,GAAAR,GAuBA,OAtBAzN,EAAAE,EAAAuN,EAAAvN,OAEAnD,GACA0Q,EAAArP,GAAAqP,EAAA3S,EAAAe,EAAAgB,MAGAmD,EAAAlF,EAAAyF,IACAP,EAAA5B,EAAA,MACAqP,EAAA3S,EAAAe,EAAAe,MAGAoD,EAAAlF,EAAA,EACAkF,EAAA5B,EAAA,CAAA,KAEA4B,EAAAlF,EAAA2S,EAAA3S,EACAkF,EAAA5B,EAAAqP,EAAArP,EAAAqE,UAGAzC,EAAAlF,EAAA2S,EAAA3S,EACAkF,EAAA5B,EAAAqP,EAAArP,EAAAqP,EAAArP,EAAAqE,QAAAgL,EAAArP,IAQA,GAAA,YAFApD,SAAAyS,GAEA,CACA,GAAA,IAAAA,EAIA,OAHAzN,EAAAE,EAAA,EAAAuN,EAAA,GAAA,EAAA,EACAzN,EAAAlF,EAAA,OACAkF,EAAA5B,EAAA,CAAA,IAYA,GARAqP,EAAA,GACAA,GAAAA,EACAzN,EAAAE,GAAA,GAEAF,EAAAE,EAAA,EAIAuN,MAAAA,GAAAA,EAAA,IAAA,CACA,IAAA3S,EAAA,EAAAI,EAAAuS,EAAAvS,GAAA,GAAAA,GAAA,GAAAJ,IAkBA,YAhBAiC,EACAjC,EAAAe,EAAAgB,MACAmD,EAAAlF,EAAAyF,IACAP,EAAA5B,EAAA,MACAtD,EAAAe,EAAAe,MACAoD,EAAAlF,EAAA,EACAkF,EAAA5B,EAAA,CAAA,KAEA4B,EAAAlF,EAAAA,EACAkF,EAAA5B,EAAA,CAAAqP,KAGAzN,EAAAlF,EAAAA,EACAkF,EAAA5B,EAAA,CAAAqP,IAMA,CAAA,OAAA,EAAAA,GAAA,GACAA,IAAAzN,EAAAE,EAAAK,KACAP,EAAAlF,EAAAyF,SACAP,EAAA5B,EAAA,OAIAsO,EAAA1M,EAAAyN,EAAAhM,WAEA,CAAA,GAAA,WAAAzG,EACA,MAAAO,MAAA0B,EAAAwQ,GAaA,OATA,MAAAvS,EAAAuS,EAAAX,WAAA,KACAW,EAAAA,EAAAhL,MAAA,GACAzC,EAAAE,GAAA,IAGA,KAAAhF,IAAAuS,EAAAA,EAAAhL,MAAA,IACAzC,EAAAE,EAAA,GAGArC,EAAAqP,KAAAO,GAAAf,EAAA1M,EAAAyN,GAAAV,EAAA/M,EAAAyN,EACA,CA2DA,GAzDA5R,EAAA2S,UAAAvQ,EAEApC,EAAA4S,SAAA,EACA5S,EAAA6S,WAAA,EACA7S,EAAA8S,WAAA,EACA9S,EAAA+S,YAAA,EACA/S,EAAAgT,cAAA,EACAhT,EAAAiT,gBAAA,EACAjT,EAAAkT,gBAAA,EACAlT,EAAAmT,gBAAA,EACAnT,EAAAoT,iBAAA,EACApT,EAAAqT,OAAA,EAEArT,EAAA0R,OAAA1R,EAAAsT,IAAA5B,GACA1R,EAAA0S,MAAAA,EACA1S,EAAAgC,UAAAoQ,GAEApS,EAAAkE,IAAAA,EACAlE,EAAAwI,KAAAA,GACAxI,EAAA8I,MAAAA,GACA9I,EAAA2L,IAAAA,GACA3L,EAAA4I,KAAAA,GACA5I,EAAAkJ,MAAAA,GACAlJ,EAAAwJ,KAAAA,GACAxJ,EAAAoJ,MAAAA,GACApJ,EAAAyR,MAAAA,GACAzR,EAAAqG,KAAAA,GACArG,EAAAsD,KAAAA,GACAtD,EAAAwE,MAAAA,GACAxE,EAAAsF,IAAAA,GACAtF,EAAA0H,KAAAA,GACA1H,EAAAkH,IAAAA,GACAlH,EAAAyL,IAAAA,GACAzL,EAAA0B,MAAAA,GACA1B,EAAAkS,MAAAA,GACAlS,EAAAgJ,GAAAA,GACAhJ,EAAAsK,IAAAA,GACAtK,EAAAsS,MAAAA,GACAtS,EAAAqS,KAAAA,GACArS,EAAAgD,IAAAA,GACAhD,EAAA+C,IAAAA,GACA/C,EAAAsL,IAAAA,GACAtL,EAAAuM,IAAAA,GACAvM,EAAA4B,IAAAA,GACA5B,EAAAuS,OAAAA,GACAvS,EAAAgM,MAAAA,GACAhM,EAAAyP,KAAAA,GACAzP,EAAAkM,IAAAA,GACAlM,EAAA+H,KAAAA,GACA/H,EAAAgI,KAAAA,GACAhI,EAAA+K,IAAAA,GACA/K,EAAAwQ,IAAAA,GACAxQ,EAAAsM,IAAAA,GACAtM,EAAAsI,KAAAA,GACAtI,EAAAkO,MAAAA,QAEA,IAAAyD,IAAAA,EAAA,CAAA,GACAA,IACA,IAAAA,EAAAG,SAEA,IADAC,EAAA,CAAA,YAAA,WAAA,WAAA,WAAA,OAAA,OAAA,SAAA,UACA1S,EAAA,EAAAA,EAAA0S,EAAAjS,QAAA6R,EAAA4B,eAAA3T,EAAAmS,EAAA1S,QAAAsS,EAAA/R,GAAAd,KAAAc,IAMA,OAFAI,EAAA0R,OAAAC,GAEA3R,CACA,CAqbA0S,CAAAjS,GACAT,EAAA2S,UAAAvO,YAAApE,EACAA,EAAA,QAAAA,EAAAA,QAAAA,EAGAO,EAAA,IAAAP,EAAAO,GACAC,EAAA,IAAAR,EAAAQ,QAaA,IAAAhC,GAAAA,EAAAD,SACA,mBAAAiV,QAAA,iBAAAA,OAAAC,WACArR,EAAAoR,OAAA,IAAA,+BAAApR,EAAAwD,SACAxD,EAAAoR,OAAAnR,aAAA,WAGA7D,EAAAD,QAAAyB,IAIAD,IACAA,EAAA,oBAAAlB,MAAAA,MAAAA,KAAAA,MAAAA,KAAAA,KAAAF,QAGAuB,EAAAH,EAAAC,QACAA,EAAAE,WAAA,WAEA,OADAH,EAAAC,QAAAE,EACAF,CACA,EAEAD,EAAAC,QAAAA,EAEA,CAr0JA,CAq0JAlB,KCGA,EAAE,CAAC,GAAG,EAAE,CAAC,SAASS,EAAQf,EAAOD;;;;;ACp0JjC,IAAAmV,EAAAnU,EAAA,8BAiHAf,EAAAD,QAhGA,MAEA6F,YAAAuP,EAAAC,GAGA9U,KAAA+U,QAAA,mBAAA,EAAAF,EAAAD,EACA5U,KAAAgV,SAAA,mBAAA,EAAAF,EAAAF,EAEA5U,KAAAiV,iBAAA,CAAA,CACA,CAEAC,mBAEA,OAAAC,OAAAC,KAAApV,KAAAiV,kBAAAjU,MACA,CAEAqU,eAAAC,GAIA,GAAA,iBAAA,EAGA,OADAtV,KAAAgV,SAAA,kGAAA,IACA,EAGAG,OAAAC,KAAAE,GAEAC,SACAC,IAEA,iBAAAF,EAAAE,GAEAxV,KAAAgV,SAAA,gFAAAQ,oDAAAF,EAAAE,MAIAxV,KAAAiV,iBAAAO,GAAAF,EAAAE,EACA,GAEA,CAEAC,sBAAAC,GAEA1V,KAAAiV,iBAAAR,eAAAiB,WAEA1V,KAAAiV,iBAAAS,EAEA,CAKAC,kBAAAL,GAEA,GAAA,iBAAA,EAGA,OADAtV,KAAAyV,sBAAAH,IACA,EAEA,GAAA,iBAAA,EACA,CAQA,OAPAH,OAAAC,KAAAE,GAEAC,SACAC,IAEAxV,KAAA2V,kBAAAH,EAAA,KAEA,CACA,CAIA,OADAxV,KAAAgV,SAAA,0HAAA,IACA,CAEA,CAEAY,oBAEA5V,KAAAiV,iBAAA,CAAA,CACA,CAEAY,UAAAP,GAEA,OAAAtV,KAAAiV,iBAAAR,eAAAa,GAEAtV,KAAAiV,iBAAAK,GAIAA,CAEA,ED60JA,EAAE,CAAC,6BAA6B,IAAI,EAAE,CAAC,SAAS7U,EAAQf,EAAOD,GE76J/DC,EAAAD,QATA,CAAAqW,EAAAC,KAEA,IAAAC,EAAA,iBAAA,EAAAF,EAAA,GAEAG,QAAAzK,IAAA,cAAAwK,KAEAD,GAAAE,QAAAzK,IAAA0K,KAAAC,UAAAJ,GAAA,CFo8JA,EAAE,CAAC,GAAG,EAAE,CAAC,SAAStV,EAAQf,EAAOD;;;;;AG/8JjC,IAAAmV,EAAAnU,EAAA,8BAsHAf,EAAAD,QA9FA,MAEA6F,YAAAuP,EAAAC,GAGA9U,KAAA+U,QAAA,mBAAA,EAAAF,EAAAD,EACA5U,KAAAgV,SAAA,mBAAA,EAAAF,EAAAF,CACA,CAWAwB,mBAAAC,EAAAC,EAAAC,GAEA,IAAAC,EAAA,iBAAA,EAAAF,EAAA,GACAG,EAAA,iBAAA,EAAAF,EAAA,CAAA,EAIAG,EAAA,CAEAC,QAAAH,EACAI,KAAAJ,EACAK,KAAAL,EAEAM,UAAA,GAIA,cAZA,GAcA,IAAA,SACAJ,EAAAK,SAAA,SACAL,EAAAM,QAAAX,EACAI,EAAAD,GAAAE,EACA,MACA,IAAA,SACA,IAAA,SACAA,EAAAK,SAAA,SACAL,EAAAM,QAAAX,EACAI,EAAAD,GAAAE,EACA,MACA,IAAA,YACAA,EAAAK,SAAA,MACAL,EAAAM,QAAAX,EACAI,EAAAD,GAAAE,EACA,MACA,IAAA,SACA,GAAAO,MAAAC,QAAAb,GACA,CACAK,EAAAK,SAAA,QACA,IAAAP,IAEAC,EAAAD,GAAAE,GAGA,IAAA,IAAAnW,EAAA,EAAAA,EAAA8V,EAAArV,OAAAT,IAEAP,KAAAoW,mBAAAC,EAAA9V,GAAA,GAAAiW,KAAAjW,KAAAkW,EAEA,KAEA,CACAC,EAAAK,SAAA,SACA,IAAAP,IAEAC,EAAAD,GAAAE,EACAF,GAAA,KAGA,IAAAW,EAAAhC,OAAAC,KAAAiB,GAEA,IAAA,IAAA9V,EAAA,EAAAA,EAAA4W,EAAAnW,OAAAT,IAEAP,KAAAoW,mBAAAC,EAAAc,EAAA5W,IAAA,GAAAiW,IAAAW,EAAA5W,KAAAkW,EAEA,EAQA,OAAAA,CACA,EHw9JA,EAAE,CAAC,6BAA6B,IAAI,EAAE,CAAC,SAAShW,EAAQf,EAAOD;;;;;AI3kK/D,IAAAmV,EAAAnU,EAAA,8BAmrBAf,EAAAD,QA/pBA,MAEA6F,YAAAuP,EAAAC,GAGA9U,KAAA+U,QAAA,mBAAA,EAAAF,EAAAD,EACA5U,KAAAgV,SAAA,mBAAA,EAAAF,EAAAF,CACA,CAgBAwC,oBAAAC,EAAAC,GAEA,OAAAA,EAAAC,WAAAF,IAAAC,EAAAE,SAAAH,GAEAC,EAAApF,UAAA,EAAAoF,EAAAtW,OAAA,GAIAsW,CAEA,CAQAG,mBAAApB,EAAAqB,GAIA,GAAA,iBAAA,EAAA,OAAA,EAEA,GAAA,iBAAA,EAAA,OAAA,EAGA,IAAAC,EAAAD,EAAA1S,QAAA,KAGA,IAAA,GAAA2S,EACA,CAEA,IAAAC,EAAAF,EAAA1S,QAAA,KACA6S,EAAAH,EAAA1S,QAAA,KAUA,GAAA4S,EAAA,GAEAC,EAAAD,GAEAC,EAAAD,EAAA,EACA,CAEA,IAAAE,EAAAJ,EAAAxF,UAAA,EAAA0F,GAAAG,OAIA,GAAA,iBAAA1B,EAAAyB,GAEA,OAAA,EAIA,IAAAE,EAAAN,EAAAxF,UAAA0F,EAAA,EAAAC,GAAAE,OAEAE,EAAAC,SAAAF,EAAA,IAOA,OAAAf,MAAAC,QAAAb,EAAAyB,KAAA9M,MAAAiN,KAOAjN,MAAAiN,IAIAD,EAAAhY,KAAAoX,oBAAA,IAAAY,GACAA,EAAAhY,KAAAoX,oBAAA,IAAAY,GACAA,EAAAhY,KAAAoX,oBAAA,IAAAY,GAGA3B,EAAAyB,GAAArD,eAAAuD,IAKAC,KAAA5B,EAAAyB,GAEA,CAIA,OAAAzB,EAAA5B,eAAAiD,EAEA,CAEA,CACA,IAAAS,EAAAT,EAAAxF,UAAA,EAAAyF,GACAS,EAAAV,EAAAxF,UAAAyF,EAAA,GAIAC,EAAAO,EAAAnT,QAAA,KACA6S,EAAAM,EAAAnT,QAAA,KAUA,GAAA4S,EAAA,GAEAC,EAAAD,GAEAC,EAAAD,EAAA,EACA,CACA,IAAAE,EAAAK,EAAAjG,UAAA,EAAA0F,GAAAG,OAEAC,EAAAG,EAAAjG,UAAA0F,EAAA,EAAAC,GAAAE,OAEAE,EAAAC,SAAAF,EAAA,IAgBA,OAAAf,MAAAC,QAAAb,EAAAyB,KAAA9M,MAAAiN,KAUAjN,MAAAiN,IAGAD,EAAAhY,KAAAoX,oBAAA,IAAAY,GACAA,EAAAhY,KAAAoX,oBAAA,IAAAY,GACAA,EAAAhY,KAAAoX,oBAAA,IAAAY,GAGAhY,KAAAyX,mBAAApB,EAAAyB,GAAAE,GAAAI,IAKApY,KAAAyX,mBAAApB,EAAAyB,GAAAG,GAAAG,GAEA,CAIA,QAAA/B,EAAA5B,eAAA0D,IAAA,iBAAA9B,EAAA8B,MAIA9B,EAAA5B,eAAA0D,KAQA9B,EAAA8B,GAAA,CAAA,GALAnY,KAAAyX,mBAAApB,EAAA8B,GAAAC,GAQA,CACA,CAGAC,kBAAAhC,EAAAqB,EAAAY,GAGA,GAAA,iBAAA,EAAA,OAEA,GAAA,iBAAA,EAAA,OACA,IAAAC,EAAA,GACA,iBAAA,IAEAA,EAAAD,GAIA,IAAAX,EAAAD,EAAA1S,QAAA,KAGA,IAAA,GAAA2S,EACA,CAEA,IAAAC,EAAAF,EAAA1S,QAAA,KACA6S,EAAAH,EAAA1S,QAAA,KAIAwT,EAAAd,EAAA1S,QAAA,MAWA,GAAA4S,EAAA,GAEAC,EAAAD,GAEAC,EAAAD,EAAA,EACA,CAEA,IAAAE,EAAAJ,EAAAxF,UAAA,EAAA0F,GAAAG,OAIA,GAAA,iBAAA1B,EAAAyB,GAEA,OAIA,IAAAE,EAAAN,EAAAxF,UAAA0F,EAAA,EAAAC,GAAAE,OAEAE,EAAAC,SAAAF,EAAA,IAOA,GAAAf,MAAAC,QAAAb,EAAAyB,KAAA9M,MAAAiN,GAEA,OAKA,OAAAjN,MAAAiN,IAIAD,EAAAhY,KAAAoX,oBAAA,IAAAY,GACAA,EAAAhY,KAAAoX,oBAAA,IAAAY,GACAA,EAAAhY,KAAAoX,oBAAA,IAAAY,GAGA3B,EAAAyB,GAAAE,IAIA3B,EAAAyB,GAAAG,EAEA,CAGA,GAAAL,EAAA,GAEAC,EAAAD,GAEAC,EAAAD,GAAA,EACA,CACA,IAAAE,EAAAJ,EAAAxF,UAAA,EAAA0F,GAAAG,OAEA,QAAAd,MAAAC,QAAAb,EAAAyB,KAMAzB,EAAAyB,EACA,CAEA,GAAAU,EAAA,EACA,CACA,IAAAC,EAAAf,EAAAxF,UAAA,EAAAsG,GAAAT,OAEA,MAAA,iBAAA1B,EAAAoC,IAMApC,EAAAoC,EACA,CAIA,OAAApC,EAAAqB,EAEA,CAEA,CACA,IAAAS,EAAAT,EAAAxF,UAAA,EAAAyF,GACAS,EAAAV,EAAAxF,UAAAyF,EAAA,GAKAC,EAAAO,EAAAnT,QAAA,KACA6S,EAAAM,EAAAnT,QAAA,KAUA,GAAA4S,EAAA,GAEAC,EAAAD,GAEAC,EAAAD,EAAA,EACA,CACA,IAAAE,EAAAK,EAAAjG,UAAA,EAAA0F,GAAAG,OAEAC,EAAAG,EAAAjG,UAAA0F,EAAA,EAAAC,GAAAE,OAEAE,EAAAC,SAAAF,EAAA,IAgBA,GAAAf,MAAAC,QAAAb,EAAAyB,KAAA9M,MAAAiN,GAEA,OAMA,OAAAjN,MAAAiN,IAGAD,EAAAhY,KAAAoX,oBAAA,IAAAY,GACAA,EAAAhY,KAAAoX,oBAAA,IAAAY,GACAA,EAAAhY,KAAAoX,oBAAA,IAAAY,GAGAO,EAAA,GAAAA,IAAAA,EAAAvX,OAAA,EAAA,IAAA,KAAAmX,IAEAnY,KAAAqY,kBAAAhC,EAAAyB,GAAAE,GAAAI,EAAAG,KAKAA,EAAA,GAAAA,IAAAA,EAAAvX,OAAA,EAAA,IAAA,KAAAmX,IAEAnY,KAAAqY,kBAAAhC,EAAAyB,GAAAG,GAAAG,EAAAG,GAEA,CAGA,GAAAX,EAAA,GAEAC,EAAAD,GAEAC,EAAAD,GAAA,EACA,CACA,IAAAE,EAAAJ,EAAAxF,UAAA,EAAA0F,GAAAG,OAEA,IAAAd,MAAAC,QAAAb,EAAAyB,IAGA,OAAA,EAIA,IAAAY,EAAArC,EAAAyB,GAEAS,EAAA,GAAAA,IAAAA,EAAAvX,OAAA,EAAA,IAAA,KAAA8W,IAEA,IAAAa,EAAA,CAAA,EACA,IAAA,IAAApY,EAAA,EAAAA,EAAAmY,EAAA1X,OAAAT,IACA,CACA,IAAAqY,EAAA,GAAAL,KAAAhY,KACAsY,EAAA7Y,KAAAqY,kBAAAhC,EAAAyB,GAAAvX,GAAA6X,EAAAQ,GACAD,EAAA,GAAAC,KAAAR,KAAAS,CACA,CAEA,OAAAF,CACA,CAIA,IAAAH,EAAAd,EAAA1S,QAAA,MACA,GAAAwT,EAAA,EACA,CACA,IAAAC,EAAAf,EAAAxF,UAAA,EAAAsG,GAAAT,OAEA,GAAA,iBAAA1B,EAAAoC,GAGA,OAAA,EAIA,IAAAK,EAAAzC,EAAAoC,GACAM,EAAA5D,OAAAC,KAAA0D,GAEAP,EAAA,GAAAA,IAAAA,EAAAvX,OAAA,EAAA,IAAA,KAAAyX,IAEA,IAAAE,EAAA,CAAA,EACA,IAAA,IAAApY,EAAA,EAAAA,EAAAwY,EAAA/X,OAAAT,IACA,CACA,IAAAqY,EAAA,GAAAL,KAAAQ,EAAAxY,KACAsY,EAAA7Y,KAAAqY,kBAAAhC,EAAAoC,GAAAM,EAAAxY,IAAA6X,EAAAQ,GACAD,EAAA,GAAAC,KAAAR,KAAAS,CACA,CAEA,OAAAF,CACA,CAIA,OAAAtC,EAAA5B,eAAA0D,IAAA,iBAAA9B,EAAA8B,QAEA,EAEA9B,EAAA5B,eAAA0D,IAIAI,EAAA,GAAAA,IAAAA,EAAAvX,OAAA,EAAA,IAAA,KAAAmX,IACAnY,KAAAqY,kBAAAhC,EAAA8B,GAAAC,EAAAG,KAMAA,EAAA,GAAAA,IAAAA,EAAAvX,OAAA,EAAA,IAAA,KAAAmX,IACA9B,EAAA8B,GAAA,CAAA,EACAnY,KAAAqY,kBAAAhC,EAAA8B,GAAAC,EAAAG,GAEA,CACA,CAGAS,kBAAA3C,EAAAqB,EAAAuB,GAGA,GAAA,iBAAA,EAAA,OAAA,EAEA,GAAA,iBAAA,EAAA,OAAA,EAEA,IAAAtB,EAAAD,EAAA1S,QAAA,KAEA,IAAA,GAAA2S,EACA,CAEA,IAAAC,EAAAF,EAAA1S,QAAA,KACA6S,EAAAH,EAAA1S,QAAA,KAUA,GAAA4S,EAAA,GAEAC,EAAAD,GAEAC,EAAAD,EAAA,EACA,CAEA,IAAAE,EAAAJ,EAAAxF,UAAA,EAAA0F,GAAAG,OAIA,GAAA,iBAAA1B,EAAAyB,GAEA,OAAA,EAIA,IAAAE,EAAAN,EAAAxF,UAAA0F,EAAA,EAAAC,GAAAE,OAEAE,EAAAC,SAAAF,EAAA,IAOA,OAAAf,MAAAC,QAAAb,EAAAyB,KAAA9M,MAAAiN,KAOAjN,MAAAiN,IAIAD,EAAAhY,KAAAoX,oBAAA,IAAAY,GACAA,EAAAhY,KAAAoX,oBAAA,IAAAY,GACAA,EAAAhY,KAAAoX,oBAAA,IAAAY,GAGA3B,EAAAyB,GAAAE,GAAAiB,GACA,IAIA5C,EAAAyB,GAAAG,GAAAgB,GACA,GAEA,CAKA,OADA5C,EAAAqB,GAAAuB,GACA,CAEA,CAEA,CACA,IAAAd,EAAAT,EAAAxF,UAAA,EAAAyF,GACAS,EAAAV,EAAAxF,UAAAyF,EAAA,GAIAC,EAAAO,EAAAnT,QAAA,KACA6S,EAAAM,EAAAnT,QAAA,KAUA,GAAA4S,EAAA,GAEAC,EAAAD,GAEAC,EAAAD,EAAA,EACA,CACA,IAAAE,EAAAK,EAAAjG,UAAA,EAAA0F,GAAAG,OAEAC,EAAAG,EAAAjG,UAAA0F,EAAA,EAAAC,GAAAE,OAEAE,EAAAC,SAAAF,EAAA,IAgBA,OAAAf,MAAAC,QAAAb,EAAAyB,KAAA9M,MAAAiN,KAQAjN,MAAAiN,IAGAD,EAAAhY,KAAAoX,oBAAA,IAAAY,GACAA,EAAAhY,KAAAoX,oBAAA,IAAAY,GACAA,EAAAhY,KAAAoX,oBAAA,IAAAY,GAGAhY,KAAAgZ,kBAAA3C,EAAAyB,GAAAE,GAAAI,EAAAa,IAKAjZ,KAAAgZ,kBAAA3C,EAAAyB,GAAAG,GAAAG,EAAAa,GAEA,CAIA,OAAA5C,EAAA5B,eAAA0D,IAAA,iBAAA9B,EAAA8B,IAEA9B,EAAA5B,eAAA,aACA4B,EAAA,QAAA,CAAA,GAEAA,EAAA,QAAAqB,GAAAuB,GACA,IAEA5C,EAAA5B,eAAA0D,KAQA9B,EAAA8B,GAAA,CAAA,GALAnY,KAAAgZ,kBAAA3C,EAAA8B,GAAAC,EAAAa,GAQA,CACA,EJolKA,EAAE,CAAC,6BAA6B,IAAI,EAAE,CAAC,SAASxY,EAAQf,EAAOD;;;;;AKpwL/D,IAAAmV,EAAAnU,EAAA,8BAqIAf,EAAAD,QA9HA,MAEA6F,YAAAuP,EAAAC,GAGA9U,KAAA+U,QAAA,mBAAA,EAAAF,EAAAD,EACA5U,KAAAgV,SAAA,mBAAA,EAAAF,EAAAF,CACA,CAoBAsE,uBAAAC,EAAAC,GAEA,GAAA,iBAAA,EAGA,OADApZ,KAAAgV,SAAA,+EACA,EAGA,GAAA,iBAAA,EAGA,OAAA,EAIA,IAAAqE,EAAAlE,OAAAC,KAAA+D,GACAG,EAAA,CAAA,EA6CA,OA5CAD,EAAA9D,SACAmC,IAEAyB,EAAAzB,GAAAjD,eAAA,UAEA6E,EAAAH,EAAAzB,GAAAd,MAAAc,EACA,IAGAvC,OAAAC,KAAAgE,GAEA7D,SACAgE,IAEA,IAAAC,EAAAJ,EAAAG,GACAE,GAAA,EACAC,GAAA,EAGAP,EAAA1E,eAAA8E,GAEAE,EAAAF,EAEAD,EAAA7E,eAAA8E,KAEAE,EAAAH,EAAAC,IAIAE,GAEAC,EAAAP,EAAAM,UACAN,EAAAM,IAKAC,EAAA,CAAA9C,KAAA2C,GAIAJ,EAAAK,GAAAE,CAAA,KAGA,CACA,CAEAC,2BAAAR,EAAAC,GAGA,IAAAQ,EAAA1D,KAAA2D,MAAA3D,KAAAC,UAAAgD,IAEA,OADAnZ,KAAAkZ,uBAAAU,EAAAR,GACAQ,CACA,CAEAE,qBAAAC,EAAAC,GAEA,GAAA,iBAAA,GAAA,iBAAA,EAGA,OADAha,KAAAgV,SAAA,yEACA,EAGA,IAAAiF,EAAA/D,KAAA2D,MAAA3D,KAAAC,UAAA6D,IACAE,EAAAhE,KAAA2D,MAAA3D,KAAAC,UAAA4D,IAcA,OAXA5E,OAAAC,KAAA6E,GAEA1E,SACA4E,IAEAD,EAAAzF,eAAA0F,KAEAD,EAAAC,GAAAF,EAAAE,GACA,IAGAD,CACA,EL6wLA,EAAE,CAAC,6BAA6B,IAAI,EAAE,CAAC,SAASzZ,EAAQf,EAAOD;;;;;AM/4L/D,IAAAmV,EAAAnU,EAAA,8BAEA2Z,EAAA3Z,EAAA,iCACA4Z,EAAA5Z,EAAA,uCACA6Z,EAAA7Z,EAAA,yCACA8Z,EAAA9Z,EAAA,oCAQA,MAAA+Z,EAEAlV,YAAAmV,EAAA5F,EAAAC,EAAA4F,GAGA1a,KAAA+U,QAAA,mBAAA,EAAAF,EAAAD,EACA5U,KAAAgV,SAAA,mBAAA,EAAAF,EAAAF,EAGA5U,KAAA2a,sBAAA,IAAAN,EAAAra,KAAA+U,QAAA/U,KAAAgV,UAEAhV,KAAA4a,QAAA,CAEAC,QAAA,EACAC,cACA,CACAhJ,OAAA,GACAiJ,OAAA,EACAC,MAAA,EACAC,QAAA,EACAC,SAAA,EACAC,OAAA,EACAC,SAAA,EACAnE,MAAA,GACA9B,OAAA,CAAA,EACAkG,KAAA,OAIArb,KAAAsb,WAAAC,EACAvb,KAAAwb,sBAAAD,EACAvb,KAAAyb,mBAAAF,EACAvb,KAAA0b,wBAAAH,EAEAvb,KAAA2b,QAEA,iBAAA,GAEA3b,KAAA4b,aAAAnB,GAGAza,KAAA6b,oBAAA,IAAAtB,EAAAva,KAAA+U,QAAA/U,KAAAgV,UACAhV,KAAA8b,wBAAA,IAAAxB,EAAAta,KAAA+U,QAAA/U,KAAAgV,UAEAhV,KAAA+b,iBAAA,IAAA3B,EAAApa,KAAA+U,QAAA/U,KAAAgV,SACA,CAOA2G,QAEA3b,KAAAsb,MAAA,UACAtb,KAAAwb,iBAAA,GACAxb,KAAAyb,cAAA,CAAA,EACAzb,KAAA0b,mBAAA,CAAA,CACA,CAEA9H,QAGA,IAAAoI,EAAA9F,KAAA2D,MAAA3D,KAAAC,UAAAnW,KAAA4a,UAEAqB,EAAA,IAAAzB,EAAAxa,KAAAkc,cAAAlc,KAAA+U,QAAA/U,KAAAgV,SAAAgH,GAKA,OAFAC,EAAAF,iBAAA1G,eAAArV,KAAA+b,iBAAA9G,kBAEAgH,CACA,CAGAE,YAAAC,GAGA,OAAApc,KAAA4b,aAAA1F,KAAA2D,MAAAuC,GACA,CAGAR,aAAAnB,GAEA,GAAA,iBAAA,EAGA,OADAza,KAAAgV,SAAA,IAAAhV,KAAAsb,oFAAA,OACA,EAmBA,GAhBAb,EAAAhG,eAAA,SAEA,iBAAAgG,EAAA,MAEAza,KAAAsb,MAAAb,EAAA4B,MAIArc,KAAAgV,SAAA,IAAAhV,KAAAsb,6FAAAb,EAAA,SAAAA,GAKAza,KAAAgV,SAAA,IAAAhV,KAAAsb,+GAAAb,GAGAA,EAAAhG,eAAA,eAEA,GAAA,iBAAAgG,EAAA,YACA,CACA,IAAA6B,EAAAnH,OAAAC,KAAAqF,EAAA8B,aACA,IAAA,IAAAhc,EAAA,EAAAA,EAAA+b,EAAAtb,OAAAT,IAEAP,KAAAwc,cAAAF,EAAA/b,GAAAka,EAAA8B,YAAAD,EAAA/b,IAEA,MAGAP,KAAAgV,SAAA,IAAAhV,KAAAsb,iJAAAb,EAAA,eAAAA,QAKAza,KAAAgV,SAAA,IAAAhV,KAAAsb,2IAAAb,EAEA,CAIAgC,YAEA,OAAAvG,KAAAC,UAAAnW,KAAAkc,cACA,CAEAA,cAEA,MAAA,CAEAG,MAAArc,KAAAsb,MACAiB,YAAArG,KAAA2D,MAAA3D,KAAAC,UAAAnW,KAAA0b,qBAEA,CAGAc,cAAA9E,EAAAgF,GAEA,MAAA,iBAAA,GAGAA,EAAAjI,eAAA,aAEAiI,EAAA/F,QAAAe,GAGA1X,KAAA0b,mBAAAjH,eAAAiD,IAEA1X,KAAAwb,iBAAApP,KAAAsL,GAIA1X,KAAA0b,mBAAAhE,GAAAgF,EAGA1c,KAAAyb,cAAA/D,GAAAA,EAEAgF,EAAAjI,eAAA,QAIAzU,KAAAyb,cAAAiB,EAAA9F,MAAAc,EAIAgF,EAAA9F,KAAAc,GAGA,IAIA1X,KAAAgV,SAAA,IAAAhV,KAAAsb,uDAAA5D,8EAAA,OACA,EAEA,CAEAiF,oBAAAC,GAEA,OAAA5c,KAAA6c,cAAA7c,KAAA8c,mBAAAF,GACA,CAEAC,cAAAnF,GAEA,OAAA1X,KAAA0b,mBAAAhE,EACA,CAMAqF,yBAAA1G,EAAAuG,GAEA,OAAA5c,KAAAyX,mBAAApB,EAAArW,KAAA8c,mBAAAF,GACA,CAGAnF,mBAAApB,EAAAqB,GAEA,OAAA1X,KAAA2a,sBAAAlD,mBAAApB,EAAAqB,EACA,CAGAoF,mBAAAF,GAEA,IAAAI,EAEAC,EAAAjd,KAAAyb,cAAAhH,eAAAmI,GACAM,EAAAld,KAAA+b,iBAAA9G,iBAAAR,eAAAmI,GAwBA,OAnBAI,EAFAC,IAAAC,EAEAld,KAAAyb,cAAAmB,GAGAM,GAAAld,KAAAyb,cAAAhH,eAAAzU,KAAA+b,iBAAAlG,UAAA+G,IAEA5c,KAAAyb,cAAAzb,KAAA+b,iBAAAlG,UAAA+G,IAGAM,EAEAld,KAAA+b,iBAAAlG,UAAA+G,GAMAA,EAGAI,CACA,CAGAG,eAAA9G,EAAAuG,GAEA,IAAA/D,EAAA7Y,KAAAqY,kBAAAhC,EAAArW,KAAA8c,mBAAAF,IAQA,YANA,IAAA,IAGA/D,EAAA7Y,KAAAod,gBAAApd,KAAA2c,oBAAAC,KAGA/D,CACA,CAGAR,kBAAAhC,EAAAqB,GAEA,IAAAmB,EAAA7Y,KAAA2a,sBAAAtC,kBAAAhC,EAAAqB,GAQA,YANA,IAAA,IAGAmB,EAAA7Y,KAAAod,gBAAApd,KAAA6c,cAAAnF,KAGAmB,CACA,CAGAwE,eAAAhH,EAAAuG,EAAA3D,GAEA,OAAAjZ,KAAAgZ,kBAAA3C,EAAArW,KAAA8c,mBAAAF,GAAA3D,EACA,CAIAD,kBAAA3C,EAAAqB,EAAAuB,GAEA,OAAAjZ,KAAA2a,sBAAA3B,kBAAA3C,EAAAqB,EAAAuB,EACA,CAGAqE,SAAAjH,GAEA,IAAAkH,EACA,CACA3c,MAAA,KACA4c,OAAA,GACAC,gBAAA,IAGA,iBAAA,IAEAF,EAAA3c,OAAA,EACA2c,EAAAC,OAAApR,KAAA,wEAAA,IAGA,IAAAsR,EAAA,CAAAhG,EAAAiG,KAEAJ,EAAA3c,OAAA,EACA2c,EAAAC,OAAApR,KAAA,uBAAAsL,MAAAiG,KAAA,EAIA,IAAA,IAAApd,EAAA,EAAAA,EAAAP,KAAAwb,iBAAAxa,OAAAT,IACA,CACA,IAAAmZ,EAAA1Z,KAAA6c,cAAA7c,KAAAwb,iBAAAjb,IACAqd,EAAA5d,KAAAyX,mBAAApB,EAAAqD,EAAA/C,SACAkC,EAAA7Y,KAAAqY,kBAAAhC,EAAAqD,EAAA/C,SAcA,QAZA,IAAA,GAAAiH,IAIAL,EAAAE,gBAAArR,KAAAsN,EAAA/C,UACA+C,EAAAmE,UAAA7d,KAAA4a,QAAAC,SAEA6C,EAAAhE,EAAA/C,QAAA,qDAKA+C,EAAA3C,SACA,CACA,IAAA+G,SAAA,EACA,OAAApE,EAAA3C,SAAAjQ,WAAAiR,OAAAvF,eAEA,IAAA,SACA,UAAAsL,GAEAJ,EAAAhE,EAAA/C,QAAA,kBAAA+C,EAAA3C,+BAAA+G,KAEA,MAEA,IAAA,SACA,UAAAA,GAEAJ,EAAAhE,EAAA/C,QAAA,kBAAA+C,EAAA3C,+BAAA+G,KAEA,MAEA,IAAA,UACA,GAAA,UAAAA,EAEAJ,EAAAhE,EAAA/C,QAAA,kBAAA+C,EAAA3C,+BAAA+G,SAGA,CACAjF,EAAA/R,WACA9B,QAAA,MAAA,GAGA0Y,EAAAhE,EAAA/C,QAAA,kBAAA+C,EAAA3C,kDAEA,CACA,MAEA,IAAA,QACA,UAAA+G,GAEAJ,EAAAhE,EAAA/C,QAAA,kBAAA+C,EAAA3C,+BAAA+G,KAEA,MAEA,IAAA,WAEA,gBADA,IAAAC,KAAAlF,GACA/R,YAEA4W,EAAAhE,EAAA/C,QAAA,kBAAA+C,EAAA3C,wDAGA,QAGA,UAAA+G,GAEAJ,EAAAhE,EAAA/C,QAAA,kBAAA+C,EAAA3C,4FAAA+G,KAIA,CACA,CAEA,OAAAP,CACA,CAGAH,gBAAAV,GAEA,GAAA,iBAAA,EAAA,CAKA,GAAAA,EAAAjI,eAAA,WAEA,OAAAiI,EAAA1F,QAGA,CAGA,IAAAgH,EAAAtB,EAAAjI,eAAA,YAAAiI,EAAA3F,SAAA,SACA,OAAA/W,KAAA4a,QAAAE,cAAArG,eAAAuJ,GAEAhe,KAAA4a,QAAAE,cAAAkD,GAKA,IAEA,CApBA,CAqBA,CAGAC,iBAAA5H,EAAA6H,GAEA,OAAAle,KAAAme,eAAA9H,EAAA6H,GAEAxB,GAEAA,EAAAjI,eAAA,YAEA,CAIA0J,eAAA9H,EAAA6H,EAAAE,GAGA,IAAAC,EAAA,iBAAA,EAAAhI,EAAA,CAAA,EAEAiI,OAAA,IAAA,GAAAJ,EAGAK,EAAA,mBAAA,EAAAH,EAAA1B,IAAA,EAiBA,OAfA1c,KAAAwb,iBAAAjG,SACAmC,IAEA,IAAAgC,EAAA1Z,KAAA6c,cAAAnF,GAEA6G,EAAA7E,MAGA4E,GAAAte,KAAAyX,mBAAA4G,EAAA3G,IAEA1X,KAAAgZ,kBAAAqF,EAAA3G,EAAA1X,KAAAod,gBAAA1D,IAEA,IAGA2E,CACA,EAGA3e,EAAAD,QAAA+a,CNq5LA,EAAE,CAAC,gCAAgC,EAAE,6BAA6B,EAAE,wCAAwC,EAAE,sCAAsC,EAAE,mCAAmC,IAAI,EAAE,CAAC,SAAS/Z,EAAQf,EAAOD;;;;;;;;;;AOx2MxN,IAAA+e,EAAA/d,EAAA,iBACAge,EAAAhe,EAAA,qBAyCAf,EAAAD,QAvCA,MAKA6F,cAEAtF,KAAA0e,SAAA,IAAAF,EAEAxe,KAAA2e,aAAA,IAAAF,EAEAze,KAAA4e,UAAA5e,KAAA0e,SAAAE,SACA,CAUAC,WAAAC,EAAAC,EAAAC,GAEA,OAAAhf,KAAA0e,SAAAG,WAAAC,EAAAC,EAAAC,EACA,CAQAC,YAAA3H,GAEA,OAAAtX,KAAA2e,aAAAM,YAAA3H,EAAAtX,KAAA4e,UACA,EPu3MA,EAAE,CAAC,oBAAoB,EAAE,gBAAgB,KAAK,EAAE,CAAC,SAASne,EAAQf,EAAOD,GQ5vMzEC,EAAAD;;;;;;;;;;AAjKA,MAKA6F,cAEA,CASA4Z,eAAAC,GAEA,MAAA,CAEAP,UAAAO,EAEAC,OAAA,GACAC,aAAA,GAEAC,SAAA,EAEAC,cAAA,EACAC,yBAAA,GAEA,CAUAC,WAAAC,EAAAC,GAEAA,EAAAJ,aAAAG,EAGAC,EAAAJ,aAAA9K,eAAA,gBAGAkL,EAAAL,QAAAK,EAAAJ,aAEA,CAUAK,mBAAAvI,EAAAsI,GAEAA,EAAAN,cAAAhI,CACA,CAQAwI,kBAAAF,GAEAA,EAAAP,QAAAO,EAAAN,aACAM,EAAAN,aAAA,EACA,CASAS,gBAAAH,GAEAA,EAAAN,aAAAre,QAAA2e,EAAAL,QAAAS,WAAA/e,OAAA2e,EAAAL,QAAAU,aAAAhf,QACA2e,EAAAN,aAAAY,QAAAN,EAAAL,QAAAS,WAAA/e,UAAA2e,EAAAL,QAAAS,aAIAJ,EAAAN,aAAAM,EAAAL,QAAAY,MAAAP,EAAAN,aAAAY,OAAAN,EAAAL,QAAAU,aAAAhf,OAAA2e,EAAAN,aAAAre,QAAA2e,EAAAL,QAAAU,aAAAhf,OAAA2e,EAAAL,QAAAS,WAAA/e,UAEAhB,KAAA6f,kBAAAF,GAEAA,EAAAL,SAAA,EACAK,EAAAJ,cAAA,EAEA,CASAY,eAAA9I,EAAAsI,IAGAA,EAAAJ,cAAAI,EAAAf,UAAAnK,eAAA4C,IAGArX,KAAAyf,WAAAE,EAAAf,UAAAvH,GAAAsI,GACA3f,KAAA4f,mBAAAvI,EAAAsI,IAGAA,EAAAJ,cAGAI,EAAAJ,aAAA9K,eAAA4C,IAGArX,KAAAyf,WAAAE,EAAAJ,aAAAlI,GAAAsI,GAEA3f,KAAA4f,mBAAAvI,EAAAsI,GACAA,EAAAL,SAGAtf,KAAA8f,gBAAAH,IAMAA,EAAAP,QAAA/H,CAEA,CAQA4H,YAAA3H,EAAA6H,GAEA,IAAAiB,EAAApgB,KAAAkf,eAAAC,GAEA,IAAA,IAAA5e,EAAA,EAAAA,EAAA+W,EAAAtW,OAAAT,IAGAP,KAAAmgB,eAAA7I,EAAA/W,GAAA6f,GAKA,OAFApgB,KAAA6f,kBAAAO,GAEAA,EAAAhB,MACA,ER66MA,EAAE,CAAC,GAAG,GAAG,CAAC,SAAS3e,EAAQf,EAAOD,GSjhNlCC,EAAAD;;;;;;;;;;AA1DA,MAKA6F,cAEAtF,KAAA4e,UAAA,CAAA,CACA,CAWAyB,SAAAC,EAAAC,EAAAC,GAEA,OAAAA,EAAAD,EAAAvf,OACAsf,GAEAA,EAAA7L,eAAA8L,EAAAC,MACAF,EAAAC,EAAAC,IAAA,CAAA,GAEAF,EAAAC,EAAAC,IACA,CASA3B,WAAAC,EAAAC,EAAAC,GAEA,GAAAF,EAAA9d,OAAA,EACA,OAAA,EAEA,IAAAyf,EAAAzgB,KAAA4e,UAGA,IAAA,IAAAre,EAAA,EAAAA,EAAAue,EAAA9d,OAAAT,IACAkgB,EAAAzgB,KAAAqgB,SAAAI,EAAA3B,EAAAve,GAQA,OANAkgB,EAAAT,aAAAlB,EACA2B,EAAAV,WAAA,iBAAA,GAAAhB,EAAA/d,OAAA,EAAA+d,EAAAD,EACA2B,EAAAP,MAAA,mBAAA,EAAAlB,EACA,iBAAA,EAAA,IAAAA,EACA0B,GAAAA,GAEA,CACA,ET2lNA,EAAE,CAAC,GAAG,GAAG,CAAC,SAASjgB,EAAQf,EAAOD;;;;;AUlpNlC,IAAAkhB,EAAAlgB,EAAA,mBAEA,iBAAA,SAAAZ,OAAAI,WAAA0gB,GAEAjhB,EAAAD,QAAAkhB,CV8pNA,EAAE,CAAC,kBAAkB,KAAK,GAAG,CAAC,SAASlgB,EAAQf,EAAOD,GWhgNtDC,EAAAD;;;;;AAlKA,MAEA6F,YAAAsb,GAEA5gB,KAAA6gB,WAAAD,EAEA5gB,KAAA8gB,UAAA,SACA,CAGAC,oBAAAC,GAEA,iBAAA,IAEAhhB,KAAA8gB,UAAAE,GAEAhhB,KAAA6gB,WAAAI,gBAAAxM,eAAAzU,KAAA8gB,aAEA9gB,KAAA6gB,WAAAI,gBAAAjhB,KAAA8gB,UAAAtO,eAAA,CAAA,GAEAxS,KAAA6gB,WAAAK,cAAAzM,eAAAzU,KAAA8gB,aAEA9gB,KAAA6gB,WAAAK,cAAAlhB,KAAA8gB,UAAAtO,eAAA,CAAA,EAEA,CAGA2O,eAAAC,EAAAC,GAEA,MAAA,iBAAA,GAEArhB,KAAA6gB,WAAA7L,SAAA,oHAAA,IACA,GAEA,mBAAA,GAEAhV,KAAA6gB,WAAA7L,SAAA,qGAAA,IACA,IAGAhV,KAAA6gB,WAAAI,gBAAAjhB,KAAA8gB,UAAAtO,eAAA4O,GAAAC,GACA,EACA,CAEAC,yBAaA,OAPAthB,KAAAmhB,eAAA,QACAI,IAEAA,EAAAxM,QAAA,wCACA,MAGA,CACA,CAGAyM,aAAAC,EAAAF,GAEA,GAAA,iBAAA,EAGA,OADAvhB,KAAA6gB,WAAA7L,SAAA,gHAAA,EAAAuM,IACA,EAEA,GAAA,iBAAA,EAGA,OADAvhB,KAAA6gB,WAAA7L,SAAA,+FAAA,EAAAuM,IACA,EAGA,IAAAA,EAAA9M,eAAA,eAGA,OADAzU,KAAA6gB,WAAA7L,SAAA,2FAAAuM,IACA,EAEA,GAAA,iBAAAA,EAAA,YAGA,OADAvhB,KAAA6gB,WAAA7L,SAAA,4HAAAuM,EAAA,eAAAA,IACA,EAEA,GAAA,iBAAAA,EAAAG,YAAA,KACA,CACA,GAAA,iBAAAH,EAAAG,YAAA,UAQA,OADA1hB,KAAA6gB,WAAA7L,SAAA,yJAAAuM,IACA,EALAA,EAAAG,YAAA9K,KAAA2K,EAAAG,YAAAC,SAOA,CA4BA,MAzBA,iBAAAJ,EAAAG,YAAA,WAAAH,EAAAG,YAAAE,WAAA5hB,KAAA8gB,YAEAS,EAAAG,YAAAE,UAAA5hB,KAAA8gB,WAEA,iBAAAS,EAAAG,YAAA,UAEAH,EAAAG,YAAAG,QAAA,IAAAN,EAAAG,YAAAE,eAAAL,EAAAG,YAAA9K,oBAIA2K,EAAA9M,eAAA,YAEA8M,EAAAO,OAAA,CAAA,GAEAP,EAAA9M,eAAA,aAEA8M,EAAAQ,QAAA,CAAA,GAEAR,EAAA9M,eAAA,WAEA8M,EAAAS,MAAA,IAKA,iBAAAT,EAAA,QAEAvhB,KAAA6gB,WAAA7L,SAAA,+DAAAuM,IACA,GAIA,iBAAAA,EAAA,SAEAvhB,KAAA6gB,WAAA7L,SAAA,gEAAAuM,IACA,GAEAtK,MAAAC,QAAAqK,EAAAS,QAOAhiB,KAAA6gB,WAAAK,cAAAlhB,KAAA8gB,UAAAtO,eAAAiP,EAAAjP,eAAA+O,GACA,IANAvhB,KAAA6gB,WAAA7L,SAAA,6DAAAuM,IACA,EAMA,CAEAU,uBAWA,OATAjiB,KAAAwhB,aAAA,OACA,CACAE,YACA,CACAC,UAAA,OACAD,YAAA,4CAIA,CACA,EXirNA,EAAE,CAAC,GAAG,GAAG,CAAC,SAASjhB,EAAQf,EAAOD;;;;;AYj1NlC,MAAAyiB,EAAA,CAAApM,EAAAC,EAAAoM,KAEA,IAAAnM,EAAA,iBAAA,EAAAF,EAAA,GACAsM,EAAA,iBAAA,EAAAD,EAAA,OAEAlM,QAAAzK,IAAA,eAAA4W,MAAApM,KAEAD,GAAAE,QAAAzK,IAAA0K,KAAAC,UAAAJ,EAAA,KAAA,GAAA,KAAA,EAoBArW,EAAAD,QAAA,CAEAyiB,aAAAA,EACAG,KApBA,CAAAvM,EAAAC,KAEAmM,EAAApM,EAAAC,EAAA,OAAA,EAmBAuM,QAfA,CAAAxM,EAAAC,KAEAmM,EAAApM,EAAAC,EAAA,UAAA,EAcAwM,MAVA,CAAAzM,EAAAC,KAEAmM,EAAApM,EAAAC,EAAA,QAAA,EZq2NA,EAAE,CAAC,GAAG,GAAG,CAAC,SAAStV,EAAQf,EAAOD;;;;;Aal4NlC,MAAAmV,EAAAnU,EAAA,gCACA+hB,EAAA/hB,EAAA,YACAgiB,EAAAhiB,EAAA,aAEAiiB,EAAAjiB,EAAA,kCAiYAf,EAAAD,QA1XA,MAEA6F,YAAAqd,EAAAC,EAAAC,GAmBA,GAhBA7iB,KAAA+U,QAAA,mBAAA,EAAA6N,EAAAhO,EAAAyN,KACAriB,KAAA8iB,WAAA,mBAAA,YAAAC,YAAAnO,EAAA0N,QACAtiB,KAAAgV,SAAA,mBAAA,EAAA6N,EAAAjO,EAAA2N,MAGAviB,KAAAihB,gBAAA,CAAA,EAIAjhB,KAAAkhB,cAAA,CAAA,EAGAlhB,KAAAgjB,KAAA,EAEAhjB,KAAAijB,6BAEAN,EACA,CACA,IAAAO,EAAA/N,OAAAC,KAAAuN,GACA,IAAA,IAAApiB,EAAA,EAAAA,EAAA2iB,EAAAliB,OAAAT,IAEAP,KAAAwhB,aAAA,SAAA0B,EAAA3iB,GAAAoiB,EAAAO,EAAA3iB,IAEA,CACA,CAGA4iB,mBAAAC,GAEA,IAAAC,EAAA,IAAAD,EAAApjB,MAEAqjB,EAAAtC,sBACAsC,EAAA/B,yBACA+B,EAAApB,sBACA,CAEAgB,6BAIAjjB,KAAAmjB,mBAAA1iB,EAAA,yCAKAT,KAAAmjB,mBAAA1iB,EAAA,6CAIAT,KAAAmjB,mBAAA1iB,EAAA,kCAIAT,KAAAmjB,mBAAA1iB,EAAA,+BAIAT,KAAAmjB,mBAAA1iB,EAAA,+BACA,CAEA6iB,gBAAAtC,EAAAS,GAEA,GAAA,iBAAA,GAAA,iBAAA,EAEA,OAAA,EAGA,IAAA8B,EAAAvC,EAAAxO,cACA,OAAAxS,KAAAkhB,cAAAzM,eAAA8O,IAAAvjB,KAAAkhB,cAAAqC,GAAA9O,eAAAgN,EAAAjP,cACA,CAEAgP,aAAAR,EAAAS,EAAAF,GAEA,GAAA,iBAAA,EAGA,OADAvhB,KAAAgV,SAAA,6IAAA,EAAAuM,IACA,EAGA,IAAAiC,EAAA,IAAAd,EAAA1iB,MAGA,OAFAwjB,EAAAzC,oBAAAC,GAEAwC,EAAAhC,aAAAC,EAAAF,EACA,CAEAkC,uBAAAzC,EAAAS,EAAAiC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GAEA,IAAA/jB,KAAAsjB,gBAAAtC,EAAAS,GAIA,OAFAzhB,KAAAgV,SAAA,qDAAAgM,mBAAAS,uCAEA,EAEA,IAAAuC,EAAAhkB,KAAAkhB,cAAAF,EAAAxO,eAAAiP,EAAAjP,eACA,OAAAxS,KAAAikB,eAAAD,EAAAN,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EACA,CAEAE,eAAAC,EAAAR,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GAEA,IAAAC,EAAA9N,KAAA2D,MAAA3D,KAAAC,UAAA+N,IAEA,GAAA,iBAAA,EAGA,OADAlkB,KAAAgV,SAAA,4FAAA,OACA,EAEA,IAAAmP,EAAAT,EAGAU,EAAAD,EAGAE,EAAAN,OACA,IAAA,IAEAM,EAAA,CAEAC,aAAA,YAAAtkB,KAAAgjB,OACAuB,sBAAAL,EAAAxC,YAAAE,UACA4C,sBAAAN,EAAAxC,YAAAC,UACA8C,YAAA,IAIAT,EAAAvP,eAAA,YAEAuP,EAAAlC,OAAA,CAAA,GAEAkC,EAAAvP,eAAA,aAEAuP,EAAAjC,QAAA,CAAA,GAIAiC,EAAAvP,eAAA,6BAEA4P,EAAAK,iBAAAxO,KAAA2D,MAAA3D,KAAAC,UAAA6N,EAAAW,4BAIAN,EAAAK,iBAAA,CAAA,EAGAV,EAAAvP,eAAA,gCAEA4P,EAAAO,kBAAA1O,KAAA2D,MAAA3D,KAAAC,UAAA6N,EAAAa,8BAGA,iBAAA,GACA,oBAAA,sBACA,oBAAA,sBAUAR,EAAAO,kBAAAP,EAAAK,mBAIA,iBAAA,IAGAN,EAAAT,GAGA,IAAAmB,GAAA,EACA,QAAA,IAAA,EACA,CAEAA,EAAA,IAAAtC,EAKAsC,EAAAjJ,oBAAA/B,qBAAAkK,EAAAlC,OAAAkC,EAAAjC,QAEA,MAIA+C,EAAAlB,EAAAhQ,QAGAiQ,GAEAiB,EAAAjJ,oBAAA3C,uBAAA8K,EAAAlC,OAAA+B,GAEAC,GAEAgB,EAAAjJ,oBAAA3C,uBAAA8K,EAAAlC,OAAAgC,GAEAO,EAAAK,kBAEAI,EAAA/I,iBAAA1G,eAAAgP,EAAAK,kBAEAL,EAAAO,mBAEAE,EAAA/I,iBAAA1G,eAAAgP,EAAAO,mBAKAZ,EAAAhB,KAAAhjB,KAAAgjB,OACAgB,EAAAe,gBAAAV,EAEAL,EAAAtC,YAAAsD,UAEAX,EAAAI,YAAArY,KAAA,IAAA4X,EAAAhB,mCAAAgB,EAAAtC,YAAAsD,YAGA,IAAAC,EAAA,IAAAxC,EA8BA,GA7BAwC,EAAApG,WAAA,UAAA,MACAjC,IAEA,IAAAsI,EAAAtI,EAAA7E,OACA2B,EAAAoL,EAAAnI,oBAAAuI,GAGA,MAAA,iBAAA,GAAAxL,EAAAjF,eAAA,QAEAiF,EAAA7C,KAIAqO,CACA,IAEAD,EAAApG,WAAA,gBAAA,MACAjC,IAEA,IAAAsI,EAAAtI,EAAA7E,OACA,OAAA+M,EAAA3H,eAAAgH,EAAAe,EAAA,IAEAD,EAAApG,WAAA,iBAAA,MACAjC,IAEA,IAAAsI,EAAAtI,EAAA7E,OACA,OAAA+M,EAAA3H,eAAAiH,EAAAc,EAAA,IAGAlB,EAAAvP,eAAA,QAAAuP,EAAAmB,IAAA1Q,eAAA,gBAEA,GAAA,iBAAAuP,EAAAmB,IAAA,aAEAnB,EAAAe,gBAAAN,YAAArY,KAAA6Y,EAAAhG,YAAA+E,EAAAmB,IAAAC,oBAEA,GAAAnO,MAAAC,QAAA8M,EAAAmB,IAAAC,cAEA,IAAA,IAAA7kB,EAAA,EAAAA,EAAAyjB,EAAAmB,IAAAC,aAAApkB,OAAAT,IAEA,iBAAAyjB,EAAAmB,IAAAC,aAAA7kB,IAEAyjB,EAAAe,gBAAAN,YAAArY,KAAA6Y,EAAAhG,YAAA+E,EAAAmB,IAAAC,aAAA7kB,KAOA,IAAA,IAAAA,EAAA,EAAAA,EAAAyjB,EAAAhC,MAAAhhB,OAAAT,IACA,CACA,IAAA8kB,EAAArB,EAAAhC,MAAAzhB,GAGA,GAAA8kB,EAAA5Q,eAAA,eACA,CACA,IAAA6Q,EAAA,CAEAjJ,MAAA,cACAE,YAAArG,KAAA2D,MAAA3D,KAAAC,UAAA6N,EAAAlC,UAGAgD,EAAAjJ,oBAAA3C,uBAAAoM,EAAA/I,YAAA8I,EAAAE,qBACA,IAAAC,EAAA,IAAAhD,EAAA8C,GACAjB,EAAAK,kBAEAc,EAAAzJ,iBAAA1G,eAAAgP,EAAAK,kBAGA,IAAAe,EAAA,CAEApJ,MAAA,eACAE,YAAArG,KAAA2D,MAAA3D,KAAAC,UAAA6N,EAAAjC,WAEA+C,EAAAjJ,oBAAA3C,uBAAAuM,EAAAlJ,YAAA8I,EAAAK,sBACA,IAAAC,EAAA,IAAAnD,EAAAiD,GACApB,EAAAO,mBAEAe,EAAA5J,iBAAA1G,eAAAgP,EAAAO,mBAIA,IAAAgB,EAAA,CAEA3lB,WAAAD,KAEA4hB,UAAAyD,EAAAzD,UAAApP,cACAqT,YAAAR,EAAAQ,YAAArT,cAEAmP,UAAAqC,EAEAe,gBAAAV,EAEAyB,oBAAAhB,EAEAiB,YAAA5B,EACA6B,cAAAR,EAEAS,aAAA7B,EACA8B,eAAAP,GAeA,GAZAC,EAAA5Q,SACAmR,IAEA9B,EAAAI,YAAArY,KAAA,qBAAAwZ,EAAAjE,UAAAD,YAAAE,aAAAgE,EAAAjE,UAAAD,YAAA9K,gBAAArW,KAAA8kB,EAAAzD,aAAAyD,EAAAQ,gBAAAM,IAAA,EAGAP,EAAA7Q,QACAoR,IAEA9B,EAAAI,YAAArY,KAAA,oBAAAwZ,EAAAjE,UAAAD,YAAAE,aAAAgE,EAAAjE,UAAAD,YAAA9K,gBAAArW,KAAA8kB,EAAAzD,aAAAyD,EAAAQ,gBAAAM,IAAA,EAGAnmB,KAAAihB,gBAAA2E,EAAAhE,WAAAnN,eAAAmR,EAAAC,aACA,EAEAO,EADApmB,KAAAihB,gBAAA2E,EAAAhE,WAAAgE,EAAAC,cACAD,EACA,CACA,CAGAP,EAAA5Q,eAAA,eAEA,iBAAA4Q,EAAA,UAEArlB,KAAAyjB,uBAAA4B,EAAAzD,UAAAyD,EAAA1D,UAAAwC,EAAAC,EAAAU,EAAAO,EAAAE,oBAAAF,EAAAK,qBAAArB,GAEA,iBAAAgB,EAAA,WAGArlB,KAAAikB,eAAAoB,EAAA1D,UAAAwC,EAAAC,EAAAU,EAAAO,EAAAE,oBAAAF,EAAAK,qBAAArB,GAGA,CAEA,GAAAL,EAAAvP,eAAA,QAAAuP,EAAAmB,IAAA1Q,eAAA,iBAEA,GAAA,iBAAAuP,EAAAmB,IAAA,cAEAnB,EAAAe,gBAAAN,YAAArY,KAAA6Y,EAAAhG,YAAA+E,EAAAmB,IAAAkB,qBAEA,GAAApP,MAAAC,QAAA8M,EAAAmB,IAAAC,cAEA,IAAA,IAAA7kB,EAAA,EAAAA,EAAAyjB,EAAAmB,IAAAkB,cAAArlB,OAAAT,IAEA,iBAAAyjB,EAAAmB,IAAAkB,cAAA9lB,IAEAyjB,EAAAe,gBAAAN,YAAArY,KAAA6Y,EAAAhG,YAAA+E,EAAAmB,IAAAkB,cAAA9lB,KAMA,OAAA8jB,CACA,Eb24NA,EAAE,CAAC,iCAAiC,GAAG,+BAA+B,GAAG,gCAAgC,GAAG,6BAA6B,GAAG,uCAAuC,GAAG,2CAA2C,GAAG,8BAA8B,GAAGiC,SAAW,EAAEC,UAAY,IAAI,GAAG,CAAC,SAAS9lB,EAAQf,EAAOD,Gc7wO9T,IAAAijB,EAAAjiB,EAAA,mCAwBAf,EAAAD,QAtBA,cAAAijB,EAEApd,YAAAsb,GAEA4F,MAAA5F,GACA5gB,KAAA8gB,UAAA,UACA,CAGAQ,yBAEA,OAAA,CACA,CAEAW,uBAIA,OAFAjiB,KAAAwhB,aAAA,gBAAA/gB,EAAA,8CAEA,CACA,EdsxOA,EAAE,CAAC,kCAAkC,GAAG,2CAA2C,KAAK,GAAG,CAAC,SAASA,EAAQf,EAAOD,Ge3yOpH,IAAAijB,EAAAjiB,EAAA,mCAEA,MAAAgmB,EAAAlF,IAEA,IAAAmF,EAAAnF,EAAAyE,cAAA7I,eAAAoE,EAAAwE,YAAA,aACAY,EAAApF,EAAAyE,cAAA7I,eAAAoE,EAAAwE,YAAA,cACAa,EAAArF,EAAAyE,cAAA7I,eAAAoE,EAAAwE,YAAA,cAAAjf,WAAA0L,cAEAqU,EAAA,QAGAC,EAAA,CAEA,KAAA,QACA9e,GAAA,QACA+e,MAAA,QAEA,KAAA,WACAC,MAAA,WACAC,SAAA,WAEA,MAAA,WACAC,GAAA,WACAC,SAAA,WAEA,IAAA,cACAthB,GAAA,cACAuhB,YAAA,cAEA,KAAA,qBACA1e,IAAA,qBACA2e,mBAAA,qBAEA,IAAA,WACAhc,GAAA,WACAic,SAAA,WAEA,KAAA,kBACArd,IAAA,kBACAsd,gBAAA,mBAGAT,EAAArS,eAAAmS,KAEAC,EAAAC,EAAAF,IAGA,IAAAY,EAAAjG,EAAAyE,cAAA7I,eAAAoE,EAAAwE,YAAA,iBACA0B,EAAAlG,EAAAyE,cAAA7I,eAAAoE,EAAAwE,YAAA,iBAEA2B,EAAAnG,EAAAyE,cAAA7I,eAAAoE,EAAAwE,YAAA,kBACA4B,EAAApG,EAAAyE,cAAA7I,eAAAoE,EAAAwE,YAAA,kBAEA6B,EAAA,KAEA,OAAAf,GAEA,IAAA,QACAe,EAAAlB,GAAAC,EACA,MACA,IAAA,WACAiB,EAAAlB,IAAAC,EACA,MACA,IAAA,WACAiB,EAAAlB,GAAAC,EACA,MACA,IAAA,cACAiB,EAAAlB,EAAAC,EACA,MACA,IAAA,qBACAiB,EAAAlB,GAAAC,EACA,MACA,IAAA,WACAiB,EAAAlB,EAAAC,EACA,MACA,IAAA,kBACAiB,EAAAlB,GAAAC,EAmBA,OAfApF,EAAA2E,eAAA7I,eAAAkE,EAAA0E,aAAA,mBAAA2B,GAMAA,GAAA,iBAAA,GAAA,iBAAA,GAAA,QAAAH,EAEAlG,EAAAthB,WAAAwjB,uBAAA+D,EAAAC,EAAAlG,EAAAwE,YAAAxE,EAAA0E,aAAA1E,EAAAuE,oBAAAvE,EAAAwD,gBAAAL,iBAAAnD,EAAAwD,gBAAAH,kBAAArD,EAAAwD,iBAEA,iBAAA,GAAA,iBAAA,GAAA,QAAA4C,GAEApG,EAAAthB,WAAAwjB,uBAAAiE,EAAAC,EAAApG,EAAAwE,YAAAxE,EAAA0E,aAAA1E,EAAAuE,oBAAAvE,EAAAwD,gBAAAL,iBAAAnD,EAAAwD,gBAAAH,kBAAArD,EAAAwD,kBAGA,CAAA,EAGA8C,EAAAtG,IAEA,IAAAgC,EAAAhC,EAAAyE,cAAA7I,eAAAoE,EAAAwE,YAAA,aACA/B,EAAAzC,EAAAyE,cAAA7I,eAAAoE,EAAAwE,YAAA,aAIA,OAFAxE,EAAAthB,WAAAwjB,uBAAAF,EAAAS,EAAAzC,EAAAwE,YAAAxE,EAAA0E,aAAA1E,EAAAuE,oBAAAvE,EAAAwD,gBAAAL,iBAAAnD,EAAAwD,gBAAAH,kBAAArD,EAAAwD,kBAEA,CAAA,EA+BArlB,EAAAD,QA5BA,cAAAijB,EAEApd,YAAAsb,GAEA4F,MAAA5F,GACA5gB,KAAA8gB,UAAA,OACA,CAEAQ,yBAQA,OALAkF,MAAAlF,yBAEAthB,KAAAmhB,eAAA,KAAAsF,GACAzmB,KAAAmhB,eAAA,UAAA0G,IAEA,CACA,CAEA5F,uBAKA,OAHAjiB,KAAAwhB,aAAA,KAAA/gB,EAAA,+BACAT,KAAAwhB,aAAA,UAAA/gB,EAAA,qCAEA,CACA,EfozOA,EAAE,CAAC,kCAAkC,GAAG,kCAAkC,GAAG,6BAA6B,KAAK,GAAG,CAAC,SAASA,EAAQf,EAAOD,GgBz7O3I,IAAAijB,EAAAjiB,EAAA,mCAEAoM,EAAA0U,IAGA,IAAAuG,EAAAvG,EAAAyE,cAAA7I,eAAAoE,EAAAwE,YAAA,KACAgC,EAAAxG,EAAAyE,cAAA7I,eAAAoE,EAAAwE,YAAA,KAEA,OADAxE,EAAA2E,eAAA7I,eAAAkE,EAAA0E,aAAA,IAAA6B,EAAAC,IACA,CAAA,EAGAlY,EAAA0R,IAGA,IAAAuG,EAAAvG,EAAAyE,cAAA7I,eAAAoE,EAAAwE,YAAA,KACAgC,EAAAxG,EAAAyE,cAAA7I,eAAAoE,EAAAwE,YAAA,KAEA,OADAxE,EAAA2E,eAAA7I,eAAAkE,EAAA0E,aAAA,IAAA6B,EAAAC,IACA,CAAA,EAGAC,EAAAzG,IAGA,IAAAuG,EAAAvG,EAAAyE,cAAA7I,eAAAoE,EAAAwE,YAAA,KACAgC,EAAAxG,EAAAyE,cAAA7I,eAAAoE,EAAAwE,YAAA,KAEA,OADAxE,EAAA2E,eAAA7I,eAAAkE,EAAA0E,aAAA,IAAA6B,EAAAC,IACA,CAAA,EAGAhgB,EAAAwZ,IAGA,IAAAuG,EAAAvG,EAAAyE,cAAA7I,eAAAoE,EAAAwE,YAAA,KACAgC,EAAAxG,EAAAyE,cAAA7I,eAAAoE,EAAAwE,YAAA,KAEA,OADAxE,EAAA2E,eAAA7I,eAAAkE,EAAA0E,aAAA,IAAA6B,EAAAC,IACA,CAAA,EAGAE,EAAA1G,IAEA,IAAAuG,EAAAvG,EAAAyE,cAAA7I,eAAAoE,EAAAwE,YAAA,KAIAmC,EAAA,EAEA,GAAA,iBAJA,EAMA,GAAAjR,MAAAC,QAAA4Q,GAEA,IAAA,IAAAvnB,EAAA,EAAAA,EAAAunB,EAAA9mB,OAAAT,IACA,CAEA,IAAAsY,EAAAX,SAAA4P,EAAAvnB,IAEAyK,MAAA6N,GAEA0I,EAAAvM,SAAA,wBAAAzU,mDAAAunB,EAAAvnB,QAIA2nB,GAAArP,EACA0I,EAAAxM,QAAA,mBAAAxU,YAAAsY,eAAAqP,KAEA,KAGA,CACA,IAAAC,EAAAhT,OAAAC,KAAA0S,GACA,IAAA,IAAAvnB,EAAA,EAAAA,EAAA4nB,EAAAnnB,OAAAT,IACA,CACA,IAAAsY,EAAAX,SAAA4P,EAAAK,EAAA5nB,KAEAyK,MAAA6N,GAEA0I,EAAAvM,SAAA,oBAAAmT,EAAA5nB,oDAAAunB,EAAAK,EAAA5nB,SAIA2nB,GAAArP,EACA0I,EAAAxM,QAAA,2BAAAoT,EAAA5nB,aAAAsY,eAAAqP,KAEA,CACA,KAGA,CACA,IAAArP,EAAAX,SAAA4P,GAEA9c,MAAA6N,GAEA0I,EAAAvM,SAAA,6DAAA8S,MAIAI,GAAArP,CAEA,CAEA,OADA0I,EAAA2E,eAAA7I,eAAAkE,EAAA0E,aAAA,IAAAiC,IACA,CAAA,EA0CAxoB,EAAAD,QAvCA,cAAAijB,EAEApd,YAAAsb,GAEA4F,MAAA5F,GACA5gB,KAAA8gB,UAAA,MACA,CAEAQ,yBAeA,OAbAthB,KAAAmhB,eAAA,MAAAtU,GAEA7M,KAAAmhB,eAAA,WAAAtR,GACA7P,KAAAmhB,eAAA,MAAAtR,GAEA7P,KAAAmhB,eAAA,WAAA6G,GACAhoB,KAAAmhB,eAAA,MAAA6G,GAEAhoB,KAAAmhB,eAAA,SAAApZ,GACA/H,KAAAmhB,eAAA,MAAApZ,GAEA/H,KAAAmhB,eAAA,YAAA8G,IAEA,CACA,CAEAhG,uBASA,OAPAjiB,KAAAwhB,aAAA,MAAA/gB,EAAA,+BACAT,KAAAwhB,aAAA,WAAA/gB,EAAA,oCACAT,KAAAwhB,aAAA,WAAA/gB,EAAA,oCACAT,KAAAwhB,aAAA,SAAA/gB,EAAA,kCAEAT,KAAAwhB,aAAA,YAAA/gB,EAAA,sCAEA,CACA,EhBk8OA,EAAE,CAAC,kCAAkC,GAAG,6BAA6B,GAAG,mCAAmC,GAAG,gCAAgC,GAAG,kCAAkC,GAAG,kCAAkC,KAAK,GAAG,CAAC,SAASA,EAAQf,EAAOD,GiBhlPzPC,EAAAD,QAAA,CACAiiB,YACA,CACAE,UAAA,WACAD,UAAA,gBACAyG,SAAA,6DAGAtG,OACA,CACAuG,MAAA,CAAAzR,KAAA,QAAA0R,KAAA,UACAC,OAAA,CAAA3R,KAAA,SAAA0R,KAAA,WAGAvG,QACA,CACAyG,KAAA,CAAA5R,KAAA,OAAAC,KAAA,yBACA4R,MAAA,CAAA7R,KAAA,QAAAC,KAAA,+CAGAsO,IACA,CACAC,aAAA,mFACAiB,cAAA,+GAGArE,MACA,CACA,CACAJ,UAAA,cACAiE,YAAA,WACAN,oBACA,CACA5kB,EAAA,QACA+O,EAAA,UAEAgW,qBACA,CACArgB,EAAA,SAGA,CACAuc,UAAA,cACAiE,YAAA,SACAN,oBACA,CACA5kB,EAAA,QACA+O,EAAA,UAEAgW,qBACA,CACArgB,EAAA,WjBslPA,EAAE,CAAC,GAAG,GAAG,CAAC,SAAS5E,EAAQf,EAAOD,GkBzoPlCC,EAAAD,QAAA,CACAiiB,YACA,CACAE,UAAA,QACAD,UAAA,UACAyG,SAAA,0DAGAtG,OACA,CACAhB,UAAA,CAAAlK,KAAA,YAAA0R,KAAA,SAAAtR,QAAA,SACA0R,UAAA,CAAA9R,KAAA,YAAA0R,KAAA,SAAAtR,QAAA,SAGA+K,QACA,CACA,EAEAoD,IACA,CACAC,aAAA,wFACAiB,cAAA,qFAGArE,MACA,CACA,CACAJ,UAAA,QACAiE,YAAA,YlB8oPA,EAAE,CAAC,GAAG,GAAG,CAAC,SAASplB,EAAQf,EAAOD,GmB1qPlCC,EAAAD,QAAA,CACAiiB,YACA,CACAE,UAAA,QACAD,UAAA,KACAyG,SAAA,iOAGAtG,OACA,CACA6G,UAAA,CAAA/R,KAAA,YAAA0R,KAAA,OACAM,WAAA,CAAAhS,KAAA,aAAA0R,KAAA,MAAAtR,SAAA,GACA6R,WAAA,CAAAjS,KAAA,aAAA0R,KAAA,SAAAtR,QAAA,MAEA8R,cAAA,CAAAlS,KAAA,gBAAA0R,KAAA,SAAAtR,QAAA,SACA+R,cAAA,CAAAnS,KAAA,gBAAA0R,KAAA,SAAAtR,QAAA,QAEAgS,eAAA,CAAApS,KAAA,iBAAA0R,KAAA,SAAAtR,QAAA,SACAiS,eAAA,CAAArS,KAAA,iBAAA0R,KAAA,SAAAtR,QAAA,SAGA+K,QACA,CACAmH,iBAAA,CAAAtS,KAAA,mBAAA0R,KAAA,YAGAnD,IACA,CACAC,aAAA,uJACAiB,cAAA,kJAGArE,MACA,CACA,CACAJ,UAAA,QACAiE,YAAA,OnB+qPA,EAAE,CAAC,GAAG,GAAG,CAAC,SAASplB,EAAQf,EAAOD,GoBntPlCC,EAAAD,QAAA,CACAiiB,YACA,CACAE,UAAA,OACAD,UAAA,MACAyG,SAAA,+BAGAtG,OACA,CACAnhB,EAAA,CAAAiW,KAAA,IAAA0R,KAAA,UACA5Y,EAAA,CAAAkH,KAAA,IAAA0R,KAAA,WAGAvG,QACA,CACA1c,EAAA,CAAAuR,KAAA,IAAA0R,KAAA,WAGAnD,IACA,CACAC,aAAA,kEACAiB,cAAA,4FAGArE,MACA,CACA,CACAJ,UAAA,OACAiE,YAAA,QpBwtPA,EAAE,CAAC,GAAG,GAAG,CAAC,SAASplB,EAAQf,EAAOD,GqBrvPlCC,EAAAD,QAAA,CACAiiB,YACA,CACAE,UAAA,OACAD,UAAA,YACAyG,SAAA,mFAGAtG,OACA,CACAnhB,EAAA,CAAAiW,KAAA,IAAA0R,KAAA,WAGAvG,QACA,CACA1c,EAAA,CAAAuR,KAAA,IAAA0R,KAAA,WAGAnD,IACA,CACAC,aAAA,mFACAiB,cAAA,sDAGArE,MACA,CACA,CACAJ,UAAA,OACAiE,YAAA,crB0vPA,EAAE,CAAC,GAAG,GAAG,CAAC,SAASplB,EAAQf,EAAOD,GsBtxPlCC,EAAAD,QAAA,CACAiiB,YACA,CACAE,UAAA,OACAD,UAAA,SACAyG,SAAA,kCAGAtG,OACA,CACAnhB,EAAA,CAAAiW,KAAA,IAAA0R,KAAA,UACA5Y,EAAA,CAAAkH,KAAA,IAAA0R,KAAA,WAGAvG,QACA,CACA1c,EAAA,CAAAuR,KAAA,IAAA0R,KAAA,WAGAnD,IACA,CACAC,aAAA,sEACAiB,cAAA,4FAGArE,MACA,CACA,CACAJ,UAAA,OACAiE,YAAA,WtB2xPA,EAAE,CAAC,GAAG,GAAG,CAAC,SAASplB,EAAQf,EAAOD,GuBxzPlCC,EAAAD,QAAA,CACAiiB,YACA,CACAE,UAAA,OACAD,UAAA,WACAyG,SAAA,oCAGAtG,OACA,CACAnhB,EAAA,CAAAiW,KAAA,IAAA0R,KAAA,UACA5Y,EAAA,CAAAkH,KAAA,IAAA0R,KAAA,WAGAvG,QACA,CACA1c,EAAA,CAAAuR,KAAA,IAAA0R,KAAA,WAGAnD,IACA,CACAC,aAAA,uEACAiB,cAAA,4FAGArE,MACA,CACA,CACAJ,UAAA,OACAiE,YAAA,avB6zPA,EAAE,CAAC,GAAG,GAAG,CAAC,SAASplB,EAAQf,EAAOD,GwB11PlCC,EAAAD,QAAA,CACAiiB,YACA,CACAE,UAAA,OACAD,UAAA,WACAyG,SAAA,oCAGAtG,OACA,CACAnhB,EAAA,CAAAiW,KAAA,IAAA0R,KAAA,UACA5Y,EAAA,CAAAkH,KAAA,IAAA0R,KAAA,WAGAvG,QACA,CACA1c,EAAA,CAAAuR,KAAA,IAAA0R,KAAA,WAGAnD,IACA,CACAC,aAAA,uEACAiB,cAAA,4FAGArE,MACA,CACA,CACAJ,UAAA,OACAiE,YAAA,axB+1PA,EAAE,CAAC,GAAG,GAAG,CAAC,SAASplB,EAAQf,EAAOD,GyB53PlCC,EAAAD,QAAA,CACAiiB,YACA,CACAE,UAAA,cACAD,UAAA,MACAyG,SAAA,yCAGAtG,OACA,CACAnhB,EAAA,CAAAiW,KAAA,IAAA0R,KAAA,UACA5Y,EAAA,CAAAkH,KAAA,IAAA0R,KAAA,WAGAvG,QACA,CACA1c,EAAA,CAAAuR,KAAA,IAAA0R,KAAA,WAGAnD,IACA,CACAC,aAAA,kEACAiB,cAAA,4FAGArE,MACA,CACA,CACAJ,UAAA,cACAiE,YAAA,QzBi4PA,EAAE,CAAC,GAAG,GAAG,CAAC,SAASplB,EAAQf,EAAOD,G0B95PlCC,EAAAD,QAAA,CACAiiB,YACA,CACAE,UAAA,cACAD,UAAA,YACAyG,SAAA,6FAGAtG,OACA,CACAnhB,EAAA,CAAAiW,KAAA,IAAA0R,KAAA,WAGAvG,QACA,CACA1c,EAAA,CAAAuR,KAAA,IAAA0R,KAAA,WAGAnD,IACA,CACAC,aAAA,mFACAiB,cAAA,sDAGArE,MACA,CACA,CACAJ,UAAA,cACAiE,YAAA,c1Bm6PA,EAAE,CAAC,GAAG,GAAG,CAAC,SAASplB,EAAQf,EAAOD,G2B/7PlCC,EAAAD,QAAA,CACAiiB,YACA,CACAE,UAAA,cACAD,UAAA,SACAyG,SAAA,4CAGAtG,OACA,CACAnhB,EAAA,CAAAiW,KAAA,IAAA0R,KAAA,UACA5Y,EAAA,CAAAkH,KAAA,IAAA0R,KAAA,WAGAvG,QACA,CACA1c,EAAA,CAAAuR,KAAA,IAAA0R,KAAA,WAGAnD,IACA,CACAC,aAAA,sEACAiB,cAAA,4FAGArE,MACA,CACA,CACAJ,UAAA,cACAiE,YAAA,W3Bo8PA,EAAE,CAAC,GAAG,GAAG,CAAC,SAASplB,EAAQf,EAAOD,G4Bj+PlCC,EAAAD,QAAA,CACAiiB,YACA,CACAE,UAAA,cACAD,UAAA,WACAyG,SAAA,8CAGAtG,OACA,CACAnhB,EAAA,CAAAiW,KAAA,IAAA0R,KAAA,UACA5Y,EAAA,CAAAkH,KAAA,IAAA0R,KAAA,WAGAvG,QACA,CACA1c,EAAA,CAAAuR,KAAA,IAAA0R,KAAA,WAGAnD,IACA,CACAC,aAAA,uEACAiB,cAAA,4FAGArE,MACA,CACA,CACAJ,UAAA,cACAiE,YAAA,a5Bs+PA,EAAE,CAAC,GAAG,GAAG,CAAC,SAASplB,EAAQf,EAAOD,G6BngQlCC,EAAAD,QAAA,CACAiiB,YACA,CACAE,UAAA,cACAD,UAAA,WACAyG,SAAA,8CAGAtG,OACA,CACAnhB,EAAA,CAAAiW,KAAA,IAAA0R,KAAA,UACA5Y,EAAA,CAAAkH,KAAA,IAAA0R,KAAA,WAGAvG,QACA,CACA1c,EAAA,CAAAuR,KAAA,IAAA0R,KAAA,WAGAnD,IACA,CACAC,aAAA,uEACAiB,cAAA,4FAGArE,MACA,CACA,CACAJ,UAAA,cACAiE,YAAA,a7BwgQA,EAAE,CAAC,GAAG,GAAG,CAAC,SAASplB,EAAQf,EAAOD,G8BriQlCC,EAAAD,QAAA,CACAiiB,YACA,CACAE,UAAA,SACAD,UAAA,UACAyG,SAAA,sEAGAtG,OACA,CACAqH,YAAA,CAAAvS,KAAA,cAAA0R,KAAA,UACAc,UAAA,CAAAxS,KAAA,YAAA0R,KAAA,UACAe,YAAA,CAAAzS,KAAA,cAAA0R,KAAA,WAGAvG,QACA,CACAuH,aAAA,CAAA1S,KAAA,eAAA0R,KAAA,WAGAnD,IACA,CACAC,aAAA,0HACAiB,cAAA,wLAGArE,MACA,CACA,CACAJ,UAAA,SACAiE,YAAA,Y9B0iQA,EAAE,CAAC,GAAG,GAAG,CAAC,SAASplB,EAAQf,EAAOD,G+BxkQlCC,EAAAD,QAAA,CACAiiB,YACA,CACAE,UAAA,SACAD,UAAA,YACAyG,SAAA,0FAGAtG,OACA,CACAqH,YAAA,CAAAvS,KAAA,cAAA0R,KAAA,UACAiB,WAAA,CAAA3S,KAAA,aAAA0R,KAAA,SAAAtR,QAAA,GACAwS,SAAA,CAAA5S,KAAA,WAAA0R,KAAA,SAAAtR,QAAA,OAGA+K,QACA,CACAuH,aAAA,CAAA1S,KAAA,eAAA0R,KAAA,WAGAnD,IACA,CACAC,aAAA,oHACAiB,cAAA,+KAGArE,MACA,CACA,CACAJ,UAAA,SACAiE,YAAA,c/B6kQA,EAAE,CAAC,GAAG,GAAG,CAAC,SAASplB,EAAQf,EAAOD,GgC3mQlCC,EAAAD,QAAA,CACAiiB,YACA,CACAE,UAAA,SACAD,UAAA,OACAyG,SAAA,4FAGAtG,OACA,CACAqH,YAAA,CAAAvS,KAAA,cAAA0R,KAAA,WAGAvG,QACA,CACAuH,aAAA,CAAA1S,KAAA,eAAA0R,KAAA,WAGAnD,IACA,CACAC,aAAA,+DACAiB,cAAA,gHAGArE,MACA,CACA,CACAJ,UAAA,SACAiE,YAAA,ShCgnQA,EAAE,CAAC,GAAG,GAAG,CAAC,SAASplB,EAAQf,EAAOD,GiC5oQlC,IAAAijB,EAAAjiB,EAAA,mCAEA,MAAAgpB,EAAAhpB,EAAA,cAEA,IAAAoM,EAAA0U,IAGA,IAAAuG,EAAA,IAAA2B,EAAAlI,EAAAyE,cAAA7I,eAAAoE,EAAAwE,YAAA,MACAgC,EAAA,IAAA0B,EAAAlI,EAAAyE,cAAA7I,eAAAoE,EAAAwE,YAAA,MAEA,OADAxE,EAAA2E,eAAA7I,eAAAkE,EAAA0E,aAAA,IAAA6B,EAAA3gB,KAAA4gB,GAAAjhB,aACA,CAAA,EAGA+I,EAAA0R,IAGA,IAAAuG,EAAA,IAAA2B,EAAAlI,EAAAyE,cAAA7I,eAAAoE,EAAAwE,YAAA,MACAgC,EAAA,IAAA0B,EAAAlI,EAAAyE,cAAA7I,eAAAoE,EAAAwE,YAAA,MAEA,OADAxE,EAAA2E,eAAA7I,eAAAkE,EAAA0E,aAAA,IAAA6B,EAAA7b,IAAA8b,GAAAjhB,aACA,CAAA,EAGAkhB,EAAAzG,IAGA,IAAAuG,EAAA,IAAA2B,EAAAlI,EAAAyE,cAAA7I,eAAAoE,EAAAwE,YAAA,MACAgC,EAAA,IAAA0B,EAAAlI,EAAAyE,cAAA7I,eAAAoE,EAAAwE,YAAA,MAEA,OADAxE,EAAA2E,eAAA7I,eAAAkE,EAAA0E,aAAA,IAAA6B,EAAAra,IAAAsa,GAAAjhB,aACA,CAAA,EAGAiB,EAAAwZ,IAGA,IAAAuG,EAAA,IAAA2B,EAAAlI,EAAAyE,cAAA7I,eAAAoE,EAAAwE,YAAA,MACAgC,EAAA,IAAA0B,EAAAlI,EAAAyE,cAAA7I,eAAAoE,EAAAwE,YAAA,MAEA,OADAxE,EAAA2E,eAAA7I,eAAAkE,EAAA0E,aAAA,IAAA6B,EAAA1f,IAAA2f,GAAAjhB,aACA,CAAA,EAGAmhB,EAAA1G,IAEA,IAAAuG,EAAAvG,EAAAyE,cAAA7I,eAAAoE,EAAAwE,YAAA,KAEA2D,SAAA,EAEAxB,EAAA,IAAAuB,EAAA,GAEA,GAAA,UAAAC,EAEA,GAAAzS,MAAAC,QAAA4Q,GAEA,IAAA,IAAAvnB,EAAA,EAAAA,EAAAunB,EAAA9mB,OAAAT,IACA,CAEA,IAAAsY,EAAA,IAAA4Q,EAAA3B,EAAAvnB,IAEAyK,MAAA6N,GAEA0I,EAAAvM,SAAA,wBAAAzU,iEAAAunB,EAAAvnB,QAIA2nB,EAAAA,EAAA/gB,KAAA0R,GACA0I,EAAAxM,QAAA,mBAAAxU,YAAAsY,eAAAqP,KAEA,KAGA,CACA,IAAAC,EAAAhT,OAAAC,KAAA0S,GACA,IAAA,IAAAvnB,EAAA,EAAAA,EAAA4nB,EAAAnnB,OAAAT,IACA,CACA,IAAAsY,EAAA,IAAA4Q,EAAA3B,EAAAK,EAAA5nB,KAEAyK,MAAA6N,GAEA0I,EAAAvM,SAAA,oBAAAmT,EAAA5nB,oDAAAunB,EAAAK,EAAA5nB,SAIA2nB,EAAAA,EAAA/gB,KAAA0R,GACA0I,EAAAxM,QAAA,2BAAAoT,EAAA5nB,aAAAsY,eAAAqP,KAEA,CACA,KAGA,CACA,IAAArP,EAAA,IAAA4Q,EAAA3B,GAEA9c,MAAA6N,GAEA0I,EAAAvM,SAAA,6DAAA8S,MAIAI,EAAArP,CAEA,CAEA,OADA0I,EAAA2E,eAAA7I,eAAAkE,EAAA0E,aAAA,IAAAiC,EAAAphB,aACA,CAAA,EAGAmH,EAAAsT,IAGA,IAAAuG,EAAA,IAAA2B,EAAAlI,EAAAyE,cAAA7I,eAAAoE,EAAAwE,YAAA,MAEA,OADAxE,EAAA2E,eAAA7I,eAAAkE,EAAA0E,aAAA,IAAA6B,EAAA7Z,aAAAnH,aACA,CAAA,EA4CApH,EAAAD,QAxCA,cAAAijB,EAEApd,YAAAsb,GAEA4F,MAAA5F,GACA5gB,KAAA8gB,UAAA,aACA,CAEAQ,yBAiBA,OAfAthB,KAAAmhB,eAAA,MAAAtU,GAEA7M,KAAAmhB,eAAA,WAAAtR,GACA7P,KAAAmhB,eAAA,MAAAtR,GAEA7P,KAAAmhB,eAAA,WAAA6G,GACAhoB,KAAAmhB,eAAA,MAAA6G,GAEAhoB,KAAAmhB,eAAA,SAAApZ,GACA/H,KAAAmhB,eAAA,MAAApZ,GAEA/H,KAAAmhB,eAAA,YAAA8G,GAEAjoB,KAAAmhB,eAAA,aAAAlT,IAEA,CACA,CAEAgU,uBAQA,OANAjiB,KAAAwhB,aAAA,MAAA/gB,EAAA,sCACAT,KAAAwhB,aAAA,WAAA/gB,EAAA,2CACAT,KAAAwhB,aAAA,WAAA/gB,EAAA,2CACAT,KAAAwhB,aAAA,SAAA/gB,EAAA,yCACAT,KAAAwhB,aAAA,YAAA/gB,EAAA,6CAEA,CACA,EjCipQA,EAAE,CAAC,kCAAkC,GAAG,oCAAoC,GAAG,0CAA0C,GAAG,uCAAuC,GAAG,yCAAyC,GAAG,yCAAyC,GAAG,aAAa,IAAI,GAAG,CAAC,SAASA,EAAQf,EAAOD,GkCnyQ3S,IAAAijB,EAAAjiB,EAAA,mCAEAsX,EAAAwJ,IAEA,IAAAoI,EAAApI,EAAAyE,cAAA7I,eAAAoE,EAAAwE,YAAA,eAIA,OAFAxE,EAAA2E,eAAA7I,eAAAkE,EAAA0E,aAAA,eAAA0D,EAAA5R,SAEA,CAAA,EAGA/F,EAAAuP,IAEA,IAAAoI,EAAApI,EAAAyE,cAAA7I,eAAAoE,EAAAwE,YAAA,eACA6D,EAAArI,EAAAyE,cAAA7I,eAAAoE,EAAAwE,YAAA,aACA8D,EAAAtI,EAAAyE,cAAA7I,eAAAoE,EAAAwE,YAAA,eAIA,OAFAxE,EAAA2E,eAAA7I,eAAAkE,EAAA0E,aAAA,eAAA0D,EAAA3X,QAAA4X,EAAAC,KAEA,CAAA,EAGA3X,EAAAqP,IAEA,IAAAoI,EAAApI,EAAAyE,cAAA7I,eAAAoE,EAAAwE,YAAA,eACAwD,EAAAhI,EAAAyE,cAAA7I,eAAAoE,EAAAwE,YAAA,cACAyD,EAAAjI,EAAAyE,cAAA7I,eAAAoE,EAAAwE,YAAA,YAWA,OATA,MAAAyD,EAEAjI,EAAA2E,eAAA7I,eAAAkE,EAAA0E,aAAA,eAAA0D,EAAAzX,UAAAqX,EAAAC,IAIAjI,EAAA2E,eAAA7I,eAAAkE,EAAA0E,aAAA,eAAA0D,EAAAzX,UAAAqX,KAGA,CAAA,EA8BA7pB,EAAAD,QA3BA,cAAAijB,EAEApd,YAAAsb,GAEA4F,MAAA5F,GACA5gB,KAAA8gB,UAAA,QACA,CAEAQ,yBAMA,OAJAthB,KAAAmhB,eAAA,OAAApJ,GACA/X,KAAAmhB,eAAA,UAAAnP,GACAhS,KAAAmhB,eAAA,YAAAjP,IAEA,CACA,CAEA+P,uBAMA,OAJAjiB,KAAAwhB,aAAA,OAAA/gB,EAAA,kCACAT,KAAAwhB,aAAA,UAAA/gB,EAAA,qCACAT,KAAAwhB,aAAA,YAAA/gB,EAAA,wCAEA,CACA,ElC4yQA,EAAE,CAAC,kCAAkC,GAAG,mCAAmC,GAAG,qCAAqC,GAAG,gCAAgC,MAAM,CAAC,EAAE,CAAC,IFh3QhK,CEg3QqK,GACrK","file":"elucidator.min.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()",";(function (globalScope) {\r\n  'use strict';\r\n\r\n\r\n  /*!\r\n   *  decimal.js v10.4.2\r\n   *  An arbitrary-precision Decimal type for JavaScript.\r\n   *  https://github.com/MikeMcl/decimal.js\r\n   *  Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>\r\n   *  MIT Licence\r\n   */\r\n\r\n\r\n  // -----------------------------------  EDITABLE DEFAULTS  ------------------------------------ //\r\n\r\n\r\n    // The maximum exponent magnitude.\r\n    // The limit on the value of `toExpNeg`, `toExpPos`, `minE` and `maxE`.\r\n  var EXP_LIMIT = 9e15,                      // 0 to 9e15\r\n\r\n    // The limit on the value of `precision`, and on the value of the first argument to\r\n    // `toDecimalPlaces`, `toExponential`, `toFixed`, `toPrecision` and `toSignificantDigits`.\r\n    MAX_DIGITS = 1e9,                        // 0 to 1e9\r\n\r\n    // Base conversion alphabet.\r\n    NUMERALS = '0123456789abcdef',\r\n\r\n    // The natural logarithm of 10 (1025 digits).\r\n    LN10 = '2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058',\r\n\r\n    // Pi (1025 digits).\r\n    PI = '3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789',\r\n\r\n\r\n    // The initial configuration properties of the Decimal constructor.\r\n    DEFAULTS = {\r\n\r\n      // These values must be integers within the stated ranges (inclusive).\r\n      // Most of these values can be changed at run-time using the `Decimal.config` method.\r\n\r\n      // The maximum number of significant digits of the result of a calculation or base conversion.\r\n      // E.g. `Decimal.config({ precision: 20 });`\r\n      precision: 20,                         // 1 to MAX_DIGITS\r\n\r\n      // The rounding mode used when rounding to `precision`.\r\n      //\r\n      // ROUND_UP         0 Away from zero.\r\n      // ROUND_DOWN       1 Towards zero.\r\n      // ROUND_CEIL       2 Towards +Infinity.\r\n      // ROUND_FLOOR      3 Towards -Infinity.\r\n      // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.\r\n      // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.\r\n      // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.\r\n      // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.\r\n      // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.\r\n      //\r\n      // E.g.\r\n      // `Decimal.rounding = 4;`\r\n      // `Decimal.rounding = Decimal.ROUND_HALF_UP;`\r\n      rounding: 4,                           // 0 to 8\r\n\r\n      // The modulo mode used when calculating the modulus: a mod n.\r\n      // The quotient (q = a / n) is calculated according to the corresponding rounding mode.\r\n      // The remainder (r) is calculated as: r = a - n * q.\r\n      //\r\n      // UP         0 The remainder is positive if the dividend is negative, else is negative.\r\n      // DOWN       1 The remainder has the same sign as the dividend (JavaScript %).\r\n      // FLOOR      3 The remainder has the same sign as the divisor (Python %).\r\n      // HALF_EVEN  6 The IEEE 754 remainder function.\r\n      // EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.\r\n      //\r\n      // Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian\r\n      // division (9) are commonly used for the modulus operation. The other rounding modes can also\r\n      // be used, but they may not give useful results.\r\n      modulo: 1,                             // 0 to 9\r\n\r\n      // The exponent value at and beneath which `toString` returns exponential notation.\r\n      // JavaScript numbers: -7\r\n      toExpNeg: -7,                          // 0 to -EXP_LIMIT\r\n\r\n      // The exponent value at and above which `toString` returns exponential notation.\r\n      // JavaScript numbers: 21\r\n      toExpPos:  21,                         // 0 to EXP_LIMIT\r\n\r\n      // The minimum exponent value, beneath which underflow to zero occurs.\r\n      // JavaScript numbers: -324  (5e-324)\r\n      minE: -EXP_LIMIT,                      // -1 to -EXP_LIMIT\r\n\r\n      // The maximum exponent value, above which overflow to Infinity occurs.\r\n      // JavaScript numbers: 308  (1.7976931348623157e+308)\r\n      maxE: EXP_LIMIT,                       // 1 to EXP_LIMIT\r\n\r\n      // Whether to use cryptographically-secure random number generation, if available.\r\n      crypto: false                          // true/false\r\n    },\r\n\r\n\r\n  // ----------------------------------- END OF EDITABLE DEFAULTS ------------------------------- //\r\n\r\n\r\n    Decimal, inexact, noConflict, quadrant,\r\n    external = true,\r\n\r\n    decimalError = '[DecimalError] ',\r\n    invalidArgument = decimalError + 'Invalid argument: ',\r\n    precisionLimitExceeded = decimalError + 'Precision limit exceeded',\r\n    cryptoUnavailable = decimalError + 'crypto unavailable',\r\n    tag = '[object Decimal]',\r\n\r\n    mathfloor = Math.floor,\r\n    mathpow = Math.pow,\r\n\r\n    isBinary = /^0b([01]+(\\.[01]*)?|\\.[01]+)(p[+-]?\\d+)?$/i,\r\n    isHex = /^0x([0-9a-f]+(\\.[0-9a-f]*)?|\\.[0-9a-f]+)(p[+-]?\\d+)?$/i,\r\n    isOctal = /^0o([0-7]+(\\.[0-7]*)?|\\.[0-7]+)(p[+-]?\\d+)?$/i,\r\n    isDecimal = /^(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?$/i,\r\n\r\n    BASE = 1e7,\r\n    LOG_BASE = 7,\r\n    MAX_SAFE_INTEGER = 9007199254740991,\r\n\r\n    LN10_PRECISION = LN10.length - 1,\r\n    PI_PRECISION = PI.length - 1,\r\n\r\n    // Decimal.prototype object\r\n    P = { toStringTag: tag };\r\n\r\n\r\n  // Decimal prototype methods\r\n\r\n\r\n  /*\r\n   *  absoluteValue             abs\r\n   *  ceil\r\n   *  clampedTo                 clamp\r\n   *  comparedTo                cmp\r\n   *  cosine                    cos\r\n   *  cubeRoot                  cbrt\r\n   *  decimalPlaces             dp\r\n   *  dividedBy                 div\r\n   *  dividedToIntegerBy        divToInt\r\n   *  equals                    eq\r\n   *  floor\r\n   *  greaterThan               gt\r\n   *  greaterThanOrEqualTo      gte\r\n   *  hyperbolicCosine          cosh\r\n   *  hyperbolicSine            sinh\r\n   *  hyperbolicTangent         tanh\r\n   *  inverseCosine             acos\r\n   *  inverseHyperbolicCosine   acosh\r\n   *  inverseHyperbolicSine     asinh\r\n   *  inverseHyperbolicTangent  atanh\r\n   *  inverseSine               asin\r\n   *  inverseTangent            atan\r\n   *  isFinite\r\n   *  isInteger                 isInt\r\n   *  isNaN\r\n   *  isNegative                isNeg\r\n   *  isPositive                isPos\r\n   *  isZero\r\n   *  lessThan                  lt\r\n   *  lessThanOrEqualTo         lte\r\n   *  logarithm                 log\r\n   *  [maximum]                 [max]\r\n   *  [minimum]                 [min]\r\n   *  minus                     sub\r\n   *  modulo                    mod\r\n   *  naturalExponential        exp\r\n   *  naturalLogarithm          ln\r\n   *  negated                   neg\r\n   *  plus                      add\r\n   *  precision                 sd\r\n   *  round\r\n   *  sine                      sin\r\n   *  squareRoot                sqrt\r\n   *  tangent                   tan\r\n   *  times                     mul\r\n   *  toBinary\r\n   *  toDecimalPlaces           toDP\r\n   *  toExponential\r\n   *  toFixed\r\n   *  toFraction\r\n   *  toHexadecimal             toHex\r\n   *  toNearest\r\n   *  toNumber\r\n   *  toOctal\r\n   *  toPower                   pow\r\n   *  toPrecision\r\n   *  toSignificantDigits       toSD\r\n   *  toString\r\n   *  truncated                 trunc\r\n   *  valueOf                   toJSON\r\n   */\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the absolute value of this Decimal.\r\n   *\r\n   */\r\n  P.absoluteValue = P.abs = function () {\r\n    var x = new this.constructor(this);\r\n    if (x.s < 0) x.s = 1;\r\n    return finalise(x);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal rounded to a whole number in the\r\n   * direction of positive Infinity.\r\n   *\r\n   */\r\n  P.ceil = function () {\r\n    return finalise(new this.constructor(this), this.e + 1, 2);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal clamped to the range\r\n   * delineated by `min` and `max`.\r\n   *\r\n   * min {number|string|Decimal}\r\n   * max {number|string|Decimal}\r\n   *\r\n   */\r\n  P.clampedTo = P.clamp = function (min, max) {\r\n    var k,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n    min = new Ctor(min);\r\n    max = new Ctor(max);\r\n    if (!min.s || !max.s) return new Ctor(NaN);\r\n    if (min.gt(max)) throw Error(invalidArgument + max);\r\n    k = x.cmp(min);\r\n    return k < 0 ? min : x.cmp(max) > 0 ? max : new Ctor(x);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return\r\n   *   1    if the value of this Decimal is greater than the value of `y`,\r\n   *  -1    if the value of this Decimal is less than the value of `y`,\r\n   *   0    if they have the same value,\r\n   *   NaN  if the value of either Decimal is NaN.\r\n   *\r\n   */\r\n  P.comparedTo = P.cmp = function (y) {\r\n    var i, j, xdL, ydL,\r\n      x = this,\r\n      xd = x.d,\r\n      yd = (y = new x.constructor(y)).d,\r\n      xs = x.s,\r\n      ys = y.s;\r\n\r\n    // Either NaN or ±Infinity?\r\n    if (!xd || !yd) {\r\n      return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;\r\n    }\r\n\r\n    // Either zero?\r\n    if (!xd[0] || !yd[0]) return xd[0] ? xs : yd[0] ? -ys : 0;\r\n\r\n    // Signs differ?\r\n    if (xs !== ys) return xs;\r\n\r\n    // Compare exponents.\r\n    if (x.e !== y.e) return x.e > y.e ^ xs < 0 ? 1 : -1;\r\n\r\n    xdL = xd.length;\r\n    ydL = yd.length;\r\n\r\n    // Compare digit by digit.\r\n    for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) {\r\n      if (xd[i] !== yd[i]) return xd[i] > yd[i] ^ xs < 0 ? 1 : -1;\r\n    }\r\n\r\n    // Compare lengths.\r\n    return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the cosine of the value in radians of this Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-1, 1]\r\n   *\r\n   * cos(0)         = 1\r\n   * cos(-0)        = 1\r\n   * cos(Infinity)  = NaN\r\n   * cos(-Infinity) = NaN\r\n   * cos(NaN)       = NaN\r\n   *\r\n   */\r\n  P.cosine = P.cos = function () {\r\n    var pr, rm,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (!x.d) return new Ctor(NaN);\r\n\r\n    // cos(0) = cos(-0) = 1\r\n    if (!x.d[0]) return new Ctor(1);\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n    Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;\r\n    Ctor.rounding = 1;\r\n\r\n    x = cosine(Ctor, toLessThanHalfPi(Ctor, x));\r\n\r\n    Ctor.precision = pr;\r\n    Ctor.rounding = rm;\r\n\r\n    return finalise(quadrant == 2 || quadrant == 3 ? x.neg() : x, pr, rm, true);\r\n  };\r\n\r\n\r\n  /*\r\n   *\r\n   * Return a new Decimal whose value is the cube root of the value of this Decimal, rounded to\r\n   * `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   *  cbrt(0)  =  0\r\n   *  cbrt(-0) = -0\r\n   *  cbrt(1)  =  1\r\n   *  cbrt(-1) = -1\r\n   *  cbrt(N)  =  N\r\n   *  cbrt(-I) = -I\r\n   *  cbrt(I)  =  I\r\n   *\r\n   * Math.cbrt(x) = (x < 0 ? -Math.pow(-x, 1/3) : Math.pow(x, 1/3))\r\n   *\r\n   */\r\n  P.cubeRoot = P.cbrt = function () {\r\n    var e, m, n, r, rep, s, sd, t, t3, t3plusx,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (!x.isFinite() || x.isZero()) return new Ctor(x);\r\n    external = false;\r\n\r\n    // Initial estimate.\r\n    s = x.s * mathpow(x.s * x, 1 / 3);\r\n\r\n     // Math.cbrt underflow/overflow?\r\n     // Pass x to Math.pow as integer, then adjust the exponent of the result.\r\n    if (!s || Math.abs(s) == 1 / 0) {\r\n      n = digitsToString(x.d);\r\n      e = x.e;\r\n\r\n      // Adjust n exponent so it is a multiple of 3 away from x exponent.\r\n      if (s = (e - n.length + 1) % 3) n += (s == 1 || s == -2 ? '0' : '00');\r\n      s = mathpow(n, 1 / 3);\r\n\r\n      // Rarely, e may be one less than the result exponent value.\r\n      e = mathfloor((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2));\r\n\r\n      if (s == 1 / 0) {\r\n        n = '5e' + e;\r\n      } else {\r\n        n = s.toExponential();\r\n        n = n.slice(0, n.indexOf('e') + 1) + e;\r\n      }\r\n\r\n      r = new Ctor(n);\r\n      r.s = x.s;\r\n    } else {\r\n      r = new Ctor(s.toString());\r\n    }\r\n\r\n    sd = (e = Ctor.precision) + 3;\r\n\r\n    // Halley's method.\r\n    // TODO? Compare Newton's method.\r\n    for (;;) {\r\n      t = r;\r\n      t3 = t.times(t).times(t);\r\n      t3plusx = t3.plus(x);\r\n      r = divide(t3plusx.plus(x).times(t), t3plusx.plus(t3), sd + 2, 1);\r\n\r\n      // TODO? Replace with for-loop and checkRoundingDigits.\r\n      if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {\r\n        n = n.slice(sd - 3, sd + 1);\r\n\r\n        // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or 4999\r\n        // , i.e. approaching a rounding boundary, continue the iteration.\r\n        if (n == '9999' || !rep && n == '4999') {\r\n\r\n          // On the first iteration only, check to see if rounding up gives the exact result as the\r\n          // nines may infinitely repeat.\r\n          if (!rep) {\r\n            finalise(t, e + 1, 0);\r\n\r\n            if (t.times(t).times(t).eq(x)) {\r\n              r = t;\r\n              break;\r\n            }\r\n          }\r\n\r\n          sd += 4;\r\n          rep = 1;\r\n        } else {\r\n\r\n          // If the rounding digits are null, 0{0,4} or 50{0,3}, check for an exact result.\r\n          // If not, then there are further digits and m will be truthy.\r\n          if (!+n || !+n.slice(1) && n.charAt(0) == '5') {\r\n\r\n            // Truncate to the first rounding digit.\r\n            finalise(r, e + 1, 1);\r\n            m = !r.times(r).times(r).eq(x);\r\n          }\r\n\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    external = true;\r\n\r\n    return finalise(r, e, Ctor.rounding, m);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return the number of decimal places of the value of this Decimal.\r\n   *\r\n   */\r\n  P.decimalPlaces = P.dp = function () {\r\n    var w,\r\n      d = this.d,\r\n      n = NaN;\r\n\r\n    if (d) {\r\n      w = d.length - 1;\r\n      n = (w - mathfloor(this.e / LOG_BASE)) * LOG_BASE;\r\n\r\n      // Subtract the number of trailing zeros of the last word.\r\n      w = d[w];\r\n      if (w) for (; w % 10 == 0; w /= 10) n--;\r\n      if (n < 0) n = 0;\r\n    }\r\n\r\n    return n;\r\n  };\r\n\r\n\r\n  /*\r\n   *  n / 0 = I\r\n   *  n / N = N\r\n   *  n / I = 0\r\n   *  0 / n = 0\r\n   *  0 / 0 = N\r\n   *  0 / N = N\r\n   *  0 / I = 0\r\n   *  N / n = N\r\n   *  N / 0 = N\r\n   *  N / N = N\r\n   *  N / I = N\r\n   *  I / n = I\r\n   *  I / 0 = I\r\n   *  I / N = N\r\n   *  I / I = N\r\n   *\r\n   * Return a new Decimal whose value is the value of this Decimal divided by `y`, rounded to\r\n   * `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   */\r\n  P.dividedBy = P.div = function (y) {\r\n    return divide(this, new this.constructor(y));\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the integer part of dividing the value of this Decimal\r\n   * by the value of `y`, rounded to `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   */\r\n  P.dividedToIntegerBy = P.divToInt = function (y) {\r\n    var x = this,\r\n      Ctor = x.constructor;\r\n    return finalise(divide(x, new Ctor(y), 0, 1, 1), Ctor.precision, Ctor.rounding);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is equal to the value of `y`, otherwise return false.\r\n   *\r\n   */\r\n  P.equals = P.eq = function (y) {\r\n    return this.cmp(y) === 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal rounded to a whole number in the\r\n   * direction of negative Infinity.\r\n   *\r\n   */\r\n  P.floor = function () {\r\n    return finalise(new this.constructor(this), this.e + 1, 3);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is greater than the value of `y`, otherwise return\r\n   * false.\r\n   *\r\n   */\r\n  P.greaterThan = P.gt = function (y) {\r\n    return this.cmp(y) > 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is greater than or equal to the value of `y`,\r\n   * otherwise return false.\r\n   *\r\n   */\r\n  P.greaterThanOrEqualTo = P.gte = function (y) {\r\n    var k = this.cmp(y);\r\n    return k == 1 || k === 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the hyperbolic cosine of the value in radians of this\r\n   * Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [1, Infinity]\r\n   *\r\n   * cosh(x) = 1 + x^2/2! + x^4/4! + x^6/6! + ...\r\n   *\r\n   * cosh(0)         = 1\r\n   * cosh(-0)        = 1\r\n   * cosh(Infinity)  = Infinity\r\n   * cosh(-Infinity) = Infinity\r\n   * cosh(NaN)       = NaN\r\n   *\r\n   *  x        time taken (ms)   result\r\n   * 1000      9                 9.8503555700852349694e+433\r\n   * 10000     25                4.4034091128314607936e+4342\r\n   * 100000    171               1.4033316802130615897e+43429\r\n   * 1000000   3817              1.5166076984010437725e+434294\r\n   * 10000000  abandoned after 2 minute wait\r\n   *\r\n   * TODO? Compare performance of cosh(x) = 0.5 * (exp(x) + exp(-x))\r\n   *\r\n   */\r\n  P.hyperbolicCosine = P.cosh = function () {\r\n    var k, n, pr, rm, len,\r\n      x = this,\r\n      Ctor = x.constructor,\r\n      one = new Ctor(1);\r\n\r\n    if (!x.isFinite()) return new Ctor(x.s ? 1 / 0 : NaN);\r\n    if (x.isZero()) return one;\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n    Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;\r\n    Ctor.rounding = 1;\r\n    len = x.d.length;\r\n\r\n    // Argument reduction: cos(4x) = 1 - 8cos^2(x) + 8cos^4(x) + 1\r\n    // i.e. cos(x) = 1 - cos^2(x/4)(8 - 8cos^2(x/4))\r\n\r\n    // Estimate the optimum number of times to use the argument reduction.\r\n    // TODO? Estimation reused from cosine() and may not be optimal here.\r\n    if (len < 32) {\r\n      k = Math.ceil(len / 3);\r\n      n = (1 / tinyPow(4, k)).toString();\r\n    } else {\r\n      k = 16;\r\n      n = '2.3283064365386962890625e-10';\r\n    }\r\n\r\n    x = taylorSeries(Ctor, 1, x.times(n), new Ctor(1), true);\r\n\r\n    // Reverse argument reduction\r\n    var cosh2_x,\r\n      i = k,\r\n      d8 = new Ctor(8);\r\n    for (; i--;) {\r\n      cosh2_x = x.times(x);\r\n      x = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));\r\n    }\r\n\r\n    return finalise(x, Ctor.precision = pr, Ctor.rounding = rm, true);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the hyperbolic sine of the value in radians of this\r\n   * Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-Infinity, Infinity]\r\n   *\r\n   * sinh(x) = x + x^3/3! + x^5/5! + x^7/7! + ...\r\n   *\r\n   * sinh(0)         = 0\r\n   * sinh(-0)        = -0\r\n   * sinh(Infinity)  = Infinity\r\n   * sinh(-Infinity) = -Infinity\r\n   * sinh(NaN)       = NaN\r\n   *\r\n   * x        time taken (ms)\r\n   * 10       2 ms\r\n   * 100      5 ms\r\n   * 1000     14 ms\r\n   * 10000    82 ms\r\n   * 100000   886 ms            1.4033316802130615897e+43429\r\n   * 200000   2613 ms\r\n   * 300000   5407 ms\r\n   * 400000   8824 ms\r\n   * 500000   13026 ms          8.7080643612718084129e+217146\r\n   * 1000000  48543 ms\r\n   *\r\n   * TODO? Compare performance of sinh(x) = 0.5 * (exp(x) - exp(-x))\r\n   *\r\n   */\r\n  P.hyperbolicSine = P.sinh = function () {\r\n    var k, pr, rm, len,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (!x.isFinite() || x.isZero()) return new Ctor(x);\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n    Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;\r\n    Ctor.rounding = 1;\r\n    len = x.d.length;\r\n\r\n    if (len < 3) {\r\n      x = taylorSeries(Ctor, 2, x, x, true);\r\n    } else {\r\n\r\n      // Alternative argument reduction: sinh(3x) = sinh(x)(3 + 4sinh^2(x))\r\n      // i.e. sinh(x) = sinh(x/3)(3 + 4sinh^2(x/3))\r\n      // 3 multiplications and 1 addition\r\n\r\n      // Argument reduction: sinh(5x) = sinh(x)(5 + sinh^2(x)(20 + 16sinh^2(x)))\r\n      // i.e. sinh(x) = sinh(x/5)(5 + sinh^2(x/5)(20 + 16sinh^2(x/5)))\r\n      // 4 multiplications and 2 additions\r\n\r\n      // Estimate the optimum number of times to use the argument reduction.\r\n      k = 1.4 * Math.sqrt(len);\r\n      k = k > 16 ? 16 : k | 0;\r\n\r\n      x = x.times(1 / tinyPow(5, k));\r\n      x = taylorSeries(Ctor, 2, x, x, true);\r\n\r\n      // Reverse argument reduction\r\n      var sinh2_x,\r\n        d5 = new Ctor(5),\r\n        d16 = new Ctor(16),\r\n        d20 = new Ctor(20);\r\n      for (; k--;) {\r\n        sinh2_x = x.times(x);\r\n        x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));\r\n      }\r\n    }\r\n\r\n    Ctor.precision = pr;\r\n    Ctor.rounding = rm;\r\n\r\n    return finalise(x, pr, rm, true);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the hyperbolic tangent of the value in radians of this\r\n   * Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-1, 1]\r\n   *\r\n   * tanh(x) = sinh(x) / cosh(x)\r\n   *\r\n   * tanh(0)         = 0\r\n   * tanh(-0)        = -0\r\n   * tanh(Infinity)  = 1\r\n   * tanh(-Infinity) = -1\r\n   * tanh(NaN)       = NaN\r\n   *\r\n   */\r\n  P.hyperbolicTangent = P.tanh = function () {\r\n    var pr, rm,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (!x.isFinite()) return new Ctor(x.s);\r\n    if (x.isZero()) return new Ctor(x);\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n    Ctor.precision = pr + 7;\r\n    Ctor.rounding = 1;\r\n\r\n    return divide(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the arccosine (inverse cosine) in radians of the value of\r\n   * this Decimal.\r\n   *\r\n   * Domain: [-1, 1]\r\n   * Range: [0, pi]\r\n   *\r\n   * acos(x) = pi/2 - asin(x)\r\n   *\r\n   * acos(0)       = pi/2\r\n   * acos(-0)      = pi/2\r\n   * acos(1)       = 0\r\n   * acos(-1)      = pi\r\n   * acos(1/2)     = pi/3\r\n   * acos(-1/2)    = 2*pi/3\r\n   * acos(|x| > 1) = NaN\r\n   * acos(NaN)     = NaN\r\n   *\r\n   */\r\n  P.inverseCosine = P.acos = function () {\r\n    var halfPi,\r\n      x = this,\r\n      Ctor = x.constructor,\r\n      k = x.abs().cmp(1),\r\n      pr = Ctor.precision,\r\n      rm = Ctor.rounding;\r\n\r\n    if (k !== -1) {\r\n      return k === 0\r\n        // |x| is 1\r\n        ? x.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0)\r\n        // |x| > 1 or x is NaN\r\n        : new Ctor(NaN);\r\n    }\r\n\r\n    if (x.isZero()) return getPi(Ctor, pr + 4, rm).times(0.5);\r\n\r\n    // TODO? Special case acos(0.5) = pi/3 and acos(-0.5) = 2*pi/3\r\n\r\n    Ctor.precision = pr + 6;\r\n    Ctor.rounding = 1;\r\n\r\n    x = x.asin();\r\n    halfPi = getPi(Ctor, pr + 4, rm).times(0.5);\r\n\r\n    Ctor.precision = pr;\r\n    Ctor.rounding = rm;\r\n\r\n    return halfPi.minus(x);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the inverse of the hyperbolic cosine in radians of the\r\n   * value of this Decimal.\r\n   *\r\n   * Domain: [1, Infinity]\r\n   * Range: [0, Infinity]\r\n   *\r\n   * acosh(x) = ln(x + sqrt(x^2 - 1))\r\n   *\r\n   * acosh(x < 1)     = NaN\r\n   * acosh(NaN)       = NaN\r\n   * acosh(Infinity)  = Infinity\r\n   * acosh(-Infinity) = NaN\r\n   * acosh(0)         = NaN\r\n   * acosh(-0)        = NaN\r\n   * acosh(1)         = 0\r\n   * acosh(-1)        = NaN\r\n   *\r\n   */\r\n  P.inverseHyperbolicCosine = P.acosh = function () {\r\n    var pr, rm,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (x.lte(1)) return new Ctor(x.eq(1) ? 0 : NaN);\r\n    if (!x.isFinite()) return new Ctor(x);\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n    Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;\r\n    Ctor.rounding = 1;\r\n    external = false;\r\n\r\n    x = x.times(x).minus(1).sqrt().plus(x);\r\n\r\n    external = true;\r\n    Ctor.precision = pr;\r\n    Ctor.rounding = rm;\r\n\r\n    return x.ln();\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the inverse of the hyperbolic sine in radians of the value\r\n   * of this Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-Infinity, Infinity]\r\n   *\r\n   * asinh(x) = ln(x + sqrt(x^2 + 1))\r\n   *\r\n   * asinh(NaN)       = NaN\r\n   * asinh(Infinity)  = Infinity\r\n   * asinh(-Infinity) = -Infinity\r\n   * asinh(0)         = 0\r\n   * asinh(-0)        = -0\r\n   *\r\n   */\r\n  P.inverseHyperbolicSine = P.asinh = function () {\r\n    var pr, rm,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (!x.isFinite() || x.isZero()) return new Ctor(x);\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n    Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6;\r\n    Ctor.rounding = 1;\r\n    external = false;\r\n\r\n    x = x.times(x).plus(1).sqrt().plus(x);\r\n\r\n    external = true;\r\n    Ctor.precision = pr;\r\n    Ctor.rounding = rm;\r\n\r\n    return x.ln();\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the inverse of the hyperbolic tangent in radians of the\r\n   * value of this Decimal.\r\n   *\r\n   * Domain: [-1, 1]\r\n   * Range: [-Infinity, Infinity]\r\n   *\r\n   * atanh(x) = 0.5 * ln((1 + x) / (1 - x))\r\n   *\r\n   * atanh(|x| > 1)   = NaN\r\n   * atanh(NaN)       = NaN\r\n   * atanh(Infinity)  = NaN\r\n   * atanh(-Infinity) = NaN\r\n   * atanh(0)         = 0\r\n   * atanh(-0)        = -0\r\n   * atanh(1)         = Infinity\r\n   * atanh(-1)        = -Infinity\r\n   *\r\n   */\r\n  P.inverseHyperbolicTangent = P.atanh = function () {\r\n    var pr, rm, wpr, xsd,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (!x.isFinite()) return new Ctor(NaN);\r\n    if (x.e >= 0) return new Ctor(x.abs().eq(1) ? x.s / 0 : x.isZero() ? x : NaN);\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n    xsd = x.sd();\r\n\r\n    if (Math.max(xsd, pr) < 2 * -x.e - 1) return finalise(new Ctor(x), pr, rm, true);\r\n\r\n    Ctor.precision = wpr = xsd - x.e;\r\n\r\n    x = divide(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1);\r\n\r\n    Ctor.precision = pr + 4;\r\n    Ctor.rounding = 1;\r\n\r\n    x = x.ln();\r\n\r\n    Ctor.precision = pr;\r\n    Ctor.rounding = rm;\r\n\r\n    return x.times(0.5);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the arcsine (inverse sine) in radians of the value of this\r\n   * Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-pi/2, pi/2]\r\n   *\r\n   * asin(x) = 2*atan(x/(1 + sqrt(1 - x^2)))\r\n   *\r\n   * asin(0)       = 0\r\n   * asin(-0)      = -0\r\n   * asin(1/2)     = pi/6\r\n   * asin(-1/2)    = -pi/6\r\n   * asin(1)       = pi/2\r\n   * asin(-1)      = -pi/2\r\n   * asin(|x| > 1) = NaN\r\n   * asin(NaN)     = NaN\r\n   *\r\n   * TODO? Compare performance of Taylor series.\r\n   *\r\n   */\r\n  P.inverseSine = P.asin = function () {\r\n    var halfPi, k,\r\n      pr, rm,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (x.isZero()) return new Ctor(x);\r\n\r\n    k = x.abs().cmp(1);\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n\r\n    if (k !== -1) {\r\n\r\n      // |x| is 1\r\n      if (k === 0) {\r\n        halfPi = getPi(Ctor, pr + 4, rm).times(0.5);\r\n        halfPi.s = x.s;\r\n        return halfPi;\r\n      }\r\n\r\n      // |x| > 1 or x is NaN\r\n      return new Ctor(NaN);\r\n    }\r\n\r\n    // TODO? Special case asin(1/2) = pi/6 and asin(-1/2) = -pi/6\r\n\r\n    Ctor.precision = pr + 6;\r\n    Ctor.rounding = 1;\r\n\r\n    x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan();\r\n\r\n    Ctor.precision = pr;\r\n    Ctor.rounding = rm;\r\n\r\n    return x.times(2);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the arctangent (inverse tangent) in radians of the value\r\n   * of this Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-pi/2, pi/2]\r\n   *\r\n   * atan(x) = x - x^3/3 + x^5/5 - x^7/7 + ...\r\n   *\r\n   * atan(0)         = 0\r\n   * atan(-0)        = -0\r\n   * atan(1)         = pi/4\r\n   * atan(-1)        = -pi/4\r\n   * atan(Infinity)  = pi/2\r\n   * atan(-Infinity) = -pi/2\r\n   * atan(NaN)       = NaN\r\n   *\r\n   */\r\n  P.inverseTangent = P.atan = function () {\r\n    var i, j, k, n, px, t, r, wpr, x2,\r\n      x = this,\r\n      Ctor = x.constructor,\r\n      pr = Ctor.precision,\r\n      rm = Ctor.rounding;\r\n\r\n    if (!x.isFinite()) {\r\n      if (!x.s) return new Ctor(NaN);\r\n      if (pr + 4 <= PI_PRECISION) {\r\n        r = getPi(Ctor, pr + 4, rm).times(0.5);\r\n        r.s = x.s;\r\n        return r;\r\n      }\r\n    } else if (x.isZero()) {\r\n      return new Ctor(x);\r\n    } else if (x.abs().eq(1) && pr + 4 <= PI_PRECISION) {\r\n      r = getPi(Ctor, pr + 4, rm).times(0.25);\r\n      r.s = x.s;\r\n      return r;\r\n    }\r\n\r\n    Ctor.precision = wpr = pr + 10;\r\n    Ctor.rounding = 1;\r\n\r\n    // TODO? if (x >= 1 && pr <= PI_PRECISION) atan(x) = halfPi * x.s - atan(1 / x);\r\n\r\n    // Argument reduction\r\n    // Ensure |x| < 0.42\r\n    // atan(x) = 2 * atan(x / (1 + sqrt(1 + x^2)))\r\n\r\n    k = Math.min(28, wpr / LOG_BASE + 2 | 0);\r\n\r\n    for (i = k; i; --i) x = x.div(x.times(x).plus(1).sqrt().plus(1));\r\n\r\n    external = false;\r\n\r\n    j = Math.ceil(wpr / LOG_BASE);\r\n    n = 1;\r\n    x2 = x.times(x);\r\n    r = new Ctor(x);\r\n    px = x;\r\n\r\n    // atan(x) = x - x^3/3 + x^5/5 - x^7/7 + ...\r\n    for (; i !== -1;) {\r\n      px = px.times(x2);\r\n      t = r.minus(px.div(n += 2));\r\n\r\n      px = px.times(x2);\r\n      r = t.plus(px.div(n += 2));\r\n\r\n      if (r.d[j] !== void 0) for (i = j; r.d[i] === t.d[i] && i--;);\r\n    }\r\n\r\n    if (k) r = r.times(2 << (k - 1));\r\n\r\n    external = true;\r\n\r\n    return finalise(r, Ctor.precision = pr, Ctor.rounding = rm, true);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is a finite number, otherwise return false.\r\n   *\r\n   */\r\n  P.isFinite = function () {\r\n    return !!this.d;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is an integer, otherwise return false.\r\n   *\r\n   */\r\n  P.isInteger = P.isInt = function () {\r\n    return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is NaN, otherwise return false.\r\n   *\r\n   */\r\n  P.isNaN = function () {\r\n    return !this.s;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is negative, otherwise return false.\r\n   *\r\n   */\r\n  P.isNegative = P.isNeg = function () {\r\n    return this.s < 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is positive, otherwise return false.\r\n   *\r\n   */\r\n  P.isPositive = P.isPos = function () {\r\n    return this.s > 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is 0 or -0, otherwise return false.\r\n   *\r\n   */\r\n  P.isZero = function () {\r\n    return !!this.d && this.d[0] === 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is less than `y`, otherwise return false.\r\n   *\r\n   */\r\n  P.lessThan = P.lt = function (y) {\r\n    return this.cmp(y) < 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is less than or equal to `y`, otherwise return false.\r\n   *\r\n   */\r\n  P.lessThanOrEqualTo = P.lte = function (y) {\r\n    return this.cmp(y) < 1;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return the logarithm of the value of this Decimal to the specified base, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * If no base is specified, return log[10](arg).\r\n   *\r\n   * log[base](arg) = ln(arg) / ln(base)\r\n   *\r\n   * The result will always be correctly rounded if the base of the log is 10, and 'almost always'\r\n   * otherwise:\r\n   *\r\n   * Depending on the rounding mode, the result may be incorrectly rounded if the first fifteen\r\n   * rounding digits are [49]99999999999999 or [50]00000000000000. In that case, the maximum error\r\n   * between the result and the correctly rounded result will be one ulp (unit in the last place).\r\n   *\r\n   * log[-b](a)       = NaN\r\n   * log[0](a)        = NaN\r\n   * log[1](a)        = NaN\r\n   * log[NaN](a)      = NaN\r\n   * log[Infinity](a) = NaN\r\n   * log[b](0)        = -Infinity\r\n   * log[b](-0)       = -Infinity\r\n   * log[b](-a)       = NaN\r\n   * log[b](1)        = 0\r\n   * log[b](Infinity) = Infinity\r\n   * log[b](NaN)      = NaN\r\n   *\r\n   * [base] {number|string|Decimal} The base of the logarithm.\r\n   *\r\n   */\r\n  P.logarithm = P.log = function (base) {\r\n    var isBase10, d, denominator, k, inf, num, sd, r,\r\n      arg = this,\r\n      Ctor = arg.constructor,\r\n      pr = Ctor.precision,\r\n      rm = Ctor.rounding,\r\n      guard = 5;\r\n\r\n    // Default base is 10.\r\n    if (base == null) {\r\n      base = new Ctor(10);\r\n      isBase10 = true;\r\n    } else {\r\n      base = new Ctor(base);\r\n      d = base.d;\r\n\r\n      // Return NaN if base is negative, or non-finite, or is 0 or 1.\r\n      if (base.s < 0 || !d || !d[0] || base.eq(1)) return new Ctor(NaN);\r\n\r\n      isBase10 = base.eq(10);\r\n    }\r\n\r\n    d = arg.d;\r\n\r\n    // Is arg negative, non-finite, 0 or 1?\r\n    if (arg.s < 0 || !d || !d[0] || arg.eq(1)) {\r\n      return new Ctor(d && !d[0] ? -1 / 0 : arg.s != 1 ? NaN : d ? 0 : 1 / 0);\r\n    }\r\n\r\n    // The result will have a non-terminating decimal expansion if base is 10 and arg is not an\r\n    // integer power of 10.\r\n    if (isBase10) {\r\n      if (d.length > 1) {\r\n        inf = true;\r\n      } else {\r\n        for (k = d[0]; k % 10 === 0;) k /= 10;\r\n        inf = k !== 1;\r\n      }\r\n    }\r\n\r\n    external = false;\r\n    sd = pr + guard;\r\n    num = naturalLogarithm(arg, sd);\r\n    denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);\r\n\r\n    // The result will have 5 rounding digits.\r\n    r = divide(num, denominator, sd, 1);\r\n\r\n    // If at a rounding boundary, i.e. the result's rounding digits are [49]9999 or [50]0000,\r\n    // calculate 10 further digits.\r\n    //\r\n    // If the result is known to have an infinite decimal expansion, repeat this until it is clear\r\n    // that the result is above or below the boundary. Otherwise, if after calculating the 10\r\n    // further digits, the last 14 are nines, round up and assume the result is exact.\r\n    // Also assume the result is exact if the last 14 are zero.\r\n    //\r\n    // Example of a result that will be incorrectly rounded:\r\n    // log[1048576](4503599627370502) = 2.60000000000000009610279511444746...\r\n    // The above result correctly rounded using ROUND_CEIL to 1 decimal place should be 2.7, but it\r\n    // will be given as 2.6 as there are 15 zeros immediately after the requested decimal place, so\r\n    // the exact result would be assumed to be 2.6, which rounded using ROUND_CEIL to 1 decimal\r\n    // place is still 2.6.\r\n    if (checkRoundingDigits(r.d, k = pr, rm)) {\r\n\r\n      do {\r\n        sd += 10;\r\n        num = naturalLogarithm(arg, sd);\r\n        denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);\r\n        r = divide(num, denominator, sd, 1);\r\n\r\n        if (!inf) {\r\n\r\n          // Check for 14 nines from the 2nd rounding digit, as the first may be 4.\r\n          if (+digitsToString(r.d).slice(k + 1, k + 15) + 1 == 1e14) {\r\n            r = finalise(r, pr + 1, 0);\r\n          }\r\n\r\n          break;\r\n        }\r\n      } while (checkRoundingDigits(r.d, k += 10, rm));\r\n    }\r\n\r\n    external = true;\r\n\r\n    return finalise(r, pr, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the maximum of the arguments and the value of this Decimal.\r\n   *\r\n   * arguments {number|string|Decimal}\r\n   *\r\n  P.max = function () {\r\n    Array.prototype.push.call(arguments, this);\r\n    return maxOrMin(this.constructor, arguments, 'lt');\r\n  };\r\n   */\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the minimum of the arguments and the value of this Decimal.\r\n   *\r\n   * arguments {number|string|Decimal}\r\n   *\r\n  P.min = function () {\r\n    Array.prototype.push.call(arguments, this);\r\n    return maxOrMin(this.constructor, arguments, 'gt');\r\n  };\r\n   */\r\n\r\n\r\n  /*\r\n   *  n - 0 = n\r\n   *  n - N = N\r\n   *  n - I = -I\r\n   *  0 - n = -n\r\n   *  0 - 0 = 0\r\n   *  0 - N = N\r\n   *  0 - I = -I\r\n   *  N - n = N\r\n   *  N - 0 = N\r\n   *  N - N = N\r\n   *  N - I = N\r\n   *  I - n = I\r\n   *  I - 0 = I\r\n   *  I - N = N\r\n   *  I - I = N\r\n   *\r\n   * Return a new Decimal whose value is the value of this Decimal minus `y`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   */\r\n  P.minus = P.sub = function (y) {\r\n    var d, e, i, j, k, len, pr, rm, xd, xe, xLTy, yd,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    y = new Ctor(y);\r\n\r\n    // If either is not finite...\r\n    if (!x.d || !y.d) {\r\n\r\n      // Return NaN if either is NaN.\r\n      if (!x.s || !y.s) y = new Ctor(NaN);\r\n\r\n      // Return y negated if x is finite and y is ±Infinity.\r\n      else if (x.d) y.s = -y.s;\r\n\r\n      // Return x if y is finite and x is ±Infinity.\r\n      // Return x if both are ±Infinity with different signs.\r\n      // Return NaN if both are ±Infinity with the same sign.\r\n      else y = new Ctor(y.d || x.s !== y.s ? x : NaN);\r\n\r\n      return y;\r\n    }\r\n\r\n    // If signs differ...\r\n    if (x.s != y.s) {\r\n      y.s = -y.s;\r\n      return x.plus(y);\r\n    }\r\n\r\n    xd = x.d;\r\n    yd = y.d;\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n\r\n    // If either is zero...\r\n    if (!xd[0] || !yd[0]) {\r\n\r\n      // Return y negated if x is zero and y is non-zero.\r\n      if (yd[0]) y.s = -y.s;\r\n\r\n      // Return x if y is zero and x is non-zero.\r\n      else if (xd[0]) y = new Ctor(x);\r\n\r\n      // Return zero if both are zero.\r\n      // From IEEE 754 (2008) 6.3: 0 - 0 = -0 - -0 = -0 when rounding to -Infinity.\r\n      else return new Ctor(rm === 3 ? -0 : 0);\r\n\r\n      return external ? finalise(y, pr, rm) : y;\r\n    }\r\n\r\n    // x and y are finite, non-zero numbers with the same sign.\r\n\r\n    // Calculate base 1e7 exponents.\r\n    e = mathfloor(y.e / LOG_BASE);\r\n    xe = mathfloor(x.e / LOG_BASE);\r\n\r\n    xd = xd.slice();\r\n    k = xe - e;\r\n\r\n    // If base 1e7 exponents differ...\r\n    if (k) {\r\n      xLTy = k < 0;\r\n\r\n      if (xLTy) {\r\n        d = xd;\r\n        k = -k;\r\n        len = yd.length;\r\n      } else {\r\n        d = yd;\r\n        e = xe;\r\n        len = xd.length;\r\n      }\r\n\r\n      // Numbers with massively different exponents would result in a very high number of\r\n      // zeros needing to be prepended, but this can be avoided while still ensuring correct\r\n      // rounding by limiting the number of zeros to `Math.ceil(pr / LOG_BASE) + 2`.\r\n      i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;\r\n\r\n      if (k > i) {\r\n        k = i;\r\n        d.length = 1;\r\n      }\r\n\r\n      // Prepend zeros to equalise exponents.\r\n      d.reverse();\r\n      for (i = k; i--;) d.push(0);\r\n      d.reverse();\r\n\r\n    // Base 1e7 exponents equal.\r\n    } else {\r\n\r\n      // Check digits to determine which is the bigger number.\r\n\r\n      i = xd.length;\r\n      len = yd.length;\r\n      xLTy = i < len;\r\n      if (xLTy) len = i;\r\n\r\n      for (i = 0; i < len; i++) {\r\n        if (xd[i] != yd[i]) {\r\n          xLTy = xd[i] < yd[i];\r\n          break;\r\n        }\r\n      }\r\n\r\n      k = 0;\r\n    }\r\n\r\n    if (xLTy) {\r\n      d = xd;\r\n      xd = yd;\r\n      yd = d;\r\n      y.s = -y.s;\r\n    }\r\n\r\n    len = xd.length;\r\n\r\n    // Append zeros to `xd` if shorter.\r\n    // Don't add zeros to `yd` if shorter as subtraction only needs to start at `yd` length.\r\n    for (i = yd.length - len; i > 0; --i) xd[len++] = 0;\r\n\r\n    // Subtract yd from xd.\r\n    for (i = yd.length; i > k;) {\r\n\r\n      if (xd[--i] < yd[i]) {\r\n        for (j = i; j && xd[--j] === 0;) xd[j] = BASE - 1;\r\n        --xd[j];\r\n        xd[i] += BASE;\r\n      }\r\n\r\n      xd[i] -= yd[i];\r\n    }\r\n\r\n    // Remove trailing zeros.\r\n    for (; xd[--len] === 0;) xd.pop();\r\n\r\n    // Remove leading zeros and adjust exponent accordingly.\r\n    for (; xd[0] === 0; xd.shift()) --e;\r\n\r\n    // Zero?\r\n    if (!xd[0]) return new Ctor(rm === 3 ? -0 : 0);\r\n\r\n    y.d = xd;\r\n    y.e = getBase10Exponent(xd, e);\r\n\r\n    return external ? finalise(y, pr, rm) : y;\r\n  };\r\n\r\n\r\n  /*\r\n   *   n % 0 =  N\r\n   *   n % N =  N\r\n   *   n % I =  n\r\n   *   0 % n =  0\r\n   *  -0 % n = -0\r\n   *   0 % 0 =  N\r\n   *   0 % N =  N\r\n   *   0 % I =  0\r\n   *   N % n =  N\r\n   *   N % 0 =  N\r\n   *   N % N =  N\r\n   *   N % I =  N\r\n   *   I % n =  N\r\n   *   I % 0 =  N\r\n   *   I % N =  N\r\n   *   I % I =  N\r\n   *\r\n   * Return a new Decimal whose value is the value of this Decimal modulo `y`, rounded to\r\n   * `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * The result depends on the modulo mode.\r\n   *\r\n   */\r\n  P.modulo = P.mod = function (y) {\r\n    var q,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    y = new Ctor(y);\r\n\r\n    // Return NaN if x is ±Infinity or NaN, or y is NaN or ±0.\r\n    if (!x.d || !y.s || y.d && !y.d[0]) return new Ctor(NaN);\r\n\r\n    // Return x if y is ±Infinity or x is ±0.\r\n    if (!y.d || x.d && !x.d[0]) {\r\n      return finalise(new Ctor(x), Ctor.precision, Ctor.rounding);\r\n    }\r\n\r\n    // Prevent rounding of intermediate calculations.\r\n    external = false;\r\n\r\n    if (Ctor.modulo == 9) {\r\n\r\n      // Euclidian division: q = sign(y) * floor(x / abs(y))\r\n      // result = x - q * y    where  0 <= result < abs(y)\r\n      q = divide(x, y.abs(), 0, 3, 1);\r\n      q.s *= y.s;\r\n    } else {\r\n      q = divide(x, y, 0, Ctor.modulo, 1);\r\n    }\r\n\r\n    q = q.times(y);\r\n\r\n    external = true;\r\n\r\n    return x.minus(q);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the natural exponential of the value of this Decimal,\r\n   * i.e. the base e raised to the power the value of this Decimal, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   */\r\n  P.naturalExponential = P.exp = function () {\r\n    return naturalExponential(this);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the natural logarithm of the value of this Decimal,\r\n   * rounded to `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   */\r\n  P.naturalLogarithm = P.ln = function () {\r\n    return naturalLogarithm(this);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal negated, i.e. as if multiplied by\r\n   * -1.\r\n   *\r\n   */\r\n  P.negated = P.neg = function () {\r\n    var x = new this.constructor(this);\r\n    x.s = -x.s;\r\n    return finalise(x);\r\n  };\r\n\r\n\r\n  /*\r\n   *  n + 0 = n\r\n   *  n + N = N\r\n   *  n + I = I\r\n   *  0 + n = n\r\n   *  0 + 0 = 0\r\n   *  0 + N = N\r\n   *  0 + I = I\r\n   *  N + n = N\r\n   *  N + 0 = N\r\n   *  N + N = N\r\n   *  N + I = N\r\n   *  I + n = I\r\n   *  I + 0 = I\r\n   *  I + N = N\r\n   *  I + I = I\r\n   *\r\n   * Return a new Decimal whose value is the value of this Decimal plus `y`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   */\r\n  P.plus = P.add = function (y) {\r\n    var carry, d, e, i, k, len, pr, rm, xd, yd,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    y = new Ctor(y);\r\n\r\n    // If either is not finite...\r\n    if (!x.d || !y.d) {\r\n\r\n      // Return NaN if either is NaN.\r\n      if (!x.s || !y.s) y = new Ctor(NaN);\r\n\r\n      // Return x if y is finite and x is ±Infinity.\r\n      // Return x if both are ±Infinity with the same sign.\r\n      // Return NaN if both are ±Infinity with different signs.\r\n      // Return y if x is finite and y is ±Infinity.\r\n      else if (!x.d) y = new Ctor(y.d || x.s === y.s ? x : NaN);\r\n\r\n      return y;\r\n    }\r\n\r\n     // If signs differ...\r\n    if (x.s != y.s) {\r\n      y.s = -y.s;\r\n      return x.minus(y);\r\n    }\r\n\r\n    xd = x.d;\r\n    yd = y.d;\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n\r\n    // If either is zero...\r\n    if (!xd[0] || !yd[0]) {\r\n\r\n      // Return x if y is zero.\r\n      // Return y if y is non-zero.\r\n      if (!yd[0]) y = new Ctor(x);\r\n\r\n      return external ? finalise(y, pr, rm) : y;\r\n    }\r\n\r\n    // x and y are finite, non-zero numbers with the same sign.\r\n\r\n    // Calculate base 1e7 exponents.\r\n    k = mathfloor(x.e / LOG_BASE);\r\n    e = mathfloor(y.e / LOG_BASE);\r\n\r\n    xd = xd.slice();\r\n    i = k - e;\r\n\r\n    // If base 1e7 exponents differ...\r\n    if (i) {\r\n\r\n      if (i < 0) {\r\n        d = xd;\r\n        i = -i;\r\n        len = yd.length;\r\n      } else {\r\n        d = yd;\r\n        e = k;\r\n        len = xd.length;\r\n      }\r\n\r\n      // Limit number of zeros prepended to max(ceil(pr / LOG_BASE), len) + 1.\r\n      k = Math.ceil(pr / LOG_BASE);\r\n      len = k > len ? k + 1 : len + 1;\r\n\r\n      if (i > len) {\r\n        i = len;\r\n        d.length = 1;\r\n      }\r\n\r\n      // Prepend zeros to equalise exponents. Note: Faster to use reverse then do unshifts.\r\n      d.reverse();\r\n      for (; i--;) d.push(0);\r\n      d.reverse();\r\n    }\r\n\r\n    len = xd.length;\r\n    i = yd.length;\r\n\r\n    // If yd is longer than xd, swap xd and yd so xd points to the longer array.\r\n    if (len - i < 0) {\r\n      i = len;\r\n      d = yd;\r\n      yd = xd;\r\n      xd = d;\r\n    }\r\n\r\n    // Only start adding at yd.length - 1 as the further digits of xd can be left as they are.\r\n    for (carry = 0; i;) {\r\n      carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;\r\n      xd[i] %= BASE;\r\n    }\r\n\r\n    if (carry) {\r\n      xd.unshift(carry);\r\n      ++e;\r\n    }\r\n\r\n    // Remove trailing zeros.\r\n    // No need to check for zero, as +x + +y != 0 && -x + -y != 0\r\n    for (len = xd.length; xd[--len] == 0;) xd.pop();\r\n\r\n    y.d = xd;\r\n    y.e = getBase10Exponent(xd, e);\r\n\r\n    return external ? finalise(y, pr, rm) : y;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return the number of significant digits of the value of this Decimal.\r\n   *\r\n   * [z] {boolean|number} Whether to count integer-part trailing zeros: true, false, 1 or 0.\r\n   *\r\n   */\r\n  P.precision = P.sd = function (z) {\r\n    var k,\r\n      x = this;\r\n\r\n    if (z !== void 0 && z !== !!z && z !== 1 && z !== 0) throw Error(invalidArgument + z);\r\n\r\n    if (x.d) {\r\n      k = getPrecision(x.d);\r\n      if (z && x.e + 1 > k) k = x.e + 1;\r\n    } else {\r\n      k = NaN;\r\n    }\r\n\r\n    return k;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal rounded to a whole number using\r\n   * rounding mode `rounding`.\r\n   *\r\n   */\r\n  P.round = function () {\r\n    var x = this,\r\n      Ctor = x.constructor;\r\n\r\n    return finalise(new Ctor(x), x.e + 1, Ctor.rounding);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the sine of the value in radians of this Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-1, 1]\r\n   *\r\n   * sin(x) = x - x^3/3! + x^5/5! - ...\r\n   *\r\n   * sin(0)         = 0\r\n   * sin(-0)        = -0\r\n   * sin(Infinity)  = NaN\r\n   * sin(-Infinity) = NaN\r\n   * sin(NaN)       = NaN\r\n   *\r\n   */\r\n  P.sine = P.sin = function () {\r\n    var pr, rm,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (!x.isFinite()) return new Ctor(NaN);\r\n    if (x.isZero()) return new Ctor(x);\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n    Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;\r\n    Ctor.rounding = 1;\r\n\r\n    x = sine(Ctor, toLessThanHalfPi(Ctor, x));\r\n\r\n    Ctor.precision = pr;\r\n    Ctor.rounding = rm;\r\n\r\n    return finalise(quadrant > 2 ? x.neg() : x, pr, rm, true);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the square root of this Decimal, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   *  sqrt(-n) =  N\r\n   *  sqrt(N)  =  N\r\n   *  sqrt(-I) =  N\r\n   *  sqrt(I)  =  I\r\n   *  sqrt(0)  =  0\r\n   *  sqrt(-0) = -0\r\n   *\r\n   */\r\n  P.squareRoot = P.sqrt = function () {\r\n    var m, n, sd, r, rep, t,\r\n      x = this,\r\n      d = x.d,\r\n      e = x.e,\r\n      s = x.s,\r\n      Ctor = x.constructor;\r\n\r\n    // Negative/NaN/Infinity/zero?\r\n    if (s !== 1 || !d || !d[0]) {\r\n      return new Ctor(!s || s < 0 && (!d || d[0]) ? NaN : d ? x : 1 / 0);\r\n    }\r\n\r\n    external = false;\r\n\r\n    // Initial estimate.\r\n    s = Math.sqrt(+x);\r\n\r\n    // Math.sqrt underflow/overflow?\r\n    // Pass x to Math.sqrt as integer, then adjust the exponent of the result.\r\n    if (s == 0 || s == 1 / 0) {\r\n      n = digitsToString(d);\r\n\r\n      if ((n.length + e) % 2 == 0) n += '0';\r\n      s = Math.sqrt(n);\r\n      e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);\r\n\r\n      if (s == 1 / 0) {\r\n        n = '5e' + e;\r\n      } else {\r\n        n = s.toExponential();\r\n        n = n.slice(0, n.indexOf('e') + 1) + e;\r\n      }\r\n\r\n      r = new Ctor(n);\r\n    } else {\r\n      r = new Ctor(s.toString());\r\n    }\r\n\r\n    sd = (e = Ctor.precision) + 3;\r\n\r\n    // Newton-Raphson iteration.\r\n    for (;;) {\r\n      t = r;\r\n      r = t.plus(divide(x, t, sd + 2, 1)).times(0.5);\r\n\r\n      // TODO? Replace with for-loop and checkRoundingDigits.\r\n      if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {\r\n        n = n.slice(sd - 3, sd + 1);\r\n\r\n        // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or\r\n        // 4999, i.e. approaching a rounding boundary, continue the iteration.\r\n        if (n == '9999' || !rep && n == '4999') {\r\n\r\n          // On the first iteration only, check to see if rounding up gives the exact result as the\r\n          // nines may infinitely repeat.\r\n          if (!rep) {\r\n            finalise(t, e + 1, 0);\r\n\r\n            if (t.times(t).eq(x)) {\r\n              r = t;\r\n              break;\r\n            }\r\n          }\r\n\r\n          sd += 4;\r\n          rep = 1;\r\n        } else {\r\n\r\n          // If the rounding digits are null, 0{0,4} or 50{0,3}, check for an exact result.\r\n          // If not, then there are further digits and m will be truthy.\r\n          if (!+n || !+n.slice(1) && n.charAt(0) == '5') {\r\n\r\n            // Truncate to the first rounding digit.\r\n            finalise(r, e + 1, 1);\r\n            m = !r.times(r).eq(x);\r\n          }\r\n\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    external = true;\r\n\r\n    return finalise(r, e, Ctor.rounding, m);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the tangent of the value in radians of this Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-Infinity, Infinity]\r\n   *\r\n   * tan(0)         = 0\r\n   * tan(-0)        = -0\r\n   * tan(Infinity)  = NaN\r\n   * tan(-Infinity) = NaN\r\n   * tan(NaN)       = NaN\r\n   *\r\n   */\r\n  P.tangent = P.tan = function () {\r\n    var pr, rm,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (!x.isFinite()) return new Ctor(NaN);\r\n    if (x.isZero()) return new Ctor(x);\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n    Ctor.precision = pr + 10;\r\n    Ctor.rounding = 1;\r\n\r\n    x = x.sin();\r\n    x.s = 1;\r\n    x = divide(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);\r\n\r\n    Ctor.precision = pr;\r\n    Ctor.rounding = rm;\r\n\r\n    return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);\r\n  };\r\n\r\n\r\n  /*\r\n   *  n * 0 = 0\r\n   *  n * N = N\r\n   *  n * I = I\r\n   *  0 * n = 0\r\n   *  0 * 0 = 0\r\n   *  0 * N = N\r\n   *  0 * I = N\r\n   *  N * n = N\r\n   *  N * 0 = N\r\n   *  N * N = N\r\n   *  N * I = N\r\n   *  I * n = I\r\n   *  I * 0 = N\r\n   *  I * N = N\r\n   *  I * I = I\r\n   *\r\n   * Return a new Decimal whose value is this Decimal times `y`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   */\r\n  P.times = P.mul = function (y) {\r\n    var carry, e, i, k, r, rL, t, xdL, ydL,\r\n      x = this,\r\n      Ctor = x.constructor,\r\n      xd = x.d,\r\n      yd = (y = new Ctor(y)).d;\r\n\r\n    y.s *= x.s;\r\n\r\n     // If either is NaN, ±Infinity or ±0...\r\n    if (!xd || !xd[0] || !yd || !yd[0]) {\r\n\r\n      return new Ctor(!y.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd\r\n\r\n        // Return NaN if either is NaN.\r\n        // Return NaN if x is ±0 and y is ±Infinity, or y is ±0 and x is ±Infinity.\r\n        ? NaN\r\n\r\n        // Return ±Infinity if either is ±Infinity.\r\n        // Return ±0 if either is ±0.\r\n        : !xd || !yd ? y.s / 0 : y.s * 0);\r\n    }\r\n\r\n    e = mathfloor(x.e / LOG_BASE) + mathfloor(y.e / LOG_BASE);\r\n    xdL = xd.length;\r\n    ydL = yd.length;\r\n\r\n    // Ensure xd points to the longer array.\r\n    if (xdL < ydL) {\r\n      r = xd;\r\n      xd = yd;\r\n      yd = r;\r\n      rL = xdL;\r\n      xdL = ydL;\r\n      ydL = rL;\r\n    }\r\n\r\n    // Initialise the result array with zeros.\r\n    r = [];\r\n    rL = xdL + ydL;\r\n    for (i = rL; i--;) r.push(0);\r\n\r\n    // Multiply!\r\n    for (i = ydL; --i >= 0;) {\r\n      carry = 0;\r\n      for (k = xdL + i; k > i;) {\r\n        t = r[k] + yd[i] * xd[k - i - 1] + carry;\r\n        r[k--] = t % BASE | 0;\r\n        carry = t / BASE | 0;\r\n      }\r\n\r\n      r[k] = (r[k] + carry) % BASE | 0;\r\n    }\r\n\r\n    // Remove trailing zeros.\r\n    for (; !r[--rL];) r.pop();\r\n\r\n    if (carry) ++e;\r\n    else r.shift();\r\n\r\n    y.d = r;\r\n    y.e = getBase10Exponent(r, e);\r\n\r\n    return external ? finalise(y, Ctor.precision, Ctor.rounding) : y;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Decimal in base 2, round to `sd` significant\r\n   * digits using rounding mode `rm`.\r\n   *\r\n   * If the optional `sd` argument is present then return binary exponential notation.\r\n   *\r\n   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   */\r\n  P.toBinary = function (sd, rm) {\r\n    return toStringBinary(this, 2, sd, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `dp`\r\n   * decimal places using rounding mode `rm` or `rounding` if `rm` is omitted.\r\n   *\r\n   * If `dp` is omitted, return a new Decimal whose value is the value of this Decimal.\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   */\r\n  P.toDecimalPlaces = P.toDP = function (dp, rm) {\r\n    var x = this,\r\n      Ctor = x.constructor;\r\n\r\n    x = new Ctor(x);\r\n    if (dp === void 0) return x;\r\n\r\n    checkInt32(dp, 0, MAX_DIGITS);\r\n\r\n    if (rm === void 0) rm = Ctor.rounding;\r\n    else checkInt32(rm, 0, 8);\r\n\r\n    return finalise(x, dp + x.e + 1, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Decimal in exponential notation rounded to\r\n   * `dp` fixed decimal places using rounding mode `rounding`.\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   */\r\n  P.toExponential = function (dp, rm) {\r\n    var str,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (dp === void 0) {\r\n      str = finiteToString(x, true);\r\n    } else {\r\n      checkInt32(dp, 0, MAX_DIGITS);\r\n\r\n      if (rm === void 0) rm = Ctor.rounding;\r\n      else checkInt32(rm, 0, 8);\r\n\r\n      x = finalise(new Ctor(x), dp + 1, rm);\r\n      str = finiteToString(x, true, dp + 1);\r\n    }\r\n\r\n    return x.isNeg() && !x.isZero() ? '-' + str : str;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Decimal in normal (fixed-point) notation to\r\n   * `dp` fixed decimal places and rounded using rounding mode `rm` or `rounding` if `rm` is\r\n   * omitted.\r\n   *\r\n   * As with JavaScript numbers, (-0).toFixed(0) is '0', but e.g. (-0.00001).toFixed(0) is '-0'.\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * (-0).toFixed(0) is '0', but (-0.1).toFixed(0) is '-0'.\r\n   * (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.\r\n   * (-0).toFixed(3) is '0.000'.\r\n   * (-0.5).toFixed(0) is '-0'.\r\n   *\r\n   */\r\n  P.toFixed = function (dp, rm) {\r\n    var str, y,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (dp === void 0) {\r\n      str = finiteToString(x);\r\n    } else {\r\n      checkInt32(dp, 0, MAX_DIGITS);\r\n\r\n      if (rm === void 0) rm = Ctor.rounding;\r\n      else checkInt32(rm, 0, 8);\r\n\r\n      y = finalise(new Ctor(x), dp + x.e + 1, rm);\r\n      str = finiteToString(y, false, dp + y.e + 1);\r\n    }\r\n\r\n    // To determine whether to add the minus sign look at the value before it was rounded,\r\n    // i.e. look at `x` rather than `y`.\r\n    return x.isNeg() && !x.isZero() ? '-' + str : str;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return an array representing the value of this Decimal as a simple fraction with an integer\r\n   * numerator and an integer denominator.\r\n   *\r\n   * The denominator will be a positive non-zero value less than or equal to the specified maximum\r\n   * denominator. If a maximum denominator is not specified, the denominator will be the lowest\r\n   * value necessary to represent the number exactly.\r\n   *\r\n   * [maxD] {number|string|Decimal} Maximum denominator. Integer >= 1 and < Infinity.\r\n   *\r\n   */\r\n  P.toFraction = function (maxD) {\r\n    var d, d0, d1, d2, e, k, n, n0, n1, pr, q, r,\r\n      x = this,\r\n      xd = x.d,\r\n      Ctor = x.constructor;\r\n\r\n    if (!xd) return new Ctor(x);\r\n\r\n    n1 = d0 = new Ctor(1);\r\n    d1 = n0 = new Ctor(0);\r\n\r\n    d = new Ctor(d1);\r\n    e = d.e = getPrecision(xd) - x.e - 1;\r\n    k = e % LOG_BASE;\r\n    d.d[0] = mathpow(10, k < 0 ? LOG_BASE + k : k);\r\n\r\n    if (maxD == null) {\r\n\r\n      // d is 10**e, the minimum max-denominator needed.\r\n      maxD = e > 0 ? d : n1;\r\n    } else {\r\n      n = new Ctor(maxD);\r\n      if (!n.isInt() || n.lt(n1)) throw Error(invalidArgument + n);\r\n      maxD = n.gt(d) ? (e > 0 ? d : n1) : n;\r\n    }\r\n\r\n    external = false;\r\n    n = new Ctor(digitsToString(xd));\r\n    pr = Ctor.precision;\r\n    Ctor.precision = e = xd.length * LOG_BASE * 2;\r\n\r\n    for (;;)  {\r\n      q = divide(n, d, 0, 1, 1);\r\n      d2 = d0.plus(q.times(d1));\r\n      if (d2.cmp(maxD) == 1) break;\r\n      d0 = d1;\r\n      d1 = d2;\r\n      d2 = n1;\r\n      n1 = n0.plus(q.times(d2));\r\n      n0 = d2;\r\n      d2 = d;\r\n      d = n.minus(q.times(d2));\r\n      n = d2;\r\n    }\r\n\r\n    d2 = divide(maxD.minus(d0), d1, 0, 1, 1);\r\n    n0 = n0.plus(d2.times(n1));\r\n    d0 = d0.plus(d2.times(d1));\r\n    n0.s = n1.s = x.s;\r\n\r\n    // Determine which fraction is closer to x, n0/d0 or n1/d1?\r\n    r = divide(n1, d1, e, 1).minus(x).abs().cmp(divide(n0, d0, e, 1).minus(x).abs()) < 1\r\n        ? [n1, d1] : [n0, d0];\r\n\r\n    Ctor.precision = pr;\r\n    external = true;\r\n\r\n    return r;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Decimal in base 16, round to `sd` significant\r\n   * digits using rounding mode `rm`.\r\n   *\r\n   * If the optional `sd` argument is present then return binary exponential notation.\r\n   *\r\n   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   */\r\n  P.toHexadecimal = P.toHex = function (sd, rm) {\r\n    return toStringBinary(this, 16, sd, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Returns a new Decimal whose value is the nearest multiple of `y` in the direction of rounding\r\n   * mode `rm`, or `Decimal.rounding` if `rm` is omitted, to the value of this Decimal.\r\n   *\r\n   * The return value will always have the same sign as this Decimal, unless either this Decimal\r\n   * or `y` is NaN, in which case the return value will be also be NaN.\r\n   *\r\n   * The return value is not affected by the value of `precision`.\r\n   *\r\n   * y {number|string|Decimal} The magnitude to round to a multiple of.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * 'toNearest() rounding mode not an integer: {rm}'\r\n   * 'toNearest() rounding mode out of range: {rm}'\r\n   *\r\n   */\r\n  P.toNearest = function (y, rm) {\r\n    var x = this,\r\n      Ctor = x.constructor;\r\n\r\n    x = new Ctor(x);\r\n\r\n    if (y == null) {\r\n\r\n      // If x is not finite, return x.\r\n      if (!x.d) return x;\r\n\r\n      y = new Ctor(1);\r\n      rm = Ctor.rounding;\r\n    } else {\r\n      y = new Ctor(y);\r\n      if (rm === void 0) {\r\n        rm = Ctor.rounding;\r\n      } else {\r\n        checkInt32(rm, 0, 8);\r\n      }\r\n\r\n      // If x is not finite, return x if y is not NaN, else NaN.\r\n      if (!x.d) return y.s ? x : y;\r\n\r\n      // If y is not finite, return Infinity with the sign of x if y is Infinity, else NaN.\r\n      if (!y.d) {\r\n        if (y.s) y.s = x.s;\r\n        return y;\r\n      }\r\n    }\r\n\r\n    // If y is not zero, calculate the nearest multiple of y to x.\r\n    if (y.d[0]) {\r\n      external = false;\r\n      x = divide(x, y, 0, rm, 1).times(y);\r\n      external = true;\r\n      finalise(x);\r\n\r\n    // If y is zero, return zero with the sign of x.\r\n    } else {\r\n      y.s = x.s;\r\n      x = y;\r\n    }\r\n\r\n    return x;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return the value of this Decimal converted to a number primitive.\r\n   * Zero keeps its sign.\r\n   *\r\n   */\r\n  P.toNumber = function () {\r\n    return +this;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Decimal in base 8, round to `sd` significant\r\n   * digits using rounding mode `rm`.\r\n   *\r\n   * If the optional `sd` argument is present then return binary exponential notation.\r\n   *\r\n   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   */\r\n  P.toOctal = function (sd, rm) {\r\n    return toStringBinary(this, 8, sd, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal raised to the power `y`, rounded\r\n   * to `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * ECMAScript compliant.\r\n   *\r\n   *   pow(x, NaN)                           = NaN\r\n   *   pow(x, ±0)                            = 1\r\n\r\n   *   pow(NaN, non-zero)                    = NaN\r\n   *   pow(abs(x) > 1, +Infinity)            = +Infinity\r\n   *   pow(abs(x) > 1, -Infinity)            = +0\r\n   *   pow(abs(x) == 1, ±Infinity)           = NaN\r\n   *   pow(abs(x) < 1, +Infinity)            = +0\r\n   *   pow(abs(x) < 1, -Infinity)            = +Infinity\r\n   *   pow(+Infinity, y > 0)                 = +Infinity\r\n   *   pow(+Infinity, y < 0)                 = +0\r\n   *   pow(-Infinity, odd integer > 0)       = -Infinity\r\n   *   pow(-Infinity, even integer > 0)      = +Infinity\r\n   *   pow(-Infinity, odd integer < 0)       = -0\r\n   *   pow(-Infinity, even integer < 0)      = +0\r\n   *   pow(+0, y > 0)                        = +0\r\n   *   pow(+0, y < 0)                        = +Infinity\r\n   *   pow(-0, odd integer > 0)              = -0\r\n   *   pow(-0, even integer > 0)             = +0\r\n   *   pow(-0, odd integer < 0)              = -Infinity\r\n   *   pow(-0, even integer < 0)             = +Infinity\r\n   *   pow(finite x < 0, finite non-integer) = NaN\r\n   *\r\n   * For non-integer or very large exponents pow(x, y) is calculated using\r\n   *\r\n   *   x^y = exp(y*ln(x))\r\n   *\r\n   * Assuming the first 15 rounding digits are each equally likely to be any digit 0-9, the\r\n   * probability of an incorrectly rounded result\r\n   * P([49]9{14} | [50]0{14}) = 2 * 0.2 * 10^-14 = 4e-15 = 1/2.5e+14\r\n   * i.e. 1 in 250,000,000,000,000\r\n   *\r\n   * If a result is incorrectly rounded the maximum error will be 1 ulp (unit in last place).\r\n   *\r\n   * y {number|string|Decimal} The power to which to raise this Decimal.\r\n   *\r\n   */\r\n  P.toPower = P.pow = function (y) {\r\n    var e, k, pr, r, rm, s,\r\n      x = this,\r\n      Ctor = x.constructor,\r\n      yn = +(y = new Ctor(y));\r\n\r\n    // Either ±Infinity, NaN or ±0?\r\n    if (!x.d || !y.d || !x.d[0] || !y.d[0]) return new Ctor(mathpow(+x, yn));\r\n\r\n    x = new Ctor(x);\r\n\r\n    if (x.eq(1)) return x;\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n\r\n    if (y.eq(1)) return finalise(x, pr, rm);\r\n\r\n    // y exponent\r\n    e = mathfloor(y.e / LOG_BASE);\r\n\r\n    // If y is a small integer use the 'exponentiation by squaring' algorithm.\r\n    if (e >= y.d.length - 1 && (k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {\r\n      r = intPow(Ctor, x, k, pr);\r\n      return y.s < 0 ? new Ctor(1).div(r) : finalise(r, pr, rm);\r\n    }\r\n\r\n    s = x.s;\r\n\r\n    // if x is negative\r\n    if (s < 0) {\r\n\r\n      // if y is not an integer\r\n      if (e < y.d.length - 1) return new Ctor(NaN);\r\n\r\n      // Result is positive if x is negative and the last digit of integer y is even.\r\n      if ((y.d[e] & 1) == 0) s = 1;\r\n\r\n      // if x.eq(-1)\r\n      if (x.e == 0 && x.d[0] == 1 && x.d.length == 1) {\r\n        x.s = s;\r\n        return x;\r\n      }\r\n    }\r\n\r\n    // Estimate result exponent.\r\n    // x^y = 10^e,  where e = y * log10(x)\r\n    // log10(x) = log10(x_significand) + x_exponent\r\n    // log10(x_significand) = ln(x_significand) / ln(10)\r\n    k = mathpow(+x, yn);\r\n    e = k == 0 || !isFinite(k)\r\n      ? mathfloor(yn * (Math.log('0.' + digitsToString(x.d)) / Math.LN10 + x.e + 1))\r\n      : new Ctor(k + '').e;\r\n\r\n    // Exponent estimate may be incorrect e.g. x: 0.999999999999999999, y: 2.29, e: 0, r.e: -1.\r\n\r\n    // Overflow/underflow?\r\n    if (e > Ctor.maxE + 1 || e < Ctor.minE - 1) return new Ctor(e > 0 ? s / 0 : 0);\r\n\r\n    external = false;\r\n    Ctor.rounding = x.s = 1;\r\n\r\n    // Estimate the extra guard digits needed to ensure five correct rounding digits from\r\n    // naturalLogarithm(x). Example of failure without these extra digits (precision: 10):\r\n    // new Decimal(2.32456).pow('2087987436534566.46411')\r\n    // should be 1.162377823e+764914905173815, but is 1.162355823e+764914905173815\r\n    k = Math.min(12, (e + '').length);\r\n\r\n    // r = x^y = exp(y*ln(x))\r\n    r = naturalExponential(y.times(naturalLogarithm(x, pr + k)), pr);\r\n\r\n    // r may be Infinity, e.g. (0.9999999999999999).pow(-1e+40)\r\n    if (r.d) {\r\n\r\n      // Truncate to the required precision plus five rounding digits.\r\n      r = finalise(r, pr + 5, 1);\r\n\r\n      // If the rounding digits are [49]9999 or [50]0000 increase the precision by 10 and recalculate\r\n      // the result.\r\n      if (checkRoundingDigits(r.d, pr, rm)) {\r\n        e = pr + 10;\r\n\r\n        // Truncate to the increased precision plus five rounding digits.\r\n        r = finalise(naturalExponential(y.times(naturalLogarithm(x, e + k)), e), e + 5, 1);\r\n\r\n        // Check for 14 nines from the 2nd rounding digit (the first rounding digit may be 4 or 9).\r\n        if (+digitsToString(r.d).slice(pr + 1, pr + 15) + 1 == 1e14) {\r\n          r = finalise(r, pr + 1, 0);\r\n        }\r\n      }\r\n    }\r\n\r\n    r.s = s;\r\n    external = true;\r\n    Ctor.rounding = rm;\r\n\r\n    return finalise(r, pr, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Decimal rounded to `sd` significant digits\r\n   * using rounding mode `rounding`.\r\n   *\r\n   * Return exponential notation if `sd` is less than the number of digits necessary to represent\r\n   * the integer part of the value in normal notation.\r\n   *\r\n   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   */\r\n  P.toPrecision = function (sd, rm) {\r\n    var str,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (sd === void 0) {\r\n      str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);\r\n    } else {\r\n      checkInt32(sd, 1, MAX_DIGITS);\r\n\r\n      if (rm === void 0) rm = Ctor.rounding;\r\n      else checkInt32(rm, 0, 8);\r\n\r\n      x = finalise(new Ctor(x), sd, rm);\r\n      str = finiteToString(x, sd <= x.e || x.e <= Ctor.toExpNeg, sd);\r\n    }\r\n\r\n    return x.isNeg() && !x.isZero() ? '-' + str : str;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `sd`\r\n   * significant digits using rounding mode `rm`, or to `precision` and `rounding` respectively if\r\n   * omitted.\r\n   *\r\n   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * 'toSD() digits out of range: {sd}'\r\n   * 'toSD() digits not an integer: {sd}'\r\n   * 'toSD() rounding mode not an integer: {rm}'\r\n   * 'toSD() rounding mode out of range: {rm}'\r\n   *\r\n   */\r\n  P.toSignificantDigits = P.toSD = function (sd, rm) {\r\n    var x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (sd === void 0) {\r\n      sd = Ctor.precision;\r\n      rm = Ctor.rounding;\r\n    } else {\r\n      checkInt32(sd, 1, MAX_DIGITS);\r\n\r\n      if (rm === void 0) rm = Ctor.rounding;\r\n      else checkInt32(rm, 0, 8);\r\n    }\r\n\r\n    return finalise(new Ctor(x), sd, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Decimal.\r\n   *\r\n   * Return exponential notation if this Decimal has a positive exponent equal to or greater than\r\n   * `toExpPos`, or a negative exponent equal to or less than `toExpNeg`.\r\n   *\r\n   */\r\n  P.toString = function () {\r\n    var x = this,\r\n      Ctor = x.constructor,\r\n      str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);\r\n\r\n    return x.isNeg() && !x.isZero() ? '-' + str : str;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal truncated to a whole number.\r\n   *\r\n   */\r\n  P.truncated = P.trunc = function () {\r\n    return finalise(new this.constructor(this), this.e + 1, 1);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Decimal.\r\n   * Unlike `toString`, negative zero will include the minus sign.\r\n   *\r\n   */\r\n  P.valueOf = P.toJSON = function () {\r\n    var x = this,\r\n      Ctor = x.constructor,\r\n      str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);\r\n\r\n    return x.isNeg() ? '-' + str : str;\r\n  };\r\n\r\n\r\n  // Helper functions for Decimal.prototype (P) and/or Decimal methods, and their callers.\r\n\r\n\r\n  /*\r\n   *  digitsToString           P.cubeRoot, P.logarithm, P.squareRoot, P.toFraction, P.toPower,\r\n   *                           finiteToString, naturalExponential, naturalLogarithm\r\n   *  checkInt32               P.toDecimalPlaces, P.toExponential, P.toFixed, P.toNearest,\r\n   *                           P.toPrecision, P.toSignificantDigits, toStringBinary, random\r\n   *  checkRoundingDigits      P.logarithm, P.toPower, naturalExponential, naturalLogarithm\r\n   *  convertBase              toStringBinary, parseOther\r\n   *  cos                      P.cos\r\n   *  divide                   P.atanh, P.cubeRoot, P.dividedBy, P.dividedToIntegerBy,\r\n   *                           P.logarithm, P.modulo, P.squareRoot, P.tan, P.tanh, P.toFraction,\r\n   *                           P.toNearest, toStringBinary, naturalExponential, naturalLogarithm,\r\n   *                           taylorSeries, atan2, parseOther\r\n   *  finalise                 P.absoluteValue, P.atan, P.atanh, P.ceil, P.cos, P.cosh,\r\n   *                           P.cubeRoot, P.dividedToIntegerBy, P.floor, P.logarithm, P.minus,\r\n   *                           P.modulo, P.negated, P.plus, P.round, P.sin, P.sinh, P.squareRoot,\r\n   *                           P.tan, P.times, P.toDecimalPlaces, P.toExponential, P.toFixed,\r\n   *                           P.toNearest, P.toPower, P.toPrecision, P.toSignificantDigits,\r\n   *                           P.truncated, divide, getLn10, getPi, naturalExponential,\r\n   *                           naturalLogarithm, ceil, floor, round, trunc\r\n   *  finiteToString           P.toExponential, P.toFixed, P.toPrecision, P.toString, P.valueOf,\r\n   *                           toStringBinary\r\n   *  getBase10Exponent        P.minus, P.plus, P.times, parseOther\r\n   *  getLn10                  P.logarithm, naturalLogarithm\r\n   *  getPi                    P.acos, P.asin, P.atan, toLessThanHalfPi, atan2\r\n   *  getPrecision             P.precision, P.toFraction\r\n   *  getZeroString            digitsToString, finiteToString\r\n   *  intPow                   P.toPower, parseOther\r\n   *  isOdd                    toLessThanHalfPi\r\n   *  maxOrMin                 max, min\r\n   *  naturalExponential       P.naturalExponential, P.toPower\r\n   *  naturalLogarithm         P.acosh, P.asinh, P.atanh, P.logarithm, P.naturalLogarithm,\r\n   *                           P.toPower, naturalExponential\r\n   *  nonFiniteToString        finiteToString, toStringBinary\r\n   *  parseDecimal             Decimal\r\n   *  parseOther               Decimal\r\n   *  sin                      P.sin\r\n   *  taylorSeries             P.cosh, P.sinh, cos, sin\r\n   *  toLessThanHalfPi         P.cos, P.sin\r\n   *  toStringBinary           P.toBinary, P.toHexadecimal, P.toOctal\r\n   *  truncate                 intPow\r\n   *\r\n   *  Throws:                  P.logarithm, P.precision, P.toFraction, checkInt32, getLn10, getPi,\r\n   *                           naturalLogarithm, config, parseOther, random, Decimal\r\n   */\r\n\r\n\r\n  function digitsToString(d) {\r\n    var i, k, ws,\r\n      indexOfLastWord = d.length - 1,\r\n      str = '',\r\n      w = d[0];\r\n\r\n    if (indexOfLastWord > 0) {\r\n      str += w;\r\n      for (i = 1; i < indexOfLastWord; i++) {\r\n        ws = d[i] + '';\r\n        k = LOG_BASE - ws.length;\r\n        if (k) str += getZeroString(k);\r\n        str += ws;\r\n      }\r\n\r\n      w = d[i];\r\n      ws = w + '';\r\n      k = LOG_BASE - ws.length;\r\n      if (k) str += getZeroString(k);\r\n    } else if (w === 0) {\r\n      return '0';\r\n    }\r\n\r\n    // Remove trailing zeros of last w.\r\n    for (; w % 10 === 0;) w /= 10;\r\n\r\n    return str + w;\r\n  }\r\n\r\n\r\n  function checkInt32(i, min, max) {\r\n    if (i !== ~~i || i < min || i > max) {\r\n      throw Error(invalidArgument + i);\r\n    }\r\n  }\r\n\r\n\r\n  /*\r\n   * Check 5 rounding digits if `repeating` is null, 4 otherwise.\r\n   * `repeating == null` if caller is `log` or `pow`,\r\n   * `repeating != null` if caller is `naturalLogarithm` or `naturalExponential`.\r\n   */\r\n  function checkRoundingDigits(d, i, rm, repeating) {\r\n    var di, k, r, rd;\r\n\r\n    // Get the length of the first word of the array d.\r\n    for (k = d[0]; k >= 10; k /= 10) --i;\r\n\r\n    // Is the rounding digit in the first word of d?\r\n    if (--i < 0) {\r\n      i += LOG_BASE;\r\n      di = 0;\r\n    } else {\r\n      di = Math.ceil((i + 1) / LOG_BASE);\r\n      i %= LOG_BASE;\r\n    }\r\n\r\n    // i is the index (0 - 6) of the rounding digit.\r\n    // E.g. if within the word 3487563 the first rounding digit is 5,\r\n    // then i = 4, k = 1000, rd = 3487563 % 1000 = 563\r\n    k = mathpow(10, LOG_BASE - i);\r\n    rd = d[di] % k | 0;\r\n\r\n    if (repeating == null) {\r\n      if (i < 3) {\r\n        if (i == 0) rd = rd / 100 | 0;\r\n        else if (i == 1) rd = rd / 10 | 0;\r\n        r = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 50000 || rd == 0;\r\n      } else {\r\n        r = (rm < 4 && rd + 1 == k || rm > 3 && rd + 1 == k / 2) &&\r\n          (d[di + 1] / k / 100 | 0) == mathpow(10, i - 2) - 1 ||\r\n            (rd == k / 2 || rd == 0) && (d[di + 1] / k / 100 | 0) == 0;\r\n      }\r\n    } else {\r\n      if (i < 4) {\r\n        if (i == 0) rd = rd / 1000 | 0;\r\n        else if (i == 1) rd = rd / 100 | 0;\r\n        else if (i == 2) rd = rd / 10 | 0;\r\n        r = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;\r\n      } else {\r\n        r = ((repeating || rm < 4) && rd + 1 == k ||\r\n        (!repeating && rm > 3) && rd + 1 == k / 2) &&\r\n          (d[di + 1] / k / 1000 | 0) == mathpow(10, i - 3) - 1;\r\n      }\r\n    }\r\n\r\n    return r;\r\n  }\r\n\r\n\r\n  // Convert string of `baseIn` to an array of numbers of `baseOut`.\r\n  // Eg. convertBase('255', 10, 16) returns [15, 15].\r\n  // Eg. convertBase('ff', 16, 10) returns [2, 5, 5].\r\n  function convertBase(str, baseIn, baseOut) {\r\n    var j,\r\n      arr = [0],\r\n      arrL,\r\n      i = 0,\r\n      strL = str.length;\r\n\r\n    for (; i < strL;) {\r\n      for (arrL = arr.length; arrL--;) arr[arrL] *= baseIn;\r\n      arr[0] += NUMERALS.indexOf(str.charAt(i++));\r\n      for (j = 0; j < arr.length; j++) {\r\n        if (arr[j] > baseOut - 1) {\r\n          if (arr[j + 1] === void 0) arr[j + 1] = 0;\r\n          arr[j + 1] += arr[j] / baseOut | 0;\r\n          arr[j] %= baseOut;\r\n        }\r\n      }\r\n    }\r\n\r\n    return arr.reverse();\r\n  }\r\n\r\n\r\n  /*\r\n   * cos(x) = 1 - x^2/2! + x^4/4! - ...\r\n   * |x| < pi/2\r\n   *\r\n   */\r\n  function cosine(Ctor, x) {\r\n    var k, len, y;\r\n\r\n    if (x.isZero()) return x;\r\n\r\n    // Argument reduction: cos(4x) = 8*(cos^4(x) - cos^2(x)) + 1\r\n    // i.e. cos(x) = 8*(cos^4(x/4) - cos^2(x/4)) + 1\r\n\r\n    // Estimate the optimum number of times to use the argument reduction.\r\n    len = x.d.length;\r\n    if (len < 32) {\r\n      k = Math.ceil(len / 3);\r\n      y = (1 / tinyPow(4, k)).toString();\r\n    } else {\r\n      k = 16;\r\n      y = '2.3283064365386962890625e-10';\r\n    }\r\n\r\n    Ctor.precision += k;\r\n\r\n    x = taylorSeries(Ctor, 1, x.times(y), new Ctor(1));\r\n\r\n    // Reverse argument reduction\r\n    for (var i = k; i--;) {\r\n      var cos2x = x.times(x);\r\n      x = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);\r\n    }\r\n\r\n    Ctor.precision -= k;\r\n\r\n    return x;\r\n  }\r\n\r\n\r\n  /*\r\n   * Perform division in the specified base.\r\n   */\r\n  var divide = (function () {\r\n\r\n    // Assumes non-zero x and k, and hence non-zero result.\r\n    function multiplyInteger(x, k, base) {\r\n      var temp,\r\n        carry = 0,\r\n        i = x.length;\r\n\r\n      for (x = x.slice(); i--;) {\r\n        temp = x[i] * k + carry;\r\n        x[i] = temp % base | 0;\r\n        carry = temp / base | 0;\r\n      }\r\n\r\n      if (carry) x.unshift(carry);\r\n\r\n      return x;\r\n    }\r\n\r\n    function compare(a, b, aL, bL) {\r\n      var i, r;\r\n\r\n      if (aL != bL) {\r\n        r = aL > bL ? 1 : -1;\r\n      } else {\r\n        for (i = r = 0; i < aL; i++) {\r\n          if (a[i] != b[i]) {\r\n            r = a[i] > b[i] ? 1 : -1;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      return r;\r\n    }\r\n\r\n    function subtract(a, b, aL, base) {\r\n      var i = 0;\r\n\r\n      // Subtract b from a.\r\n      for (; aL--;) {\r\n        a[aL] -= i;\r\n        i = a[aL] < b[aL] ? 1 : 0;\r\n        a[aL] = i * base + a[aL] - b[aL];\r\n      }\r\n\r\n      // Remove leading zeros.\r\n      for (; !a[0] && a.length > 1;) a.shift();\r\n    }\r\n\r\n    return function (x, y, pr, rm, dp, base) {\r\n      var cmp, e, i, k, logBase, more, prod, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0,\r\n        yL, yz,\r\n        Ctor = x.constructor,\r\n        sign = x.s == y.s ? 1 : -1,\r\n        xd = x.d,\r\n        yd = y.d;\r\n\r\n      // Either NaN, Infinity or 0?\r\n      if (!xd || !xd[0] || !yd || !yd[0]) {\r\n\r\n        return new Ctor(// Return NaN if either NaN, or both Infinity or 0.\r\n          !x.s || !y.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN :\r\n\r\n          // Return ±0 if x is 0 or y is ±Infinity, or return ±Infinity as y is 0.\r\n          xd && xd[0] == 0 || !yd ? sign * 0 : sign / 0);\r\n      }\r\n\r\n      if (base) {\r\n        logBase = 1;\r\n        e = x.e - y.e;\r\n      } else {\r\n        base = BASE;\r\n        logBase = LOG_BASE;\r\n        e = mathfloor(x.e / logBase) - mathfloor(y.e / logBase);\r\n      }\r\n\r\n      yL = yd.length;\r\n      xL = xd.length;\r\n      q = new Ctor(sign);\r\n      qd = q.d = [];\r\n\r\n      // Result exponent may be one less than e.\r\n      // The digit array of a Decimal from toStringBinary may have trailing zeros.\r\n      for (i = 0; yd[i] == (xd[i] || 0); i++);\r\n\r\n      if (yd[i] > (xd[i] || 0)) e--;\r\n\r\n      if (pr == null) {\r\n        sd = pr = Ctor.precision;\r\n        rm = Ctor.rounding;\r\n      } else if (dp) {\r\n        sd = pr + (x.e - y.e) + 1;\r\n      } else {\r\n        sd = pr;\r\n      }\r\n\r\n      if (sd < 0) {\r\n        qd.push(1);\r\n        more = true;\r\n      } else {\r\n\r\n        // Convert precision in number of base 10 digits to base 1e7 digits.\r\n        sd = sd / logBase + 2 | 0;\r\n        i = 0;\r\n\r\n        // divisor < 1e7\r\n        if (yL == 1) {\r\n          k = 0;\r\n          yd = yd[0];\r\n          sd++;\r\n\r\n          // k is the carry.\r\n          for (; (i < xL || k) && sd--; i++) {\r\n            t = k * base + (xd[i] || 0);\r\n            qd[i] = t / yd | 0;\r\n            k = t % yd | 0;\r\n          }\r\n\r\n          more = k || i < xL;\r\n\r\n        // divisor >= 1e7\r\n        } else {\r\n\r\n          // Normalise xd and yd so highest order digit of yd is >= base/2\r\n          k = base / (yd[0] + 1) | 0;\r\n\r\n          if (k > 1) {\r\n            yd = multiplyInteger(yd, k, base);\r\n            xd = multiplyInteger(xd, k, base);\r\n            yL = yd.length;\r\n            xL = xd.length;\r\n          }\r\n\r\n          xi = yL;\r\n          rem = xd.slice(0, yL);\r\n          remL = rem.length;\r\n\r\n          // Add zeros to make remainder as long as divisor.\r\n          for (; remL < yL;) rem[remL++] = 0;\r\n\r\n          yz = yd.slice();\r\n          yz.unshift(0);\r\n          yd0 = yd[0];\r\n\r\n          if (yd[1] >= base / 2) ++yd0;\r\n\r\n          do {\r\n            k = 0;\r\n\r\n            // Compare divisor and remainder.\r\n            cmp = compare(yd, rem, yL, remL);\r\n\r\n            // If divisor < remainder.\r\n            if (cmp < 0) {\r\n\r\n              // Calculate trial digit, k.\r\n              rem0 = rem[0];\r\n              if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);\r\n\r\n              // k will be how many times the divisor goes into the current remainder.\r\n              k = rem0 / yd0 | 0;\r\n\r\n              //  Algorithm:\r\n              //  1. product = divisor * trial digit (k)\r\n              //  2. if product > remainder: product -= divisor, k--\r\n              //  3. remainder -= product\r\n              //  4. if product was < remainder at 2:\r\n              //    5. compare new remainder and divisor\r\n              //    6. If remainder > divisor: remainder -= divisor, k++\r\n\r\n              if (k > 1) {\r\n                if (k >= base) k = base - 1;\r\n\r\n                // product = divisor * trial digit.\r\n                prod = multiplyInteger(yd, k, base);\r\n                prodL = prod.length;\r\n                remL = rem.length;\r\n\r\n                // Compare product and remainder.\r\n                cmp = compare(prod, rem, prodL, remL);\r\n\r\n                // product > remainder.\r\n                if (cmp == 1) {\r\n                  k--;\r\n\r\n                  // Subtract divisor from product.\r\n                  subtract(prod, yL < prodL ? yz : yd, prodL, base);\r\n                }\r\n              } else {\r\n\r\n                // cmp is -1.\r\n                // If k is 0, there is no need to compare yd and rem again below, so change cmp to 1\r\n                // to avoid it. If k is 1 there is a need to compare yd and rem again below.\r\n                if (k == 0) cmp = k = 1;\r\n                prod = yd.slice();\r\n              }\r\n\r\n              prodL = prod.length;\r\n              if (prodL < remL) prod.unshift(0);\r\n\r\n              // Subtract product from remainder.\r\n              subtract(rem, prod, remL, base);\r\n\r\n              // If product was < previous remainder.\r\n              if (cmp == -1) {\r\n                remL = rem.length;\r\n\r\n                // Compare divisor and new remainder.\r\n                cmp = compare(yd, rem, yL, remL);\r\n\r\n                // If divisor < new remainder, subtract divisor from remainder.\r\n                if (cmp < 1) {\r\n                  k++;\r\n\r\n                  // Subtract divisor from remainder.\r\n                  subtract(rem, yL < remL ? yz : yd, remL, base);\r\n                }\r\n              }\r\n\r\n              remL = rem.length;\r\n            } else if (cmp === 0) {\r\n              k++;\r\n              rem = [0];\r\n            }    // if cmp === 1, k will be 0\r\n\r\n            // Add the next digit, k, to the result array.\r\n            qd[i++] = k;\r\n\r\n            // Update the remainder.\r\n            if (cmp && rem[0]) {\r\n              rem[remL++] = xd[xi] || 0;\r\n            } else {\r\n              rem = [xd[xi]];\r\n              remL = 1;\r\n            }\r\n\r\n          } while ((xi++ < xL || rem[0] !== void 0) && sd--);\r\n\r\n          more = rem[0] !== void 0;\r\n        }\r\n\r\n        // Leading zero?\r\n        if (!qd[0]) qd.shift();\r\n      }\r\n\r\n      // logBase is 1 when divide is being used for base conversion.\r\n      if (logBase == 1) {\r\n        q.e = e;\r\n        inexact = more;\r\n      } else {\r\n\r\n        // To calculate q.e, first get the number of digits of qd[0].\r\n        for (i = 1, k = qd[0]; k >= 10; k /= 10) i++;\r\n        q.e = i + e * logBase - 1;\r\n\r\n        finalise(q, dp ? pr + q.e + 1 : pr, rm, more);\r\n      }\r\n\r\n      return q;\r\n    };\r\n  })();\r\n\r\n\r\n  /*\r\n   * Round `x` to `sd` significant digits using rounding mode `rm`.\r\n   * Check for over/under-flow.\r\n   */\r\n   function finalise(x, sd, rm, isTruncated) {\r\n    var digits, i, j, k, rd, roundUp, w, xd, xdi,\r\n      Ctor = x.constructor;\r\n\r\n    // Don't round if sd is null or undefined.\r\n    out: if (sd != null) {\r\n      xd = x.d;\r\n\r\n      // Infinity/NaN.\r\n      if (!xd) return x;\r\n\r\n      // rd: the rounding digit, i.e. the digit after the digit that may be rounded up.\r\n      // w: the word of xd containing rd, a base 1e7 number.\r\n      // xdi: the index of w within xd.\r\n      // digits: the number of digits of w.\r\n      // i: what would be the index of rd within w if all the numbers were 7 digits long (i.e. if\r\n      // they had leading zeros)\r\n      // j: if > 0, the actual index of rd within w (if < 0, rd is a leading zero).\r\n\r\n      // Get the length of the first word of the digits array xd.\r\n      for (digits = 1, k = xd[0]; k >= 10; k /= 10) digits++;\r\n      i = sd - digits;\r\n\r\n      // Is the rounding digit in the first word of xd?\r\n      if (i < 0) {\r\n        i += LOG_BASE;\r\n        j = sd;\r\n        w = xd[xdi = 0];\r\n\r\n        // Get the rounding digit at index j of w.\r\n        rd = w / mathpow(10, digits - j - 1) % 10 | 0;\r\n      } else {\r\n        xdi = Math.ceil((i + 1) / LOG_BASE);\r\n        k = xd.length;\r\n        if (xdi >= k) {\r\n          if (isTruncated) {\r\n\r\n            // Needed by `naturalExponential`, `naturalLogarithm` and `squareRoot`.\r\n            for (; k++ <= xdi;) xd.push(0);\r\n            w = rd = 0;\r\n            digits = 1;\r\n            i %= LOG_BASE;\r\n            j = i - LOG_BASE + 1;\r\n          } else {\r\n            break out;\r\n          }\r\n        } else {\r\n          w = k = xd[xdi];\r\n\r\n          // Get the number of digits of w.\r\n          for (digits = 1; k >= 10; k /= 10) digits++;\r\n\r\n          // Get the index of rd within w.\r\n          i %= LOG_BASE;\r\n\r\n          // Get the index of rd within w, adjusted for leading zeros.\r\n          // The number of leading zeros of w is given by LOG_BASE - digits.\r\n          j = i - LOG_BASE + digits;\r\n\r\n          // Get the rounding digit at index j of w.\r\n          rd = j < 0 ? 0 : w / mathpow(10, digits - j - 1) % 10 | 0;\r\n        }\r\n      }\r\n\r\n      // Are there any non-zero digits after the rounding digit?\r\n      isTruncated = isTruncated || sd < 0 ||\r\n        xd[xdi + 1] !== void 0 || (j < 0 ? w : w % mathpow(10, digits - j - 1));\r\n\r\n      // The expression `w % mathpow(10, digits - j - 1)` returns all the digits of w to the right\r\n      // of the digit at (left-to-right) index j, e.g. if w is 908714 and j is 2, the expression\r\n      // will give 714.\r\n\r\n      roundUp = rm < 4\r\n        ? (rd || isTruncated) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))\r\n        : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 &&\r\n\r\n          // Check whether the digit to the left of the rounding digit is odd.\r\n          ((i > 0 ? j > 0 ? w / mathpow(10, digits - j) : 0 : xd[xdi - 1]) % 10) & 1 ||\r\n            rm == (x.s < 0 ? 8 : 7));\r\n\r\n      if (sd < 1 || !xd[0]) {\r\n        xd.length = 0;\r\n        if (roundUp) {\r\n\r\n          // Convert sd to decimal places.\r\n          sd -= x.e + 1;\r\n\r\n          // 1, 0.1, 0.01, 0.001, 0.0001 etc.\r\n          xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);\r\n          x.e = -sd || 0;\r\n        } else {\r\n\r\n          // Zero.\r\n          xd[0] = x.e = 0;\r\n        }\r\n\r\n        return x;\r\n      }\r\n\r\n      // Remove excess digits.\r\n      if (i == 0) {\r\n        xd.length = xdi;\r\n        k = 1;\r\n        xdi--;\r\n      } else {\r\n        xd.length = xdi + 1;\r\n        k = mathpow(10, LOG_BASE - i);\r\n\r\n        // E.g. 56700 becomes 56000 if 7 is the rounding digit.\r\n        // j > 0 means i > number of leading zeros of w.\r\n        xd[xdi] = j > 0 ? (w / mathpow(10, digits - j) % mathpow(10, j) | 0) * k : 0;\r\n      }\r\n\r\n      if (roundUp) {\r\n        for (;;) {\r\n\r\n          // Is the digit to be rounded up in the first word of xd?\r\n          if (xdi == 0) {\r\n\r\n            // i will be the length of xd[0] before k is added.\r\n            for (i = 1, j = xd[0]; j >= 10; j /= 10) i++;\r\n            j = xd[0] += k;\r\n            for (k = 1; j >= 10; j /= 10) k++;\r\n\r\n            // if i != k the length has increased.\r\n            if (i != k) {\r\n              x.e++;\r\n              if (xd[0] == BASE) xd[0] = 1;\r\n            }\r\n\r\n            break;\r\n          } else {\r\n            xd[xdi] += k;\r\n            if (xd[xdi] != BASE) break;\r\n            xd[xdi--] = 0;\r\n            k = 1;\r\n          }\r\n        }\r\n      }\r\n\r\n      // Remove trailing zeros.\r\n      for (i = xd.length; xd[--i] === 0;) xd.pop();\r\n    }\r\n\r\n    if (external) {\r\n\r\n      // Overflow?\r\n      if (x.e > Ctor.maxE) {\r\n\r\n        // Infinity.\r\n        x.d = null;\r\n        x.e = NaN;\r\n\r\n      // Underflow?\r\n      } else if (x.e < Ctor.minE) {\r\n\r\n        // Zero.\r\n        x.e = 0;\r\n        x.d = [0];\r\n        // Ctor.underflow = true;\r\n      } // else Ctor.underflow = false;\r\n    }\r\n\r\n    return x;\r\n  }\r\n\r\n\r\n  function finiteToString(x, isExp, sd) {\r\n    if (!x.isFinite()) return nonFiniteToString(x);\r\n    var k,\r\n      e = x.e,\r\n      str = digitsToString(x.d),\r\n      len = str.length;\r\n\r\n    if (isExp) {\r\n      if (sd && (k = sd - len) > 0) {\r\n        str = str.charAt(0) + '.' + str.slice(1) + getZeroString(k);\r\n      } else if (len > 1) {\r\n        str = str.charAt(0) + '.' + str.slice(1);\r\n      }\r\n\r\n      str = str + (x.e < 0 ? 'e' : 'e+') + x.e;\r\n    } else if (e < 0) {\r\n      str = '0.' + getZeroString(-e - 1) + str;\r\n      if (sd && (k = sd - len) > 0) str += getZeroString(k);\r\n    } else if (e >= len) {\r\n      str += getZeroString(e + 1 - len);\r\n      if (sd && (k = sd - e - 1) > 0) str = str + '.' + getZeroString(k);\r\n    } else {\r\n      if ((k = e + 1) < len) str = str.slice(0, k) + '.' + str.slice(k);\r\n      if (sd && (k = sd - len) > 0) {\r\n        if (e + 1 === len) str += '.';\r\n        str += getZeroString(k);\r\n      }\r\n    }\r\n\r\n    return str;\r\n  }\r\n\r\n\r\n  // Calculate the base 10 exponent from the base 1e7 exponent.\r\n  function getBase10Exponent(digits, e) {\r\n    var w = digits[0];\r\n\r\n    // Add the number of digits of the first word of the digits array.\r\n    for ( e *= LOG_BASE; w >= 10; w /= 10) e++;\r\n    return e;\r\n  }\r\n\r\n\r\n  function getLn10(Ctor, sd, pr) {\r\n    if (sd > LN10_PRECISION) {\r\n\r\n      // Reset global state in case the exception is caught.\r\n      external = true;\r\n      if (pr) Ctor.precision = pr;\r\n      throw Error(precisionLimitExceeded);\r\n    }\r\n    return finalise(new Ctor(LN10), sd, 1, true);\r\n  }\r\n\r\n\r\n  function getPi(Ctor, sd, rm) {\r\n    if (sd > PI_PRECISION) throw Error(precisionLimitExceeded);\r\n    return finalise(new Ctor(PI), sd, rm, true);\r\n  }\r\n\r\n\r\n  function getPrecision(digits) {\r\n    var w = digits.length - 1,\r\n      len = w * LOG_BASE + 1;\r\n\r\n    w = digits[w];\r\n\r\n    // If non-zero...\r\n    if (w) {\r\n\r\n      // Subtract the number of trailing zeros of the last word.\r\n      for (; w % 10 == 0; w /= 10) len--;\r\n\r\n      // Add the number of digits of the first word.\r\n      for (w = digits[0]; w >= 10; w /= 10) len++;\r\n    }\r\n\r\n    return len;\r\n  }\r\n\r\n\r\n  function getZeroString(k) {\r\n    var zs = '';\r\n    for (; k--;) zs += '0';\r\n    return zs;\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of Decimal `x` to the power `n`, where `n` is an\r\n   * integer of type number.\r\n   *\r\n   * Implements 'exponentiation by squaring'. Called by `pow` and `parseOther`.\r\n   *\r\n   */\r\n  function intPow(Ctor, x, n, pr) {\r\n    var isTruncated,\r\n      r = new Ctor(1),\r\n\r\n      // Max n of 9007199254740991 takes 53 loop iterations.\r\n      // Maximum digits array length; leaves [28, 34] guard digits.\r\n      k = Math.ceil(pr / LOG_BASE + 4);\r\n\r\n    external = false;\r\n\r\n    for (;;) {\r\n      if (n % 2) {\r\n        r = r.times(x);\r\n        if (truncate(r.d, k)) isTruncated = true;\r\n      }\r\n\r\n      n = mathfloor(n / 2);\r\n      if (n === 0) {\r\n\r\n        // To ensure correct rounding when r.d is truncated, increment the last word if it is zero.\r\n        n = r.d.length - 1;\r\n        if (isTruncated && r.d[n] === 0) ++r.d[n];\r\n        break;\r\n      }\r\n\r\n      x = x.times(x);\r\n      truncate(x.d, k);\r\n    }\r\n\r\n    external = true;\r\n\r\n    return r;\r\n  }\r\n\r\n\r\n  function isOdd(n) {\r\n    return n.d[n.d.length - 1] & 1;\r\n  }\r\n\r\n\r\n  /*\r\n   * Handle `max` and `min`. `ltgt` is 'lt' or 'gt'.\r\n   */\r\n  function maxOrMin(Ctor, args, ltgt) {\r\n    var y,\r\n      x = new Ctor(args[0]),\r\n      i = 0;\r\n\r\n    for (; ++i < args.length;) {\r\n      y = new Ctor(args[i]);\r\n      if (!y.s) {\r\n        x = y;\r\n        break;\r\n      } else if (x[ltgt](y)) {\r\n        x = y;\r\n      }\r\n    }\r\n\r\n    return x;\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the natural exponential of `x` rounded to `sd` significant\r\n   * digits.\r\n   *\r\n   * Taylor/Maclaurin series.\r\n   *\r\n   * exp(x) = x^0/0! + x^1/1! + x^2/2! + x^3/3! + ...\r\n   *\r\n   * Argument reduction:\r\n   *   Repeat x = x / 32, k += 5, until |x| < 0.1\r\n   *   exp(x) = exp(x / 2^k)^(2^k)\r\n   *\r\n   * Previously, the argument was initially reduced by\r\n   * exp(x) = exp(r) * 10^k  where r = x - k * ln10, k = floor(x / ln10)\r\n   * to first put r in the range [0, ln10], before dividing by 32 until |x| < 0.1, but this was\r\n   * found to be slower than just dividing repeatedly by 32 as above.\r\n   *\r\n   * Max integer argument: exp('20723265836946413') = 6.3e+9000000000000000\r\n   * Min integer argument: exp('-20723265836946411') = 1.2e-9000000000000000\r\n   * (Math object integer min/max: Math.exp(709) = 8.2e+307, Math.exp(-745) = 5e-324)\r\n   *\r\n   *  exp(Infinity)  = Infinity\r\n   *  exp(-Infinity) = 0\r\n   *  exp(NaN)       = NaN\r\n   *  exp(±0)        = 1\r\n   *\r\n   *  exp(x) is non-terminating for any finite, non-zero x.\r\n   *\r\n   *  The result will always be correctly rounded.\r\n   *\r\n   */\r\n  function naturalExponential(x, sd) {\r\n    var denominator, guard, j, pow, sum, t, wpr,\r\n      rep = 0,\r\n      i = 0,\r\n      k = 0,\r\n      Ctor = x.constructor,\r\n      rm = Ctor.rounding,\r\n      pr = Ctor.precision;\r\n\r\n    // 0/NaN/Infinity?\r\n    if (!x.d || !x.d[0] || x.e > 17) {\r\n\r\n      return new Ctor(x.d\r\n        ? !x.d[0] ? 1 : x.s < 0 ? 0 : 1 / 0\r\n        : x.s ? x.s < 0 ? 0 : x : 0 / 0);\r\n    }\r\n\r\n    if (sd == null) {\r\n      external = false;\r\n      wpr = pr;\r\n    } else {\r\n      wpr = sd;\r\n    }\r\n\r\n    t = new Ctor(0.03125);\r\n\r\n    // while abs(x) >= 0.1\r\n    while (x.e > -2) {\r\n\r\n      // x = x / 2^5\r\n      x = x.times(t);\r\n      k += 5;\r\n    }\r\n\r\n    // Use 2 * log10(2^k) + 5 (empirically derived) to estimate the increase in precision\r\n    // necessary to ensure the first 4 rounding digits are correct.\r\n    guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;\r\n    wpr += guard;\r\n    denominator = pow = sum = new Ctor(1);\r\n    Ctor.precision = wpr;\r\n\r\n    for (;;) {\r\n      pow = finalise(pow.times(x), wpr, 1);\r\n      denominator = denominator.times(++i);\r\n      t = sum.plus(divide(pow, denominator, wpr, 1));\r\n\r\n      if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {\r\n        j = k;\r\n        while (j--) sum = finalise(sum.times(sum), wpr, 1);\r\n\r\n        // Check to see if the first 4 rounding digits are [49]999.\r\n        // If so, repeat the summation with a higher precision, otherwise\r\n        // e.g. with precision: 18, rounding: 1\r\n        // exp(18.404272462595034083567793919843761) = 98372560.1229999999 (should be 98372560.123)\r\n        // `wpr - guard` is the index of first rounding digit.\r\n        if (sd == null) {\r\n\r\n          if (rep < 3 && checkRoundingDigits(sum.d, wpr - guard, rm, rep)) {\r\n            Ctor.precision = wpr += 10;\r\n            denominator = pow = t = new Ctor(1);\r\n            i = 0;\r\n            rep++;\r\n          } else {\r\n            return finalise(sum, Ctor.precision = pr, rm, external = true);\r\n          }\r\n        } else {\r\n          Ctor.precision = pr;\r\n          return sum;\r\n        }\r\n      }\r\n\r\n      sum = t;\r\n    }\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the natural logarithm of `x` rounded to `sd` significant\r\n   * digits.\r\n   *\r\n   *  ln(-n)        = NaN\r\n   *  ln(0)         = -Infinity\r\n   *  ln(-0)        = -Infinity\r\n   *  ln(1)         = 0\r\n   *  ln(Infinity)  = Infinity\r\n   *  ln(-Infinity) = NaN\r\n   *  ln(NaN)       = NaN\r\n   *\r\n   *  ln(n) (n != 1) is non-terminating.\r\n   *\r\n   */\r\n  function naturalLogarithm(y, sd) {\r\n    var c, c0, denominator, e, numerator, rep, sum, t, wpr, x1, x2,\r\n      n = 1,\r\n      guard = 10,\r\n      x = y,\r\n      xd = x.d,\r\n      Ctor = x.constructor,\r\n      rm = Ctor.rounding,\r\n      pr = Ctor.precision;\r\n\r\n    // Is x negative or Infinity, NaN, 0 or 1?\r\n    if (x.s < 0 || !xd || !xd[0] || !x.e && xd[0] == 1 && xd.length == 1) {\r\n      return new Ctor(xd && !xd[0] ? -1 / 0 : x.s != 1 ? NaN : xd ? 0 : x);\r\n    }\r\n\r\n    if (sd == null) {\r\n      external = false;\r\n      wpr = pr;\r\n    } else {\r\n      wpr = sd;\r\n    }\r\n\r\n    Ctor.precision = wpr += guard;\r\n    c = digitsToString(xd);\r\n    c0 = c.charAt(0);\r\n\r\n    if (Math.abs(e = x.e) < 1.5e15) {\r\n\r\n      // Argument reduction.\r\n      // The series converges faster the closer the argument is to 1, so using\r\n      // ln(a^b) = b * ln(a),   ln(a) = ln(a^b) / b\r\n      // multiply the argument by itself until the leading digits of the significand are 7, 8, 9,\r\n      // 10, 11, 12 or 13, recording the number of multiplications so the sum of the series can\r\n      // later be divided by this number, then separate out the power of 10 using\r\n      // ln(a*10^b) = ln(a) + b*ln(10).\r\n\r\n      // max n is 21 (gives 0.9, 1.0 or 1.1) (9e15 / 21 = 4.2e14).\r\n      //while (c0 < 9 && c0 != 1 || c0 == 1 && c.charAt(1) > 1) {\r\n      // max n is 6 (gives 0.7 - 1.3)\r\n      while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {\r\n        x = x.times(y);\r\n        c = digitsToString(x.d);\r\n        c0 = c.charAt(0);\r\n        n++;\r\n      }\r\n\r\n      e = x.e;\r\n\r\n      if (c0 > 1) {\r\n        x = new Ctor('0.' + c);\r\n        e++;\r\n      } else {\r\n        x = new Ctor(c0 + '.' + c.slice(1));\r\n      }\r\n    } else {\r\n\r\n      // The argument reduction method above may result in overflow if the argument y is a massive\r\n      // number with exponent >= 1500000000000000 (9e15 / 6 = 1.5e15), so instead recall this\r\n      // function using ln(x*10^e) = ln(x) + e*ln(10).\r\n      t = getLn10(Ctor, wpr + 2, pr).times(e + '');\r\n      x = naturalLogarithm(new Ctor(c0 + '.' + c.slice(1)), wpr - guard).plus(t);\r\n      Ctor.precision = pr;\r\n\r\n      return sd == null ? finalise(x, pr, rm, external = true) : x;\r\n    }\r\n\r\n    // x1 is x reduced to a value near 1.\r\n    x1 = x;\r\n\r\n    // Taylor series.\r\n    // ln(y) = ln((1 + x)/(1 - x)) = 2(x + x^3/3 + x^5/5 + x^7/7 + ...)\r\n    // where x = (y - 1)/(y + 1)    (|x| < 1)\r\n    sum = numerator = x = divide(x.minus(1), x.plus(1), wpr, 1);\r\n    x2 = finalise(x.times(x), wpr, 1);\r\n    denominator = 3;\r\n\r\n    for (;;) {\r\n      numerator = finalise(numerator.times(x2), wpr, 1);\r\n      t = sum.plus(divide(numerator, new Ctor(denominator), wpr, 1));\r\n\r\n      if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {\r\n        sum = sum.times(2);\r\n\r\n        // Reverse the argument reduction. Check that e is not 0 because, besides preventing an\r\n        // unnecessary calculation, -0 + 0 = +0 and to ensure correct rounding -0 needs to stay -0.\r\n        if (e !== 0) sum = sum.plus(getLn10(Ctor, wpr + 2, pr).times(e + ''));\r\n        sum = divide(sum, new Ctor(n), wpr, 1);\r\n\r\n        // Is rm > 3 and the first 4 rounding digits 4999, or rm < 4 (or the summation has\r\n        // been repeated previously) and the first 4 rounding digits 9999?\r\n        // If so, restart the summation with a higher precision, otherwise\r\n        // e.g. with precision: 12, rounding: 1\r\n        // ln(135520028.6126091714265381533) = 18.7246299999 when it should be 18.72463.\r\n        // `wpr - guard` is the index of first rounding digit.\r\n        if (sd == null) {\r\n          if (checkRoundingDigits(sum.d, wpr - guard, rm, rep)) {\r\n            Ctor.precision = wpr += guard;\r\n            t = numerator = x = divide(x1.minus(1), x1.plus(1), wpr, 1);\r\n            x2 = finalise(x.times(x), wpr, 1);\r\n            denominator = rep = 1;\r\n          } else {\r\n            return finalise(sum, Ctor.precision = pr, rm, external = true);\r\n          }\r\n        } else {\r\n          Ctor.precision = pr;\r\n          return sum;\r\n        }\r\n      }\r\n\r\n      sum = t;\r\n      denominator += 2;\r\n    }\r\n  }\r\n\r\n\r\n  // ±Infinity, NaN.\r\n  function nonFiniteToString(x) {\r\n    // Unsigned.\r\n    return String(x.s * x.s / 0);\r\n  }\r\n\r\n\r\n  /*\r\n   * Parse the value of a new Decimal `x` from string `str`.\r\n   */\r\n  function parseDecimal(x, str) {\r\n    var e, i, len;\r\n\r\n    // Decimal point?\r\n    if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');\r\n\r\n    // Exponential form?\r\n    if ((i = str.search(/e/i)) > 0) {\r\n\r\n      // Determine exponent.\r\n      if (e < 0) e = i;\r\n      e += +str.slice(i + 1);\r\n      str = str.substring(0, i);\r\n    } else if (e < 0) {\r\n\r\n      // Integer.\r\n      e = str.length;\r\n    }\r\n\r\n    // Determine leading zeros.\r\n    for (i = 0; str.charCodeAt(i) === 48; i++);\r\n\r\n    // Determine trailing zeros.\r\n    for (len = str.length; str.charCodeAt(len - 1) === 48; --len);\r\n    str = str.slice(i, len);\r\n\r\n    if (str) {\r\n      len -= i;\r\n      x.e = e = e - i - 1;\r\n      x.d = [];\r\n\r\n      // Transform base\r\n\r\n      // e is the base 10 exponent.\r\n      // i is where to slice str to get the first word of the digits array.\r\n      i = (e + 1) % LOG_BASE;\r\n      if (e < 0) i += LOG_BASE;\r\n\r\n      if (i < len) {\r\n        if (i) x.d.push(+str.slice(0, i));\r\n        for (len -= LOG_BASE; i < len;) x.d.push(+str.slice(i, i += LOG_BASE));\r\n        str = str.slice(i);\r\n        i = LOG_BASE - str.length;\r\n      } else {\r\n        i -= len;\r\n      }\r\n\r\n      for (; i--;) str += '0';\r\n      x.d.push(+str);\r\n\r\n      if (external) {\r\n\r\n        // Overflow?\r\n        if (x.e > x.constructor.maxE) {\r\n\r\n          // Infinity.\r\n          x.d = null;\r\n          x.e = NaN;\r\n\r\n        // Underflow?\r\n        } else if (x.e < x.constructor.minE) {\r\n\r\n          // Zero.\r\n          x.e = 0;\r\n          x.d = [0];\r\n          // x.constructor.underflow = true;\r\n        } // else x.constructor.underflow = false;\r\n      }\r\n    } else {\r\n\r\n      // Zero.\r\n      x.e = 0;\r\n      x.d = [0];\r\n    }\r\n\r\n    return x;\r\n  }\r\n\r\n\r\n  /*\r\n   * Parse the value of a new Decimal `x` from a string `str`, which is not a decimal value.\r\n   */\r\n  function parseOther(x, str) {\r\n    var base, Ctor, divisor, i, isFloat, len, p, xd, xe;\r\n\r\n    if (str.indexOf('_') > -1) {\r\n      str = str.replace(/(\\d)_(?=\\d)/g, '$1');\r\n      if (isDecimal.test(str)) return parseDecimal(x, str);\r\n    } else if (str === 'Infinity' || str === 'NaN') {\r\n      if (!+str) x.s = NaN;\r\n      x.e = NaN;\r\n      x.d = null;\r\n      return x;\r\n    }\r\n\r\n    if (isHex.test(str))  {\r\n      base = 16;\r\n      str = str.toLowerCase();\r\n    } else if (isBinary.test(str))  {\r\n      base = 2;\r\n    } else if (isOctal.test(str))  {\r\n      base = 8;\r\n    } else {\r\n      throw Error(invalidArgument + str);\r\n    }\r\n\r\n    // Is there a binary exponent part?\r\n    i = str.search(/p/i);\r\n\r\n    if (i > 0) {\r\n      p = +str.slice(i + 1);\r\n      str = str.substring(2, i);\r\n    } else {\r\n      str = str.slice(2);\r\n    }\r\n\r\n    // Convert `str` as an integer then divide the result by `base` raised to a power such that the\r\n    // fraction part will be restored.\r\n    i = str.indexOf('.');\r\n    isFloat = i >= 0;\r\n    Ctor = x.constructor;\r\n\r\n    if (isFloat) {\r\n      str = str.replace('.', '');\r\n      len = str.length;\r\n      i = len - i;\r\n\r\n      // log[10](16) = 1.2041... , log[10](88) = 1.9444....\r\n      divisor = intPow(Ctor, new Ctor(base), i, i * 2);\r\n    }\r\n\r\n    xd = convertBase(str, base, BASE);\r\n    xe = xd.length - 1;\r\n\r\n    // Remove trailing zeros.\r\n    for (i = xe; xd[i] === 0; --i) xd.pop();\r\n    if (i < 0) return new Ctor(x.s * 0);\r\n    x.e = getBase10Exponent(xd, xe);\r\n    x.d = xd;\r\n    external = false;\r\n\r\n    // At what precision to perform the division to ensure exact conversion?\r\n    // maxDecimalIntegerPartDigitCount = ceil(log[10](b) * otherBaseIntegerPartDigitCount)\r\n    // log[10](2) = 0.30103, log[10](8) = 0.90309, log[10](16) = 1.20412\r\n    // E.g. ceil(1.2 * 3) = 4, so up to 4 decimal digits are needed to represent 3 hex int digits.\r\n    // maxDecimalFractionPartDigitCount = {Hex:4|Oct:3|Bin:1} * otherBaseFractionPartDigitCount\r\n    // Therefore using 4 * the number of digits of str will always be enough.\r\n    if (isFloat) x = divide(x, divisor, len * 4);\r\n\r\n    // Multiply by the binary exponent part if present.\r\n    if (p) x = x.times(Math.abs(p) < 54 ? mathpow(2, p) : Decimal.pow(2, p));\r\n    external = true;\r\n\r\n    return x;\r\n  }\r\n\r\n\r\n  /*\r\n   * sin(x) = x - x^3/3! + x^5/5! - ...\r\n   * |x| < pi/2\r\n   *\r\n   */\r\n  function sine(Ctor, x) {\r\n    var k,\r\n      len = x.d.length;\r\n\r\n    if (len < 3) {\r\n      return x.isZero() ? x : taylorSeries(Ctor, 2, x, x);\r\n    }\r\n\r\n    // Argument reduction: sin(5x) = 16*sin^5(x) - 20*sin^3(x) + 5*sin(x)\r\n    // i.e. sin(x) = 16*sin^5(x/5) - 20*sin^3(x/5) + 5*sin(x/5)\r\n    // and  sin(x) = sin(x/5)(5 + sin^2(x/5)(16sin^2(x/5) - 20))\r\n\r\n    // Estimate the optimum number of times to use the argument reduction.\r\n    k = 1.4 * Math.sqrt(len);\r\n    k = k > 16 ? 16 : k | 0;\r\n\r\n    x = x.times(1 / tinyPow(5, k));\r\n    x = taylorSeries(Ctor, 2, x, x);\r\n\r\n    // Reverse argument reduction\r\n    var sin2_x,\r\n      d5 = new Ctor(5),\r\n      d16 = new Ctor(16),\r\n      d20 = new Ctor(20);\r\n    for (; k--;) {\r\n      sin2_x = x.times(x);\r\n      x = x.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));\r\n    }\r\n\r\n    return x;\r\n  }\r\n\r\n\r\n  // Calculate Taylor series for `cos`, `cosh`, `sin` and `sinh`.\r\n  function taylorSeries(Ctor, n, x, y, isHyperbolic) {\r\n    var j, t, u, x2,\r\n      i = 1,\r\n      pr = Ctor.precision,\r\n      k = Math.ceil(pr / LOG_BASE);\r\n\r\n    external = false;\r\n    x2 = x.times(x);\r\n    u = new Ctor(y);\r\n\r\n    for (;;) {\r\n      t = divide(u.times(x2), new Ctor(n++ * n++), pr, 1);\r\n      u = isHyperbolic ? y.plus(t) : y.minus(t);\r\n      y = divide(t.times(x2), new Ctor(n++ * n++), pr, 1);\r\n      t = u.plus(y);\r\n\r\n      if (t.d[k] !== void 0) {\r\n        for (j = k; t.d[j] === u.d[j] && j--;);\r\n        if (j == -1) break;\r\n      }\r\n\r\n      j = u;\r\n      u = y;\r\n      y = t;\r\n      t = j;\r\n      i++;\r\n    }\r\n\r\n    external = true;\r\n    t.d.length = k + 1;\r\n\r\n    return t;\r\n  }\r\n\r\n\r\n  // Exponent e must be positive and non-zero.\r\n  function tinyPow(b, e) {\r\n    var n = b;\r\n    while (--e) n *= b;\r\n    return n;\r\n  }\r\n\r\n\r\n  // Return the absolute value of `x` reduced to less than or equal to half pi.\r\n  function toLessThanHalfPi(Ctor, x) {\r\n    var t,\r\n      isNeg = x.s < 0,\r\n      pi = getPi(Ctor, Ctor.precision, 1),\r\n      halfPi = pi.times(0.5);\r\n\r\n    x = x.abs();\r\n\r\n    if (x.lte(halfPi)) {\r\n      quadrant = isNeg ? 4 : 1;\r\n      return x;\r\n    }\r\n\r\n    t = x.divToInt(pi);\r\n\r\n    if (t.isZero()) {\r\n      quadrant = isNeg ? 3 : 2;\r\n    } else {\r\n      x = x.minus(t.times(pi));\r\n\r\n      // 0 <= x < pi\r\n      if (x.lte(halfPi)) {\r\n        quadrant = isOdd(t) ? (isNeg ? 2 : 3) : (isNeg ? 4 : 1);\r\n        return x;\r\n      }\r\n\r\n      quadrant = isOdd(t) ? (isNeg ? 1 : 4) : (isNeg ? 3 : 2);\r\n    }\r\n\r\n    return x.minus(pi).abs();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return the value of Decimal `x` as a string in base `baseOut`.\r\n   *\r\n   * If the optional `sd` argument is present include a binary exponent suffix.\r\n   */\r\n  function toStringBinary(x, baseOut, sd, rm) {\r\n    var base, e, i, k, len, roundUp, str, xd, y,\r\n      Ctor = x.constructor,\r\n      isExp = sd !== void 0;\r\n\r\n    if (isExp) {\r\n      checkInt32(sd, 1, MAX_DIGITS);\r\n      if (rm === void 0) rm = Ctor.rounding;\r\n      else checkInt32(rm, 0, 8);\r\n    } else {\r\n      sd = Ctor.precision;\r\n      rm = Ctor.rounding;\r\n    }\r\n\r\n    if (!x.isFinite()) {\r\n      str = nonFiniteToString(x);\r\n    } else {\r\n      str = finiteToString(x);\r\n      i = str.indexOf('.');\r\n\r\n      // Use exponential notation according to `toExpPos` and `toExpNeg`? No, but if required:\r\n      // maxBinaryExponent = floor((decimalExponent + 1) * log[2](10))\r\n      // minBinaryExponent = floor(decimalExponent * log[2](10))\r\n      // log[2](10) = 3.321928094887362347870319429489390175864\r\n\r\n      if (isExp) {\r\n        base = 2;\r\n        if (baseOut == 16) {\r\n          sd = sd * 4 - 3;\r\n        } else if (baseOut == 8) {\r\n          sd = sd * 3 - 2;\r\n        }\r\n      } else {\r\n        base = baseOut;\r\n      }\r\n\r\n      // Convert the number as an integer then divide the result by its base raised to a power such\r\n      // that the fraction part will be restored.\r\n\r\n      // Non-integer.\r\n      if (i >= 0) {\r\n        str = str.replace('.', '');\r\n        y = new Ctor(1);\r\n        y.e = str.length - i;\r\n        y.d = convertBase(finiteToString(y), 10, base);\r\n        y.e = y.d.length;\r\n      }\r\n\r\n      xd = convertBase(str, 10, base);\r\n      e = len = xd.length;\r\n\r\n      // Remove trailing zeros.\r\n      for (; xd[--len] == 0;) xd.pop();\r\n\r\n      if (!xd[0]) {\r\n        str = isExp ? '0p+0' : '0';\r\n      } else {\r\n        if (i < 0) {\r\n          e--;\r\n        } else {\r\n          x = new Ctor(x);\r\n          x.d = xd;\r\n          x.e = e;\r\n          x = divide(x, y, sd, rm, 0, base);\r\n          xd = x.d;\r\n          e = x.e;\r\n          roundUp = inexact;\r\n        }\r\n\r\n        // The rounding digit, i.e. the digit after the digit that may be rounded up.\r\n        i = xd[sd];\r\n        k = base / 2;\r\n        roundUp = roundUp || xd[sd + 1] !== void 0;\r\n\r\n        roundUp = rm < 4\r\n          ? (i !== void 0 || roundUp) && (rm === 0 || rm === (x.s < 0 ? 3 : 2))\r\n          : i > k || i === k && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 ||\r\n            rm === (x.s < 0 ? 8 : 7));\r\n\r\n        xd.length = sd;\r\n\r\n        if (roundUp) {\r\n\r\n          // Rounding up may mean the previous digit has to be rounded up and so on.\r\n          for (; ++xd[--sd] > base - 1;) {\r\n            xd[sd] = 0;\r\n            if (!sd) {\r\n              ++e;\r\n              xd.unshift(1);\r\n            }\r\n          }\r\n        }\r\n\r\n        // Determine trailing zeros.\r\n        for (len = xd.length; !xd[len - 1]; --len);\r\n\r\n        // E.g. [4, 11, 15] becomes 4bf.\r\n        for (i = 0, str = ''; i < len; i++) str += NUMERALS.charAt(xd[i]);\r\n\r\n        // Add binary exponent suffix?\r\n        if (isExp) {\r\n          if (len > 1) {\r\n            if (baseOut == 16 || baseOut == 8) {\r\n              i = baseOut == 16 ? 4 : 3;\r\n              for (--len; len % i; len++) str += '0';\r\n              xd = convertBase(str, base, baseOut);\r\n              for (len = xd.length; !xd[len - 1]; --len);\r\n\r\n              // xd[0] will always be be 1\r\n              for (i = 1, str = '1.'; i < len; i++) str += NUMERALS.charAt(xd[i]);\r\n            } else {\r\n              str = str.charAt(0) + '.' + str.slice(1);\r\n            }\r\n          }\r\n\r\n          str =  str + (e < 0 ? 'p' : 'p+') + e;\r\n        } else if (e < 0) {\r\n          for (; ++e;) str = '0' + str;\r\n          str = '0.' + str;\r\n        } else {\r\n          if (++e > len) for (e -= len; e-- ;) str += '0';\r\n          else if (e < len) str = str.slice(0, e) + '.' + str.slice(e);\r\n        }\r\n      }\r\n\r\n      str = (baseOut == 16 ? '0x' : baseOut == 2 ? '0b' : baseOut == 8 ? '0o' : '') + str;\r\n    }\r\n\r\n    return x.s < 0 ? '-' + str : str;\r\n  }\r\n\r\n\r\n  // Does not strip trailing zeros.\r\n  function truncate(arr, len) {\r\n    if (arr.length > len) {\r\n      arr.length = len;\r\n      return true;\r\n    }\r\n  }\r\n\r\n\r\n  // Decimal methods\r\n\r\n\r\n  /*\r\n   *  abs\r\n   *  acos\r\n   *  acosh\r\n   *  add\r\n   *  asin\r\n   *  asinh\r\n   *  atan\r\n   *  atanh\r\n   *  atan2\r\n   *  cbrt\r\n   *  ceil\r\n   *  clamp\r\n   *  clone\r\n   *  config\r\n   *  cos\r\n   *  cosh\r\n   *  div\r\n   *  exp\r\n   *  floor\r\n   *  hypot\r\n   *  ln\r\n   *  log\r\n   *  log2\r\n   *  log10\r\n   *  max\r\n   *  min\r\n   *  mod\r\n   *  mul\r\n   *  pow\r\n   *  random\r\n   *  round\r\n   *  set\r\n   *  sign\r\n   *  sin\r\n   *  sinh\r\n   *  sqrt\r\n   *  sub\r\n   *  sum\r\n   *  tan\r\n   *  tanh\r\n   *  trunc\r\n   */\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the absolute value of `x`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function abs(x) {\r\n    return new this(x).abs();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the arccosine in radians of `x`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function acos(x) {\r\n    return new this(x).acos();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the inverse of the hyperbolic cosine of `x`, rounded to\r\n   * `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\r\n  function acosh(x) {\r\n    return new this(x).acosh();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the sum of `x` and `y`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   * y {number|string|Decimal}\r\n   *\r\n   */\r\n  function add(x, y) {\r\n    return new this(x).plus(y);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the arcsine in radians of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function asin(x) {\r\n    return new this(x).asin();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the inverse of the hyperbolic sine of `x`, rounded to\r\n   * `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\r\n  function asinh(x) {\r\n    return new this(x).asinh();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the arctangent in radians of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function atan(x) {\r\n    return new this(x).atan();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the inverse of the hyperbolic tangent of `x`, rounded to\r\n   * `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\r\n  function atanh(x) {\r\n    return new this(x).atanh();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the arctangent in radians of `y/x` in the range -pi to pi\r\n   * (inclusive), rounded to `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-pi, pi]\r\n   *\r\n   * y {number|string|Decimal} The y-coordinate.\r\n   * x {number|string|Decimal} The x-coordinate.\r\n   *\r\n   * atan2(±0, -0)               = ±pi\r\n   * atan2(±0, +0)               = ±0\r\n   * atan2(±0, -x)               = ±pi for x > 0\r\n   * atan2(±0, x)                = ±0 for x > 0\r\n   * atan2(-y, ±0)               = -pi/2 for y > 0\r\n   * atan2(y, ±0)                = pi/2 for y > 0\r\n   * atan2(±y, -Infinity)        = ±pi for finite y > 0\r\n   * atan2(±y, +Infinity)        = ±0 for finite y > 0\r\n   * atan2(±Infinity, x)         = ±pi/2 for finite x\r\n   * atan2(±Infinity, -Infinity) = ±3*pi/4\r\n   * atan2(±Infinity, +Infinity) = ±pi/4\r\n   * atan2(NaN, x) = NaN\r\n   * atan2(y, NaN) = NaN\r\n   *\r\n   */\r\n  function atan2(y, x) {\r\n    y = new this(y);\r\n    x = new this(x);\r\n    var r,\r\n      pr = this.precision,\r\n      rm = this.rounding,\r\n      wpr = pr + 4;\r\n\r\n    // Either NaN\r\n    if (!y.s || !x.s) {\r\n      r = new this(NaN);\r\n\r\n    // Both ±Infinity\r\n    } else if (!y.d && !x.d) {\r\n      r = getPi(this, wpr, 1).times(x.s > 0 ? 0.25 : 0.75);\r\n      r.s = y.s;\r\n\r\n    // x is ±Infinity or y is ±0\r\n    } else if (!x.d || y.isZero()) {\r\n      r = x.s < 0 ? getPi(this, pr, rm) : new this(0);\r\n      r.s = y.s;\r\n\r\n    // y is ±Infinity or x is ±0\r\n    } else if (!y.d || x.isZero()) {\r\n      r = getPi(this, wpr, 1).times(0.5);\r\n      r.s = y.s;\r\n\r\n    // Both non-zero and finite\r\n    } else if (x.s < 0) {\r\n      this.precision = wpr;\r\n      this.rounding = 1;\r\n      r = this.atan(divide(y, x, wpr, 1));\r\n      x = getPi(this, wpr, 1);\r\n      this.precision = pr;\r\n      this.rounding = rm;\r\n      r = y.s < 0 ? r.minus(x) : r.plus(x);\r\n    } else {\r\n      r = this.atan(divide(y, x, wpr, 1));\r\n    }\r\n\r\n    return r;\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the cube root of `x`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function cbrt(x) {\r\n    return new this(x).cbrt();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` rounded to an integer using `ROUND_CEIL`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function ceil(x) {\r\n    return finalise(x = new this(x), x.e + 1, 2);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` clamped to the range delineated by `min` and `max`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   * min {number|string|Decimal}\r\n   * max {number|string|Decimal}\r\n   *\r\n   */\r\n  function clamp(x, min, max) {\r\n    return new this(x).clamp(min, max);\r\n  }\r\n\r\n\r\n  /*\r\n   * Configure global settings for a Decimal constructor.\r\n   *\r\n   * `obj` is an object with one or more of the following properties,\r\n   *\r\n   *   precision  {number}\r\n   *   rounding   {number}\r\n   *   toExpNeg   {number}\r\n   *   toExpPos   {number}\r\n   *   maxE       {number}\r\n   *   minE       {number}\r\n   *   modulo     {number}\r\n   *   crypto     {boolean|number}\r\n   *   defaults   {true}\r\n   *\r\n   * E.g. Decimal.config({ precision: 20, rounding: 4 })\r\n   *\r\n   */\r\n  function config(obj) {\r\n    if (!obj || typeof obj !== 'object') throw Error(decimalError + 'Object expected');\r\n    var i, p, v,\r\n      useDefaults = obj.defaults === true,\r\n      ps = [\r\n        'precision', 1, MAX_DIGITS,\r\n        'rounding', 0, 8,\r\n        'toExpNeg', -EXP_LIMIT, 0,\r\n        'toExpPos', 0, EXP_LIMIT,\r\n        'maxE', 0, EXP_LIMIT,\r\n        'minE', -EXP_LIMIT, 0,\r\n        'modulo', 0, 9\r\n      ];\r\n\r\n    for (i = 0; i < ps.length; i += 3) {\r\n      if (p = ps[i], useDefaults) this[p] = DEFAULTS[p];\r\n      if ((v = obj[p]) !== void 0) {\r\n        if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2]) this[p] = v;\r\n        else throw Error(invalidArgument + p + ': ' + v);\r\n      }\r\n    }\r\n\r\n    if (p = 'crypto', useDefaults) this[p] = DEFAULTS[p];\r\n    if ((v = obj[p]) !== void 0) {\r\n      if (v === true || v === false || v === 0 || v === 1) {\r\n        if (v) {\r\n          if (typeof crypto != 'undefined' && crypto &&\r\n            (crypto.getRandomValues || crypto.randomBytes)) {\r\n            this[p] = true;\r\n          } else {\r\n            throw Error(cryptoUnavailable);\r\n          }\r\n        } else {\r\n          this[p] = false;\r\n        }\r\n      } else {\r\n        throw Error(invalidArgument + p + ': ' + v);\r\n      }\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the cosine of `x`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\r\n  function cos(x) {\r\n    return new this(x).cos();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the hyperbolic cosine of `x`, rounded to precision\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\r\n  function cosh(x) {\r\n    return new this(x).cosh();\r\n  }\r\n\r\n\r\n  /*\r\n   * Create and return a Decimal constructor with the same configuration properties as this Decimal\r\n   * constructor.\r\n   *\r\n   */\r\n  function clone(obj) {\r\n    var i, p, ps;\r\n\r\n    /*\r\n     * The Decimal constructor and exported function.\r\n     * Return a new Decimal instance.\r\n     *\r\n     * v {number|string|Decimal} A numeric value.\r\n     *\r\n     */\r\n    function Decimal(v) {\r\n      var e, i, t,\r\n        x = this;\r\n\r\n      // Decimal called without new.\r\n      if (!(x instanceof Decimal)) return new Decimal(v);\r\n\r\n      // Retain a reference to this Decimal constructor, and shadow Decimal.prototype.constructor\r\n      // which points to Object.\r\n      x.constructor = Decimal;\r\n\r\n      // Duplicate.\r\n      if (isDecimalInstance(v)) {\r\n        x.s = v.s;\r\n\r\n        if (external) {\r\n          if (!v.d || v.e > Decimal.maxE) {\r\n\r\n            // Infinity.\r\n            x.e = NaN;\r\n            x.d = null;\r\n          } else if (v.e < Decimal.minE) {\r\n\r\n            // Zero.\r\n            x.e = 0;\r\n            x.d = [0];\r\n          } else {\r\n            x.e = v.e;\r\n            x.d = v.d.slice();\r\n          }\r\n        } else {\r\n          x.e = v.e;\r\n          x.d = v.d ? v.d.slice() : v.d;\r\n        }\r\n\r\n        return;\r\n      }\r\n\r\n      t = typeof v;\r\n\r\n      if (t === 'number') {\r\n        if (v === 0) {\r\n          x.s = 1 / v < 0 ? -1 : 1;\r\n          x.e = 0;\r\n          x.d = [0];\r\n          return;\r\n        }\r\n\r\n        if (v < 0) {\r\n          v = -v;\r\n          x.s = -1;\r\n        } else {\r\n          x.s = 1;\r\n        }\r\n\r\n        // Fast path for small integers.\r\n        if (v === ~~v && v < 1e7) {\r\n          for (e = 0, i = v; i >= 10; i /= 10) e++;\r\n\r\n          if (external) {\r\n            if (e > Decimal.maxE) {\r\n              x.e = NaN;\r\n              x.d = null;\r\n            } else if (e < Decimal.minE) {\r\n              x.e = 0;\r\n              x.d = [0];\r\n            } else {\r\n              x.e = e;\r\n              x.d = [v];\r\n            }\r\n          } else {\r\n            x.e = e;\r\n            x.d = [v];\r\n          }\r\n\r\n          return;\r\n\r\n        // Infinity, NaN.\r\n        } else if (v * 0 !== 0) {\r\n          if (!v) x.s = NaN;\r\n          x.e = NaN;\r\n          x.d = null;\r\n          return;\r\n        }\r\n\r\n        return parseDecimal(x, v.toString());\r\n\r\n      } else if (t !== 'string') {\r\n        throw Error(invalidArgument + v);\r\n      }\r\n\r\n      // Minus sign?\r\n      if ((i = v.charCodeAt(0)) === 45) {\r\n        v = v.slice(1);\r\n        x.s = -1;\r\n      } else {\r\n        // Plus sign?\r\n        if (i === 43) v = v.slice(1);\r\n        x.s = 1;\r\n      }\r\n\r\n      return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);\r\n    }\r\n\r\n    Decimal.prototype = P;\r\n\r\n    Decimal.ROUND_UP = 0;\r\n    Decimal.ROUND_DOWN = 1;\r\n    Decimal.ROUND_CEIL = 2;\r\n    Decimal.ROUND_FLOOR = 3;\r\n    Decimal.ROUND_HALF_UP = 4;\r\n    Decimal.ROUND_HALF_DOWN = 5;\r\n    Decimal.ROUND_HALF_EVEN = 6;\r\n    Decimal.ROUND_HALF_CEIL = 7;\r\n    Decimal.ROUND_HALF_FLOOR = 8;\r\n    Decimal.EUCLID = 9;\r\n\r\n    Decimal.config = Decimal.set = config;\r\n    Decimal.clone = clone;\r\n    Decimal.isDecimal = isDecimalInstance;\r\n\r\n    Decimal.abs = abs;\r\n    Decimal.acos = acos;\r\n    Decimal.acosh = acosh;        // ES6\r\n    Decimal.add = add;\r\n    Decimal.asin = asin;\r\n    Decimal.asinh = asinh;        // ES6\r\n    Decimal.atan = atan;\r\n    Decimal.atanh = atanh;        // ES6\r\n    Decimal.atan2 = atan2;\r\n    Decimal.cbrt = cbrt;          // ES6\r\n    Decimal.ceil = ceil;\r\n    Decimal.clamp = clamp;\r\n    Decimal.cos = cos;\r\n    Decimal.cosh = cosh;          // ES6\r\n    Decimal.div = div;\r\n    Decimal.exp = exp;\r\n    Decimal.floor = floor;\r\n    Decimal.hypot = hypot;        // ES6\r\n    Decimal.ln = ln;\r\n    Decimal.log = log;\r\n    Decimal.log10 = log10;        // ES6\r\n    Decimal.log2 = log2;          // ES6\r\n    Decimal.max = max;\r\n    Decimal.min = min;\r\n    Decimal.mod = mod;\r\n    Decimal.mul = mul;\r\n    Decimal.pow = pow;\r\n    Decimal.random = random;\r\n    Decimal.round = round;\r\n    Decimal.sign = sign;          // ES6\r\n    Decimal.sin = sin;\r\n    Decimal.sinh = sinh;          // ES6\r\n    Decimal.sqrt = sqrt;\r\n    Decimal.sub = sub;\r\n    Decimal.sum = sum;\r\n    Decimal.tan = tan;\r\n    Decimal.tanh = tanh;          // ES6\r\n    Decimal.trunc = trunc;        // ES6\r\n\r\n    if (obj === void 0) obj = {};\r\n    if (obj) {\r\n      if (obj.defaults !== true) {\r\n        ps = ['precision', 'rounding', 'toExpNeg', 'toExpPos', 'maxE', 'minE', 'modulo', 'crypto'];\r\n        for (i = 0; i < ps.length;) if (!obj.hasOwnProperty(p = ps[i++])) obj[p] = this[p];\r\n      }\r\n    }\r\n\r\n    Decimal.config(obj);\r\n\r\n    return Decimal;\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` divided by `y`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   * y {number|string|Decimal}\r\n   *\r\n   */\r\n  function div(x, y) {\r\n    return new this(x).div(y);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the natural exponential of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} The power to which to raise the base of the natural log.\r\n   *\r\n   */\r\n  function exp(x) {\r\n    return new this(x).exp();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` round to an integer using `ROUND_FLOOR`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function floor(x) {\r\n    return finalise(x = new this(x), x.e + 1, 3);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the square root of the sum of the squares of the arguments,\r\n   * rounded to `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * hypot(a, b, ...) = sqrt(a^2 + b^2 + ...)\r\n   *\r\n   * arguments {number|string|Decimal}\r\n   *\r\n   */\r\n  function hypot() {\r\n    var i, n,\r\n      t = new this(0);\r\n\r\n    external = false;\r\n\r\n    for (i = 0; i < arguments.length;) {\r\n      n = new this(arguments[i++]);\r\n      if (!n.d) {\r\n        if (n.s) {\r\n          external = true;\r\n          return new this(1 / 0);\r\n        }\r\n        t = n;\r\n      } else if (t.d) {\r\n        t = t.plus(n.times(n));\r\n      }\r\n    }\r\n\r\n    external = true;\r\n\r\n    return t.sqrt();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return true if object is a Decimal instance (where Decimal is any Decimal constructor),\r\n   * otherwise return false.\r\n   *\r\n   */\r\n  function isDecimalInstance(obj) {\r\n    return obj instanceof Decimal || obj && obj.toStringTag === tag || false;\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the natural logarithm of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function ln(x) {\r\n    return new this(x).ln();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the log of `x` to the base `y`, or to base 10 if no base\r\n   * is specified, rounded to `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * log[y](x)\r\n   *\r\n   * x {number|string|Decimal} The argument of the logarithm.\r\n   * y {number|string|Decimal} The base of the logarithm.\r\n   *\r\n   */\r\n  function log(x, y) {\r\n    return new this(x).log(y);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the base 2 logarithm of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function log2(x) {\r\n    return new this(x).log(2);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the base 10 logarithm of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function log10(x) {\r\n    return new this(x).log(10);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the maximum of the arguments.\r\n   *\r\n   * arguments {number|string|Decimal}\r\n   *\r\n   */\r\n  function max() {\r\n    return maxOrMin(this, arguments, 'lt');\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the minimum of the arguments.\r\n   *\r\n   * arguments {number|string|Decimal}\r\n   *\r\n   */\r\n  function min() {\r\n    return maxOrMin(this, arguments, 'gt');\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` modulo `y`, rounded to `precision` significant digits\r\n   * using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   * y {number|string|Decimal}\r\n   *\r\n   */\r\n  function mod(x, y) {\r\n    return new this(x).mod(y);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` multiplied by `y`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   * y {number|string|Decimal}\r\n   *\r\n   */\r\n  function mul(x, y) {\r\n    return new this(x).mul(y);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` raised to the power `y`, rounded to precision\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} The base.\r\n   * y {number|string|Decimal} The exponent.\r\n   *\r\n   */\r\n  function pow(x, y) {\r\n    return new this(x).pow(y);\r\n  }\r\n\r\n\r\n  /*\r\n   * Returns a new Decimal with a random value equal to or greater than 0 and less than 1, and with\r\n   * `sd`, or `Decimal.precision` if `sd` is omitted, significant digits (or less if trailing zeros\r\n   * are produced).\r\n   *\r\n   * [sd] {number} Significant digits. Integer, 0 to MAX_DIGITS inclusive.\r\n   *\r\n   */\r\n  function random(sd) {\r\n    var d, e, k, n,\r\n      i = 0,\r\n      r = new this(1),\r\n      rd = [];\r\n\r\n    if (sd === void 0) sd = this.precision;\r\n    else checkInt32(sd, 1, MAX_DIGITS);\r\n\r\n    k = Math.ceil(sd / LOG_BASE);\r\n\r\n    if (!this.crypto) {\r\n      for (; i < k;) rd[i++] = Math.random() * 1e7 | 0;\r\n\r\n    // Browsers supporting crypto.getRandomValues.\r\n    } else if (crypto.getRandomValues) {\r\n      d = crypto.getRandomValues(new Uint32Array(k));\r\n\r\n      for (; i < k;) {\r\n        n = d[i];\r\n\r\n        // 0 <= n < 4294967296\r\n        // Probability n >= 4.29e9, is 4967296 / 4294967296 = 0.00116 (1 in 865).\r\n        if (n >= 4.29e9) {\r\n          d[i] = crypto.getRandomValues(new Uint32Array(1))[0];\r\n        } else {\r\n\r\n          // 0 <= n <= 4289999999\r\n          // 0 <= (n % 1e7) <= 9999999\r\n          rd[i++] = n % 1e7;\r\n        }\r\n      }\r\n\r\n    // Node.js supporting crypto.randomBytes.\r\n    } else if (crypto.randomBytes) {\r\n\r\n      // buffer\r\n      d = crypto.randomBytes(k *= 4);\r\n\r\n      for (; i < k;) {\r\n\r\n        // 0 <= n < 2147483648\r\n        n = d[i] + (d[i + 1] << 8) + (d[i + 2] << 16) + ((d[i + 3] & 0x7f) << 24);\r\n\r\n        // Probability n >= 2.14e9, is 7483648 / 2147483648 = 0.0035 (1 in 286).\r\n        if (n >= 2.14e9) {\r\n          crypto.randomBytes(4).copy(d, i);\r\n        } else {\r\n\r\n          // 0 <= n <= 2139999999\r\n          // 0 <= (n % 1e7) <= 9999999\r\n          rd.push(n % 1e7);\r\n          i += 4;\r\n        }\r\n      }\r\n\r\n      i = k / 4;\r\n    } else {\r\n      throw Error(cryptoUnavailable);\r\n    }\r\n\r\n    k = rd[--i];\r\n    sd %= LOG_BASE;\r\n\r\n    // Convert trailing digits to zeros according to sd.\r\n    if (k && sd) {\r\n      n = mathpow(10, LOG_BASE - sd);\r\n      rd[i] = (k / n | 0) * n;\r\n    }\r\n\r\n    // Remove trailing words which are zero.\r\n    for (; rd[i] === 0; i--) rd.pop();\r\n\r\n    // Zero?\r\n    if (i < 0) {\r\n      e = 0;\r\n      rd = [0];\r\n    } else {\r\n      e = -1;\r\n\r\n      // Remove leading words which are zero and adjust exponent accordingly.\r\n      for (; rd[0] === 0; e -= LOG_BASE) rd.shift();\r\n\r\n      // Count the digits of the first word of rd to determine leading zeros.\r\n      for (k = 1, n = rd[0]; n >= 10; n /= 10) k++;\r\n\r\n      // Adjust the exponent for leading zeros of the first word of rd.\r\n      if (k < LOG_BASE) e -= LOG_BASE - k;\r\n    }\r\n\r\n    r.e = e;\r\n    r.d = rd;\r\n\r\n    return r;\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` rounded to an integer using rounding mode `rounding`.\r\n   *\r\n   * To emulate `Math.round`, set rounding to 7 (ROUND_HALF_CEIL).\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function round(x) {\r\n    return finalise(x = new this(x), x.e + 1, this.rounding);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return\r\n   *   1    if x > 0,\r\n   *  -1    if x < 0,\r\n   *   0    if x is 0,\r\n   *  -0    if x is -0,\r\n   *   NaN  otherwise\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function sign(x) {\r\n    x = new this(x);\r\n    return x.d ? (x.d[0] ? x.s : 0 * x.s) : x.s || NaN;\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the sine of `x`, rounded to `precision` significant digits\r\n   * using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\r\n  function sin(x) {\r\n    return new this(x).sin();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the hyperbolic sine of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\r\n  function sinh(x) {\r\n    return new this(x).sinh();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the square root of `x`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function sqrt(x) {\r\n    return new this(x).sqrt();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` minus `y`, rounded to `precision` significant digits\r\n   * using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   * y {number|string|Decimal}\r\n   *\r\n   */\r\n  function sub(x, y) {\r\n    return new this(x).sub(y);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the sum of the arguments, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * Only the result is rounded, not the intermediate calculations.\r\n   *\r\n   * arguments {number|string|Decimal}\r\n   *\r\n   */\r\n  function sum() {\r\n    var i = 0,\r\n      args = arguments,\r\n      x = new this(args[i]);\r\n\r\n    external = false;\r\n    for (; x.s && ++i < args.length;) x = x.plus(args[i]);\r\n    external = true;\r\n\r\n    return finalise(x, this.precision, this.rounding);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the tangent of `x`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\r\n  function tan(x) {\r\n    return new this(x).tan();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the hyperbolic tangent of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\r\n  function tanh(x) {\r\n    return new this(x).tanh();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` truncated to an integer.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function trunc(x) {\r\n    return finalise(x = new this(x), x.e + 1, 1);\r\n  }\r\n\r\n\r\n  // Create and configure initial Decimal constructor.\r\n  Decimal = clone(DEFAULTS);\r\n  Decimal.prototype.constructor = Decimal;\r\n  Decimal['default'] = Decimal.Decimal = Decimal;\r\n\r\n  // Create the internal constants from their string values.\r\n  LN10 = new Decimal(LN10);\r\n  PI = new Decimal(PI);\r\n\r\n\r\n  // Export.\r\n\r\n\r\n  // AMD.\r\n  if (typeof define == 'function' && define.amd) {\r\n    define(function () {\r\n      return Decimal;\r\n    });\r\n\r\n  // Node and other environments that support module.exports.\r\n  } else if (typeof module != 'undefined' && module.exports) {\r\n    if (typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol') {\r\n      P[Symbol['for']('nodejs.util.inspect.custom')] = P.toString;\r\n      P[Symbol.toStringTag] = 'Decimal';\r\n    }\r\n\r\n    module.exports = Decimal;\r\n\r\n  // Browser.\r\n  } else {\r\n    if (!globalScope) {\r\n      globalScope = typeof self != 'undefined' && self && self.self == self ? self : window;\r\n    }\r\n\r\n    noConflict = globalScope.Decimal;\r\n    Decimal.noConflict = function () {\r\n      globalScope.Decimal = noConflict;\r\n      return Decimal;\r\n    };\r\n\r\n    globalScope.Decimal = Decimal;\r\n  }\r\n})(this);\r\n",null,"/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\nlet libSimpleLog = require('./Manyfest-LogToConsole.js');\n\n/**\n* Hash Translation\n*\n* This is a very simple translation table for hashes, which allows the same schema to resolve \n* differently based on a loaded translation table.\n*\n* This is to prevent the requirement for mutating schemas over and over again when we want to\n* reuse the structure but look up data elements by different addresses.\n*\n* One side-effect of this is that a translation table can \"override\" the built-in hashes, since\n* this is always used to resolve hashes before any of the functionCallByHash(pHash, ...) perform\n* their lookups by hash.\n*\n* @class ManyfestHashTranslation\n*/\nclass ManyfestHashTranslation\n{\n\tconstructor(pInfoLog, pErrorLog)\n\t{\n\t\t// Wire in logging\n\t\tthis.logInfo = (typeof(pInfoLog) === 'function') ? pInfoLog : libSimpleLog;\n\t\tthis.logError = (typeof(pErrorLog) === 'function') ? pErrorLog : libSimpleLog;\n\n        this.translationTable = {};\n\t}\n\n    translationCount()\n    {\n        return Object.keys(this.translationTable).length;\n    }\n\n    addTranslation(pTranslation)\n    {\n        // This adds a translation in the form of:\n        // { \"SourceHash\": \"DestinationHash\", \"SecondSourceHash\":\"SecondDestinationHash\" }\n        if (typeof(pTranslation) != 'object')\n        {\n            this.logError(`Hash translation addTranslation expected a translation be type object but was passed in ${typeof(pTranslation)}`);\n            return false;\n        }\n\n        let tmpTranslationSources = Object.keys(pTranslation)\n\n        tmpTranslationSources.forEach(\n            (pTranslationSource) =>\n            {\n                if (typeof(pTranslation[pTranslationSource]) != 'string')\n                {\n                    this.logError(`Hash translation addTranslation expected a translation destination hash for [${pTranslationSource}] to be a string but the referrant was a ${typeof(pTranslation[pTranslationSource])}`);\n                }\n                else\n                {\n                    this.translationTable[pTranslationSource] = pTranslation[pTranslationSource];\n                }\n            });\n    }\n\n    removeTranslationHash(pTranslationHash)\n    {\n        if (this.translationTable.hasOwnProperty(pTranslationHash))\n        {\n            delete this.translationTable[pTranslationHash];\n        }\n    }\n\n    // This removes translations.\n    // If passed a string, just removes the single one.\n    // If passed an object, it does all the source keys.\n    removeTranslation(pTranslation)\n    {\n        if (typeof(pTranslation) == 'string')\n        {\n            this.removeTranslationHash(pTranslation);\n            return true;\n        }\n        else if (typeof(pTranslation) == 'object')\n        {\n            let tmpTranslationSources = Object.keys(pTranslation)\n\n            tmpTranslationSources.forEach(\n                (pTranslationSource) =>\n                {\n                    this.removeTranslation(pTranslationSource);\n                });\n            return true;\n        }\n        else\n        {\n            this.logError(`Hash translation removeTranslation expected either a string or an object but the passed-in translation was type ${typeof(pTranslation)}`);\n            return false;\n        }\n    }\n\n    clearTranslations()\n    {\n        this.translationTable = {};\n    }\n\n    translate(pTranslation)\n    {\n        if (this.translationTable.hasOwnProperty(pTranslation))\n        {\n            return this.translationTable[pTranslation];\n        }\n        else\n        {\n            return pTranslation;\n        }\n    }\n}\n\nmodule.exports = ManyfestHashTranslation;","/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\n\n/**\n* Manyfest simple logging shim (for browser and dependency-free running)\n*/\n\nconst logToConsole = (pLogLine, pLogObject) =>\n{\n    let tmpLogLine = (typeof(pLogLine) === 'string') ? pLogLine : '';\n\n    console.log(`[Manyfest] ${tmpLogLine}`);\n\n    if (pLogObject) console.log(JSON.stringify(pLogObject));\n};\n\nmodule.exports = logToConsole;","/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\nlet libSimpleLog = require('./Manyfest-LogToConsole.js');\n\n/**\n* Object Address Generation\n*\n* Automagically generate addresses and properties based on a passed-in object, \n* to be used for easy creation of schemas.  Meant to simplify the lives of\n* developers wanting to create schemas without typing a bunch of stuff.\n* \n* IMPORTANT NOTE: This code is intentionally more verbose than necessary, to\n*                 be extremely clear what is going on in the recursion for\n*                 each of the three address resolution functions.\n* \n*                 Although there is some opportunity to repeat ourselves a\n*                 bit less in this codebase (e.g. with detection of arrays\n*                 versus objects versus direct properties), it can make\n*                 debugging.. challenging.  The minified version of the code\n*                 optimizes out almost anything repeated in here.  So please\n*                 be kind and rewind... meaning please keep the codebase less\n*                 terse and more verbose so humans can comprehend it.\n*                 \n*\n* @class ManyfestObjectAddressGeneration\n*/\nclass ManyfestObjectAddressGeneration\n{\n\tconstructor(pInfoLog, pErrorLog)\n\t{\n\t\t// Wire in logging\n\t\tthis.logInfo = (typeof(pInfoLog) == 'function') ? pInfoLog : libSimpleLog;\n\t\tthis.logError = (typeof(pErrorLog) == 'function') ? pErrorLog : libSimpleLog;\n\t}\n\n\t// generateAddressses\n\t//\n\t// This flattens an object into a set of key:value pairs for *EVERY SINGLE\n\t// POSSIBLE ADDRESS* in the object.  It can get ... really insane really\n\t// quickly.  This is not meant to be used directly to generate schemas, but\n\t// instead as a starting point for scripts or UIs.\n\t//\n\t// This will return a mega set of key:value pairs with all possible schema \n\t// permutations and default values (when not an object) and everything else.\n\tgenerateAddressses (pObject, pBaseAddress, pSchema)\n\t{\n\t\tlet tmpBaseAddress = (typeof(pBaseAddress) == 'string') ? pBaseAddress : '';\n\t\tlet tmpSchema = (typeof(pSchema) == 'object') ? pSchema : {};\n\n\t\tlet tmpObjectType = typeof(pObject);\n\n\t\tlet tmpSchemaObjectEntry = (\n\t\t\t{\n\t\t\t\tAddress: tmpBaseAddress,\n\t\t\t\tHash: tmpBaseAddress,\n\t\t\t\tName: tmpBaseAddress,\n\t\t\t\t// This is so scripts and UI controls can force a developer to opt-in.\n\t\t\t\tInSchema: false\n\t\t\t}\n\t\t)\n\n\t\tswitch(tmpObjectType)\n\t\t{\n\t\t\tcase 'string':\n\t\t\t\ttmpSchemaObjectEntry.DataType = 'String';\n\t\t\t\ttmpSchemaObjectEntry.Default = pObject;\n\t\t\t\ttmpSchema[tmpBaseAddress] = tmpSchemaObjectEntry;\n\t\t\t\tbreak;\n\t\t\tcase 'number':\n\t\t\tcase 'bigint':\n\t\t\t\ttmpSchemaObjectEntry.DataType = 'Number';\n\t\t\t\ttmpSchemaObjectEntry.Default = pObject;\n\t\t\t\ttmpSchema[tmpBaseAddress] = tmpSchemaObjectEntry;\n\t\t\t\tbreak;\n\t\t\tcase 'undefined':\n\t\t\t\ttmpSchemaObjectEntry.DataType = 'Any';\n\t\t\t\ttmpSchemaObjectEntry.Default = pObject;\n\t\t\t\ttmpSchema[tmpBaseAddress] = tmpSchemaObjectEntry;\n\t\t\t\tbreak;\n\t\t\tcase 'object':\n\t\t\t\tif (Array.isArray(pObject))\n\t\t\t\t{\n\t\t\t\t\ttmpSchemaObjectEntry.DataType = 'Array';\n\t\t\t\t\tif (tmpBaseAddress != '')\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpSchema[tmpBaseAddress] = tmpSchemaObjectEntry;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tfor (let i = 0; i < pObject.length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.generateAddressses(pObject[i], `${tmpBaseAddress}[${i}]`, tmpSchema);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttmpSchemaObjectEntry.DataType = 'Object';\n\t\t\t\t\tif (tmpBaseAddress != '')\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpSchema[tmpBaseAddress] = tmpSchemaObjectEntry;\n\t\t\t\t\t\ttmpBaseAddress += '.';\n\t\t\t\t\t}\n\t\n\t\t\t\t\tlet tmpObjectProperties = Object.keys(pObject);\n\n\t\t\t\t\tfor (let i = 0; i < tmpObjectProperties.length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.generateAddressses(pObject[tmpObjectProperties[i]], `${tmpBaseAddress}${tmpObjectProperties[i]}`, tmpSchema);\n\t\t\t\t\t}\t\t\t\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'symbol':\n\t\t\tcase 'function':\n\t\t\t\t// Symbols and functions neither recurse nor get added to the schema\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn tmpSchema;\n\t}\n};\n\nmodule.exports = ManyfestObjectAddressGeneration;","/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\nlet libSimpleLog = require('./Manyfest-LogToConsole.js');\n\n/**\n* Object Address Resolver\n* \n* IMPORTANT NOTE: This code is intentionally more verbose than necessary, to\n*                 be extremely clear what is going on in the recursion for\n*                 each of the three address resolution functions.\n* \n*                 Although there is some opportunity to repeat ourselves a\n*                 bit less in this codebase (e.g. with detection of arrays\n*                 versus objects versus direct properties), it can make\n*                 debugging.. challenging.  The minified version of the code\n*                 optimizes out almost anything repeated in here.  So please\n*                 be kind and rewind... meaning please keep the codebase less\n*                 terse and more verbose so humans can comprehend it.\n*                 \n*\n* @class ManyfestObjectAddressResolver\n*/\nclass ManyfestObjectAddressResolver\n{\n\tconstructor(pInfoLog, pErrorLog)\n\t{\n\t\t// Wire in logging\n\t\tthis.logInfo = (typeof(pInfoLog) == 'function') ? pInfoLog : libSimpleLog;\n\t\tthis.logError = (typeof(pErrorLog) == 'function') ? pErrorLog : libSimpleLog;\n\t}\n\n\t// When a boxed property is passed in, it should have quotes of some\n\t// kind around it.\n\t//\n\t// For instance:\n\t// \t\tMyValues['Name']\n\t// \t\tMyValues[\"Age\"]\n\t// \t\tMyValues[`Cost`]\n\t//\n\t// This function removes the wrapping quotes.\n\t//\n\t// Please note it *DOES NOT PARSE* template literals, so backticks just\n\t// end up doing the same thing as other quote types.\n\t//\n\t// TODO: Should template literals be processed?  If so what state do they have access to?\n\tcleanWrapCharacters (pCharacter, pString)\n\t{\n\t\tif (pString.startsWith(pCharacter) && pString.endsWith(pCharacter))\n\t\t{\n\t\t\treturn pString.substring(1, pString.length - 1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn pString;\n\t\t}\n\t}\n\n\t// Check if an address exists.\n\t//\n\t// This is necessary because the getValueAtAddress function is ambiguous on \n\t// whether the element/property is actually there or not (it returns \n\t// undefined whether the property exists or not).  This function checks for\n\t// existance and returns true or false dependent.\n\tcheckAddressExists (pObject, pAddress)\n\t{\n\t\t// TODO: Should these throw an error?\n\t\t// Make sure pObject is an object\n\t\tif (typeof(pObject) != 'object') return false;\n\t\t// Make sure pAddress is a string\n\t\tif (typeof(pAddress) != 'string') return false;\n\n\t\t// TODO: Make this work for things like SomeRootObject.Metadata[\"Some.People.Use.Bad.Object.Property.Names\"]\n\t\tlet tmpSeparatorIndex = pAddress.indexOf('.');\n\n\t\t// This is the terminal address string (no more dots so the RECUSION ENDS IN HERE somehow)\n\t\tif (tmpSeparatorIndex == -1)\n\t\t{\n\t\t\t// Check if the address refers to a boxed property\n\t\t\tlet tmpBracketStartIndex = pAddress.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = pAddress.indexOf(']');\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[10]\n\t\t\t// \t\tMyValues['Name']\n\t\t\t// \t\tMyValues[\"Age\"]\n\t\t\t// \t\tMyValues[`Cost`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpBracketStartIndex > 0) \n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex) \n\t\t\t//    3) There is data \n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 1))\n\t\t\t{\n\t\t\t\t// The \"Name\" of the Object contained too the left of the bracket\n\t\t\t\tlet tmpBoxedPropertyName = pAddress.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\t// If the subproperty doesn't test as a proper Object, none of the rest of this is possible.\n\t\t\t\t// This is a rare case where Arrays testing as Objects is useful\n\t\t\t\tif (typeof(pObject[tmpBoxedPropertyName]) !== 'object')\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// The \"Reference\" to the property within it, either an array element or object property\n\t\t\t\tlet tmpBoxedPropertyReference = pAddress.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\t\t\t\t// Attempt to parse the reference as a number, which will be used as an array element\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to treat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynamic object property.\n\t\t\t\t\t// We would expect the property to be wrapped in some kind of quotes so strip them\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\t// Check if the property exists.\n\t\t\t\t\treturn pObject[tmpBoxedPropertyName].hasOwnProperty(tmpBoxedPropertyReference);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Use the new in operator to see if the element is in the array\n\t\t\t\t\treturn (tmpBoxedPropertyNumber in pObject[tmpBoxedPropertyName]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Check if the property exists\n\t\t\t\treturn pObject.hasOwnProperty(pAddress);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlet tmpSubObjectName = pAddress.substring(0, tmpSeparatorIndex);\n\t\t\tlet tmpNewAddress = pAddress.substring(tmpSeparatorIndex+1);\n\n\t\t\t// Test if the tmpNewAddress is an array or object\n\t\t\t// Check if it's a boxed property\n\t\t\tlet tmpBracketStartIndex = tmpSubObjectName.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = tmpSubObjectName.indexOf(']');\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[42]\n\t\t\t// \t\tMyValues['Color']\n\t\t\t// \t\tMyValues[\"Weight\"]\n\t\t\t// \t\tMyValues[`Diameter`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpBracketStartIndex > 0) \n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex) \n\t\t\t//    3) There is data \n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 1))\n\t\t\t{\n\t\t\t\tlet tmpBoxedPropertyName = tmpSubObjectName.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyReference = tmpSubObjectName.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[1].Tardy\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an object, so the [1].Tardy is not possible to access\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[\"JaneDoe\"].Grade\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an array, so the [\"JaneDoe\"].Grade is not possible to access\n\t\t\t\t// TODO: Should this be an error or something?  Should we keep a log of failures like this?\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// Because this is an impossible address, the property doesn't exist\n\t\t\t\t\t// TODO: Should we throw an error in this condition?\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t//This is a bracketed value\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to reat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynanmic object property.\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\t// Recurse directly into the subobject\n\t\t\t\t\treturn this.checkAddressExists(pObject[tmpBoxedPropertyName][tmpBoxedPropertyReference], tmpNewAddress);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// We parsed a valid number out of the boxed property name, so recurse into the array\n\t\t\t\t\treturn this.checkAddressExists(pObject[tmpBoxedPropertyName][tmpBoxedPropertyNumber], tmpNewAddress);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If there is an object property already named for the sub object, but it isn't an object\n\t\t\t// then the system can't set the value in there.  Error and abort!\n\t\t\tif (pObject.hasOwnProperty(tmpSubObjectName) && typeof(pObject[tmpSubObjectName]) !== 'object')\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse if (pObject.hasOwnProperty(tmpSubObjectName))\n\t\t\t{\n\t\t\t\t// If there is already a subobject pass that to the recursive thingy\n\t\t\t\treturn this.checkAddressExists(pObject[tmpSubObjectName], tmpNewAddress);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Create a subobject and then pass that\n\t\t\t\tpObject[tmpSubObjectName] = {};\n\t\t\t\treturn this.checkAddressExists(pObject[tmpSubObjectName], tmpNewAddress);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Get the value of an element at an address\n\tgetValueAtAddress (pObject, pAddress, pParentAddress)\n\t{\n\t\t// Make sure pObject is an object\n\t\tif (typeof(pObject) != 'object') return undefined;\n\t\t// Make sure pAddress is a string\n\t\tif (typeof(pAddress) != 'string') return undefined;\n\t\tlet tmpParentAddress = \"\";\n\t\tif (typeof(pParentAddress) == 'string')\n\t\t{\n\t\t\ttmpParentAddress = pParentAddress;\n\t\t}\n\n\t\t// TODO: Make this work for things like SomeRootObject.Metadata[\"Some.People.Use.Bad.Object.Property.Names\"]\n\t\tlet tmpSeparatorIndex = pAddress.indexOf('.');\n\n\t\t// This is the terminal address string (no more dots so the RECUSION ENDS IN HERE somehow)\n\t\tif (tmpSeparatorIndex == -1)\n\t\t{\n\t\t\t// Check if the address refers to a boxed property\n\t\t\tlet tmpBracketStartIndex = pAddress.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = pAddress.indexOf(']');\n\n\t\t\t// Check for the Object Set Type marker.\n\t\t\t// Note this will not work with a bracket in the same address box set\n\t\t\tlet tmpObjectTypeMarkerIndex = pAddress.indexOf('{}');\n\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[10]\n\t\t\t// \t\tMyValues['Name']\n\t\t\t// \t\tMyValues[\"Age\"]\n\t\t\t// \t\tMyValues[`Cost`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpBracketStartIndex > 0) \n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex) \n\t\t\t//    3) There is data \n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 1))\n\t\t\t{\n\t\t\t\t// The \"Name\" of the Object contained too the left of the bracket\n\t\t\t\tlet tmpBoxedPropertyName = pAddress.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\t// If the subproperty doesn't test as a proper Object, none of the rest of this is possible.\n\t\t\t\t// This is a rare case where Arrays testing as Objects is useful\n\t\t\t\tif (typeof(pObject[tmpBoxedPropertyName]) !== 'object')\n\t\t\t\t{\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\t// The \"Reference\" to the property within it, either an array element or object property\n\t\t\t\tlet tmpBoxedPropertyReference = pAddress.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\t\t\t\t// Attempt to parse the reference as a number, which will be used as an array element\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to treat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynamic object property.\n\t\t\t\t\t// We would expect the property to be wrapped in some kind of quotes so strip them\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\t// Return the value in the property\n\t\t\t\t\treturn pObject[tmpBoxedPropertyName][tmpBoxedPropertyReference];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treturn pObject[tmpBoxedPropertyName][tmpBoxedPropertyNumber];\n\t\t\t\t}\n\t\t\t}\n\t\t\t// The requirements to detect a boxed set element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\telse if ((tmpBracketStartIndex > 0) \n\t\t\t//    2) The end bracket is after the start bracket\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex) \n\t\t\t//    3) There is nothing in the brackets\n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex == 1))\n\t\t\t{\n\t\t\t\tlet tmpBoxedPropertyName = pAddress.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\tif (!Array.isArray(pObject[tmpBoxedPropertyName]))\n\t\t\t\t{\n\t\t\t\t\t// We asked for a set from an array but it isnt' an array.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\treturn pObject[tmpBoxedPropertyName];\n\t\t\t}\n\t\t\t// The object has been flagged as an object set, so treat it as such\n\t\t\telse if (tmpObjectTypeMarkerIndex > 0)\n\t\t\t{\n\t\t\t\tlet tmpObjectPropertyName = pAddress.substring(0, tmpObjectTypeMarkerIndex).trim();\n\n\t\t\t\tif (typeof(pObject[tmpObjectPropertyName]) != 'object')\n\t\t\t\t{\n\t\t\t\t\t// We asked for a set from an array but it isnt' an array.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\treturn pObject[tmpObjectPropertyName];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Now is the point in recursion to return the value in the address\n\t\t\t\treturn pObject[pAddress];\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlet tmpSubObjectName = pAddress.substring(0, tmpSeparatorIndex);\n\t\t\tlet tmpNewAddress = pAddress.substring(tmpSeparatorIndex+1);\n\n\t\t\t// BOXED ELEMENTS\n\t\t\t// Test if the tmpNewAddress is an array or object\n\t\t\t// Check if it's a boxed property\n\t\t\tlet tmpBracketStartIndex = tmpSubObjectName.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = tmpSubObjectName.indexOf(']');\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[42]\n\t\t\t// \t\tMyValues['Color']\n\t\t\t// \t\tMyValues[\"Weight\"]\n\t\t\t// \t\tMyValues[`Diameter`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpBracketStartIndex > 0) \n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex) \n\t\t\t//    3) There is data \n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 1))\n\t\t\t{\n\t\t\t\tlet tmpBoxedPropertyName = tmpSubObjectName.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyReference = tmpSubObjectName.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[1].Tardy\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an object, so the [1].Tardy is not possible to access\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[\"JaneDoe\"].Grade\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an array, so the [\"JaneDoe\"].Grade is not possible to access\n\t\t\t\t// TODO: Should this be an error or something?  Should we keep a log of failures like this?\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\t//This is a bracketed value\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to reat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynanmic object property.\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\t// Continue to manage the parent address for recursion\n\t\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpSubObjectName}`;\n\t\t\t\t\t// Recurse directly into the subobject\n\t\t\t\t\treturn this.getValueAtAddress(pObject[tmpBoxedPropertyName][tmpBoxedPropertyReference], tmpNewAddress, tmpParentAddress);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Continue to manage the parent address for recursion\n\t\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpSubObjectName}`;\n\t\t\t\t\t// We parsed a valid number out of the boxed property name, so recurse into the array\n\t\t\t\t\treturn this.getValueAtAddress(pObject[tmpBoxedPropertyName][tmpBoxedPropertyNumber], tmpNewAddress, tmpParentAddress);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// The requirements to detect a boxed set element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\telse if ((tmpBracketStartIndex > 0) \n\t\t\t//    2) The end bracket is after the start bracket\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex) \n\t\t\t//    3) There is nothing in the brackets\n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex == 1))\n\t\t\t{\n\t\t\t\tlet tmpBoxedPropertyName = pAddress.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\tif (!Array.isArray(pObject[tmpBoxedPropertyName]))\n\t\t\t\t{\n\t\t\t\t\t// We asked for a set from an array but it isnt' an array.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// We need to enumerate the array and grab the addresses from there.\n\t\t\t\tlet tmpArrayProperty = pObject[tmpBoxedPropertyName];\n\t\t\t\t// Managing the parent address is a bit more complex here -- the box will be added for each element.\n\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpBoxedPropertyName}`;\n\t\t\t\t// The container object is where we have the \"Address\":SOMEVALUE pairs\n\t\t\t\tlet tmpContainerObject = {};\n\t\t\t\tfor (let i = 0; i < tmpArrayProperty.length; i++)\n\t\t\t\t{\n\t\t\t\t\tlet tmpPropertyParentAddress = `${tmpParentAddress}[${i}]`;\n\t\t\t\t\tlet tmpValue = this.getValueAtAddress(pObject[tmpBoxedPropertyName][i], tmpNewAddress, tmpPropertyParentAddress);;\n\t\t\t\t\ttmpContainerObject[`${tmpPropertyParentAddress}.${tmpNewAddress}`] = tmpValue;\n\t\t\t\t}\n\n\t\t\t\treturn tmpContainerObject;\n\t\t\t}\n\n\t\t\t// OBJECT SET\n\t\t\t// Note this will not work with a bracket in the same address box set\n\t\t\tlet tmpObjectTypeMarkerIndex = pAddress.indexOf('{}');\n\t\t\tif (tmpObjectTypeMarkerIndex > 0)\n\t\t\t{\n\t\t\t\tlet tmpObjectPropertyName = pAddress.substring(0, tmpObjectTypeMarkerIndex).trim();\n\n\t\t\t\tif (typeof(pObject[tmpObjectPropertyName]) != 'object')\n\t\t\t\t{\n\t\t\t\t\t// We asked for a set from an array but it isnt' an array.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// We need to enumerate the Object and grab the addresses from there.\n\t\t\t\tlet tmpObjectProperty = pObject[tmpObjectPropertyName];\n\t\t\t\tlet tmpObjectPropertyKeys = Object.keys(tmpObjectProperty);\n\t\t\t\t// Managing the parent address is a bit more complex here -- the box will be added for each element.\n\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpObjectPropertyName}`;\n\t\t\t\t// The container object is where we have the \"Address\":SOMEVALUE pairs\n\t\t\t\tlet tmpContainerObject = {};\n\t\t\t\tfor (let i = 0; i < tmpObjectPropertyKeys.length; i++)\n\t\t\t\t{\n\t\t\t\t\tlet tmpPropertyParentAddress = `${tmpParentAddress}.${tmpObjectPropertyKeys[i]}`;\n\t\t\t\t\tlet tmpValue = this.getValueAtAddress(pObject[tmpObjectPropertyName][tmpObjectPropertyKeys[i]], tmpNewAddress, tmpPropertyParentAddress);;\n\t\t\t\t\ttmpContainerObject[`${tmpPropertyParentAddress}.${tmpNewAddress}`] = tmpValue;\n\t\t\t\t}\n\n\t\t\t\treturn tmpContainerObject;\n\t\t\t}\n\n\t\t\t// If there is an object property already named for the sub object, but it isn't an object\n\t\t\t// then the system can't set the value in there.  Error and abort!\n\t\t\tif (pObject.hasOwnProperty(tmpSubObjectName) && typeof(pObject[tmpSubObjectName]) !== 'object')\n\t\t\t{\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\telse if (pObject.hasOwnProperty(tmpSubObjectName))\n\t\t\t{\n\t\t\t\t// If there is already a subobject pass that to the recursive thingy\n\t\t\t\t// Continue to manage the parent address for recursion\n\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpSubObjectName}`;\n\t\t\t\treturn this.getValueAtAddress(pObject[tmpSubObjectName], tmpNewAddress, tmpParentAddress);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Create a subobject and then pass that\n\t\t\t\t// Continue to manage the parent address for recursion\n\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpSubObjectName}`;\n\t\t\t\tpObject[tmpSubObjectName] = {};\n\t\t\t\treturn this.getValueAtAddress(pObject[tmpSubObjectName], tmpNewAddress, tmpParentAddress);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Set the value of an element at an address\n\tsetValueAtAddress (pObject, pAddress, pValue)\n\t{\n\t\t// Make sure pObject is an object\n\t\tif (typeof(pObject) != 'object') return false;\n\t\t// Make sure pAddress is a string\n\t\tif (typeof(pAddress) != 'string') return false;\n\n\t\tlet tmpSeparatorIndex = pAddress.indexOf('.');\n\n\t\tif (tmpSeparatorIndex == -1)\n\t\t{\n\t\t\t// Check if it's a boxed property\n\t\t\tlet tmpBracketStartIndex = pAddress.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = pAddress.indexOf(']');\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[10]\n\t\t\t// \t\tMyValues['Name']\n\t\t\t// \t\tMyValues[\"Age\"]\n\t\t\t// \t\tMyValues[`Cost`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpBracketStartIndex > 0) \n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex) \n\t\t\t//    3) There is data \n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 1))\n\t\t\t{\n\t\t\t\t// The \"Name\" of the Object contained too the left of the bracket\n\t\t\t\tlet tmpBoxedPropertyName = pAddress.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\t// If the subproperty doesn't test as a proper Object, none of the rest of this is possible.\n\t\t\t\t// This is a rare case where Arrays testing as Objects is useful\n\t\t\t\tif (typeof(pObject[tmpBoxedPropertyName]) !== 'object')\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// The \"Reference\" to the property within it, either an array element or object property\n\t\t\t\tlet tmpBoxedPropertyReference = pAddress.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\t\t\t\t// Attempt to parse the reference as a number, which will be used as an array element\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to treat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynamic object property.\n\t\t\t\t\t// We would expect the property to be wrapped in some kind of quotes so strip them\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\t// Return the value in the property\n\t\t\t\t\tpObject[tmpBoxedPropertyName][tmpBoxedPropertyReference] = pValue;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tpObject[tmpBoxedPropertyName][tmpBoxedPropertyNumber] = pValue;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Now is the time in recursion to set the value in the object\n\t\t\t\tpObject[pAddress] = pValue;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlet tmpSubObjectName = pAddress.substring(0, tmpSeparatorIndex);\n\t\t\tlet tmpNewAddress = pAddress.substring(tmpSeparatorIndex+1);\n\n\t\t\t// Test if the tmpNewAddress is an array or object\n\t\t\t// Check if it's a boxed property\n\t\t\tlet tmpBracketStartIndex = tmpSubObjectName.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = tmpSubObjectName.indexOf(']');\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[42]\n\t\t\t// \t\tMyValues['Color']\n\t\t\t// \t\tMyValues[\"Weight\"]\n\t\t\t// \t\tMyValues[`Diameter`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpBracketStartIndex > 0) \n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex) \n\t\t\t//    3) There is data \n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 1))\n\t\t\t{\n\t\t\t\tlet tmpBoxedPropertyName = tmpSubObjectName.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyReference = tmpSubObjectName.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[1].Tardy\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an object, so the [1].Tardy is not possible to access\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[\"JaneDoe\"].Grade\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an array, so the [\"JaneDoe\"].Grade is not possible to access\n\t\t\t\t// TODO: Should this be an error or something?  Should we keep a log of failures like this?\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t//This is a bracketed value\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to reat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynanmic object property.\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\t// Recurse directly into the subobject\n\t\t\t\t\treturn this.setValueAtAddress(pObject[tmpBoxedPropertyName][tmpBoxedPropertyReference], tmpNewAddress, pValue);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// We parsed a valid number out of the boxed property name, so recurse into the array\n\t\t\t\t\treturn this.setValueAtAddress(pObject[tmpBoxedPropertyName][tmpBoxedPropertyNumber], tmpNewAddress, pValue);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If there is an object property already named for the sub object, but it isn't an object\n\t\t\t// then the system can't set the value in there.  Error and abort!\n\t\t\tif (pObject.hasOwnProperty(tmpSubObjectName) && typeof(pObject[tmpSubObjectName]) !== 'object')\n\t\t\t{\n\t\t\t\tif (!pObject.hasOwnProperty('__ERROR'))\n\t\t\t\t\tpObject['__ERROR'] = {};\n\t\t\t\t// Put it in an error object so data isn't lost\n\t\t\t\tpObject['__ERROR'][pAddress] = pValue;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse if (pObject.hasOwnProperty(tmpSubObjectName))\n\t\t\t{\n\t\t\t\t// If there is already a subobject pass that to the recursive thingy\n\t\t\t\treturn this.setValueAtAddress(pObject[tmpSubObjectName], tmpNewAddress, pValue);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Create a subobject and then pass that\n\t\t\t\tpObject[tmpSubObjectName] = {};\n\t\t\t\treturn this.setValueAtAddress(pObject[tmpSubObjectName], tmpNewAddress, pValue);\n\t\t\t}\n\t\t}\n\t}\n};\n\nmodule.exports = ManyfestObjectAddressResolver;","/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\nlet libSimpleLog = require('./Manyfest-LogToConsole.js');\n\n/**\n* Schema Manipulation Functions\n*\n* @class ManyfestSchemaManipulation\n*/\nclass ManyfestSchemaManipulation\n{\n\tconstructor(pInfoLog, pErrorLog)\n\t{\n\t\t// Wire in logging\n\t\tthis.logInfo = (typeof(pInfoLog) === 'function') ? pInfoLog : libSimpleLog;\n\t\tthis.logError = (typeof(pErrorLog) === 'function') ? pErrorLog : libSimpleLog;\n\t}\n\n    // This translates the default address mappings to something different.\n    //\n    // For instance you can pass in manyfest schema descriptor object:\n    // \t{\n\t//\t  \"Address.Of.a\": { \"Hash\": \"a\", \"Type\": \"Number\" },\n\t//\t  \"Address.Of.b\": { \"Hash\": \"b\", \"Type\": \"Number\" }\n\t//  }\n    //\n    //\n    // And then an address mapping (basically a Hash->Address map)\n    //  {\n    //    \"a\": \"New.Address.Of.a\",\n    //    \"b\": \"New.Address.Of.b\"  \n    //  }\n    //\n    // NOTE: This mutates the schema object permanently, altering the base hash.\n    //       If there is a collision with an existing address, it can lead to overwrites.\n    // TODO: Discuss what should happen on collisions.\n\tresolveAddressMappings(pManyfestSchemaDescriptors, pAddressMapping)\n\t{\n\t\tif (typeof(pManyfestSchemaDescriptors) != 'object')\n\t\t{\n\t\t\tthis.logError(`Attempted to resolve address mapping but the descriptor was not an object.`);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (typeof(pAddressMapping) != 'object')\n\t\t{\n\t\t\t// No mappings were passed in\n\t\t\treturn true;\n\t\t}\n\n\t\t// Get the arrays of both the schema definition and the hash mapping\n\t\tlet tmpManyfestAddresses = Object.keys(pManyfestSchemaDescriptors);\n\t\tlet tmpHashMapping = {};\n\t\ttmpManyfestAddresses.forEach(\n\t\t\t(pAddress) =>\n\t\t\t{\n\t\t\t\tif (pManyfestSchemaDescriptors[pAddress].hasOwnProperty('Hash'))\n\t\t\t\t{\n\t\t\t\t\ttmpHashMapping[pManyfestSchemaDescriptors[pAddress].Hash] = pAddress;\n\t\t\t\t}\n\t\t\t});\n\n\t\tlet tmpAddressMappingSet = Object.keys(pAddressMapping);\n\n\t\ttmpAddressMappingSet.forEach(\n\t\t\t(pInputAddress) =>\n\t\t\t{\n\t\t\t\tlet tmpNewDescriptorAddress = pAddressMapping[pInputAddress];\n\t\t\t\tlet tmpOldDescriptorAddress = false;\n\t\t\t\tlet tmpDescriptor = false;\n\n\t\t\t\t// See if there is a matching descriptor either by Address directly or Hash\n\t\t\t\tif (pManyfestSchemaDescriptors.hasOwnProperty(pInputAddress))\n\t\t\t\t{\n\t\t\t\t\ttmpOldDescriptorAddress = pInputAddress;\n\t\t\t\t}\n\t\t\t\telse if (tmpHashMapping.hasOwnProperty(pInputAddress))\n\t\t\t\t{\n\t\t\t\t\ttmpOldDescriptorAddress = tmpHashMapping[pInputAddress];\n\t\t\t\t}\n\n\t\t\t\t// If there was a matching descriptor in the manifest, store it in the temporary descriptor\n\t\t\t\tif (tmpOldDescriptorAddress)\n\t\t\t\t{\n\t\t\t\t\ttmpDescriptor = pManyfestSchemaDescriptors[tmpOldDescriptorAddress];\n\t\t\t\t\tdelete pManyfestSchemaDescriptors[tmpOldDescriptorAddress];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Create a new descriptor!  Map it to the input address.\n\t\t\t\t\ttmpDescriptor = { Hash:pInputAddress };\n\t\t\t\t}\n\n\t\t\t\t// Now re-add the descriptor to the manyfest schema\n\t\t\t\tpManyfestSchemaDescriptors[tmpNewDescriptorAddress] = tmpDescriptor;\n\t\t\t});\n\n\t\treturn true;\n\t}\n\n\tsafeResolveAddressMappings(pManyfestSchemaDescriptors, pAddressMapping)\n\t{\n\t\t// This returns the descriptors as a new object, safely remapping without mutating the original schema Descriptors\n\t\tlet tmpManyfestSchemaDescriptors = JSON.parse(JSON.stringify(pManyfestSchemaDescriptors));\n\t\tthis.resolveAddressMappings(tmpManyfestSchemaDescriptors, pAddressMapping);\n\t\treturn tmpManyfestSchemaDescriptors;\n\t}\n\n\tmergeAddressMappings(pManyfestSchemaDescriptorsDestination, pManyfestSchemaDescriptorsSource)\n\t{\n\t\tif ((typeof(pManyfestSchemaDescriptorsSource) != 'object') || (typeof(pManyfestSchemaDescriptorsDestination) != 'object'))\n\t\t{\n\t\t\tthis.logError(`Attempted to merge two schema descriptors but both were not objects.`);\n\t\t\treturn false;\n\t\t}\n\n\t\tlet tmpSource = JSON.parse(JSON.stringify(pManyfestSchemaDescriptorsSource));\n\t\tlet tmpNewManyfestSchemaDescriptors = JSON.parse(JSON.stringify(pManyfestSchemaDescriptorsDestination));\n\n\t\t// The first passed-in set of descriptors takes precedence.\n\t\tlet tmpDescriptorAddresses = Object.keys(tmpSource);\n\n\t\ttmpDescriptorAddresses.forEach(\n\t\t\t(pDescriptorAddress) => \n\t\t\t{\n\t\t\t\tif (!tmpNewManyfestSchemaDescriptors.hasOwnProperty(pDescriptorAddress))\n\t\t\t\t{\n\t\t\t\t\ttmpNewManyfestSchemaDescriptors[pDescriptorAddress] = tmpSource[pDescriptorAddress];\n\t\t\t\t}\n\t\t\t});\n\t\t\n\t\treturn tmpNewManyfestSchemaDescriptors;\n\t}\n}\n\nmodule.exports = ManyfestSchemaManipulation;","/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\nlet libSimpleLog = require('./Manyfest-LogToConsole.js');\n\nlet libHashTranslation = require('./Manyfest-HashTranslation.js');\nlet libObjectAddressResolver = require('./Manyfest-ObjectAddressResolver.js');\nlet libObjectAddressGeneration = require('./Manyfest-ObjectAddressGeneration.js');\nlet libSchemaManipulation = require('./Manyfest-SchemaManipulation.js');\n\n\n/**\n* Manyfest object address-based descriptions and manipulations.\n*\n* @class Manyfest\n*/\nclass Manyfest\n{\n\tconstructor(pManifest, pInfoLog, pErrorLog, pOptions)\n\t{\n\t\t// Wire in logging\n\t\tthis.logInfo = (typeof(pInfoLog) === 'function') ? pInfoLog : libSimpleLog;\n\t\tthis.logError = (typeof(pErrorLog) === 'function') ? pErrorLog : libSimpleLog;\n\n\t\t// Create an object address resolver and map in the functions\n\t\tthis.objectAddressResolver = new libObjectAddressResolver(this.logInfo, this.logError);\n\n\t\tthis.options = (\n\t\t\t{\n\t\t\t\tstrict: false,\n\t\t\t\tdefaultValues: \n\t\t\t\t\t{\n\t\t\t\t\t\t\"String\": \"\",\n\t\t\t\t\t\t\"Number\": 0,\n\t\t\t\t\t\t\"Float\": 0.0,\n\t\t\t\t\t\t\"Integer\": 0,\n\t\t\t\t\t\t\"Boolean\": false,\n\t\t\t\t\t\t\"Binary\": 0,\n\t\t\t\t\t\t\"DateTime\": 0,\n\t\t\t\t\t\t\"Array\": [],\n\t\t\t\t\t\t\"Object\": {},\n\t\t\t\t\t\t\"Null\": null\n\t\t\t\t\t}\n\t\t\t});\n\n\t\tthis.scope = undefined;\n\t\tthis.elementAddresses = undefined;\n\t\tthis.elementHashes = undefined;\n\t\tthis.elementDescriptors = undefined;\n\n\t\tthis.reset();\n\n\t\tif (typeof(pManifest) === 'object')\n\t\t{\n\t\t\tthis.loadManifest(pManifest);\n\t\t}\n\n\t\tthis.schemaManipulations = new libSchemaManipulation(this.logInfo, this.logError);\n\t\tthis.objectAddressGeneration = new libObjectAddressGeneration(this.logInfo, this.logError);\n\n\t\tthis.hashTranslations = new libHashTranslation(this.logInfo, this.logError);\n\t}\n\n\t/*************************************************************************\n\t * Schema Manifest Loading, Reading, Manipulation and Serialization Functions\n\t */\n\n\t// Reset critical manifest properties\n\treset()\n\t{\n\t\tthis.scope = 'DEFAULT';\n\t\tthis.elementAddresses = [];\n\t\tthis.elementHashes = {};\n\t\tthis.elementDescriptors = {};\n\t}\n\n\tclone()\n\t{\n\t\t// Make a copy of the options in-place\n\t\tlet tmpNewOptions = JSON.parse(JSON.stringify(this.options));\n\n\t\tlet tmpNewManyfest = new Manyfest(this.getManifest(), this.logInfo, this.logError, tmpNewOptions);\n\n\t\t// Import the hash translations\n\t\ttmpNewManyfest.hashTranslations.addTranslation(this.hashTranslations.translationTable);\n\n\t\treturn tmpNewManyfest;\n\t}\n\n\t// Deserialize a Manifest from a string\n\tdeserialize(pManifestString)\n\t{\n\t\t// TODO: Add guards for bad manifest string\n\t\treturn this.loadManifest(JSON.parse(pManifestString));\n\t}\n\n\t// Load a manifest from an object\n\tloadManifest(pManifest)\n\t{\n\t\tif (typeof(pManifest) !== 'object')\n\t\t{\n\t\t\tthis.logError(`(${this.scope}) Error loading manifest; expecting an object but parameter was type ${typeof(pManifest)}.`);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (pManifest.hasOwnProperty('Scope'))\n\t\t{\n\t\t\tif (typeof(pManifest.Scope) === 'string')\n\t\t\t{\n\t\t\t\tthis.scope = pManifest.Scope;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.logError(`(${this.scope}) Error loading scope from manifest; expecting a string but property was type ${typeof(pManifest.Scope)}.`, pManifest);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.logError(`(${this.scope}) Error loading scope from manifest object.  Property \"Scope\" does not exist in the root of the object.`, pManifest);\n\t\t}\n\n\t\tif (pManifest.hasOwnProperty('Descriptors'))\n\t\t{\n\t\t\tif (typeof(pManifest.Descriptors) === 'object')\n\t\t\t{\n\t\t\t\tlet tmpDescriptionAddresses = Object.keys(pManifest.Descriptors);\n\t\t\t\tfor (let i = 0; i < tmpDescriptionAddresses.length; i++)\n\t\t\t\t{\n\t\t\t\t\tthis.addDescriptor(tmpDescriptionAddresses[i], pManifest.Descriptors[tmpDescriptionAddresses[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.logError(`(${this.scope}) Error loading description object from manifest object.  Expecting an object in 'Manifest.Descriptors' but the property was type ${typeof(pManifest.Descriptors)}.`, pManifest);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.logError(`(${this.scope}) Error loading object description from manifest object.  Property \"Descriptors\" does not exist in the root of the Manifest object.`, pManifest);\n\t\t}\n\t}\n\n\t// Serialize the Manifest to a string\n\t// TODO: Should this also serialize the translation table?\n\tserialize()\n\t{\n\t\treturn JSON.stringify(this.getManifest());\n\t}\n\n\tgetManifest()\n\t{\n\t\treturn (\n\t\t\t{\n\t\t\t\tScope: this.scope,\n\t\t\t\tDescriptors: JSON.parse(JSON.stringify(this.elementDescriptors))\n\t\t\t});\n\t}\n\n\t// Add a descriptor to the manifest\n\taddDescriptor(pAddress, pDescriptor)\n\t{\n\t\tif (typeof(pDescriptor) === 'object')\n\t\t{\n\t\t\t// Add the Address into the Descriptor if it doesn't exist:\n\t\t\tif (!pDescriptor.hasOwnProperty('Address'))\n\t\t\t{\n\t\t\t\tpDescriptor.Address = pAddress;\n\t\t\t}\n\n\t\t\tif (!this.elementDescriptors.hasOwnProperty(pAddress))\n\t\t\t{\n\t\t\t\tthis.elementAddresses.push(pAddress);\n\t\t\t}\n\n\t\t\t// Add the element descriptor to the schema\n\t\t\tthis.elementDescriptors[pAddress] = pDescriptor;\n\n\t\t\t// Always add the address as a hash\n\t\t\tthis.elementHashes[pAddress] = pAddress;\n\n\t\t\tif (pDescriptor.hasOwnProperty('Hash'))\n\t\t\t{\n\t\t\t\t// TODO: Check if this is a good idea or not..\n\t\t\t\t//       Collisions are bound to happen with both representations of the address/hash in here and developers being able to create their own hashes.\n\t\t\t\tthis.elementHashes[pDescriptor.Hash] = pAddress;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpDescriptor.Hash = pAddress;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.logError(`(${this.scope}) Error loading object descriptor for address '${pAddress}' from manifest object.  Expecting an object but property was type ${typeof(pDescriptor)}.`);\n\t\t\treturn false;\n\t\t}\t\n\t}\n\n\tgetDescriptorByHash(pHash)\n\t{\n\t\treturn this.getDescriptor(this.resolveHashAddress(pHash));\n\t}\n\n\tgetDescriptor(pAddress)\n\t{\n\t\treturn this.elementDescriptors[pAddress];\n\t}\n\n\t/*************************************************************************\n\t * Beginning of Object Manipulation (read & write) Functions\n\t */\n\t// Check if an element exists by its hash\n\tcheckAddressExistsByHash (pObject, pHash)\n\t{\n\t\treturn this.checkAddressExists(pObject,this.resolveHashAddress(pHash));\n\t}\n\n\t// Check if an element exists at an address\n\tcheckAddressExists (pObject, pAddress)\n\t{\n\t\treturn this.objectAddressResolver.checkAddressExists(pObject, pAddress);\n\t}\n\n\t// Turn a hash into an address, factoring in the translation table.\n\tresolveHashAddress(pHash)\n\t{\n\t\tlet tmpAddress = undefined;\n\n\t\tlet tmpInElementHashTable = this.elementHashes.hasOwnProperty(pHash);\n\t\tlet tmpInTranslationTable = this.hashTranslations.translationTable.hasOwnProperty(pHash);\n\n\t\t// The most straightforward: the hash exists, no translations.\n\t\tif (tmpInElementHashTable && !tmpInTranslationTable)\n\t\t{\n\t\t\ttmpAddress = this.elementHashes[pHash];\n\t\t}\n\t\t// There is a translation from one hash to another, and, the elementHashes contains the pointer end\n\t\telse if (tmpInTranslationTable && this.elementHashes.hasOwnProperty(this.hashTranslations.translate(pHash)))\n\t\t{\n\t\t\ttmpAddress = this.elementHashes[this.hashTranslations.translate(pHash)];\n\t\t}\n\t\t// Use the level of indirection only in the Translation Table \n\t\telse if (tmpInTranslationTable)\n\t\t{\n\t\t\ttmpAddress = this.hashTranslations.translate(pHash);\n\t\t}\n\t\t// Just treat the hash as an address.\n\t\t// TODO: Discuss this ... it is magic but controversial\n\t\telse\n\t\t{\n\t\t\ttmpAddress = pHash;\n\t\t}\n\n\t\treturn tmpAddress;\n\t}\n\n\t// Get the value of an element by its hash\n\tgetValueByHash (pObject, pHash)\n\t{\n\t\tlet tmpValue = this.getValueAtAddress(pObject, this.resolveHashAddress(pHash));\n\n\t\tif (typeof(tmpValue) == 'undefined')\n\t\t{\n\t\t\t// Try to get a default if it exists\n\t\t\ttmpValue = this.getDefaultValue(this.getDescriptorByHash(pHash));\n\t\t}\n\n\t\treturn tmpValue;\n\t}\n\n\t// Get the value of an element at an address\n\tgetValueAtAddress (pObject, pAddress)\n\t{\n\t\tlet tmpValue = this.objectAddressResolver.getValueAtAddress(pObject, pAddress);\n\n\t\tif (typeof(tmpValue) == 'undefined')\n\t\t{\n\t\t\t// Try to get a default if it exists\n\t\t\ttmpValue = this.getDefaultValue(this.getDescriptor(pAddress));\n\t\t}\n\n\t\treturn tmpValue;\n\t}\n\n\t// Set the value of an element by its hash\n\tsetValueByHash(pObject, pHash, pValue)\n\t{\n\t\treturn this.setValueAtAddress(pObject, this.resolveHashAddress(pHash), pValue);\n\t}\n\n\n\t// Set the value of an element at an address\n\tsetValueAtAddress (pObject, pAddress, pValue)\n\t{\n\t\treturn this.objectAddressResolver.setValueAtAddress(pObject, pAddress, pValue);\n\t}\n\n\t// Validate the consistency of an object against the schema\n\tvalidate(pObject)\n\t{\n\t\tlet tmpValidationData =\n\t\t{\n\t\t\tError: null,\n\t\t\tErrors: [],\n\t\t\tMissingElements:[]\n\t\t};\n\n\t\tif (typeof(pObject) !== 'object')\n\t\t{\n\t\t\ttmpValidationData.Error = true;\n\t\t\ttmpValidationData.Errors.push(`Expected passed in object to be type object but was passed in ${typeof(pObject)}`);\n\t\t}\n\n\t\tlet addValidationError = (pAddress, pErrorMessage) =>\n\t\t{\n\t\t\ttmpValidationData.Error = true;\n\t\t\ttmpValidationData.Errors.push(`Element at address \"${pAddress}\" ${pErrorMessage}.`);\n\t\t};\n\n\t\t// Now enumerate through the values and check for anomalies based on the schema\n\t\tfor (let i = 0; i < this.elementAddresses.length; i++)\n\t\t{\n\t\t\tlet tmpDescriptor = this.getDescriptor(this.elementAddresses[i]);\n\t\t\tlet tmpValueExists = this.checkAddressExists(pObject, tmpDescriptor.Address);\n\t\t\tlet tmpValue = this.getValueAtAddress(pObject, tmpDescriptor.Address);\n\n\t\t\tif ((typeof(tmpValue) == 'undefined') || !tmpValueExists)\n\t\t\t{\n\t\t\t\t// This will technically mean that `Object.Some.Value = undefined` will end up showing as \"missing\"\n\t\t\t\t// TODO: Do we want to do a different message based on if the property exists but is undefined?\n\t\t\t\ttmpValidationData.MissingElements.push(tmpDescriptor.Address);\n\t\t\t\tif (tmpDescriptor.Required || this.options.strict)\n\t\t\t\t{\n\t\t\t\t\taddValidationError(tmpDescriptor.Address, 'is flagged REQUIRED but is not set in the object');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Now see if there is a data type specified for this element\n\t\t\tif (tmpDescriptor.DataType)\n\t\t\t{\n\t\t\t\tlet tmpElementType = typeof(tmpValue);\n\t\t\t\tswitch(tmpDescriptor.DataType.toString().trim().toLowerCase())\n\t\t\t\t{\n\t\t\t\t\tcase 'string':\n\t\t\t\t\t\tif (tmpElementType != 'string')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but is of the type ${tmpElementType}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'number':\n\t\t\t\t\t\tif (tmpElementType != 'number')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but is of the type ${tmpElementType}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'integer':\n\t\t\t\t\t\tif (tmpElementType != 'number')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but is of the type ${tmpElementType}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlet tmpValueString = tmpValue.toString();\n\t\t\t\t\t\t\tif (tmpValueString.indexOf('.') > -1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// TODO: Is this an error?\n\t\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but has a decimal point in the number.`);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'float':\n\t\t\t\t\t\tif (tmpElementType != 'number')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but is of the type ${tmpElementType}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'DateTime':\n\t\t\t\t\t\tlet tmpValueDate = new Date(tmpValue);\n\t\t\t\t\t\tif (tmpValueDate.toString() == 'Invalid Date')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but is not parsable as a Date by Javascript`);\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t// Check if this is a string, in the default case\n\t\t\t\t\t\t// Note this is only when a DataType is specified and it is an unrecognized data type.\n\t\t\t\t\t\tif (tmpElementType != 'string')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} (which auto-converted to String because it was unrecognized) but is of the type ${tmpElementType}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn tmpValidationData;\n\t}\n\n\t// Returns a default value, or, the default value for the data type (which is overridable with configuration)\n\tgetDefaultValue(pDescriptor)\n\t{\n\t\tif (typeof(pDescriptor) != 'object')\n\t\t{\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (pDescriptor.hasOwnProperty('Default'))\n\t\t{\n\t\t\treturn pDescriptor.Default;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Default to a null if it doesn't have a type specified.\n\t\t\t// This will ensure a placeholder is created but isn't misinterpreted.\n\t\t\tlet tmpDataType = (pDescriptor.hasOwnProperty('DataType')) ? pDescriptor.DataType : 'String';\n\t\t\tif (this.options.defaultValues.hasOwnProperty(tmpDataType))\n\t\t\t{\n\t\t\t\treturn this.options.defaultValues[tmpDataType];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// give up and return null\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Enumerate through the schema and populate default values if they don't exist.\n\tpopulateDefaults(pObject, pOverwriteProperties)\n\t{\n\t\treturn this.populateObject(pObject, pOverwriteProperties,\n\t\t\t// This just sets up a simple filter to see if there is a default set.\n\t\t\t(pDescriptor) =>\n\t\t\t{\n\t\t\t\treturn pDescriptor.hasOwnProperty('Default');\n\t\t\t});\n\t}\n\n\t// Forcefully populate all values even if they don't have defaults.\n\t// Based on type, this can do unexpected things.\n\tpopulateObject(pObject, pOverwriteProperties, fFilter)\n\t{\n\t\t// Automatically create an object if one isn't passed in.\n\t\tlet tmpObject = (typeof(pObject) === 'object') ? pObject : {};\n\t\t// Default to *NOT OVERWRITING* properties\n\t\tlet tmpOverwriteProperties = (typeof(pOverwriteProperties) == 'undefined') ? false : pOverwriteProperties;\n\t\t// This is a filter function, which is passed the schema and allows complex filtering of population\n\t\t// The default filter function just returns true, populating everything.\n\t\tlet tmpFilterFunction = (typeof(fFilter) == 'function') ? fFilter : (pDescriptor) => { return true; };\n\n\t\tthis.elementAddresses.forEach(\n\t\t\t(pAddress) =>\n\t\t\t{\n\t\t\t\tlet tmpDescriptor = this.getDescriptor(pAddress);\n\t\t\t\t// Check the filter function to see if this is an address we want to set the value for.\n\t\t\t\tif (tmpFilterFunction(tmpDescriptor))\n\t\t\t\t{\n\t\t\t\t\t// If we are overwriting properties OR the property does not exist\n\t\t\t\t\tif (tmpOverwriteProperties || !this.checkAddressExists(tmpObject, pAddress))\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.setValueAtAddress(tmpObject, pAddress, this.getDefaultValue(tmpDescriptor));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\treturn tmpObject;\n\t}\n};\n\nmodule.exports = Manyfest;","/**\n* Precedent Meta-Templating\n*\n* @license     MIT\n*\n* @author      Steven Velozo <steven@velozo.com>\n*\n* @description Process text streams, parsing out meta-template expressions.\n*/\nvar libWordTree = require(`./WordTree.js`);\nvar libStringParser = require(`./StringParser.js`);\n\nclass Precedent\n{\n\t/**\n\t * Precedent Constructor\n\t */\n\tconstructor()\n\t{\n\t\tthis.WordTree = new libWordTree();\n\t\t\n\t\tthis.StringParser = new libStringParser();\n\n\t\tthis.ParseTree = this.WordTree.ParseTree;\n\t}\n\t\n\t/**\n\t * Add a Pattern to the Parse Tree\n\t * @method addPattern\n\t * @param {Object} pTree - A node on the parse tree to push the characters into\n\t * @param {string} pPattern - The string to add to the tree\n\t * @param {number} pIndex - callback function\n\t * @return {bool} True if adding the pattern was successful\n\t */\n\taddPattern(pPatternStart, pPatternEnd, pParser)\n\t{\n\t\treturn this.WordTree.addPattern(pPatternStart, pPatternEnd, pParser);\n\t}\n\t\n\t/**\n\t * Parse a string with the existing parse tree\n\t * @method parseString\n\t * @param {string} pString - The string to parse\n\t * @return {string} The result from the parser\n\t */\n\tparseString(pString)\n\t{\n\t\treturn this.StringParser.parseString(pString, this.ParseTree);\n\t}\n}\n\nmodule.exports = Precedent;\n","/**\n* String Parser\n*\n* @license     MIT\n*\n* @author      Steven Velozo <steven@velozo.com>\n*\n* @description Parse a string, properly processing each matched token in the word tree.\n*/\n\nclass StringParser\n{\n\t/**\n\t * StringParser Constructor\n\t */\n\tconstructor()\n\t{\n\t}\n\t\n\t/**\n\t * Create a fresh parsing state object to work with.\n\t * @method newParserState\n\t * @param {Object} pParseTree - A node on the parse tree to begin parsing from (usually root)\n\t * @return {Object} A new parser state object for running a character parser on\n\t * @private\n\t */\n\tnewParserState (pParseTree)\n\t{\n\t\treturn (\n\t\t{\n\t\t    ParseTree: pParseTree,\n\n\t\t\tOutput: '',\n\t\t\tOutputBuffer: '',\n\n\t\t\tPattern: false,\n\n\t\t\tPatternMatch: false,\n\t\t\tPatternMatchOutputBuffer: ''\n\t\t});\n\t}\n\t\t\n\t/**\n\t * Assign a node of the parser tree to be the next potential match.\n\t * If the node has a PatternEnd property, it is a valid match and supercedes the last valid match (or becomes the initial match).\n\t * @method assignNode\n\t * @param {Object} pNode - A node on the parse tree to assign\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tassignNode (pNode, pParserState)\n\t{\n\t\tpParserState.PatternMatch = pNode;\n\n\t\t// If the pattern has a END we can assume it has a parse function...\n\t\tif (pParserState.PatternMatch.hasOwnProperty('PatternEnd'))\n\t\t{\n\t\t\t// ... this is the legitimate start of a pattern.\n\t\t\tpParserState.Pattern = pParserState.PatternMatch;\n\t\t}\n\t}\n\t\n\t/**\n\t * Append a character to the output buffer in the parser state.\n\t * This output buffer is used when a potential match is being explored, or a match is being explored.\n\t * @method appendOutputBuffer\n\t * @param {string} pCharacter - The character to append\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tappendOutputBuffer (pCharacter, pParserState)\n\t{\n\t\tpParserState.OutputBuffer += pCharacter;\n\t}\n\t\n\t/**\n\t * Flush the output buffer to the output and clear it.\n\t * @method flushOutputBuffer\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tflushOutputBuffer (pParserState)\n\t{\n\t\tpParserState.Output += pParserState.OutputBuffer;\n\t\tpParserState.OutputBuffer = '';\n\t}\n\n\t\n\t/**\n\t * Check if the pattern has ended.  If it has, properly flush the buffer and start looking for new patterns.\n\t * @method checkPatternEnd\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tcheckPatternEnd (pParserState)\n\t{\n\t\tif ((pParserState.OutputBuffer.length >= pParserState.Pattern.PatternEnd.length+pParserState.Pattern.PatternStart.length) && \n\t\t\t(pParserState.OutputBuffer.substr(-pParserState.Pattern.PatternEnd.length) === pParserState.Pattern.PatternEnd))\n\t\t{\n\t\t\t// ... this is the end of a pattern, cut off the end tag and parse it.\n\t\t\t// Trim the start and end tags off the output buffer now\n\t\t\tpParserState.OutputBuffer = pParserState.Pattern.Parse(pParserState.OutputBuffer.substr(pParserState.Pattern.PatternStart.length, pParserState.OutputBuffer.length - (pParserState.Pattern.PatternStart.length+pParserState.Pattern.PatternEnd.length)));\n\t\t\t// Flush the output buffer.\n\t\t\tthis.flushOutputBuffer(pParserState);\n\t\t\t// End pattern mode\n\t\t\tpParserState.Pattern = false;\n\t\t\tpParserState.PatternMatch = false;\n\t\t}\n\t}\n\t\n\t/**\n\t * Parse a character in the buffer.\n\t * @method parseCharacter\n\t * @param {string} pCharacter - The character to append\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tparseCharacter (pCharacter, pParserState)\n\t{\n\t\t// (1) If we aren't in a pattern match, and we aren't potentially matching, and this may be the start of a new pattern....\n\t\tif (!pParserState.PatternMatch && pParserState.ParseTree.hasOwnProperty(pCharacter))\n\t\t{\n\t\t\t// ... assign the node as the matched node.\n\t\t\tthis.assignNode(pParserState.ParseTree[pCharacter], pParserState);\n\t\t\tthis.appendOutputBuffer(pCharacter, pParserState);\n\t\t}\n\t\t// (2) If we are in a pattern match (actively seeing if this is part of a new pattern token)\n\t\telse if (pParserState.PatternMatch)\n\t\t{\n\t\t\t// If the pattern has a subpattern with this key\n\t\t\tif (pParserState.PatternMatch.hasOwnProperty(pCharacter))\n\t\t\t{\n\t\t\t\t// Continue matching patterns.\n\t\t\t\tthis.assignNode(pParserState.PatternMatch[pCharacter], pParserState);\n\t\t\t}\n\t\t\tthis.appendOutputBuffer(pCharacter, pParserState);\n\t\t\tif (pParserState.Pattern)\n\t\t\t{\n\t\t\t\t// ... Check if this is the end of the pattern (if we are matching a valid pattern)...\n\t\t\t\tthis.checkPatternEnd(pParserState);\n\t\t\t}\n\t\t}\n\t\t// (3) If we aren't in a pattern match or pattern, and this isn't the start of a new pattern (RAW mode)....\n\t\telse\n\t\t{\n\t\t\tpParserState.Output += pCharacter;\n\t\t}\n\t}\n\t\n\t/**\n\t * Parse a string for matches, and process any template segments that occur.\n\t * @method parseString\n\t * @param {string} pString - The string to parse.\n\t * @param {Object} pParseTree - The parse tree to begin parsing from (usually root)\n\t */\n\tparseString (pString, pParseTree)\n\t{\n\t\tlet tmpParserState = this.newParserState(pParseTree);\n\n\t\tfor (var i = 0; i < pString.length; i++)\n\t\t{\n\t\t\t// TODO: This is not fast.\n\t\t\tthis.parseCharacter(pString[i], tmpParserState);\n\t\t}\n\t\t\n\t\tthis.flushOutputBuffer(tmpParserState);\n\t\t\n\t\treturn tmpParserState.Output;\n\t}\n}\n\nmodule.exports = StringParser;\n","/**\n* Word Tree\n*\n* @license     MIT\n*\n* @author      Steven Velozo <steven@velozo.com>\n*\n* @description Create a tree (directed graph) of Javascript objects, one character per object.\n*/\n\nclass WordTree\n{\n\t/**\n\t * WordTree Constructor\n\t */\n\tconstructor()\n\t{\n\t\tthis.ParseTree = {};\n\t}\n\t\n\t/** \n\t * Add a child character to a Parse Tree node\n\t * @method addChild\n\t * @param {Object} pTree - A parse tree to push the characters into\n\t * @param {string} pPattern - The string to add to the tree\n\t * @param {number} pIndex - callback function\n\t * @returns {Object} The resulting leaf node that was added (or found)\n\t * @private\n\t */\n\taddChild (pTree, pPattern, pIndex)\n\t{\n\t\tif (pIndex > pPattern.length)\n\t\t\treturn pTree;\n\t\t\n\t\tif (!pTree.hasOwnProperty(pPattern[pIndex]))\n\t\t\tpTree[pPattern[pIndex]] = {};\n\t\t\n\t\treturn pTree[pPattern[pIndex]];\n\t}\n\t\n\t/** Add a Pattern to the Parse Tree\n\t * @method addPattern\n\t * @param {Object} pTree - A node on the parse tree to push the characters into\n\t * @param {string} pPattern - The string to add to the tree\n\t * @param {number} pIndex - callback function\n\t * @return {bool} True if adding the pattern was successful\n\t */\n\taddPattern (pPatternStart, pPatternEnd, pParser)\n\t{\n\t\tif (pPatternStart.length < 1)\n\t\t\treturn false;\n\n\t\tlet tmpLeaf = this.ParseTree;\n\n\t\t// Add the tree of leaves iteratively\n\t\tfor (var i = 0; i < pPatternStart.length; i++)\n\t\t\ttmpLeaf = this.addChild(tmpLeaf, pPatternStart, i);\n\n\t\ttmpLeaf.PatternStart = pPatternStart;\n\t\ttmpLeaf.PatternEnd = ((typeof(pPatternEnd) === 'string') && (pPatternEnd.length > 0)) ? pPatternEnd : pPatternStart;\n\t\ttmpLeaf.Parse = (typeof(pParser) === 'function') ? pParser : \n\t\t\t\t\t\t(typeof(pParser) === 'string') ? () => { return pParser; } :\n\t\t\t\t\t\t(pData) => { return pData; };\n\n\t\treturn true;\n\t}\n}\n\nmodule.exports = WordTree;\n","/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\n\n/**\n* Elucidator browser shim loader\n*/\n\n// Load the manyfest module into the browser global automatically.\nvar libElucidator = require('./Elucidator.js');\n\nif (typeof(window) === 'object') window.Elucidator = libElucidator;\n\nmodule.exports = libElucidator;","/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\n\n/**\n* Instruction Set Bace Class.\n*\n* @class ElucidatorInstructionSet\n*/\nclass ElucidatorInstructionSet\n{\n    constructor(pElucidator)\n    {\n        this.elucidator = pElucidator;\n\n        this.namespace = 'default';\n    }\n\n    // Create an empty namespace for instructions and operations if either one doesn't exist\n    initializeNamespace(pNamespace)\n    {\n        if (typeof(pNamespace) == 'string')\n        {\n            this.namespace = pNamespace;\n        }\n        if (!this.elucidator.instructionSets.hasOwnProperty(this.namespace))\n        {\n            this.elucidator.instructionSets[this.namespace.toLowerCase()] = {};\n        }\n        if (!this.elucidator.operationSets.hasOwnProperty(this.namespace))\n        {\n            this.elucidator.operationSets[this.namespace.toLowerCase()] = {};\n        }\n    }\n\n    // Add an instruction to the set\n    addInstruction(pInstructionHash, fInstructionFunction)\n    {\n        if (typeof(pInstructionHash) != 'string')\n        {\n            this.elucidator.logError(`Attempted to add an instruction with an invalid hash; expected a string but the instruction hash type was ${typeof(pInstructionHash)}`);\n            return false;\n        }\n        if (typeof(fInstructionFunction) != 'function')\n        {\n            this.elucidator.logError(`Attempted to add an instruction with an invalid function; expected a function but type was ${typeof(fInstructionFunction)}`);\n            return false;\n        }\n\n        this.elucidator.instructionSets[this.namespace.toLowerCase()][pInstructionHash] = fInstructionFunction;\n        return true;\n    }\n\n    initializeInstructions()\n    {\n        // This is where we map in the instructions.\n        // If the extending class calls super it will inject a harmless noop into the scope.\n        // It isn't recommended to do these inline as lambdas, but this code is generally not expected to be called.\n        // Unless the developer wants a noop in their instruction set...........\n        this.addInstruction('noop', \n            (pOperation) =>\n            {\n                pOperation.logInfo('Executing a no-operation operation.');\n                return true;\n            });\n\n        return true;\n    }\n\n    // Add an operation to the set\n    addOperation(pOperationHash, pOperation)\n    {\n        if (typeof(pOperationHash) != 'string')\n        {\n            this.elucidator.logError(`Attempted to add an operation with an invalid hash; expected a string but the operation hash type was ${typeof(pOperationHash)}`, pOperation);\n            return false;\n        }\n        if (typeof(pOperation) != 'object')\n        {\n            this.elucidator.logError(`Attempted to add an invalid operation; expected an object data type but the type was ${typeof(pOperation)}`, pOperation);\n            return false;\n        }\n        // Validate the Description subobject, which is key to functioning.\n        if (!pOperation.hasOwnProperty(\"Description\"))\n        {\n            this.elucidator.logError(`Attempted to add an operation with an invalid description; no Description subobject set.`, pOperation);\n            return false;\n        }\n        if (typeof(pOperation.Description) != 'object')\n        {\n            this.elucidator.logError(`Attempted to add an operation with an invalid description; Description subobject was not an object.  The type was ${typeof(pOperation.Description)}.`, pOperation);\n            return false;\n        }\n        if (typeof(pOperation.Description.Hash) != 'string')\n        {\n            if (typeof(pOperation.Description.Operation) == 'string')\n            {\n                // Use the \"Operation\" as the \"Hash\"\n                pOperation.Description.Hash = pOperation.Description.Operation;\n            }\n            else\n            {\n                this.elucidator.logError(`Attempted to add an operation with an invalid description; Description subobject did not contain a valid Hash which is required to call the operation.`, pOperation);\n                return false;\n            }\n        }\n\n        // Now auto create data if it is missing or wrong in the Description\n        if ((typeof(pOperation.Description.Namespace) != 'string') || (pOperation.Description.Namespace != this.namespace))\n        {\n            pOperation.Description.Namespace = this.namespace;\n        }\n        if (typeof(pOperation.Description.Summary) != 'string')\n        {\n            pOperation.Description.Summary = `[${pOperation.Description.Namespace}] [${pOperation.Description.Hash}] operation.`;\n        }\n\n        // If there are no inputs, or outputs, or steps, add them.\n        if (!pOperation.hasOwnProperty('Inputs'))\n        {\n            pOperation.Inputs = {};\n        }\n        if (!pOperation.hasOwnProperty('Outputs'))\n        {\n            pOperation.Outputs = {};\n        }\n        if (!pOperation.hasOwnProperty('Steps'))\n        {\n            pOperation.Steps = [];\n        }\n\n        // If there are no inputs, or outputs, or steps, add them.\n        // TODO: Add a step where we try to load this into Manyfest and see that it's valid.\n        if (typeof(pOperation.Inputs) !== 'object')\n        {\n            this.elucidator.logError(`Attempted to add an operation with an invalid Inputs object.`, pOperation);\n            return false;\n        }\n        // If there are no inputs, or outputs, or steps, add them.\n        // TODO: Add a step where we try to load this into Manyfest and see that it's valid.\n        if (typeof(pOperation.Outputs) !== 'object')\n        {\n            this.elucidator.logError(`Attempted to add an operation with an invalid Outputs object.`, pOperation);\n            return false;\n        }\n        if (!Array.isArray(pOperation.Steps))\n        {\n            this.elucidator.logError(`Attempted to add an operation with an invalid Steps array.`, pOperation);\n            return false;\n        }\n\n\n        this.elucidator.operationSets[this.namespace.toLowerCase()][pOperationHash.toLowerCase()] = pOperation;\n        return true;\n    }\n\n    initializeOperations()\n    {\n        this.addOperation('noop', \n            {\n                \"Description\":\n                {\n                    \"Operation\": \"noop\",\n                    \"Description\": \"No operation - no affect on any data.\"\n                }\n            });\n\n        return true;\n    }\n};\n\nmodule.exports = ElucidatorInstructionSet;","/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\n\n/**\n* Elucidator simple logging shim (for browser and dependency-free running)\n*/\n\nconst logToConsole = (pLogLine, pLogObject, pLogLevel) =>\n{\n    let tmpLogLine = (typeof(pLogLine) === 'string') ? pLogLine : '';\n    let tmpLogLevel = (typeof(pLogLevel) === 'string') ? pLogLevel : 'INFO';\n\n    console.log(`[Elucidator:${tmpLogLevel}] ${tmpLogLine}`);\n\n    if (pLogObject) console.log(JSON.stringify(pLogObject,null,4)+\"\\n\");\n};\n\nconst logInfo = (pLogLine, pLogObject) =>\n{\n    logToConsole(pLogLine, pLogObject, 'Info');\n};\n\n\nconst logWarning = (pLogLine, pLogObject) =>\n{\n    logToConsole(pLogLine, pLogObject, 'Warning');\n};\n\n\nconst logError = (pLogLine, pLogObject) =>\n{\n    logToConsole(pLogLine, pLogObject, 'Error');\n};\n\nmodule.exports = (\n{\n    logToConsole: logToConsole,\n    info: logInfo,\n    warning: logWarning,\n    error: logError\n});","/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\nconst libSimpleLog = require('./Elucidator-LogToConsole.js');\nconst libManyfest = require('manyfest');\nconst libPrecedent = require('precedent');\n\nconst libElucidatorInstructionSet = require('./Elucidator-InstructionSet.js');\n\n/**\n* Elucidator object address-based descriptions and manipulations.\n*\n* @class Elucidator\n*/\nclass Elucidator\n{\n    constructor(pOperations, fInfoLog, fErrorLog)\n    {\n        // Wire in logging\n        this.logInfo = (typeof(fInfoLog) === 'function') ? fInfoLog : libSimpleLog.info;\n        this.logWarning = (typeof(fWarningLog) === 'function') ? fWarningLog : libSimpleLog.warning;\n        this.logError = (typeof(fErrorLog) === 'function') ? fErrorLog : libSimpleLog.error;\n\n\t\t// Instructions are the basic building blocks for operations\n\t\tthis.instructionSets = {};\n\n\t\t// Operations are the solvers that can be called (instructions can't be called directly)\n\t\t// These can be added at run-time as well\n\t\tthis.operationSets = {};\n\n\t\t// Decide later how to make this truly unique.\n\t\tthis.UUID = 0;\n\n\t\tthis.loadDefaultInstructionSets();\n\n\t\tif (pOperations)\n\t\t{\n\t\t\tlet tmpSolverHashes = Object.keys(pOperations);\n\t\t\tfor (let i = 0; i < tmpSolverHashes.length; i++)\n\t\t\t{\n\t\t\t\tthis.addOperation('Custom',tmpSolverHashes[i], pOperations[tmpSolverHashes[i]]);\n\t\t\t}\n\t\t}\n    }\n\n\t// Load an instruction set\n\tloadInstructionSet(cInstructionSet)\n\t{\n\t\tlet tmpInstructionSet = new cInstructionSet(this);\n\t\t// Setup the namespace\n\t\ttmpInstructionSet.initializeNamespace();\n\t\ttmpInstructionSet.initializeInstructions();\n\t\ttmpInstructionSet.initializeOperations();\n\t}\n\n\tloadDefaultInstructionSets()\n\t{\n\t\t// The javascript math instructions and operations\n\t\t// These provide the \"Math\" namespace\n\t\tthis.loadInstructionSet(require(`./InstructionSets/Math-Javascript.js`));\n\n\t\t// A precision javascript math library that is consistent across browsers, stable and without mantissa issues\n\t\t// Uses Decimal.js\n\t\t// These provide the \"PreciseMath\" namespace\n\t\tthis.loadInstructionSet(require(`./InstructionSets/PreciseMath-Decimal.js`));\n\n\t\t// The abstract geometry instructions and operations (rectangle area, circle area, etc.)\n\t\t// These provide the \"Geometry\" namespace\n\t\tthis.loadInstructionSet(require(`./InstructionSets/Geometry.js`));\n\n\t\t// The logic operations (if, execution of instructions, etc.)\n\t\t// These provide the \"Logic\" namespace\n\t\tthis.loadInstructionSet(require(`./InstructionSets/Logic.js`));\n\n\t\t// Basic string manipulation instructions and operations\n\t\t// These provide the \"String\" namespace\n\t\tthis.loadInstructionSet(require(`./InstructionSets/String.js`));\n\t}\n\n\toperationExists(pNamespace, pOperationHash)\n\t{\n\t\tif ((typeof(pNamespace) != 'string') || (typeof(pOperationHash) != 'string'))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\tlet tmpNamespace = pNamespace.toLowerCase();\n\t\treturn (this.operationSets.hasOwnProperty(tmpNamespace) && this.operationSets[tmpNamespace].hasOwnProperty(pOperationHash.toLowerCase()));\n\t}\n\n\taddOperation(pNamespace, pOperationHash, pOperation)\n\t{\n        if (typeof(pNamespace) != 'string')\n        {\n            this.logError(`Attempted to add an operation at runtime via Elucidator.addOperation with an invalid namespace; expected a string but the type was ${typeof(pNamespace)}`, pOperation);\n            return false;\n        }\n\n\t\tlet tmpOperationInjector = new libElucidatorInstructionSet(this);\n\t\ttmpOperationInjector.initializeNamespace(pNamespace);\n\n\t\treturn tmpOperationInjector.addOperation(pOperationHash, pOperation);\n\t}\n\n\tsolveInternalOperation(pNamespace, pOperationHash, pInputObject, pOutputObject, pDescriptionManyfest, pInputAddressMapping, pOutputAddressMapping, pSolutionContext)\n\t{\n\t\tif (!this.operationExists(pNamespace, pOperationHash))\n\t\t{\n\t\t\tthis.logError(`Attempted to solveInternalOperation for namespace ${pNamespace} operationHash ${pOperationHash} but the operation was not found.`);\n\t\t\t// TODO: Should this return something with an error log populated?\n\t\t\treturn false;\n\t\t}\n\t\tlet tmpOperation = this.operationSets[pNamespace.toLowerCase()][pOperationHash.toLowerCase()];\n\t\treturn this.solveOperation(tmpOperation, pInputObject, pOutputObject, pDescriptionManyfest, pInputAddressMapping, pOutputAddressMapping, pSolutionContext);\n\t}\n\n\tsolveOperation(pOperationObject, pInputObject, pOutputObject, pDescriptionManyfest, pInputAddressMapping, pOutputAddressMapping, pSolutionContext)\n\t{\n\t\tlet tmpOperation = JSON.parse(JSON.stringify(pOperationObject));\n\n\t\tif (typeof(pInputObject) != 'object')\n\t\t{\n            this.logError(`Attempted to run a solve but the passed in Input was not an object.  The type was ${typeof(pInputObject)}.`);\n\t\t\treturn false;\n\t\t}\n\t\tlet tmpInputObject = pInputObject;\n\n\t\t// Default to reusing the input object as the output object.\n\t\tlet tmpOutputObject = tmpInputObject;\n\n\t\t// This is how recursive solutions bind their context together.\n\t\tlet tmpSolutionContext = pSolutionContext;\n\t\tif (typeof(tmpSolutionContext) === 'undefined')\n\t\t{\n\t\t\ttmpSolutionContext = (\n\t\t\t\t{\n\t\t\t\t\t\"SolutionGUID\": `Solution-${this.UUID++}`, \n\t\t\t\t\t\"SolutionBaseNamespace\": pOperationObject.Description.Namespace,\n\t\t\t\t\t\"SolutionBaseOperation\": pOperationObject.Description.Operation,\n\t\t\t\t\t\"SolutionLog\": []\n\t\t\t\t});\n\t\t\t\n\t\t\t// This is the root operation, see if there are Inputs and Outputs created ... if not, create them.\n\t\t\tif (!tmpOperation.hasOwnProperty('Inputs'))\n\t\t\t{\n\t\t\t\ttmpOperation.Inputs = {};\n\t\t\t}\n\t\t\tif (!tmpOperation.hasOwnProperty('Outputs'))\n\t\t\t{\n\t\t\t\ttmpOperation.Outputs = {};\n\t\t\t}\n\n\t\t\t// This is the root Operation, see if there is a hash translation available for either side (input or output)\n\t\t\tif (tmpOperation.hasOwnProperty('InputHashTranslationTable'))\n\t\t\t{\n\t\t\t\ttmpSolutionContext.InputHashMapping = JSON.parse(JSON.stringify(tmpOperation.InputHashTranslationTable));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttmpSolutionContext.InputHashMapping = {};\n\t\t\t}\n\n\t\t\tif (tmpOperation.hasOwnProperty('OutputHashTranslationTable'))\n\t\t\t{\n\t\t\t\ttmpSolutionContext.OutputHashMapping = JSON.parse(JSON.stringify(tmpOperation.OutputHashTranslationTable));\n\t\t\t}\n\n\t\t\tif ((typeof(pOutputObject) != 'object')\n\t\t\t\t&& (typeof(tmpOutputHashMapping) == 'undefined') \n\t\t\t\t&& (typeof(tmpInputHashMapping) != 'undefined'))\n\t\t\t{\n\t\t\t\t// Reuse the input hash mapping if:\n\t\t\t\t//   1) we auto-mapped the input hash mapping to the output because only an input object was supplied\n\t\t\t\t//   2) there *was not* an output hash mapping supplied\n\t\t\t\t//   3) there *was* an input hash mapping supplied\n\t\t\t\t//\n\t\t\t\t// This seems simple at first but exposes some really interesting behaviors in terms of\n\t\t\t\t// reusing the same object and schema for input and output, but having different hash\n\t\t\t\t// mappings for each of them.\n\t\t\t\ttmpSolutionContext.OutputHashMapping = tmpSolutionContext.InputHashMapping;\n\t\t\t}\n\t\t}\n\n\t\tif (typeof(pOutputObject) == 'object')\n\t\t{\n\t\t\t// If the call defined an explicit, different output object from the input object use that instead.\n\t\t\ttmpOutputObject = pOutputObject;\n\t\t}\n\n\t\tlet tmpDescriptionManyfest = false;\n\t\tif (typeof(pDescriptionManyfest) === 'undefined')\n\t\t{\n\t\t\t// We are going to use this for some clever schema manipulations, then recreate the object\n\t\t\ttmpDescriptionManyfest = new libManyfest();\n\t\t\t// Synthesize a manyfest from the Input and Output properties\n\t\t\tlet tmpManyfestSchema = (\n\t\t\t\t{\n\t\t\t\t\tScope: 'Solver Data Part Descriptions',\n\t\t\t\t\tDescriptors: tmpDescriptionManyfest.schemaManipulations.mergeAddressMappings(tmpOperation.Inputs, tmpOperation.Outputs)\n\t\t\t\t});\n\t\t\t}\n\t\telse\n\t\t{\n\t\t\t// Clone the passed-in manyfest, so mutations do not alter the upstream version\n\t\t\ttmpDescriptionManyfest = pDescriptionManyfest.clone();\n\t\t}\n\t\t// Now that the operation object has been created uniquely, apply any passed-in address-hash and hash-hash remappings\n\t\tif (pInputAddressMapping)\n\t\t{\n\t\t\ttmpDescriptionManyfest.schemaManipulations.resolveAddressMappings(tmpOperation.Inputs, pInputAddressMapping);\n\t\t}\n\t\tif (pOutputAddressMapping)\n\t\t{\n\t\t\ttmpDescriptionManyfest.schemaManipulations.resolveAddressMappings(tmpOperation.Inputs, pOutputAddressMapping);\n\t\t}\n\t\tif (tmpSolutionContext.InputHashMapping)\n\t\t{\n\t\t\ttmpDescriptionManyfest.hashTranslations.addTranslation(tmpSolutionContext.InputHashMapping);\n\t\t}\n\t\tif (tmpSolutionContext.OutputHashMapping)\n\t\t{\n\t\t\ttmpDescriptionManyfest.hashTranslations.addTranslation(tmpSolutionContext.OutputHashMapping);\t\t\t\n\t\t}\n\n\n\t\t// Set some kind of unique identifier for the operation\n\t\ttmpOperation.UUID = this.UUID++;\n\t\ttmpOperation.SolutionContext = tmpSolutionContext;\n\n\t\tif (tmpOperation.Description.Synopsys)\n\t\t{\n\t\t\ttmpSolutionContext.SolutionLog.push(`[${tmpOperation.UUID}]: Solver running operation ${tmpOperation.Description.Synopsys}`);\n\t\t}\n\n\t\tlet tmpPrecedent = new libPrecedent();\n\t\ttmpPrecedent.addPattern('{{Name:', '}}',\n\t\t\t(pHash)=>\n\t\t\t{\n\t\t\t\tlet tmpHash = pHash.trim();\n\t\t\t\tlet tmpDescriptor = tmpDescriptionManyfest.getDescriptorByHash(tmpHash)\n\n\t\t\t\t// Return a human readable value\n\t\t\t\tif ((typeof(tmpDescriptor) == 'object')  && tmpDescriptor.hasOwnProperty('Name'))\n\t\t\t\t{\n\t\t\t\t\treturn tmpDescriptor.Name;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treturn tmpHash;\n\t\t\t\t}\n\t\t\t});\n\t\ttmpPrecedent.addPattern('{{InputValue:', '}}',\n\t\t\t(pHash)=>\n\t\t\t{\n\t\t\t\tlet tmpHash = pHash.trim();\n\t\t\t\treturn tmpDescriptionManyfest.getValueByHash(tmpInputObject,tmpHash);\n\t\t\t});\n\t\ttmpPrecedent.addPattern('{{OutputValue:', '}}',\n\t\t\t(pHash)=>\n\t\t\t{\n\t\t\t\tlet tmpHash = pHash.trim();\n\t\t\t\treturn tmpDescriptionManyfest.getValueByHash(tmpOutputObject,tmpHash);\n\t\t\t});\n\n\t\tif (tmpOperation.hasOwnProperty('Log') && tmpOperation.Log.hasOwnProperty('PreOperation'))\n\t\t{\n\t\t\tif (typeof(tmpOperation.Log.PreOperation) == 'string')\n\t\t\t{\n\t\t\t\ttmpOperation.SolutionContext.SolutionLog.push(tmpPrecedent.parseString(tmpOperation.Log.PreOperation));\n\t\t\t}\n\t\t\telse if (Array.isArray(tmpOperation.Log.PreOperation))\n\t\t\t{\n\t\t\t\tfor (let i = 0; i < tmpOperation.Log.PreOperation.length; i++)\n\t\t\t\t{\n\t\t\t\t\tif ((typeof(tmpOperation.Log.PreOperation[i]) == 'string'))\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpOperation.SolutionContext.SolutionLog.push(tmpPrecedent.parseString(tmpOperation.Log.PreOperation[i]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Now step through each operation and solve\n\t\tfor (let i = 0; i < tmpOperation.Steps.length; i++)\n\t\t{\n\t\t\tlet tmpStep = tmpOperation.Steps[i];\n\n\t\t\t// Instructions are always endpoints -- they *do not* recurse.\n\t\t\tif (tmpStep.hasOwnProperty('Instruction'))\n\t\t\t{\n\t\t\t\tlet tmpInputSchema = (\n\t\t\t\t\t{\n\t\t\t\t\t\t\"Scope\": \"InputObject\",\n\t\t\t\t\t\t\"Descriptors\": JSON.parse(JSON.stringify(tmpOperation.Inputs))\n\t\t\t\t\t});\n\t\t\t\t// Perform step-specific address mappings.\n\t\t\t\ttmpDescriptionManyfest.schemaManipulations.resolveAddressMappings(tmpInputSchema.Descriptors, tmpStep.InputHashAddressMap);\n\t\t\t\tlet tmpInputManyfest = new libManyfest(tmpInputSchema);\n\t\t\t\tif (tmpSolutionContext.InputHashMapping)\n\t\t\t\t{\n\t\t\t\t\ttmpInputManyfest.hashTranslations.addTranslation(tmpSolutionContext.InputHashMapping);\n\t\t\t\t}\n\n\t\t\t\tlet tmpOutputSchema = (\n\t\t\t\t\t{\n\t\t\t\t\t\t\"Scope\": \"OutputObject\",\n\t\t\t\t\t\t\"Descriptors\": JSON.parse(JSON.stringify(tmpOperation.Outputs))\n\t\t\t\t\t});\n\t\t\t\t\ttmpDescriptionManyfest.schemaManipulations.resolveAddressMappings(tmpOutputSchema.Descriptors, tmpStep.OutputHashAddressMap);\n\t\t\t\tlet tmpOutputManyfest = new libManyfest(tmpOutputSchema);\n\t\t\t\tif (tmpSolutionContext.OutputHashMapping)\n\t\t\t\t{\n\t\t\t\t\ttmpOutputManyfest.hashTranslations.addTranslation(tmpSolutionContext.OutputHashMapping);\n\t\t\t\t}\n\t\n\t\t\t\t// Construct the instruction state object\n\t\t\t\tlet tmpInstructionState = (\n\t\t\t\t{\n\t\t\t\t\tElucidator: this,\n\n\t\t\t\t\tNamespace: tmpStep.Namespace.toLowerCase(),\n\t\t\t\t\tInstruction: tmpStep.Instruction.toLowerCase(),\n\n\t\t\t\t\tOperation: tmpOperation,\n\n\t\t\t\t\tSolutionContext: tmpSolutionContext,\n\n\t\t\t\t\tDescriptionManyfest: tmpDescriptionManyfest,\n\n\t\t\t\t\tInputObject: tmpInputObject,\n\t\t\t\t\tInputManyfest: tmpInputManyfest,\n\n\t\t\t\t\tOutputObject: tmpOutputObject,\n\t\t\t\t\tOutputManyfest: tmpOutputManyfest\n\t\t\t\t});\n\n\t\t\t\ttmpInstructionState.logError = \n\t\t\t\t\t(pMessage) => \n\t\t\t\t\t{\n\t\t\t\t\t\ttmpSolutionContext.SolutionLog.push(`[ERROR][Operation ${tmpInstructionState.Operation.Description.Namespace}:${tmpInstructionState.Operation.Description.Hash} - Step #${i}:${tmpStep.Namespace}:${tmpStep.Instruction}] ${pMessage}`)\n\t\t\t\t\t};\n\n\t\t\t\ttmpInstructionState.logInfo = \n\t\t\t\t\t(pMessage) => \n\t\t\t\t\t{\n\t\t\t\t\t\ttmpSolutionContext.SolutionLog.push(`[INFO][Operation ${tmpInstructionState.Operation.Description.Namespace}:${tmpInstructionState.Operation.Description.Hash} - Step #${i}:${tmpStep.Namespace}:${tmpStep.Instruction}] ${pMessage}`)\n\t\t\t\t\t};\n\n\t\t\t\tif (this.instructionSets[tmpInstructionState.Namespace].hasOwnProperty(tmpInstructionState.Instruction))\n\t\t\t\t{\n\t\t\t\t\tlet fInstruction = this.instructionSets[tmpInstructionState.Namespace][tmpInstructionState.Instruction];\n\t\t\t\t\tfInstruction(tmpInstructionState);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Operations recurse.\n\t\t\tif (tmpStep.hasOwnProperty('Operation'))\n\t\t\t{\n\t\t\t\tif (typeof(tmpStep.Operation) == 'string')\n\t\t\t\t{\n\t\t\t\t\tthis.solveInternalOperation(tmpStep.Namespace, tmpStep.Operation, tmpInputObject, tmpOutputObject, tmpDescriptionManyfest, tmpStep.InputHashAddressMap, tmpStep.OutputHashAddressMap, tmpSolutionContext);\n\t\t\t\t}\n\t\t\t\telse if (typeof(tmpStep.Operation) == 'object')\n\t\t\t\t{\n\t\t\t\t\t// You can even define an inline object operation!  This gets crazy fast\n\t\t\t\t\tthis.solveOperation(tmpStep.Operation, tmpInputObject, tmpOutputObject, tmpDescriptionManyfest, tmpStep.InputHashAddressMap, tmpStep.OutputHashAddressMap, tmpSolutionContext);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (tmpOperation.hasOwnProperty('Log') && tmpOperation.Log.hasOwnProperty('PostOperation'))\n\t\t{\n\t\t\tif (typeof(tmpOperation.Log.PostOperation) == 'string')\n\t\t\t{\n\t\t\t\ttmpOperation.SolutionContext.SolutionLog.push(tmpPrecedent.parseString(tmpOperation.Log.PostOperation));\n\t\t\t}\n\t\t\telse if (Array.isArray(tmpOperation.Log.PreOperation))\n\t\t\t{\n\t\t\t\tfor (let i = 0; i < tmpOperation.Log.PostOperation.length; i++)\n\t\t\t\t{\n\t\t\t\t\tif ((typeof(tmpOperation.Log.PostOperation[i]) == 'string'))\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpOperation.SolutionContext.SolutionLog.push(tmpPrecedent.parseString(tmpOperation.Log.PostOperation[i]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn tmpSolutionContext;\n\t}\n};\n\nmodule.exports = Elucidator;","// Solution providers are meant to be stateless, and not classes.\n// These solution providers are akin to drivers, connecting code libraries or \n// other types of behavior to mapping operations.\n\nlet libElucidatorInstructionSet = require('../Elucidator-InstructionSet.js');\n\nclass Geometry extends libElucidatorInstructionSet\n{\n    constructor(pElucidator)\n    {\n        super(pElucidator);\n        this.namespace = 'Geometry';\n    }\n\n    // Geometry provides no instructions\n    initializeInstructions()\n    {\n        return true;\n    }\n\n    initializeOperations()\n    {\n        this.addOperation('rectanglearea', require(`./Operations/Geometry-RectangleArea.json`));\n\n        return true;\n    }\n}\n\nmodule.exports = Geometry;","// Solution providers are meant to be stateless, and not classes.\n// These solution providers are akin to drivers, connecting code libraries or \n// other types of behavior to mapping operations.\n\nlet libElucidatorInstructionSet = require('../Elucidator-InstructionSet.js');\n\nconst ifInstruction = (pOperation) =>\n{\n    let tmpLeftValue = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'leftValue');\n    let tmpRightValue = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'rightValue');\n    let tmpComparator = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'comparator').toString().toLowerCase();\n\n    let tmpComparisonOperator = 'equal';\n\n    // This may eventually come from configuration; for now just leave it here.\n    let tmpComparisonOperatorMapping = (\n        {\n            '==':'equal',\n            'eq':'equal',\n            'equal':'equal',\n\n            '!=':'notequal',\n            'noteq':'notequal',\n            'notequal':'notequal',\n\n            '===':'identity',\n            'id':'identity',\n            'identity':'identity',\n\n            '>':'greaterthan',\n            'gt':'greaterthan',\n            'greaterthan':'greaterthan',\n\n            '>=':'greaterthanorequal',\n            'gte':'greaterthanorequal',\n            'greaterthanorequal':'greaterthanorequal',\n\n            '<':'lessthan',\n            'lt':'lessthan',\n            'lessthan':'lessthan',\n\n            '<=':'lessthanorequal',\n            'lte':'lessthanorequal',\n            'lessthanorequal':'lessthanorequal'\n        });\n\n    if (tmpComparisonOperatorMapping.hasOwnProperty(tmpComparator))\n    {\n        tmpComparisonOperator = tmpComparisonOperatorMapping[tmpComparator];\n    }\n\n    let tmpTrueNamespace = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'trueNamespace');\n    let tmpTrueOperation = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'trueOperation');\n\n    let tmpFalseNamespace = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'falseNamespace');\n    let tmpFalseOperation = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'falseOperation');\n\n    let tmpTruthiness = null;\n\n    switch(tmpComparisonOperator)\n    {\n        case 'equal':\n            tmpTruthiness = (tmpLeftValue == tmpRightValue);\n            break;\n        case 'identity':\n            tmpTruthiness = (tmpLeftValue === tmpRightValue);\n            break;\n        case 'notequal':\n            tmpTruthiness = (tmpLeftValue != tmpRightValue);\n            break;\n        case 'greaterthan':\n            tmpTruthiness = (tmpLeftValue > tmpRightValue);\n            break;\n        case 'greaterthanorequal':\n            tmpTruthiness = (tmpLeftValue >= tmpRightValue);\n            break;\n        case 'lessthan':\n            tmpTruthiness = (tmpLeftValue < tmpRightValue);\n            break;\n        case 'lessthanorequal':\n            tmpTruthiness = (tmpLeftValue <= tmpRightValue);\n            break;\n    }\n\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'truthinessResult', tmpTruthiness);\n\n    // Now execute the operations (unless it is a noop or a bunk operation)\n    // This is, frankly, kindof a mind-blowing amount of recursion possibility.\n    // Both of these are falling back on the base solution hash mapping.\n    // --> Not certain if this is the correct approach and the only way to tell will be through exercise of this\n    if (tmpTruthiness && (typeof(tmpTrueNamespace) == 'string') && (typeof(tmpTrueOperation) == 'string') && (tmpTrueOperation != 'noop'))\n    {\n        pOperation.Elucidator.solveInternalOperation(tmpTrueNamespace, tmpTrueOperation, pOperation.InputObject, pOperation.OutputObject, pOperation.DescriptionManyfest, pOperation.SolutionContext.InputHashMapping, pOperation.SolutionContext.OutputHashMapping, pOperation.SolutionContext);\n    }\n    else if ((typeof(tmpFalseNamespace) == 'string') &&  (typeof(tmpFalseOperation) == 'string') && (tmpFalseOperation != 'noop'))\n    {\n        pOperation.Elucidator.solveInternalOperation(tmpFalseNamespace, tmpFalseOperation, pOperation.InputObject, pOperation.OutputObject, pOperation.DescriptionManyfest, pOperation.SolutionContext.InputHashMapping, pOperation.SolutionContext.OutputHashMapping, pOperation.SolutionContext);\n    }\n\n    return true;\n};\n\nconst executeOperation = (pOperation) =>\n{\n    let tmpNamespace = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'namespace');\n    let tmpOperation = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'operation');\n\n    pOperation.Elucidator.solveInternalOperation(tmpNamespace, tmpOperation, pOperation.InputObject, pOperation.OutputObject, pOperation.DescriptionManyfest, pOperation.SolutionContext.InputHashMapping, pOperation.SolutionContext.OutputHashMapping, pOperation.SolutionContext);\n\n    return true;\n}\n\nclass Logic extends libElucidatorInstructionSet\n{\n    constructor(pElucidator)\n    {\n        super(pElucidator);\n        this.namespace = 'Logic';\n    }\n\n    initializeInstructions()\n    {\n        // Logic actually wants a noop instruction!\n        super.initializeInstructions();\n\n        this.addInstruction('if', ifInstruction);\n        this.addInstruction('execute', executeOperation);\n\n        return true;\n    }\n\n    initializeOperations()\n    {\n        this.addOperation('if', require(`./Operations/Logic-If.json`));\n        this.addOperation('execute', require(`./Operations/Logic-Execute.json`));\n\n        return true;\n    }\n}\n\nmodule.exports = Logic;","// Solution providers are meant to be stateless, and not classes.\n// These solution providers are akin to drivers, connecting code libraries or \n// other types of behavior to mapping operations.\n\nlet libElucidatorInstructionSet = require('../Elucidator-InstructionSet.js');\n\nlet add = (pOperation) =>\n{\n    // This could be done in one line, but, would be more difficult to comprehend.\n    let tmpA = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'a');\n    let tmpB = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'b');\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'x', tmpA + tmpB);\n    return true;\n};\n\nlet subtract = (pOperation) =>\n{\n    // This could be done in one line, but, would be more difficult to comprehend.\n    let tmpA = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'a');\n    let tmpB = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'b');\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'x', tmpA - tmpB);\n    return true;\n};\n\nlet multiply = (pOperation) =>\n{\n    // This could be done in one line, but, would be more difficult to comprehend.\n    let tmpA = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'a');\n    let tmpB = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'b');\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'x', tmpA * tmpB);\n    return true;\n};\n\nlet divide = (pOperation) =>\n{\n    // This could be done in one line, but, would be more difficult to comprehend.\n    let tmpA = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'a');\n    let tmpB = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'b');\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'x', tmpA / tmpB);\n    return true;\n};\n\nlet aggregate = (pOperation) =>\n{\n    let tmpA = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'a');\n\n    let tmpObjectType = typeof(tmpA);\n\n    let tmpAggregationValue = 0;\n\n    if (tmpObjectType == 'object')\n    {\n        if (Array.isArray(tmpA))\n        {\n            for (let i = 0; i < tmpA.length; i++)\n            {\n                // If this is an array, enumerate it and try to aggregate each number\n                let tmpValue = parseInt(tmpA[i]);\n\n                if (isNaN(tmpValue))\n                {\n                    pOperation.logError(`Array element index [${i}] could not be parsed as a number; skipping.  (${tmpA[i]})`);\n                }\n                else\n                {\n                    tmpAggregationValue += tmpValue;\n                    pOperation.logInfo(`Adding element [${i}] value ${tmpValue} totaling: ${tmpAggregationValue}`)\n                }\n            }\n        }\n        else\n        {\n            let tmpObjectKeys = Object.keys(tmpA);\n            for (let i = 0; i < tmpObjectKeys.length; i++)\n            {\n                let tmpValue = parseInt(tmpA[tmpObjectKeys[i]]);\n\n                if (isNaN(tmpValue))\n                {\n                    pOperation.logError(`Object property [${tmpObjectKeys[i]}] could not be parsed as a number; skipping.  (${tmpA[tmpObjectKeys[i]]})`);\n                }\n                else\n                {\n                    tmpAggregationValue += tmpValue;\n                    pOperation.logInfo(`Adding object property [${tmpObjectKeys[i]}] value ${tmpValue} totaling: ${tmpAggregationValue}`)\n                }\n            }\n        }\n    }\n    else\n    {\n        let tmpValue = parseInt(tmpA);\n\n        if (isNaN(tmpValue))\n        {\n            pOperation.logError(`Direct value could not be parsed as a number; skipping.  (${tmpA})`);\n        }\n        else\n        {\n            tmpAggregationValue += tmpValue;\n        }\n    }\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'x', tmpAggregationValue);\n    return true;\n};\n\nclass MathJavascript extends libElucidatorInstructionSet\n{\n    constructor(pElucidator)\n    {\n        super(pElucidator);\n        this.namespace = 'Math';\n    }\n\n    initializeInstructions()\n    {\n        this.addInstruction('add', add);\n\n        this.addInstruction('subtract', subtract);\n        this.addInstruction('sub', subtract);\n\n        this.addInstruction('multiply', multiply);\n        this.addInstruction('mul', multiply);\n\n        this.addInstruction('divide', divide);\n        this.addInstruction('div', divide);\n\n        this.addInstruction('aggregate', aggregate);\n\n        return true;\n    }\n\n    initializeOperations()\n    {\n        this.addOperation('add', require(`./Operations/Math-Add.json`));\n        this.addOperation('subtract', require(`./Operations/Math-Subtract.json`));\n        this.addOperation('multiply', require(`./Operations/Math-Multiply.json`));\n        this.addOperation('divide', require(`./Operations/Math-Divide.json`));\n\n        this.addOperation('aggregate', require(`./Operations/Math-Aggregate.json`));\n\n        return true;\n    }\n}\n\nmodule.exports = MathJavascript;","module.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"Geometry\",\n\t\t\"Operation\": \"RectangleArea\",\n\t\t\"Synopsis\": \"Solve for the area of a rectangle:  Area = Width * Height\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"Width\": { \"Hash\":\"Width\", \"Type\":\"Number\" },\n\t\t\"Height\": { \"Hash\":\"Height\", \"Type\":\"Number\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"Area\": { \"Hash\":\"Area\", \"Name\": \"Area of the Rectangle\"},\n\t\t\"Ratio\": { \"Hash\":\"Ratio\", \"Name\": \"The Ratio between the Width and the Height\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Solve for [ {{Name:Area}} ] based on [ {{Name:Width}} ] and [ {{Name:Height}} ].\",\n\t\t\"PostOperation\": \"Operation complete; [ {{Name:Area}} ] = {{InputValue:Width}} * {{InputValue:Height}} = {{OutputValue:Area}}\"\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"PreciseMath\",\n\t\t\t\"Instruction\": \"multiply\",\n\t\t\t\"InputHashAddressMap\": \n\t\t\t\t{\n\t\t\t\t\t\"a\": \"Width\",\n\t\t\t\t\t\"b\": \"Height\"\n\t\t\t\t},\n\t\t\t\"OutputHashAddressMap\":\n\t\t\t\t{\n\t\t\t\t\t\"x\": \"Area\"\n\t\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"Namespace\": \"PreciseMath\",\n\t\t\t\"Instruction\": \"divide\",\n\t\t\t\"InputHashAddressMap\": \n\t\t\t\t{\n\t\t\t\t\t\"a\": \"Width\",\n\t\t\t\t\t\"b\": \"Height\"\n\t\t\t\t},\n\t\t\t\"OutputHashAddressMap\":\n\t\t\t\t{\n\t\t\t\t\t\"x\": \"Ratio\"\n\t\t\t\t}\n\t\t}\n\t]\n}","module.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"Logic\",\n\t\t\"Operation\": \"Execute\",\n\t\t\"Synopsis\": \"Execute an operation based on namespace and operation.\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"namespace\": { \"Hash\": \"namespace\", \"Type\": \"string\", \"Default\":\"logic\" },\n\t\t\"operation\": { \"Hash\": \"operation\", \"Type\": \"string\", \"Default\":\"noop\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Execute the {{InputValue:operation}} operation in namespace {{InputValue:namespace}}.\",\n\t\t\"PostOperation\": \"Operation [{{InputValue:namespace}}:{{InputValue:operation}}] execution complete.\"\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"Logic\",\n\t\t\t\"Instruction\": \"execute\"\n\t\t}\n\t]\n}","module.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"Logic\",\n\t\t\"Operation\": \"If\",\n\t\t\"Synopsis\": \"Comparison-based if of leftValue and RightValue based on comparator.  Executes trueNamespace:trueOperation or falseNamespace:falseOperation based on truthiness of result.  Also outputs a true or false to truthinessResult.\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"leftValue\": { \"Hash\":\"leftValue\", \"Type\":\"Any\" },\n\t\t\"rightValue\": { \"Hash\":\"rightValue\", \"Type\":\"Any\", \"Default\": true },\n\t\t\"comparator\": { \"Hash\":\"comparator\", \"Type\":\"String\", \"Default\":\"==\" },\n\n\t\t\"trueNamespace\": {\"Hash\":\"trueNamespace\", \"Type\":\"String\", \"Default\":\"logic\" },\n\t\t\"trueOperation\": {\"Hash\":\"trueOperation\", \"Type\":\"String\", \"Default\":\"noop\" },\n\n\t\t\"falseNamespace\": {\"Hash\":\"falseNamespace\", \"Type\":\"String\", \"Default\":\"logic\" },\n\t\t\"falseOperation\": {\"Hash\":\"falseOperation\", \"Type\":\"String\", \"Default\":\"noop\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"truthinessResult\": { \"Hash\": \"truthinessResult\", \"Type\": \"Boolean\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Compare {{Name:leftValue}} and {{Name:rightValue}} with the {{InputValue:comparator}} operator, storing the truthiness in {{Name:truthinessResult}}.\",\n\t\t\"PostOperation\": \"Operation complete: {{InputValue:leftValue}} {{InputValue:comparator}} {{InputValue:rightValue}} evaluated to {{OutputValue:truthinessResult}}\"\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"Logic\",\n\t\t\t\"Instruction\": \"If\"\n\t\t}\n\t]\n}","module.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"Math\",\n\t\t\"Operation\": \"Add\",\n\t\t\"Synopsis\": \"Add two numbers:  x = a + b\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"a\": { \"Hash\": \"a\", \"Type\": \"Number\" },\n\t\t\"b\": { \"Hash\": \"b\", \"Type\": \"Number\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"x\": { \"Hash\": \"x\", \"Type\": \"Number\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Add {{Name:a}} and {{Name:b}}, storing the value in {{Name:x}}.\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:x}} = {{InputValue:a}} + {{InputValue:b}} = {{OutputValue:x}}\"\t\t\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"Math\",\n\t\t\t\"Instruction\": \"add\"\n\t\t}\n\t]\n}","module.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"Math\",\n\t\t\"Operation\": \"Aggregate\",\n\t\t\"Synopsis\": \"Aggregate a set of numbers (from array or object address):  x = a + b + ... + z\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"a\": { \"Hash\": \"a\", \"Type\": \"Number\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"x\": { \"Hash\": \"x\", \"Type\": \"Number\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Aggregate all numeric values in {{Name:a}}, storing the resultant in {{Name:x}}.\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:x}} = {{OutputValue:x}}\"\t\t\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"Math\",\n\t\t\t\"Instruction\": \"aggregate\"\n\t\t}\n\t]\n}","module.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"Math\",\n\t\t\"Operation\": \"Divide\",\n\t\t\"Synopsis\": \"Divide two numbers:  x = a / b\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"a\": { \"Hash\": \"a\", \"Type\": \"Number\" },\n\t\t\"b\": { \"Hash\": \"b\", \"Type\": \"Number\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"x\": { \"Hash\": \"x\", \"Type\": \"Number\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Divide {{Name:a}} over {{Name:b}}, storing the value in {{Name:x}}.\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:x}} = {{InputValue:a}} / {{InputValue:b}} = {{OutputValue:x}}\"\t\t\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"Math\",\n\t\t\t\"Instruction\": \"divide\"\n\t\t}\n\t]\n}","module.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"Math\",\n\t\t\"Operation\": \"Multiply\",\n\t\t\"Synopsis\": \"Multiply two numbers:  x = a * b\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"a\": { \"Hash\": \"a\", \"Type\": \"Number\" },\n\t\t\"b\": { \"Hash\": \"b\", \"Type\": \"Number\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"x\": { \"Hash\": \"x\", \"Type\": \"Number\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Multiply {{Name:a}} and {{Name:b}}, storing the value in {{Name:x}}.\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:x}} = {{InputValue:a}} * {{InputValue:b}} = {{OutputValue:x}}\"\t\t\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"Math\",\n\t\t\t\"Instruction\": \"multiply\"\n\t\t}\n\t]\n}","module.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"Math\",\n\t\t\"Operation\": \"Subtract\",\n\t\t\"Synopsis\": \"Subtract two numbers:  x = a - b\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"a\": { \"Hash\": \"a\", \"Type\": \"Number\" },\n\t\t\"b\": { \"Hash\": \"b\", \"Type\": \"Number\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"x\": { \"Hash\": \"x\", \"Type\": \"Number\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Subtract {{Name:a}} and {{Name:b}}, storing the value in {{Name:x}}.\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:x}} = {{InputValue:a}} - {{InputValue:b}} = {{OutputValue:x}}\"\t\t\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"Math\",\n\t\t\t\"Instruction\": \"subtract\"\n\t\t}\n\t]\n}","module.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"PreciseMath\",\n\t\t\"Operation\": \"Add\",\n\t\t\"Synopsis\": \"Precisely add two numbers:  x = a + b\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"a\": { \"Hash\": \"a\", \"Type\": \"Number\" },\n\t\t\"b\": { \"Hash\": \"b\", \"Type\": \"Number\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"x\": { \"Hash\": \"x\", \"Type\": \"Number\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Add {{Name:a}} and {{Name:b}}, storing the value in {{Name:x}}.\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:x}} = {{InputValue:a}} + {{InputValue:b}} = {{OutputValue:x}}\"\t\t\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"PreciseMath\",\n\t\t\t\"Instruction\": \"add\"\n\t\t}\n\t]\n}","module.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"PreciseMath\",\n\t\t\"Operation\": \"Aggregate\",\n\t\t\"Synopsis\": \"Precisely aggregate a set of numbers (from array or object address):  x = a + b + ... + z\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"a\": { \"Hash\": \"a\", \"Type\": \"Number\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"x\": { \"Hash\": \"x\", \"Type\": \"Number\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Aggregate all numeric values in {{Name:a}}, storing the resultant in {{Name:x}}.\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:x}} = {{OutputValue:x}}\"\t\t\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"PreciseMath\",\n\t\t\t\"Instruction\": \"aggregate\"\n\t\t}\n\t]\n}","module.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"PreciseMath\",\n\t\t\"Operation\": \"Divide\",\n\t\t\"Synopsis\": \"Precisely divide two numbers:  x = a / b\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"a\": { \"Hash\": \"a\", \"Type\": \"Number\" },\n\t\t\"b\": { \"Hash\": \"b\", \"Type\": \"Number\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"x\": { \"Hash\": \"x\", \"Type\": \"Number\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Divide {{Name:a}} over {{Name:b}}, storing the value in {{Name:x}}.\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:x}} = {{InputValue:a}} / {{InputValue:b}} = {{OutputValue:x}}\"\t\t\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"PreciseMath\",\n\t\t\t\"Instruction\": \"divide\"\n\t\t}\n\t]\n}","module.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"PreciseMath\",\n\t\t\"Operation\": \"Multiply\",\n\t\t\"Synopsis\": \"Precisely multiply two numbers:  x = a * b\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"a\": { \"Hash\": \"a\", \"Type\": \"Number\" },\n\t\t\"b\": { \"Hash\": \"b\", \"Type\": \"Number\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"x\": { \"Hash\": \"x\", \"Type\": \"Number\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Multiply {{Name:a}} and {{Name:b}}, storing the value in {{Name:x}}.\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:x}} = {{InputValue:a}} * {{InputValue:b}} = {{OutputValue:x}}\"\t\t\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"PreciseMath\",\n\t\t\t\"Instruction\": \"multiply\"\n\t\t}\n\t]\n}","module.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"PreciseMath\",\n\t\t\"Operation\": \"Subtract\",\n\t\t\"Synopsis\": \"Precisely subtract two numbers:  x = a - b\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"a\": { \"Hash\": \"a\", \"Type\": \"Number\" },\n\t\t\"b\": { \"Hash\": \"b\", \"Type\": \"Number\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"x\": { \"Hash\": \"x\", \"Type\": \"Number\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Subtract {{Name:a}} and {{Name:b}}, storing the value in {{Name:x}}.\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:x}} = {{InputValue:a}} - {{InputValue:b}} = {{OutputValue:x}}\"\t\t\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"PreciseMath\",\n\t\t\t\"Instruction\": \"subtract\"\n\t\t}\n\t]\n}","module.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"String\",\n\t\t\"Operation\": \"Replace\",\n\t\t\"Synopsis\": \"Replace all instances of searchFor with replaceWith in inputString\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"inputString\": { \"Hash\": \"inputString\", \"Type\": \"String\" },\n\t\t\"searchFor\": { \"Hash\": \"searchFor\", \"Type\": \"String\" },\n\t\t\"replaceWith\": { \"Hash\": \"replaceWith\", \"Type\": \"String\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"outputString\": { \"Hash\": \"outputString\", \"Type\": \"String\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Search for [{{InputValue:searchFor}}] and replace it with [{{InputValue:replaceWith}}] in [{{InputValue:inputString}}].\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:outputString}} = [{{OutputValue:outputString}}] from [{{InputValue:inputString}}] replacing [{{InputValue:searchFor}}] with [{{InputValue:replaceWith}}].\"\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"String\",\n\t\t\t\"Instruction\": \"replace\"\n\t\t}\n\t]\n}","module.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"String\",\n\t\t\"Operation\": \"Substring\",\n\t\t\"Synopsis\": \"Get all characters between indexStart and indexEnd (optional) for a given inputString.\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"inputString\": { \"Hash\": \"inputString\", \"Type\": \"String\" },\n\t\t\"indexStart\": { \"Hash\": \"indexStart\", \"Type\": \"Number\", \"Default\":0 },\n\t\t\"indexEnd\": { \"Hash\": \"indexEnd\", \"Type\": \"String\", \"Default\":null }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"outputString\": { \"Hash\": \"outputString\", \"Type\": \"String\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Get all characters between {{InputValue:indexStart}} and {{InputValue:indexEnd}} in [{{InputValue:inputString}}].\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:outputString}} = [{{OutputValue:outputString}}] from [{{InputValue:inputString}}] between {{InputValue:indexStart}} and {{InputValue:indexEnd}}.\"\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"String\",\n\t\t\t\"Instruction\": \"substring\"\n\t\t}\n\t]\n}","module.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"String\",\n\t\t\"Operation\": \"Trim\",\n\t\t\"Synopsis\": \"Trim whitespace off the end of string in inputString, putting the result in outputString\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"inputString\": { \"Hash\": \"inputString\", \"Type\": \"String\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"outputString\": { \"Hash\": \"outputString\", \"Type\": \"String\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Trim the whitespace from value [{{InputValue:inputString}}].\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:outputString}} = [{{OutputValue:outputString}}] from [{{InputValue:inputString}}]\"\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"String\",\n\t\t\t\"Instruction\": \"trim\"\n\t\t}\n\t]\n}","let libElucidatorInstructionSet = require('../Elucidator-InstructionSet.js');\n\nconst libDecimal = require('decimal.js');\n\nlet add = (pOperation) =>\n{\n    // This could be done in one line, but, would be more difficult to comprehend.\n    let tmpA = new libDecimal(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'a'));\n    let tmpB = new libDecimal(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'b'));\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'x', tmpA.plus(tmpB).toString());\n    return true;\n};\n\nlet subtract = (pOperation) =>\n{\n    // This could be done in one line, but, would be more difficult to comprehend.\n    let tmpA = new libDecimal(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'a'));\n    let tmpB = new libDecimal(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'b'));\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'x', tmpA.sub(tmpB).toString());\n    return true;\n};\n\nlet multiply = (pOperation) =>\n{\n    // This could be done in one line, but, would be more difficult to comprehend.\n    let tmpA = new libDecimal(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'a'));\n    let tmpB = new libDecimal(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'b'));\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'x', tmpA.mul(tmpB).toString());\n    return true;\n};\n\nlet divide = (pOperation) =>\n{\n    // This could be done in one line, but, would be more difficult to comprehend.\n    let tmpA = new libDecimal(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'a'));\n    let tmpB = new libDecimal(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'b'));\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'x', tmpA.div(tmpB).toString());\n    return true;\n};\n\nlet aggregate = (pOperation) =>\n{\n    let tmpA = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'a');\n\n    let tmpObjectType = typeof(tmpA);\n\n    let tmpAggregationValue = new libDecimal(0);\n\n    if (tmpObjectType == 'object')\n    {\n        if (Array.isArray(tmpA))\n        {\n            for (let i = 0; i < tmpA.length; i++)\n            {\n                // If this is an array, enumerate it and try to aggregate each number\n                let tmpValue = new libDecimal(tmpA[i]);\n\n                if (isNaN(tmpValue))\n                {\n                    pOperation.logError(`Array element index [${i}] could not be parsed as a number by Decimal.js; skipping.  (${tmpA[i]})`);\n                }\n                else\n                {\n                    tmpAggregationValue = tmpAggregationValue.plus(tmpValue);\n                    pOperation.logInfo(`Adding element [${i}] value ${tmpValue} totaling: ${tmpAggregationValue}`)\n                }\n            }\n        }\n        else\n        {\n            let tmpObjectKeys = Object.keys(tmpA);\n            for (let i = 0; i < tmpObjectKeys.length; i++)\n            {\n                let tmpValue = new libDecimal(tmpA[tmpObjectKeys[i]]);\n\n                if (isNaN(tmpValue))\n                {\n                    pOperation.logError(`Object property [${tmpObjectKeys[i]}] could not be parsed as a number; skipping.  (${tmpA[tmpObjectKeys[i]]})`);\n                }\n                else\n                {\n                    tmpAggregationValue = tmpAggregationValue.plus(tmpValue);\n                    pOperation.logInfo(`Adding object property [${tmpObjectKeys[i]}] value ${tmpValue} totaling: ${tmpAggregationValue}`)\n                }\n            }\n        }\n    }\n    else\n    {\n        let tmpValue = new libDecimal(tmpA);\n\n        if (isNaN(tmpValue))\n        {\n            pOperation.logError(`Direct value could not be parsed as a number; skipping.  (${tmpA})`);\n        }\n        else\n        {\n            tmpAggregationValue = tmpValue;\n        }\n    }\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'x', tmpAggregationValue.toString());\n    return true;\n};\n\nlet toFraction = (pOperation) =>\n{\n    // This could be done in one line, but, would be more difficult to comprehend.\n    let tmpA = new libDecimal(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'a'));\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'x', tmpA.toFraction().toString());\n    return true;\n};\n\n\nclass PreciseMath extends libElucidatorInstructionSet\n{\n    constructor(pElucidator)\n    {\n        super(pElucidator);\n        this.namespace = 'PreciseMath';\n    }\n\n    initializeInstructions()\n    {\n        this.addInstruction('add', add);\n\n        this.addInstruction('subtract', subtract);\n        this.addInstruction('sub', subtract);\n\n        this.addInstruction('multiply', multiply);\n        this.addInstruction('mul', multiply);\n\n        this.addInstruction('divide', divide);\n        this.addInstruction('div', divide);\n\n        this.addInstruction('aggregate', aggregate);\n\n\t\tthis.addInstruction('tofraction', toFraction);\n\n        return true;\n    }\n\n    initializeOperations()\n    {\n        this.addOperation('add', require(`./Operations/PreciseMath-Add.json`));\n        this.addOperation('subtract', require(`./Operations/PreciseMath-Subtract.json`));\n        this.addOperation('multiply', require(`./Operations/PreciseMath-Multiply.json`));\n        this.addOperation('divide', require(`./Operations/PreciseMath-Divide.json`));\n        this.addOperation('aggregate', require('./Operations/PreciseMath-Aggregate.json'));\n\n        return true;\n    }\n}\n\nmodule.exports = PreciseMath;","// Solution providers are meant to be stateless, and not classes.\n// These solution providers are akin to drivers, connecting code libraries or \n// other types of behavior to mapping operations.\n\nlet libElucidatorInstructionSet = require('../Elucidator-InstructionSet.js');\n\nlet trim = (pOperation) =>\n{\n    let tmpInputString = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'inputString');\n\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'outputString', tmpInputString.trim());\n\n    return true;\n};\n\nlet replace = (pOperation) =>\n{\n    let tmpInputString = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'inputString');\n    let tmpSearchFor = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'searchFor');\n    let tmpReplaceWith = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'replaceWith');\n\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'outputString', tmpInputString.replace(tmpSearchFor, tmpReplaceWith));\n\n    return true;\n};\n\nlet substring = (pOperation) =>\n{\n    let tmpInputString = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'inputString');\n    let indexStart = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'indexStart');\n    let indexEnd = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'indexEnd');\n\n    if (indexEnd != null)\n    {\n        pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'outputString', tmpInputString.substring(indexStart, indexEnd));\n    }\n    else\n    {\n        pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'outputString', tmpInputString.substring(indexStart));\n    }\n\n    return true;\n};\n\nclass StringOperations extends libElucidatorInstructionSet\n{\n    constructor(pElucidator)\n    {\n        super(pElucidator);\n        this.namespace = 'String';\n    }\n\n    initializeInstructions()\n    {\n        this.addInstruction('trim', trim);\n        this.addInstruction('replace', replace);\n        this.addInstruction('substring', substring);\n\n        return true;\n    }\n\n    initializeOperations()\n    {\n        this.addOperation('trim', require(`./Operations/String-Trim.json`));\n        this.addOperation('replace', require(`./Operations/String-Replace.json`));\n        this.addOperation('substring', require(`./Operations/String-Substring.json`));\n\n        return true;\n    }\n}\n\nmodule.exports = StringOperations;"]}