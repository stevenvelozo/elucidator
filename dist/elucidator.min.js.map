{"version":3,"sources":["node_modules/browser-pack/_prelude.js","node_modules/decimal.js/decimal.js","elucidator.min.js","node_modules/elucidator/source/Elucidator-InstructionSet.js","node_modules/elucidator/source/Elucidator-LogToConsole.js","node_modules/elucidator/source/Elucidator.js","node_modules/elucidator/source/InstructionSets/Geometry.js","node_modules/elucidator/source/InstructionSets/Logic.js","node_modules/elucidator/source/InstructionSets/Math-Javascript.js","node_modules/elucidator/source/InstructionSets/Operations/Geometry-RectangleArea.json","node_modules/elucidator/source/InstructionSets/Operations/Logic-Execute.json","node_modules/elucidator/source/InstructionSets/Operations/Logic-If.json","node_modules/elucidator/source/InstructionSets/Operations/Math-Add.json","node_modules/elucidator/source/InstructionSets/Operations/Math-Aggregate.json","node_modules/elucidator/source/InstructionSets/Operations/Math-Divide.json","node_modules/elucidator/source/InstructionSets/Operations/Math-Multiply.json","node_modules/elucidator/source/InstructionSets/Operations/Math-Subtract.json","node_modules/elucidator/source/InstructionSets/Operations/PreciseMath-Add.json","node_modules/elucidator/source/InstructionSets/Operations/PreciseMath-Aggregate.json","node_modules/elucidator/source/InstructionSets/Operations/PreciseMath-Divide.json","node_modules/elucidator/source/InstructionSets/Operations/PreciseMath-GroupValuesAndAggregate.json","node_modules/elucidator/source/InstructionSets/Operations/PreciseMath-Multiply.json","node_modules/elucidator/source/InstructionSets/Operations/PreciseMath-Round.json","node_modules/elucidator/source/InstructionSets/Operations/PreciseMath-SetPrecision.json","node_modules/elucidator/source/InstructionSets/Operations/PreciseMath-SetRoundingMode.json","node_modules/elucidator/source/InstructionSets/Operations/PreciseMath-Subtract.json","node_modules/elucidator/source/InstructionSets/Operations/PreciseMath-ToDecimalPlaces.json","node_modules/elucidator/source/InstructionSets/Operations/PreciseMath-ToSignificantDigits.json","node_modules/elucidator/source/InstructionSets/Operations/Set-GroupValuesBy.json","node_modules/elucidator/source/InstructionSets/Operations/String-Replace.json","node_modules/elucidator/source/InstructionSets/Operations/String-Substring.json","node_modules/elucidator/source/InstructionSets/Operations/String-Trim.json","node_modules/elucidator/source/InstructionSets/PreciseMath-Decimal.js","node_modules/elucidator/source/InstructionSets/Set.js","node_modules/elucidator/source/InstructionSets/String.js","node_modules/manyfest/source/Manyfest-CleanWrapCharacters.js","node_modules/manyfest/source/Manyfest-HashTranslation.js","node_modules/manyfest/source/Manyfest-LogToConsole.js","node_modules/manyfest/source/Manyfest-ObjectAddress-CheckAddressExists.js","node_modules/manyfest/source/Manyfest-ObjectAddress-DeleteValue.js","node_modules/manyfest/source/Manyfest-ObjectAddress-GetValue.js","node_modules/manyfest/source/Manyfest-ObjectAddress-SetValue.js","node_modules/manyfest/source/Manyfest-ObjectAddressGeneration.js","node_modules/manyfest/source/Manyfest-SchemaManipulation.js","node_modules/manyfest/source/Manyfest.js","node_modules/precedent/source/Precedent.js","node_modules/precedent/source/StringParser.js","node_modules/precedent/source/WordTree.js","source/Elucidator-Browser-Shim.js","source/InstructionSets/Operations/PreciseMath-Aggregate.json"],"names":["f","exports","module","define","amd","window","global","self","this","Elucidator","r","e","n","t","o","i","c","require","u","a","Error","code","p","call","length","globalScope","Decimal","inexact","noConflict","quadrant","EXP_LIMIT","MAX_DIGITS","NUMERALS","LN10","PI","DEFAULTS","precision","rounding","modulo","toExpNeg","toExpPos","minE","maxE","crypto","external","decimalError","invalidArgument","precisionLimitExceeded","cryptoUnavailable","tag","mathfloor","Math","floor","mathpow","pow","isBinary","isHex","isOctal","isDecimal","BASE","LOG_BASE","LN10_PRECISION","PI_PRECISION","P","toStringTag","digitsToString","d","k","ws","indexOfLastWord","str","w","getZeroString","checkInt32","min","max","checkRoundingDigits","rm","repeating","di","rd","ceil","convertBase","baseIn","baseOut","j","arrL","arr","strL","indexOf","charAt","reverse","absoluteValue","abs","x","constructor","s","finalise","clampedTo","clamp","Ctor","NaN","gt","cmp","comparedTo","y","xdL","ydL","xd","yd","xs","ys","cosine","cos","pr","sd","len","isZero","tinyPow","toString","taylorSeries","times","cos2x","minus","plus","toLessThanHalfPi","neg","cubeRoot","cbrt","m","rep","t3","t3plusx","isFinite","toExponential","slice","divide","eq","decimalPlaces","dp","dividedBy","div","dividedToIntegerBy","divToInt","equals","greaterThan","greaterThanOrEqualTo","gte","hyperbolicCosine","cosh","one","cosh2_x","d8","hyperbolicSine","sinh","sqrt","sinh2_x","d5","d16","d20","hyperbolicTangent","tanh","inverseCosine","acos","halfPi","isNeg","getPi","asin","inverseHyperbolicCosine","acosh","lte","ln","inverseHyperbolicSine","asinh","inverseHyperbolicTangent","atanh","wpr","xsd","inverseSine","atan","inverseTangent","px","x2","isInteger","isInt","isNaN","isNegative","isPositive","isPos","lessThan","lt","lessThanOrEqualTo","logarithm","log","base","isBase10","denominator","inf","num","arg","naturalLogarithm","getLn10","sub","xe","xLTy","push","pop","shift","getBase10Exponent","mod","q","naturalExponential","exp","negated","add","carry","unshift","z","getPrecision","round","sine","sin","sin2_x","squareRoot","tangent","tan","mul","rL","toBinary","toStringBinary","toDecimalPlaces","toDP","finiteToString","toFixed","toFraction","maxD","d0","d1","d2","n0","n1","toHexadecimal","toHex","toNearest","toNumber","toOctal","toPower","yn","intPow","toPrecision","toSignificantDigits","toSD","truncated","trunc","valueOf","toJSON","multiplyInteger","temp","compare","b","aL","bL","subtract","logBase","more","prod","prodL","qd","rem","remL","rem0","xi","xL","yd0","yL","yz","sign","isTruncated","digits","roundUp","xdi","out","isExp","nonFiniteToString","zs","truncate","isOdd","maxOrMin","args","ltgt","guard","sum","c0","numerator","x1","String","parseDecimal","replace","search","substring","charCodeAt","parseOther","divisor","isFloat","test","toLowerCase","isHyperbolic","pi","atan2","config","obj","v","useDefaults","defaults","ps","getRandomValues","randomBytes","hypot","arguments","isDecimalInstance","log2","log10","random","Uint32Array","copy","clone","prototype","ROUND_UP","ROUND_DOWN","ROUND_CEIL","ROUND_FLOOR","ROUND_HALF_UP","ROUND_HALF_DOWN","ROUND_HALF_EVEN","ROUND_HALF_CEIL","ROUND_HALF_FLOOR","EUCLID","set","hasOwnProperty","Symbol","iterator","pElucidator","elucidator","namespace","initializeNamespace","pNamespace","instructionSets","operationSets","addInstruction","pInstructionHash","fInstructionFunction","logError","initializeInstructions","pOperation","logInfo","addOperation","pOperationHash","Description","Hash","Operation","Namespace","Summary","Inputs","Outputs","Steps","Array","isArray","initializeOperations","logToConsole","pLogLine","pLogObject","pLogLevel","tmpLogLine","tmpLogLevel","console","JSON","stringify","info","warning","logWarning","error","libSimpleLog","libManyfest","libPrecedent","libElucidatorInstructionSet","pOperations","fInfoLog","fErrorLog","fWarningLog","UUID","loadDefaultInstructionSets","tmpSolverHashes","Object","keys","loadInstructionSet","cInstructionSet","tmpInstructionSet","operationExists","tmpNamespace","tmpOperationInjector","solveInternalOperation","pInputObject","pOutputObject","pDescriptionManyfest","pInputAddressMapping","pOutputAddressMapping","pSolutionContext","tmpOperation","solveOperation","pOperationObject","parse","tmpInputObject","tmpOutputObject","tmpSolutionContext","SolutionGUID","SolutionBaseNamespace","SolutionBaseOperation","SolutionLog","InputHashMapping","InputHashTranslationTable","OutputHashMapping","OutputHashTranslationTable","tmpOutputHashMapping","tmpInputHashMapping","tmpDescriptionManyfest","schemaManipulations","mergeAddressMappings","resolveAddressMappings","hashTranslations","addTranslation","SolutionContext","Synopsys","tmpPrecedent","addPattern","pHash","tmpHash","trim","tmpDescriptor","getDescriptorByHash","Name","getValueByHash","Log","PreOperation","parseString","tmpStep","tmpInputSchema","Scope","Descriptors","InputHashAddressMap","tmpInputManyfest","tmpOutputSchema","OutputHashAddressMap","tmpOutputManyfest","tmpInstructionState","Instruction","DescriptionManyfest","InputObject","InputManyfest","OutputObject","OutputManyfest","pMessage","fInstruction","PostOperation","manyfest","precedent","super","ifInstruction","tmpLeftValue","tmpRightValue","tmpComparator","tmpComparisonOperator","tmpComparisonOperatorMapping","equal","noteq","notequal","id","identity","greaterthan","greaterthanorequal","lessthan","lessthanorequal","tmpTrueNamespace","tmpTrueOperation","tmpFalseNamespace","tmpFalseOperation","tmpTruthiness","setValueByHash","executeOperation","tmpA","tmpB","multiply","aggregate","tmpAggregationValue","tmpValue","parseInt","tmpObjectKeys","Synopsis","Width","Type","Height","Area","Ratio","Default","operation","leftValue","rightValue","comparator","trueNamespace","trueOperation","falseNamespace","falseOperation","truthinessResult","inputDataSet","groupByProperty","groupValueProperty","recordIndicatorProperty","outputDataSet","roundingmode","decimalplaces","inputString","searchFor","replaceWith","outputString","indexStart","indexEnd","libDecimal","tmpPrecision","tmpRoundingMode","tosignificantdigits","tmpDigits","todecimalplaces","tmpDecimalPlaces","setprecision","setroundingmode","tmpObjectType","groupValuesAndAggregate","tmpInputDataSet","tmpGroupByProperty","tmpGroupValueProperty","tmpOutputDataSet","tmpProcessedOutputDataSet","tmpGroupByValue","tmpDecimalValue","tmpOutputGroups","groupValuesBy","tmpInputString","tmpSearchFor","tmpReplaceWith","cleanWrapCharacters","pCharacter","pString","startsWith","endsWith","pInfoLog","pErrorLog","translationTable","translationCount","pTranslation","forEach","pTranslationSource","removeTranslationHash","pTranslationHash","removeTranslation","clearTranslations","translate","elucidatorSolver","elucidatorSolverState","checkAddressExists","pObject","pAddress","tmpSeparatorIndex","tmpBracketStartIndex","tmpBracketStopIndex","tmpBoxedPropertyName","tmpBoxedPropertyReference","tmpBoxedPropertyNumber","tmpSubObjectName","tmpNewAddress","fCleanWrapCharacters","checkFilters","pRecord","tmpAddress","libElucidator","tmpFilterState","Record","keepRecord","SolutionState","pMagicSearchExpression","tmpMagicComparisonPatternSet","split","tmpSearchAddress","tmpSearchComparator","tmpSearchValue","ComparisonState","SearchAddress","Comparator","SearchTerm","deleteValueAtAddress","pParentAddress","tmpParentAddress","tmpObjectTypeMarkerIndex","tmpInputArray","splice","tmpObjectPropertyName","tmpArrayProperty","tmpContainerObject","tmpPropertyParentAddress","tmpObjectProperty","tmpObjectPropertyKeys","getValueAtAddress","tmpOutputArray","setValueAtAddress","pValue","generateAddressses","pBaseAddress","pSchema","tmpBaseAddress","tmpSchema","tmpSchemaObjectEntry","Address","InSchema","DataType","tmpObjectProperties","pManyfestSchemaDescriptors","pAddressMapping","tmpManyfestAddresses","tmpHashMapping","pInputAddress","tmpNewDescriptorAddress","tmpOldDescriptorAddress","safeResolveAddressMappings","tmpManyfestSchemaDescriptors","pManyfestSchemaDescriptorsDestination","pManyfestSchemaDescriptorsSource","tmpSource","tmpNewManyfestSchemaDescriptors","pDescriptorAddress","libHashTranslation","libObjectAddressCheckAddressExists","libObjectAddressGetValue","libObjectAddressSetValue","libObjectAddressDeleteValue","libObjectAddressGeneration","libSchemaManipulation","Manyfest","pManifest","pOptions","objectAddressCheckAddressExists","objectAddressGetValue","objectAddressSetValue","objectAddressDeleteValue","options","strict","defaultValues","Number","Float","Integer","Boolean","Binary","DateTime","Null","scope","undefined","elementAddresses","elementHashes","elementDescriptors","dataSolvers","dataSolverState","reset","loadManifest","objectAddressGeneration","setElucidatorSolvers","pElucidatorSolver","pElucidatorSolverState","tmpNewOptions","tmpNewManyfest","getManifest","deserialize","pManifestString","tmpDescriptionAddresses","addDescriptor","Solvers","tmpSolverKeys","serialize","pDescriptor","getDescriptor","resolveHashAddress","eachDescriptor","fAction","tmpDescriptorAddresses","checkAddressExistsByHash","tmpInElementHashTable","tmpInTranslationTable","getDefaultValue","deleteValueByHash","validate","tmpValidationData","Errors","MissingElements","addValidationError","pErrorMessage","tmpValueExists","Required","tmpElementType","Date","tmpDataType","populateDefaults","pOverwriteProperties","populateObject","fFilter","tmpObject","tmpOverwriteProperties","tmpFilterFunction","libWordTree","libStringParser","WordTree","StringParser","ParseTree","pPatternStart","pPatternEnd","pParser","newParserState","pParseTree","Output","OutputBuffer","Pattern","PatternMatch","PatternMatchOutputBuffer","assignNode","pNode","pParserState","appendOutputBuffer","flushOutputBuffer","checkPatternEnd","PatternEnd","PatternStart","substr","Parse","parseCharacter","tmpParserState","addChild","pTree","pPattern","pIndex","tmpLeaf","pData","apply","dup","ValueNames"],"mappings":"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","file":"elucidator.min.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()",";(function (globalScope) {\r\n  'use strict';\r\n\r\n\r\n  /*!\r\n   *  decimal.js v10.4.3\r\n   *  An arbitrary-precision Decimal type for JavaScript.\r\n   *  https://github.com/MikeMcl/decimal.js\r\n   *  Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>\r\n   *  MIT Licence\r\n   */\r\n\r\n\r\n  // -----------------------------------  EDITABLE DEFAULTS  ------------------------------------ //\r\n\r\n\r\n    // The maximum exponent magnitude.\r\n    // The limit on the value of `toExpNeg`, `toExpPos`, `minE` and `maxE`.\r\n  var EXP_LIMIT = 9e15,                      // 0 to 9e15\r\n\r\n    // The limit on the value of `precision`, and on the value of the first argument to\r\n    // `toDecimalPlaces`, `toExponential`, `toFixed`, `toPrecision` and `toSignificantDigits`.\r\n    MAX_DIGITS = 1e9,                        // 0 to 1e9\r\n\r\n    // Base conversion alphabet.\r\n    NUMERALS = '0123456789abcdef',\r\n\r\n    // The natural logarithm of 10 (1025 digits).\r\n    LN10 = '2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058',\r\n\r\n    // Pi (1025 digits).\r\n    PI = '3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789',\r\n\r\n\r\n    // The initial configuration properties of the Decimal constructor.\r\n    DEFAULTS = {\r\n\r\n      // These values must be integers within the stated ranges (inclusive).\r\n      // Most of these values can be changed at run-time using the `Decimal.config` method.\r\n\r\n      // The maximum number of significant digits of the result of a calculation or base conversion.\r\n      // E.g. `Decimal.config({ precision: 20 });`\r\n      precision: 20,                         // 1 to MAX_DIGITS\r\n\r\n      // The rounding mode used when rounding to `precision`.\r\n      //\r\n      // ROUND_UP         0 Away from zero.\r\n      // ROUND_DOWN       1 Towards zero.\r\n      // ROUND_CEIL       2 Towards +Infinity.\r\n      // ROUND_FLOOR      3 Towards -Infinity.\r\n      // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.\r\n      // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.\r\n      // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.\r\n      // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.\r\n      // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.\r\n      //\r\n      // E.g.\r\n      // `Decimal.rounding = 4;`\r\n      // `Decimal.rounding = Decimal.ROUND_HALF_UP;`\r\n      rounding: 4,                           // 0 to 8\r\n\r\n      // The modulo mode used when calculating the modulus: a mod n.\r\n      // The quotient (q = a / n) is calculated according to the corresponding rounding mode.\r\n      // The remainder (r) is calculated as: r = a - n * q.\r\n      //\r\n      // UP         0 The remainder is positive if the dividend is negative, else is negative.\r\n      // DOWN       1 The remainder has the same sign as the dividend (JavaScript %).\r\n      // FLOOR      3 The remainder has the same sign as the divisor (Python %).\r\n      // HALF_EVEN  6 The IEEE 754 remainder function.\r\n      // EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.\r\n      //\r\n      // Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian\r\n      // division (9) are commonly used for the modulus operation. The other rounding modes can also\r\n      // be used, but they may not give useful results.\r\n      modulo: 1,                             // 0 to 9\r\n\r\n      // The exponent value at and beneath which `toString` returns exponential notation.\r\n      // JavaScript numbers: -7\r\n      toExpNeg: -7,                          // 0 to -EXP_LIMIT\r\n\r\n      // The exponent value at and above which `toString` returns exponential notation.\r\n      // JavaScript numbers: 21\r\n      toExpPos:  21,                         // 0 to EXP_LIMIT\r\n\r\n      // The minimum exponent value, beneath which underflow to zero occurs.\r\n      // JavaScript numbers: -324  (5e-324)\r\n      minE: -EXP_LIMIT,                      // -1 to -EXP_LIMIT\r\n\r\n      // The maximum exponent value, above which overflow to Infinity occurs.\r\n      // JavaScript numbers: 308  (1.7976931348623157e+308)\r\n      maxE: EXP_LIMIT,                       // 1 to EXP_LIMIT\r\n\r\n      // Whether to use cryptographically-secure random number generation, if available.\r\n      crypto: false                          // true/false\r\n    },\r\n\r\n\r\n  // ----------------------------------- END OF EDITABLE DEFAULTS ------------------------------- //\r\n\r\n\r\n    Decimal, inexact, noConflict, quadrant,\r\n    external = true,\r\n\r\n    decimalError = '[DecimalError] ',\r\n    invalidArgument = decimalError + 'Invalid argument: ',\r\n    precisionLimitExceeded = decimalError + 'Precision limit exceeded',\r\n    cryptoUnavailable = decimalError + 'crypto unavailable',\r\n    tag = '[object Decimal]',\r\n\r\n    mathfloor = Math.floor,\r\n    mathpow = Math.pow,\r\n\r\n    isBinary = /^0b([01]+(\\.[01]*)?|\\.[01]+)(p[+-]?\\d+)?$/i,\r\n    isHex = /^0x([0-9a-f]+(\\.[0-9a-f]*)?|\\.[0-9a-f]+)(p[+-]?\\d+)?$/i,\r\n    isOctal = /^0o([0-7]+(\\.[0-7]*)?|\\.[0-7]+)(p[+-]?\\d+)?$/i,\r\n    isDecimal = /^(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?$/i,\r\n\r\n    BASE = 1e7,\r\n    LOG_BASE = 7,\r\n    MAX_SAFE_INTEGER = 9007199254740991,\r\n\r\n    LN10_PRECISION = LN10.length - 1,\r\n    PI_PRECISION = PI.length - 1,\r\n\r\n    // Decimal.prototype object\r\n    P = { toStringTag: tag };\r\n\r\n\r\n  // Decimal prototype methods\r\n\r\n\r\n  /*\r\n   *  absoluteValue             abs\r\n   *  ceil\r\n   *  clampedTo                 clamp\r\n   *  comparedTo                cmp\r\n   *  cosine                    cos\r\n   *  cubeRoot                  cbrt\r\n   *  decimalPlaces             dp\r\n   *  dividedBy                 div\r\n   *  dividedToIntegerBy        divToInt\r\n   *  equals                    eq\r\n   *  floor\r\n   *  greaterThan               gt\r\n   *  greaterThanOrEqualTo      gte\r\n   *  hyperbolicCosine          cosh\r\n   *  hyperbolicSine            sinh\r\n   *  hyperbolicTangent         tanh\r\n   *  inverseCosine             acos\r\n   *  inverseHyperbolicCosine   acosh\r\n   *  inverseHyperbolicSine     asinh\r\n   *  inverseHyperbolicTangent  atanh\r\n   *  inverseSine               asin\r\n   *  inverseTangent            atan\r\n   *  isFinite\r\n   *  isInteger                 isInt\r\n   *  isNaN\r\n   *  isNegative                isNeg\r\n   *  isPositive                isPos\r\n   *  isZero\r\n   *  lessThan                  lt\r\n   *  lessThanOrEqualTo         lte\r\n   *  logarithm                 log\r\n   *  [maximum]                 [max]\r\n   *  [minimum]                 [min]\r\n   *  minus                     sub\r\n   *  modulo                    mod\r\n   *  naturalExponential        exp\r\n   *  naturalLogarithm          ln\r\n   *  negated                   neg\r\n   *  plus                      add\r\n   *  precision                 sd\r\n   *  round\r\n   *  sine                      sin\r\n   *  squareRoot                sqrt\r\n   *  tangent                   tan\r\n   *  times                     mul\r\n   *  toBinary\r\n   *  toDecimalPlaces           toDP\r\n   *  toExponential\r\n   *  toFixed\r\n   *  toFraction\r\n   *  toHexadecimal             toHex\r\n   *  toNearest\r\n   *  toNumber\r\n   *  toOctal\r\n   *  toPower                   pow\r\n   *  toPrecision\r\n   *  toSignificantDigits       toSD\r\n   *  toString\r\n   *  truncated                 trunc\r\n   *  valueOf                   toJSON\r\n   */\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the absolute value of this Decimal.\r\n   *\r\n   */\r\n  P.absoluteValue = P.abs = function () {\r\n    var x = new this.constructor(this);\r\n    if (x.s < 0) x.s = 1;\r\n    return finalise(x);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal rounded to a whole number in the\r\n   * direction of positive Infinity.\r\n   *\r\n   */\r\n  P.ceil = function () {\r\n    return finalise(new this.constructor(this), this.e + 1, 2);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal clamped to the range\r\n   * delineated by `min` and `max`.\r\n   *\r\n   * min {number|string|Decimal}\r\n   * max {number|string|Decimal}\r\n   *\r\n   */\r\n  P.clampedTo = P.clamp = function (min, max) {\r\n    var k,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n    min = new Ctor(min);\r\n    max = new Ctor(max);\r\n    if (!min.s || !max.s) return new Ctor(NaN);\r\n    if (min.gt(max)) throw Error(invalidArgument + max);\r\n    k = x.cmp(min);\r\n    return k < 0 ? min : x.cmp(max) > 0 ? max : new Ctor(x);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return\r\n   *   1    if the value of this Decimal is greater than the value of `y`,\r\n   *  -1    if the value of this Decimal is less than the value of `y`,\r\n   *   0    if they have the same value,\r\n   *   NaN  if the value of either Decimal is NaN.\r\n   *\r\n   */\r\n  P.comparedTo = P.cmp = function (y) {\r\n    var i, j, xdL, ydL,\r\n      x = this,\r\n      xd = x.d,\r\n      yd = (y = new x.constructor(y)).d,\r\n      xs = x.s,\r\n      ys = y.s;\r\n\r\n    // Either NaN or ±Infinity?\r\n    if (!xd || !yd) {\r\n      return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;\r\n    }\r\n\r\n    // Either zero?\r\n    if (!xd[0] || !yd[0]) return xd[0] ? xs : yd[0] ? -ys : 0;\r\n\r\n    // Signs differ?\r\n    if (xs !== ys) return xs;\r\n\r\n    // Compare exponents.\r\n    if (x.e !== y.e) return x.e > y.e ^ xs < 0 ? 1 : -1;\r\n\r\n    xdL = xd.length;\r\n    ydL = yd.length;\r\n\r\n    // Compare digit by digit.\r\n    for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) {\r\n      if (xd[i] !== yd[i]) return xd[i] > yd[i] ^ xs < 0 ? 1 : -1;\r\n    }\r\n\r\n    // Compare lengths.\r\n    return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the cosine of the value in radians of this Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-1, 1]\r\n   *\r\n   * cos(0)         = 1\r\n   * cos(-0)        = 1\r\n   * cos(Infinity)  = NaN\r\n   * cos(-Infinity) = NaN\r\n   * cos(NaN)       = NaN\r\n   *\r\n   */\r\n  P.cosine = P.cos = function () {\r\n    var pr, rm,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (!x.d) return new Ctor(NaN);\r\n\r\n    // cos(0) = cos(-0) = 1\r\n    if (!x.d[0]) return new Ctor(1);\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n    Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;\r\n    Ctor.rounding = 1;\r\n\r\n    x = cosine(Ctor, toLessThanHalfPi(Ctor, x));\r\n\r\n    Ctor.precision = pr;\r\n    Ctor.rounding = rm;\r\n\r\n    return finalise(quadrant == 2 || quadrant == 3 ? x.neg() : x, pr, rm, true);\r\n  };\r\n\r\n\r\n  /*\r\n   *\r\n   * Return a new Decimal whose value is the cube root of the value of this Decimal, rounded to\r\n   * `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   *  cbrt(0)  =  0\r\n   *  cbrt(-0) = -0\r\n   *  cbrt(1)  =  1\r\n   *  cbrt(-1) = -1\r\n   *  cbrt(N)  =  N\r\n   *  cbrt(-I) = -I\r\n   *  cbrt(I)  =  I\r\n   *\r\n   * Math.cbrt(x) = (x < 0 ? -Math.pow(-x, 1/3) : Math.pow(x, 1/3))\r\n   *\r\n   */\r\n  P.cubeRoot = P.cbrt = function () {\r\n    var e, m, n, r, rep, s, sd, t, t3, t3plusx,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (!x.isFinite() || x.isZero()) return new Ctor(x);\r\n    external = false;\r\n\r\n    // Initial estimate.\r\n    s = x.s * mathpow(x.s * x, 1 / 3);\r\n\r\n     // Math.cbrt underflow/overflow?\r\n     // Pass x to Math.pow as integer, then adjust the exponent of the result.\r\n    if (!s || Math.abs(s) == 1 / 0) {\r\n      n = digitsToString(x.d);\r\n      e = x.e;\r\n\r\n      // Adjust n exponent so it is a multiple of 3 away from x exponent.\r\n      if (s = (e - n.length + 1) % 3) n += (s == 1 || s == -2 ? '0' : '00');\r\n      s = mathpow(n, 1 / 3);\r\n\r\n      // Rarely, e may be one less than the result exponent value.\r\n      e = mathfloor((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2));\r\n\r\n      if (s == 1 / 0) {\r\n        n = '5e' + e;\r\n      } else {\r\n        n = s.toExponential();\r\n        n = n.slice(0, n.indexOf('e') + 1) + e;\r\n      }\r\n\r\n      r = new Ctor(n);\r\n      r.s = x.s;\r\n    } else {\r\n      r = new Ctor(s.toString());\r\n    }\r\n\r\n    sd = (e = Ctor.precision) + 3;\r\n\r\n    // Halley's method.\r\n    // TODO? Compare Newton's method.\r\n    for (;;) {\r\n      t = r;\r\n      t3 = t.times(t).times(t);\r\n      t3plusx = t3.plus(x);\r\n      r = divide(t3plusx.plus(x).times(t), t3plusx.plus(t3), sd + 2, 1);\r\n\r\n      // TODO? Replace with for-loop and checkRoundingDigits.\r\n      if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {\r\n        n = n.slice(sd - 3, sd + 1);\r\n\r\n        // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or 4999\r\n        // , i.e. approaching a rounding boundary, continue the iteration.\r\n        if (n == '9999' || !rep && n == '4999') {\r\n\r\n          // On the first iteration only, check to see if rounding up gives the exact result as the\r\n          // nines may infinitely repeat.\r\n          if (!rep) {\r\n            finalise(t, e + 1, 0);\r\n\r\n            if (t.times(t).times(t).eq(x)) {\r\n              r = t;\r\n              break;\r\n            }\r\n          }\r\n\r\n          sd += 4;\r\n          rep = 1;\r\n        } else {\r\n\r\n          // If the rounding digits are null, 0{0,4} or 50{0,3}, check for an exact result.\r\n          // If not, then there are further digits and m will be truthy.\r\n          if (!+n || !+n.slice(1) && n.charAt(0) == '5') {\r\n\r\n            // Truncate to the first rounding digit.\r\n            finalise(r, e + 1, 1);\r\n            m = !r.times(r).times(r).eq(x);\r\n          }\r\n\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    external = true;\r\n\r\n    return finalise(r, e, Ctor.rounding, m);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return the number of decimal places of the value of this Decimal.\r\n   *\r\n   */\r\n  P.decimalPlaces = P.dp = function () {\r\n    var w,\r\n      d = this.d,\r\n      n = NaN;\r\n\r\n    if (d) {\r\n      w = d.length - 1;\r\n      n = (w - mathfloor(this.e / LOG_BASE)) * LOG_BASE;\r\n\r\n      // Subtract the number of trailing zeros of the last word.\r\n      w = d[w];\r\n      if (w) for (; w % 10 == 0; w /= 10) n--;\r\n      if (n < 0) n = 0;\r\n    }\r\n\r\n    return n;\r\n  };\r\n\r\n\r\n  /*\r\n   *  n / 0 = I\r\n   *  n / N = N\r\n   *  n / I = 0\r\n   *  0 / n = 0\r\n   *  0 / 0 = N\r\n   *  0 / N = N\r\n   *  0 / I = 0\r\n   *  N / n = N\r\n   *  N / 0 = N\r\n   *  N / N = N\r\n   *  N / I = N\r\n   *  I / n = I\r\n   *  I / 0 = I\r\n   *  I / N = N\r\n   *  I / I = N\r\n   *\r\n   * Return a new Decimal whose value is the value of this Decimal divided by `y`, rounded to\r\n   * `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   */\r\n  P.dividedBy = P.div = function (y) {\r\n    return divide(this, new this.constructor(y));\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the integer part of dividing the value of this Decimal\r\n   * by the value of `y`, rounded to `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   */\r\n  P.dividedToIntegerBy = P.divToInt = function (y) {\r\n    var x = this,\r\n      Ctor = x.constructor;\r\n    return finalise(divide(x, new Ctor(y), 0, 1, 1), Ctor.precision, Ctor.rounding);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is equal to the value of `y`, otherwise return false.\r\n   *\r\n   */\r\n  P.equals = P.eq = function (y) {\r\n    return this.cmp(y) === 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal rounded to a whole number in the\r\n   * direction of negative Infinity.\r\n   *\r\n   */\r\n  P.floor = function () {\r\n    return finalise(new this.constructor(this), this.e + 1, 3);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is greater than the value of `y`, otherwise return\r\n   * false.\r\n   *\r\n   */\r\n  P.greaterThan = P.gt = function (y) {\r\n    return this.cmp(y) > 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is greater than or equal to the value of `y`,\r\n   * otherwise return false.\r\n   *\r\n   */\r\n  P.greaterThanOrEqualTo = P.gte = function (y) {\r\n    var k = this.cmp(y);\r\n    return k == 1 || k === 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the hyperbolic cosine of the value in radians of this\r\n   * Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [1, Infinity]\r\n   *\r\n   * cosh(x) = 1 + x^2/2! + x^4/4! + x^6/6! + ...\r\n   *\r\n   * cosh(0)         = 1\r\n   * cosh(-0)        = 1\r\n   * cosh(Infinity)  = Infinity\r\n   * cosh(-Infinity) = Infinity\r\n   * cosh(NaN)       = NaN\r\n   *\r\n   *  x        time taken (ms)   result\r\n   * 1000      9                 9.8503555700852349694e+433\r\n   * 10000     25                4.4034091128314607936e+4342\r\n   * 100000    171               1.4033316802130615897e+43429\r\n   * 1000000   3817              1.5166076984010437725e+434294\r\n   * 10000000  abandoned after 2 minute wait\r\n   *\r\n   * TODO? Compare performance of cosh(x) = 0.5 * (exp(x) + exp(-x))\r\n   *\r\n   */\r\n  P.hyperbolicCosine = P.cosh = function () {\r\n    var k, n, pr, rm, len,\r\n      x = this,\r\n      Ctor = x.constructor,\r\n      one = new Ctor(1);\r\n\r\n    if (!x.isFinite()) return new Ctor(x.s ? 1 / 0 : NaN);\r\n    if (x.isZero()) return one;\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n    Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;\r\n    Ctor.rounding = 1;\r\n    len = x.d.length;\r\n\r\n    // Argument reduction: cos(4x) = 1 - 8cos^2(x) + 8cos^4(x) + 1\r\n    // i.e. cos(x) = 1 - cos^2(x/4)(8 - 8cos^2(x/4))\r\n\r\n    // Estimate the optimum number of times to use the argument reduction.\r\n    // TODO? Estimation reused from cosine() and may not be optimal here.\r\n    if (len < 32) {\r\n      k = Math.ceil(len / 3);\r\n      n = (1 / tinyPow(4, k)).toString();\r\n    } else {\r\n      k = 16;\r\n      n = '2.3283064365386962890625e-10';\r\n    }\r\n\r\n    x = taylorSeries(Ctor, 1, x.times(n), new Ctor(1), true);\r\n\r\n    // Reverse argument reduction\r\n    var cosh2_x,\r\n      i = k,\r\n      d8 = new Ctor(8);\r\n    for (; i--;) {\r\n      cosh2_x = x.times(x);\r\n      x = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));\r\n    }\r\n\r\n    return finalise(x, Ctor.precision = pr, Ctor.rounding = rm, true);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the hyperbolic sine of the value in radians of this\r\n   * Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-Infinity, Infinity]\r\n   *\r\n   * sinh(x) = x + x^3/3! + x^5/5! + x^7/7! + ...\r\n   *\r\n   * sinh(0)         = 0\r\n   * sinh(-0)        = -0\r\n   * sinh(Infinity)  = Infinity\r\n   * sinh(-Infinity) = -Infinity\r\n   * sinh(NaN)       = NaN\r\n   *\r\n   * x        time taken (ms)\r\n   * 10       2 ms\r\n   * 100      5 ms\r\n   * 1000     14 ms\r\n   * 10000    82 ms\r\n   * 100000   886 ms            1.4033316802130615897e+43429\r\n   * 200000   2613 ms\r\n   * 300000   5407 ms\r\n   * 400000   8824 ms\r\n   * 500000   13026 ms          8.7080643612718084129e+217146\r\n   * 1000000  48543 ms\r\n   *\r\n   * TODO? Compare performance of sinh(x) = 0.5 * (exp(x) - exp(-x))\r\n   *\r\n   */\r\n  P.hyperbolicSine = P.sinh = function () {\r\n    var k, pr, rm, len,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (!x.isFinite() || x.isZero()) return new Ctor(x);\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n    Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;\r\n    Ctor.rounding = 1;\r\n    len = x.d.length;\r\n\r\n    if (len < 3) {\r\n      x = taylorSeries(Ctor, 2, x, x, true);\r\n    } else {\r\n\r\n      // Alternative argument reduction: sinh(3x) = sinh(x)(3 + 4sinh^2(x))\r\n      // i.e. sinh(x) = sinh(x/3)(3 + 4sinh^2(x/3))\r\n      // 3 multiplications and 1 addition\r\n\r\n      // Argument reduction: sinh(5x) = sinh(x)(5 + sinh^2(x)(20 + 16sinh^2(x)))\r\n      // i.e. sinh(x) = sinh(x/5)(5 + sinh^2(x/5)(20 + 16sinh^2(x/5)))\r\n      // 4 multiplications and 2 additions\r\n\r\n      // Estimate the optimum number of times to use the argument reduction.\r\n      k = 1.4 * Math.sqrt(len);\r\n      k = k > 16 ? 16 : k | 0;\r\n\r\n      x = x.times(1 / tinyPow(5, k));\r\n      x = taylorSeries(Ctor, 2, x, x, true);\r\n\r\n      // Reverse argument reduction\r\n      var sinh2_x,\r\n        d5 = new Ctor(5),\r\n        d16 = new Ctor(16),\r\n        d20 = new Ctor(20);\r\n      for (; k--;) {\r\n        sinh2_x = x.times(x);\r\n        x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));\r\n      }\r\n    }\r\n\r\n    Ctor.precision = pr;\r\n    Ctor.rounding = rm;\r\n\r\n    return finalise(x, pr, rm, true);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the hyperbolic tangent of the value in radians of this\r\n   * Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-1, 1]\r\n   *\r\n   * tanh(x) = sinh(x) / cosh(x)\r\n   *\r\n   * tanh(0)         = 0\r\n   * tanh(-0)        = -0\r\n   * tanh(Infinity)  = 1\r\n   * tanh(-Infinity) = -1\r\n   * tanh(NaN)       = NaN\r\n   *\r\n   */\r\n  P.hyperbolicTangent = P.tanh = function () {\r\n    var pr, rm,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (!x.isFinite()) return new Ctor(x.s);\r\n    if (x.isZero()) return new Ctor(x);\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n    Ctor.precision = pr + 7;\r\n    Ctor.rounding = 1;\r\n\r\n    return divide(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the arccosine (inverse cosine) in radians of the value of\r\n   * this Decimal.\r\n   *\r\n   * Domain: [-1, 1]\r\n   * Range: [0, pi]\r\n   *\r\n   * acos(x) = pi/2 - asin(x)\r\n   *\r\n   * acos(0)       = pi/2\r\n   * acos(-0)      = pi/2\r\n   * acos(1)       = 0\r\n   * acos(-1)      = pi\r\n   * acos(1/2)     = pi/3\r\n   * acos(-1/2)    = 2*pi/3\r\n   * acos(|x| > 1) = NaN\r\n   * acos(NaN)     = NaN\r\n   *\r\n   */\r\n  P.inverseCosine = P.acos = function () {\r\n    var halfPi,\r\n      x = this,\r\n      Ctor = x.constructor,\r\n      k = x.abs().cmp(1),\r\n      pr = Ctor.precision,\r\n      rm = Ctor.rounding;\r\n\r\n    if (k !== -1) {\r\n      return k === 0\r\n        // |x| is 1\r\n        ? x.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0)\r\n        // |x| > 1 or x is NaN\r\n        : new Ctor(NaN);\r\n    }\r\n\r\n    if (x.isZero()) return getPi(Ctor, pr + 4, rm).times(0.5);\r\n\r\n    // TODO? Special case acos(0.5) = pi/3 and acos(-0.5) = 2*pi/3\r\n\r\n    Ctor.precision = pr + 6;\r\n    Ctor.rounding = 1;\r\n\r\n    x = x.asin();\r\n    halfPi = getPi(Ctor, pr + 4, rm).times(0.5);\r\n\r\n    Ctor.precision = pr;\r\n    Ctor.rounding = rm;\r\n\r\n    return halfPi.minus(x);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the inverse of the hyperbolic cosine in radians of the\r\n   * value of this Decimal.\r\n   *\r\n   * Domain: [1, Infinity]\r\n   * Range: [0, Infinity]\r\n   *\r\n   * acosh(x) = ln(x + sqrt(x^2 - 1))\r\n   *\r\n   * acosh(x < 1)     = NaN\r\n   * acosh(NaN)       = NaN\r\n   * acosh(Infinity)  = Infinity\r\n   * acosh(-Infinity) = NaN\r\n   * acosh(0)         = NaN\r\n   * acosh(-0)        = NaN\r\n   * acosh(1)         = 0\r\n   * acosh(-1)        = NaN\r\n   *\r\n   */\r\n  P.inverseHyperbolicCosine = P.acosh = function () {\r\n    var pr, rm,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (x.lte(1)) return new Ctor(x.eq(1) ? 0 : NaN);\r\n    if (!x.isFinite()) return new Ctor(x);\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n    Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;\r\n    Ctor.rounding = 1;\r\n    external = false;\r\n\r\n    x = x.times(x).minus(1).sqrt().plus(x);\r\n\r\n    external = true;\r\n    Ctor.precision = pr;\r\n    Ctor.rounding = rm;\r\n\r\n    return x.ln();\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the inverse of the hyperbolic sine in radians of the value\r\n   * of this Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-Infinity, Infinity]\r\n   *\r\n   * asinh(x) = ln(x + sqrt(x^2 + 1))\r\n   *\r\n   * asinh(NaN)       = NaN\r\n   * asinh(Infinity)  = Infinity\r\n   * asinh(-Infinity) = -Infinity\r\n   * asinh(0)         = 0\r\n   * asinh(-0)        = -0\r\n   *\r\n   */\r\n  P.inverseHyperbolicSine = P.asinh = function () {\r\n    var pr, rm,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (!x.isFinite() || x.isZero()) return new Ctor(x);\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n    Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6;\r\n    Ctor.rounding = 1;\r\n    external = false;\r\n\r\n    x = x.times(x).plus(1).sqrt().plus(x);\r\n\r\n    external = true;\r\n    Ctor.precision = pr;\r\n    Ctor.rounding = rm;\r\n\r\n    return x.ln();\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the inverse of the hyperbolic tangent in radians of the\r\n   * value of this Decimal.\r\n   *\r\n   * Domain: [-1, 1]\r\n   * Range: [-Infinity, Infinity]\r\n   *\r\n   * atanh(x) = 0.5 * ln((1 + x) / (1 - x))\r\n   *\r\n   * atanh(|x| > 1)   = NaN\r\n   * atanh(NaN)       = NaN\r\n   * atanh(Infinity)  = NaN\r\n   * atanh(-Infinity) = NaN\r\n   * atanh(0)         = 0\r\n   * atanh(-0)        = -0\r\n   * atanh(1)         = Infinity\r\n   * atanh(-1)        = -Infinity\r\n   *\r\n   */\r\n  P.inverseHyperbolicTangent = P.atanh = function () {\r\n    var pr, rm, wpr, xsd,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (!x.isFinite()) return new Ctor(NaN);\r\n    if (x.e >= 0) return new Ctor(x.abs().eq(1) ? x.s / 0 : x.isZero() ? x : NaN);\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n    xsd = x.sd();\r\n\r\n    if (Math.max(xsd, pr) < 2 * -x.e - 1) return finalise(new Ctor(x), pr, rm, true);\r\n\r\n    Ctor.precision = wpr = xsd - x.e;\r\n\r\n    x = divide(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1);\r\n\r\n    Ctor.precision = pr + 4;\r\n    Ctor.rounding = 1;\r\n\r\n    x = x.ln();\r\n\r\n    Ctor.precision = pr;\r\n    Ctor.rounding = rm;\r\n\r\n    return x.times(0.5);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the arcsine (inverse sine) in radians of the value of this\r\n   * Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-pi/2, pi/2]\r\n   *\r\n   * asin(x) = 2*atan(x/(1 + sqrt(1 - x^2)))\r\n   *\r\n   * asin(0)       = 0\r\n   * asin(-0)      = -0\r\n   * asin(1/2)     = pi/6\r\n   * asin(-1/2)    = -pi/6\r\n   * asin(1)       = pi/2\r\n   * asin(-1)      = -pi/2\r\n   * asin(|x| > 1) = NaN\r\n   * asin(NaN)     = NaN\r\n   *\r\n   * TODO? Compare performance of Taylor series.\r\n   *\r\n   */\r\n  P.inverseSine = P.asin = function () {\r\n    var halfPi, k,\r\n      pr, rm,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (x.isZero()) return new Ctor(x);\r\n\r\n    k = x.abs().cmp(1);\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n\r\n    if (k !== -1) {\r\n\r\n      // |x| is 1\r\n      if (k === 0) {\r\n        halfPi = getPi(Ctor, pr + 4, rm).times(0.5);\r\n        halfPi.s = x.s;\r\n        return halfPi;\r\n      }\r\n\r\n      // |x| > 1 or x is NaN\r\n      return new Ctor(NaN);\r\n    }\r\n\r\n    // TODO? Special case asin(1/2) = pi/6 and asin(-1/2) = -pi/6\r\n\r\n    Ctor.precision = pr + 6;\r\n    Ctor.rounding = 1;\r\n\r\n    x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan();\r\n\r\n    Ctor.precision = pr;\r\n    Ctor.rounding = rm;\r\n\r\n    return x.times(2);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the arctangent (inverse tangent) in radians of the value\r\n   * of this Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-pi/2, pi/2]\r\n   *\r\n   * atan(x) = x - x^3/3 + x^5/5 - x^7/7 + ...\r\n   *\r\n   * atan(0)         = 0\r\n   * atan(-0)        = -0\r\n   * atan(1)         = pi/4\r\n   * atan(-1)        = -pi/4\r\n   * atan(Infinity)  = pi/2\r\n   * atan(-Infinity) = -pi/2\r\n   * atan(NaN)       = NaN\r\n   *\r\n   */\r\n  P.inverseTangent = P.atan = function () {\r\n    var i, j, k, n, px, t, r, wpr, x2,\r\n      x = this,\r\n      Ctor = x.constructor,\r\n      pr = Ctor.precision,\r\n      rm = Ctor.rounding;\r\n\r\n    if (!x.isFinite()) {\r\n      if (!x.s) return new Ctor(NaN);\r\n      if (pr + 4 <= PI_PRECISION) {\r\n        r = getPi(Ctor, pr + 4, rm).times(0.5);\r\n        r.s = x.s;\r\n        return r;\r\n      }\r\n    } else if (x.isZero()) {\r\n      return new Ctor(x);\r\n    } else if (x.abs().eq(1) && pr + 4 <= PI_PRECISION) {\r\n      r = getPi(Ctor, pr + 4, rm).times(0.25);\r\n      r.s = x.s;\r\n      return r;\r\n    }\r\n\r\n    Ctor.precision = wpr = pr + 10;\r\n    Ctor.rounding = 1;\r\n\r\n    // TODO? if (x >= 1 && pr <= PI_PRECISION) atan(x) = halfPi * x.s - atan(1 / x);\r\n\r\n    // Argument reduction\r\n    // Ensure |x| < 0.42\r\n    // atan(x) = 2 * atan(x / (1 + sqrt(1 + x^2)))\r\n\r\n    k = Math.min(28, wpr / LOG_BASE + 2 | 0);\r\n\r\n    for (i = k; i; --i) x = x.div(x.times(x).plus(1).sqrt().plus(1));\r\n\r\n    external = false;\r\n\r\n    j = Math.ceil(wpr / LOG_BASE);\r\n    n = 1;\r\n    x2 = x.times(x);\r\n    r = new Ctor(x);\r\n    px = x;\r\n\r\n    // atan(x) = x - x^3/3 + x^5/5 - x^7/7 + ...\r\n    for (; i !== -1;) {\r\n      px = px.times(x2);\r\n      t = r.minus(px.div(n += 2));\r\n\r\n      px = px.times(x2);\r\n      r = t.plus(px.div(n += 2));\r\n\r\n      if (r.d[j] !== void 0) for (i = j; r.d[i] === t.d[i] && i--;);\r\n    }\r\n\r\n    if (k) r = r.times(2 << (k - 1));\r\n\r\n    external = true;\r\n\r\n    return finalise(r, Ctor.precision = pr, Ctor.rounding = rm, true);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is a finite number, otherwise return false.\r\n   *\r\n   */\r\n  P.isFinite = function () {\r\n    return !!this.d;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is an integer, otherwise return false.\r\n   *\r\n   */\r\n  P.isInteger = P.isInt = function () {\r\n    return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is NaN, otherwise return false.\r\n   *\r\n   */\r\n  P.isNaN = function () {\r\n    return !this.s;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is negative, otherwise return false.\r\n   *\r\n   */\r\n  P.isNegative = P.isNeg = function () {\r\n    return this.s < 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is positive, otherwise return false.\r\n   *\r\n   */\r\n  P.isPositive = P.isPos = function () {\r\n    return this.s > 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is 0 or -0, otherwise return false.\r\n   *\r\n   */\r\n  P.isZero = function () {\r\n    return !!this.d && this.d[0] === 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is less than `y`, otherwise return false.\r\n   *\r\n   */\r\n  P.lessThan = P.lt = function (y) {\r\n    return this.cmp(y) < 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is less than or equal to `y`, otherwise return false.\r\n   *\r\n   */\r\n  P.lessThanOrEqualTo = P.lte = function (y) {\r\n    return this.cmp(y) < 1;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return the logarithm of the value of this Decimal to the specified base, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * If no base is specified, return log[10](arg).\r\n   *\r\n   * log[base](arg) = ln(arg) / ln(base)\r\n   *\r\n   * The result will always be correctly rounded if the base of the log is 10, and 'almost always'\r\n   * otherwise:\r\n   *\r\n   * Depending on the rounding mode, the result may be incorrectly rounded if the first fifteen\r\n   * rounding digits are [49]99999999999999 or [50]00000000000000. In that case, the maximum error\r\n   * between the result and the correctly rounded result will be one ulp (unit in the last place).\r\n   *\r\n   * log[-b](a)       = NaN\r\n   * log[0](a)        = NaN\r\n   * log[1](a)        = NaN\r\n   * log[NaN](a)      = NaN\r\n   * log[Infinity](a) = NaN\r\n   * log[b](0)        = -Infinity\r\n   * log[b](-0)       = -Infinity\r\n   * log[b](-a)       = NaN\r\n   * log[b](1)        = 0\r\n   * log[b](Infinity) = Infinity\r\n   * log[b](NaN)      = NaN\r\n   *\r\n   * [base] {number|string|Decimal} The base of the logarithm.\r\n   *\r\n   */\r\n  P.logarithm = P.log = function (base) {\r\n    var isBase10, d, denominator, k, inf, num, sd, r,\r\n      arg = this,\r\n      Ctor = arg.constructor,\r\n      pr = Ctor.precision,\r\n      rm = Ctor.rounding,\r\n      guard = 5;\r\n\r\n    // Default base is 10.\r\n    if (base == null) {\r\n      base = new Ctor(10);\r\n      isBase10 = true;\r\n    } else {\r\n      base = new Ctor(base);\r\n      d = base.d;\r\n\r\n      // Return NaN if base is negative, or non-finite, or is 0 or 1.\r\n      if (base.s < 0 || !d || !d[0] || base.eq(1)) return new Ctor(NaN);\r\n\r\n      isBase10 = base.eq(10);\r\n    }\r\n\r\n    d = arg.d;\r\n\r\n    // Is arg negative, non-finite, 0 or 1?\r\n    if (arg.s < 0 || !d || !d[0] || arg.eq(1)) {\r\n      return new Ctor(d && !d[0] ? -1 / 0 : arg.s != 1 ? NaN : d ? 0 : 1 / 0);\r\n    }\r\n\r\n    // The result will have a non-terminating decimal expansion if base is 10 and arg is not an\r\n    // integer power of 10.\r\n    if (isBase10) {\r\n      if (d.length > 1) {\r\n        inf = true;\r\n      } else {\r\n        for (k = d[0]; k % 10 === 0;) k /= 10;\r\n        inf = k !== 1;\r\n      }\r\n    }\r\n\r\n    external = false;\r\n    sd = pr + guard;\r\n    num = naturalLogarithm(arg, sd);\r\n    denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);\r\n\r\n    // The result will have 5 rounding digits.\r\n    r = divide(num, denominator, sd, 1);\r\n\r\n    // If at a rounding boundary, i.e. the result's rounding digits are [49]9999 or [50]0000,\r\n    // calculate 10 further digits.\r\n    //\r\n    // If the result is known to have an infinite decimal expansion, repeat this until it is clear\r\n    // that the result is above or below the boundary. Otherwise, if after calculating the 10\r\n    // further digits, the last 14 are nines, round up and assume the result is exact.\r\n    // Also assume the result is exact if the last 14 are zero.\r\n    //\r\n    // Example of a result that will be incorrectly rounded:\r\n    // log[1048576](4503599627370502) = 2.60000000000000009610279511444746...\r\n    // The above result correctly rounded using ROUND_CEIL to 1 decimal place should be 2.7, but it\r\n    // will be given as 2.6 as there are 15 zeros immediately after the requested decimal place, so\r\n    // the exact result would be assumed to be 2.6, which rounded using ROUND_CEIL to 1 decimal\r\n    // place is still 2.6.\r\n    if (checkRoundingDigits(r.d, k = pr, rm)) {\r\n\r\n      do {\r\n        sd += 10;\r\n        num = naturalLogarithm(arg, sd);\r\n        denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);\r\n        r = divide(num, denominator, sd, 1);\r\n\r\n        if (!inf) {\r\n\r\n          // Check for 14 nines from the 2nd rounding digit, as the first may be 4.\r\n          if (+digitsToString(r.d).slice(k + 1, k + 15) + 1 == 1e14) {\r\n            r = finalise(r, pr + 1, 0);\r\n          }\r\n\r\n          break;\r\n        }\r\n      } while (checkRoundingDigits(r.d, k += 10, rm));\r\n    }\r\n\r\n    external = true;\r\n\r\n    return finalise(r, pr, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the maximum of the arguments and the value of this Decimal.\r\n   *\r\n   * arguments {number|string|Decimal}\r\n   *\r\n  P.max = function () {\r\n    Array.prototype.push.call(arguments, this);\r\n    return maxOrMin(this.constructor, arguments, 'lt');\r\n  };\r\n   */\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the minimum of the arguments and the value of this Decimal.\r\n   *\r\n   * arguments {number|string|Decimal}\r\n   *\r\n  P.min = function () {\r\n    Array.prototype.push.call(arguments, this);\r\n    return maxOrMin(this.constructor, arguments, 'gt');\r\n  };\r\n   */\r\n\r\n\r\n  /*\r\n   *  n - 0 = n\r\n   *  n - N = N\r\n   *  n - I = -I\r\n   *  0 - n = -n\r\n   *  0 - 0 = 0\r\n   *  0 - N = N\r\n   *  0 - I = -I\r\n   *  N - n = N\r\n   *  N - 0 = N\r\n   *  N - N = N\r\n   *  N - I = N\r\n   *  I - n = I\r\n   *  I - 0 = I\r\n   *  I - N = N\r\n   *  I - I = N\r\n   *\r\n   * Return a new Decimal whose value is the value of this Decimal minus `y`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   */\r\n  P.minus = P.sub = function (y) {\r\n    var d, e, i, j, k, len, pr, rm, xd, xe, xLTy, yd,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    y = new Ctor(y);\r\n\r\n    // If either is not finite...\r\n    if (!x.d || !y.d) {\r\n\r\n      // Return NaN if either is NaN.\r\n      if (!x.s || !y.s) y = new Ctor(NaN);\r\n\r\n      // Return y negated if x is finite and y is ±Infinity.\r\n      else if (x.d) y.s = -y.s;\r\n\r\n      // Return x if y is finite and x is ±Infinity.\r\n      // Return x if both are ±Infinity with different signs.\r\n      // Return NaN if both are ±Infinity with the same sign.\r\n      else y = new Ctor(y.d || x.s !== y.s ? x : NaN);\r\n\r\n      return y;\r\n    }\r\n\r\n    // If signs differ...\r\n    if (x.s != y.s) {\r\n      y.s = -y.s;\r\n      return x.plus(y);\r\n    }\r\n\r\n    xd = x.d;\r\n    yd = y.d;\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n\r\n    // If either is zero...\r\n    if (!xd[0] || !yd[0]) {\r\n\r\n      // Return y negated if x is zero and y is non-zero.\r\n      if (yd[0]) y.s = -y.s;\r\n\r\n      // Return x if y is zero and x is non-zero.\r\n      else if (xd[0]) y = new Ctor(x);\r\n\r\n      // Return zero if both are zero.\r\n      // From IEEE 754 (2008) 6.3: 0 - 0 = -0 - -0 = -0 when rounding to -Infinity.\r\n      else return new Ctor(rm === 3 ? -0 : 0);\r\n\r\n      return external ? finalise(y, pr, rm) : y;\r\n    }\r\n\r\n    // x and y are finite, non-zero numbers with the same sign.\r\n\r\n    // Calculate base 1e7 exponents.\r\n    e = mathfloor(y.e / LOG_BASE);\r\n    xe = mathfloor(x.e / LOG_BASE);\r\n\r\n    xd = xd.slice();\r\n    k = xe - e;\r\n\r\n    // If base 1e7 exponents differ...\r\n    if (k) {\r\n      xLTy = k < 0;\r\n\r\n      if (xLTy) {\r\n        d = xd;\r\n        k = -k;\r\n        len = yd.length;\r\n      } else {\r\n        d = yd;\r\n        e = xe;\r\n        len = xd.length;\r\n      }\r\n\r\n      // Numbers with massively different exponents would result in a very high number of\r\n      // zeros needing to be prepended, but this can be avoided while still ensuring correct\r\n      // rounding by limiting the number of zeros to `Math.ceil(pr / LOG_BASE) + 2`.\r\n      i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;\r\n\r\n      if (k > i) {\r\n        k = i;\r\n        d.length = 1;\r\n      }\r\n\r\n      // Prepend zeros to equalise exponents.\r\n      d.reverse();\r\n      for (i = k; i--;) d.push(0);\r\n      d.reverse();\r\n\r\n    // Base 1e7 exponents equal.\r\n    } else {\r\n\r\n      // Check digits to determine which is the bigger number.\r\n\r\n      i = xd.length;\r\n      len = yd.length;\r\n      xLTy = i < len;\r\n      if (xLTy) len = i;\r\n\r\n      for (i = 0; i < len; i++) {\r\n        if (xd[i] != yd[i]) {\r\n          xLTy = xd[i] < yd[i];\r\n          break;\r\n        }\r\n      }\r\n\r\n      k = 0;\r\n    }\r\n\r\n    if (xLTy) {\r\n      d = xd;\r\n      xd = yd;\r\n      yd = d;\r\n      y.s = -y.s;\r\n    }\r\n\r\n    len = xd.length;\r\n\r\n    // Append zeros to `xd` if shorter.\r\n    // Don't add zeros to `yd` if shorter as subtraction only needs to start at `yd` length.\r\n    for (i = yd.length - len; i > 0; --i) xd[len++] = 0;\r\n\r\n    // Subtract yd from xd.\r\n    for (i = yd.length; i > k;) {\r\n\r\n      if (xd[--i] < yd[i]) {\r\n        for (j = i; j && xd[--j] === 0;) xd[j] = BASE - 1;\r\n        --xd[j];\r\n        xd[i] += BASE;\r\n      }\r\n\r\n      xd[i] -= yd[i];\r\n    }\r\n\r\n    // Remove trailing zeros.\r\n    for (; xd[--len] === 0;) xd.pop();\r\n\r\n    // Remove leading zeros and adjust exponent accordingly.\r\n    for (; xd[0] === 0; xd.shift()) --e;\r\n\r\n    // Zero?\r\n    if (!xd[0]) return new Ctor(rm === 3 ? -0 : 0);\r\n\r\n    y.d = xd;\r\n    y.e = getBase10Exponent(xd, e);\r\n\r\n    return external ? finalise(y, pr, rm) : y;\r\n  };\r\n\r\n\r\n  /*\r\n   *   n % 0 =  N\r\n   *   n % N =  N\r\n   *   n % I =  n\r\n   *   0 % n =  0\r\n   *  -0 % n = -0\r\n   *   0 % 0 =  N\r\n   *   0 % N =  N\r\n   *   0 % I =  0\r\n   *   N % n =  N\r\n   *   N % 0 =  N\r\n   *   N % N =  N\r\n   *   N % I =  N\r\n   *   I % n =  N\r\n   *   I % 0 =  N\r\n   *   I % N =  N\r\n   *   I % I =  N\r\n   *\r\n   * Return a new Decimal whose value is the value of this Decimal modulo `y`, rounded to\r\n   * `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * The result depends on the modulo mode.\r\n   *\r\n   */\r\n  P.modulo = P.mod = function (y) {\r\n    var q,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    y = new Ctor(y);\r\n\r\n    // Return NaN if x is ±Infinity or NaN, or y is NaN or ±0.\r\n    if (!x.d || !y.s || y.d && !y.d[0]) return new Ctor(NaN);\r\n\r\n    // Return x if y is ±Infinity or x is ±0.\r\n    if (!y.d || x.d && !x.d[0]) {\r\n      return finalise(new Ctor(x), Ctor.precision, Ctor.rounding);\r\n    }\r\n\r\n    // Prevent rounding of intermediate calculations.\r\n    external = false;\r\n\r\n    if (Ctor.modulo == 9) {\r\n\r\n      // Euclidian division: q = sign(y) * floor(x / abs(y))\r\n      // result = x - q * y    where  0 <= result < abs(y)\r\n      q = divide(x, y.abs(), 0, 3, 1);\r\n      q.s *= y.s;\r\n    } else {\r\n      q = divide(x, y, 0, Ctor.modulo, 1);\r\n    }\r\n\r\n    q = q.times(y);\r\n\r\n    external = true;\r\n\r\n    return x.minus(q);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the natural exponential of the value of this Decimal,\r\n   * i.e. the base e raised to the power the value of this Decimal, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   */\r\n  P.naturalExponential = P.exp = function () {\r\n    return naturalExponential(this);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the natural logarithm of the value of this Decimal,\r\n   * rounded to `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   */\r\n  P.naturalLogarithm = P.ln = function () {\r\n    return naturalLogarithm(this);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal negated, i.e. as if multiplied by\r\n   * -1.\r\n   *\r\n   */\r\n  P.negated = P.neg = function () {\r\n    var x = new this.constructor(this);\r\n    x.s = -x.s;\r\n    return finalise(x);\r\n  };\r\n\r\n\r\n  /*\r\n   *  n + 0 = n\r\n   *  n + N = N\r\n   *  n + I = I\r\n   *  0 + n = n\r\n   *  0 + 0 = 0\r\n   *  0 + N = N\r\n   *  0 + I = I\r\n   *  N + n = N\r\n   *  N + 0 = N\r\n   *  N + N = N\r\n   *  N + I = N\r\n   *  I + n = I\r\n   *  I + 0 = I\r\n   *  I + N = N\r\n   *  I + I = I\r\n   *\r\n   * Return a new Decimal whose value is the value of this Decimal plus `y`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   */\r\n  P.plus = P.add = function (y) {\r\n    var carry, d, e, i, k, len, pr, rm, xd, yd,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    y = new Ctor(y);\r\n\r\n    // If either is not finite...\r\n    if (!x.d || !y.d) {\r\n\r\n      // Return NaN if either is NaN.\r\n      if (!x.s || !y.s) y = new Ctor(NaN);\r\n\r\n      // Return x if y is finite and x is ±Infinity.\r\n      // Return x if both are ±Infinity with the same sign.\r\n      // Return NaN if both are ±Infinity with different signs.\r\n      // Return y if x is finite and y is ±Infinity.\r\n      else if (!x.d) y = new Ctor(y.d || x.s === y.s ? x : NaN);\r\n\r\n      return y;\r\n    }\r\n\r\n     // If signs differ...\r\n    if (x.s != y.s) {\r\n      y.s = -y.s;\r\n      return x.minus(y);\r\n    }\r\n\r\n    xd = x.d;\r\n    yd = y.d;\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n\r\n    // If either is zero...\r\n    if (!xd[0] || !yd[0]) {\r\n\r\n      // Return x if y is zero.\r\n      // Return y if y is non-zero.\r\n      if (!yd[0]) y = new Ctor(x);\r\n\r\n      return external ? finalise(y, pr, rm) : y;\r\n    }\r\n\r\n    // x and y are finite, non-zero numbers with the same sign.\r\n\r\n    // Calculate base 1e7 exponents.\r\n    k = mathfloor(x.e / LOG_BASE);\r\n    e = mathfloor(y.e / LOG_BASE);\r\n\r\n    xd = xd.slice();\r\n    i = k - e;\r\n\r\n    // If base 1e7 exponents differ...\r\n    if (i) {\r\n\r\n      if (i < 0) {\r\n        d = xd;\r\n        i = -i;\r\n        len = yd.length;\r\n      } else {\r\n        d = yd;\r\n        e = k;\r\n        len = xd.length;\r\n      }\r\n\r\n      // Limit number of zeros prepended to max(ceil(pr / LOG_BASE), len) + 1.\r\n      k = Math.ceil(pr / LOG_BASE);\r\n      len = k > len ? k + 1 : len + 1;\r\n\r\n      if (i > len) {\r\n        i = len;\r\n        d.length = 1;\r\n      }\r\n\r\n      // Prepend zeros to equalise exponents. Note: Faster to use reverse then do unshifts.\r\n      d.reverse();\r\n      for (; i--;) d.push(0);\r\n      d.reverse();\r\n    }\r\n\r\n    len = xd.length;\r\n    i = yd.length;\r\n\r\n    // If yd is longer than xd, swap xd and yd so xd points to the longer array.\r\n    if (len - i < 0) {\r\n      i = len;\r\n      d = yd;\r\n      yd = xd;\r\n      xd = d;\r\n    }\r\n\r\n    // Only start adding at yd.length - 1 as the further digits of xd can be left as they are.\r\n    for (carry = 0; i;) {\r\n      carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;\r\n      xd[i] %= BASE;\r\n    }\r\n\r\n    if (carry) {\r\n      xd.unshift(carry);\r\n      ++e;\r\n    }\r\n\r\n    // Remove trailing zeros.\r\n    // No need to check for zero, as +x + +y != 0 && -x + -y != 0\r\n    for (len = xd.length; xd[--len] == 0;) xd.pop();\r\n\r\n    y.d = xd;\r\n    y.e = getBase10Exponent(xd, e);\r\n\r\n    return external ? finalise(y, pr, rm) : y;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return the number of significant digits of the value of this Decimal.\r\n   *\r\n   * [z] {boolean|number} Whether to count integer-part trailing zeros: true, false, 1 or 0.\r\n   *\r\n   */\r\n  P.precision = P.sd = function (z) {\r\n    var k,\r\n      x = this;\r\n\r\n    if (z !== void 0 && z !== !!z && z !== 1 && z !== 0) throw Error(invalidArgument + z);\r\n\r\n    if (x.d) {\r\n      k = getPrecision(x.d);\r\n      if (z && x.e + 1 > k) k = x.e + 1;\r\n    } else {\r\n      k = NaN;\r\n    }\r\n\r\n    return k;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal rounded to a whole number using\r\n   * rounding mode `rounding`.\r\n   *\r\n   */\r\n  P.round = function () {\r\n    var x = this,\r\n      Ctor = x.constructor;\r\n\r\n    return finalise(new Ctor(x), x.e + 1, Ctor.rounding);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the sine of the value in radians of this Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-1, 1]\r\n   *\r\n   * sin(x) = x - x^3/3! + x^5/5! - ...\r\n   *\r\n   * sin(0)         = 0\r\n   * sin(-0)        = -0\r\n   * sin(Infinity)  = NaN\r\n   * sin(-Infinity) = NaN\r\n   * sin(NaN)       = NaN\r\n   *\r\n   */\r\n  P.sine = P.sin = function () {\r\n    var pr, rm,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (!x.isFinite()) return new Ctor(NaN);\r\n    if (x.isZero()) return new Ctor(x);\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n    Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;\r\n    Ctor.rounding = 1;\r\n\r\n    x = sine(Ctor, toLessThanHalfPi(Ctor, x));\r\n\r\n    Ctor.precision = pr;\r\n    Ctor.rounding = rm;\r\n\r\n    return finalise(quadrant > 2 ? x.neg() : x, pr, rm, true);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the square root of this Decimal, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   *  sqrt(-n) =  N\r\n   *  sqrt(N)  =  N\r\n   *  sqrt(-I) =  N\r\n   *  sqrt(I)  =  I\r\n   *  sqrt(0)  =  0\r\n   *  sqrt(-0) = -0\r\n   *\r\n   */\r\n  P.squareRoot = P.sqrt = function () {\r\n    var m, n, sd, r, rep, t,\r\n      x = this,\r\n      d = x.d,\r\n      e = x.e,\r\n      s = x.s,\r\n      Ctor = x.constructor;\r\n\r\n    // Negative/NaN/Infinity/zero?\r\n    if (s !== 1 || !d || !d[0]) {\r\n      return new Ctor(!s || s < 0 && (!d || d[0]) ? NaN : d ? x : 1 / 0);\r\n    }\r\n\r\n    external = false;\r\n\r\n    // Initial estimate.\r\n    s = Math.sqrt(+x);\r\n\r\n    // Math.sqrt underflow/overflow?\r\n    // Pass x to Math.sqrt as integer, then adjust the exponent of the result.\r\n    if (s == 0 || s == 1 / 0) {\r\n      n = digitsToString(d);\r\n\r\n      if ((n.length + e) % 2 == 0) n += '0';\r\n      s = Math.sqrt(n);\r\n      e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);\r\n\r\n      if (s == 1 / 0) {\r\n        n = '5e' + e;\r\n      } else {\r\n        n = s.toExponential();\r\n        n = n.slice(0, n.indexOf('e') + 1) + e;\r\n      }\r\n\r\n      r = new Ctor(n);\r\n    } else {\r\n      r = new Ctor(s.toString());\r\n    }\r\n\r\n    sd = (e = Ctor.precision) + 3;\r\n\r\n    // Newton-Raphson iteration.\r\n    for (;;) {\r\n      t = r;\r\n      r = t.plus(divide(x, t, sd + 2, 1)).times(0.5);\r\n\r\n      // TODO? Replace with for-loop and checkRoundingDigits.\r\n      if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {\r\n        n = n.slice(sd - 3, sd + 1);\r\n\r\n        // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or\r\n        // 4999, i.e. approaching a rounding boundary, continue the iteration.\r\n        if (n == '9999' || !rep && n == '4999') {\r\n\r\n          // On the first iteration only, check to see if rounding up gives the exact result as the\r\n          // nines may infinitely repeat.\r\n          if (!rep) {\r\n            finalise(t, e + 1, 0);\r\n\r\n            if (t.times(t).eq(x)) {\r\n              r = t;\r\n              break;\r\n            }\r\n          }\r\n\r\n          sd += 4;\r\n          rep = 1;\r\n        } else {\r\n\r\n          // If the rounding digits are null, 0{0,4} or 50{0,3}, check for an exact result.\r\n          // If not, then there are further digits and m will be truthy.\r\n          if (!+n || !+n.slice(1) && n.charAt(0) == '5') {\r\n\r\n            // Truncate to the first rounding digit.\r\n            finalise(r, e + 1, 1);\r\n            m = !r.times(r).eq(x);\r\n          }\r\n\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    external = true;\r\n\r\n    return finalise(r, e, Ctor.rounding, m);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the tangent of the value in radians of this Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-Infinity, Infinity]\r\n   *\r\n   * tan(0)         = 0\r\n   * tan(-0)        = -0\r\n   * tan(Infinity)  = NaN\r\n   * tan(-Infinity) = NaN\r\n   * tan(NaN)       = NaN\r\n   *\r\n   */\r\n  P.tangent = P.tan = function () {\r\n    var pr, rm,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (!x.isFinite()) return new Ctor(NaN);\r\n    if (x.isZero()) return new Ctor(x);\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n    Ctor.precision = pr + 10;\r\n    Ctor.rounding = 1;\r\n\r\n    x = x.sin();\r\n    x.s = 1;\r\n    x = divide(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);\r\n\r\n    Ctor.precision = pr;\r\n    Ctor.rounding = rm;\r\n\r\n    return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);\r\n  };\r\n\r\n\r\n  /*\r\n   *  n * 0 = 0\r\n   *  n * N = N\r\n   *  n * I = I\r\n   *  0 * n = 0\r\n   *  0 * 0 = 0\r\n   *  0 * N = N\r\n   *  0 * I = N\r\n   *  N * n = N\r\n   *  N * 0 = N\r\n   *  N * N = N\r\n   *  N * I = N\r\n   *  I * n = I\r\n   *  I * 0 = N\r\n   *  I * N = N\r\n   *  I * I = I\r\n   *\r\n   * Return a new Decimal whose value is this Decimal times `y`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   */\r\n  P.times = P.mul = function (y) {\r\n    var carry, e, i, k, r, rL, t, xdL, ydL,\r\n      x = this,\r\n      Ctor = x.constructor,\r\n      xd = x.d,\r\n      yd = (y = new Ctor(y)).d;\r\n\r\n    y.s *= x.s;\r\n\r\n     // If either is NaN, ±Infinity or ±0...\r\n    if (!xd || !xd[0] || !yd || !yd[0]) {\r\n\r\n      return new Ctor(!y.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd\r\n\r\n        // Return NaN if either is NaN.\r\n        // Return NaN if x is ±0 and y is ±Infinity, or y is ±0 and x is ±Infinity.\r\n        ? NaN\r\n\r\n        // Return ±Infinity if either is ±Infinity.\r\n        // Return ±0 if either is ±0.\r\n        : !xd || !yd ? y.s / 0 : y.s * 0);\r\n    }\r\n\r\n    e = mathfloor(x.e / LOG_BASE) + mathfloor(y.e / LOG_BASE);\r\n    xdL = xd.length;\r\n    ydL = yd.length;\r\n\r\n    // Ensure xd points to the longer array.\r\n    if (xdL < ydL) {\r\n      r = xd;\r\n      xd = yd;\r\n      yd = r;\r\n      rL = xdL;\r\n      xdL = ydL;\r\n      ydL = rL;\r\n    }\r\n\r\n    // Initialise the result array with zeros.\r\n    r = [];\r\n    rL = xdL + ydL;\r\n    for (i = rL; i--;) r.push(0);\r\n\r\n    // Multiply!\r\n    for (i = ydL; --i >= 0;) {\r\n      carry = 0;\r\n      for (k = xdL + i; k > i;) {\r\n        t = r[k] + yd[i] * xd[k - i - 1] + carry;\r\n        r[k--] = t % BASE | 0;\r\n        carry = t / BASE | 0;\r\n      }\r\n\r\n      r[k] = (r[k] + carry) % BASE | 0;\r\n    }\r\n\r\n    // Remove trailing zeros.\r\n    for (; !r[--rL];) r.pop();\r\n\r\n    if (carry) ++e;\r\n    else r.shift();\r\n\r\n    y.d = r;\r\n    y.e = getBase10Exponent(r, e);\r\n\r\n    return external ? finalise(y, Ctor.precision, Ctor.rounding) : y;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Decimal in base 2, round to `sd` significant\r\n   * digits using rounding mode `rm`.\r\n   *\r\n   * If the optional `sd` argument is present then return binary exponential notation.\r\n   *\r\n   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   */\r\n  P.toBinary = function (sd, rm) {\r\n    return toStringBinary(this, 2, sd, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `dp`\r\n   * decimal places using rounding mode `rm` or `rounding` if `rm` is omitted.\r\n   *\r\n   * If `dp` is omitted, return a new Decimal whose value is the value of this Decimal.\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   */\r\n  P.toDecimalPlaces = P.toDP = function (dp, rm) {\r\n    var x = this,\r\n      Ctor = x.constructor;\r\n\r\n    x = new Ctor(x);\r\n    if (dp === void 0) return x;\r\n\r\n    checkInt32(dp, 0, MAX_DIGITS);\r\n\r\n    if (rm === void 0) rm = Ctor.rounding;\r\n    else checkInt32(rm, 0, 8);\r\n\r\n    return finalise(x, dp + x.e + 1, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Decimal in exponential notation rounded to\r\n   * `dp` fixed decimal places using rounding mode `rounding`.\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   */\r\n  P.toExponential = function (dp, rm) {\r\n    var str,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (dp === void 0) {\r\n      str = finiteToString(x, true);\r\n    } else {\r\n      checkInt32(dp, 0, MAX_DIGITS);\r\n\r\n      if (rm === void 0) rm = Ctor.rounding;\r\n      else checkInt32(rm, 0, 8);\r\n\r\n      x = finalise(new Ctor(x), dp + 1, rm);\r\n      str = finiteToString(x, true, dp + 1);\r\n    }\r\n\r\n    return x.isNeg() && !x.isZero() ? '-' + str : str;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Decimal in normal (fixed-point) notation to\r\n   * `dp` fixed decimal places and rounded using rounding mode `rm` or `rounding` if `rm` is\r\n   * omitted.\r\n   *\r\n   * As with JavaScript numbers, (-0).toFixed(0) is '0', but e.g. (-0.00001).toFixed(0) is '-0'.\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * (-0).toFixed(0) is '0', but (-0.1).toFixed(0) is '-0'.\r\n   * (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.\r\n   * (-0).toFixed(3) is '0.000'.\r\n   * (-0.5).toFixed(0) is '-0'.\r\n   *\r\n   */\r\n  P.toFixed = function (dp, rm) {\r\n    var str, y,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (dp === void 0) {\r\n      str = finiteToString(x);\r\n    } else {\r\n      checkInt32(dp, 0, MAX_DIGITS);\r\n\r\n      if (rm === void 0) rm = Ctor.rounding;\r\n      else checkInt32(rm, 0, 8);\r\n\r\n      y = finalise(new Ctor(x), dp + x.e + 1, rm);\r\n      str = finiteToString(y, false, dp + y.e + 1);\r\n    }\r\n\r\n    // To determine whether to add the minus sign look at the value before it was rounded,\r\n    // i.e. look at `x` rather than `y`.\r\n    return x.isNeg() && !x.isZero() ? '-' + str : str;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return an array representing the value of this Decimal as a simple fraction with an integer\r\n   * numerator and an integer denominator.\r\n   *\r\n   * The denominator will be a positive non-zero value less than or equal to the specified maximum\r\n   * denominator. If a maximum denominator is not specified, the denominator will be the lowest\r\n   * value necessary to represent the number exactly.\r\n   *\r\n   * [maxD] {number|string|Decimal} Maximum denominator. Integer >= 1 and < Infinity.\r\n   *\r\n   */\r\n  P.toFraction = function (maxD) {\r\n    var d, d0, d1, d2, e, k, n, n0, n1, pr, q, r,\r\n      x = this,\r\n      xd = x.d,\r\n      Ctor = x.constructor;\r\n\r\n    if (!xd) return new Ctor(x);\r\n\r\n    n1 = d0 = new Ctor(1);\r\n    d1 = n0 = new Ctor(0);\r\n\r\n    d = new Ctor(d1);\r\n    e = d.e = getPrecision(xd) - x.e - 1;\r\n    k = e % LOG_BASE;\r\n    d.d[0] = mathpow(10, k < 0 ? LOG_BASE + k : k);\r\n\r\n    if (maxD == null) {\r\n\r\n      // d is 10**e, the minimum max-denominator needed.\r\n      maxD = e > 0 ? d : n1;\r\n    } else {\r\n      n = new Ctor(maxD);\r\n      if (!n.isInt() || n.lt(n1)) throw Error(invalidArgument + n);\r\n      maxD = n.gt(d) ? (e > 0 ? d : n1) : n;\r\n    }\r\n\r\n    external = false;\r\n    n = new Ctor(digitsToString(xd));\r\n    pr = Ctor.precision;\r\n    Ctor.precision = e = xd.length * LOG_BASE * 2;\r\n\r\n    for (;;)  {\r\n      q = divide(n, d, 0, 1, 1);\r\n      d2 = d0.plus(q.times(d1));\r\n      if (d2.cmp(maxD) == 1) break;\r\n      d0 = d1;\r\n      d1 = d2;\r\n      d2 = n1;\r\n      n1 = n0.plus(q.times(d2));\r\n      n0 = d2;\r\n      d2 = d;\r\n      d = n.minus(q.times(d2));\r\n      n = d2;\r\n    }\r\n\r\n    d2 = divide(maxD.minus(d0), d1, 0, 1, 1);\r\n    n0 = n0.plus(d2.times(n1));\r\n    d0 = d0.plus(d2.times(d1));\r\n    n0.s = n1.s = x.s;\r\n\r\n    // Determine which fraction is closer to x, n0/d0 or n1/d1?\r\n    r = divide(n1, d1, e, 1).minus(x).abs().cmp(divide(n0, d0, e, 1).minus(x).abs()) < 1\r\n        ? [n1, d1] : [n0, d0];\r\n\r\n    Ctor.precision = pr;\r\n    external = true;\r\n\r\n    return r;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Decimal in base 16, round to `sd` significant\r\n   * digits using rounding mode `rm`.\r\n   *\r\n   * If the optional `sd` argument is present then return binary exponential notation.\r\n   *\r\n   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   */\r\n  P.toHexadecimal = P.toHex = function (sd, rm) {\r\n    return toStringBinary(this, 16, sd, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Returns a new Decimal whose value is the nearest multiple of `y` in the direction of rounding\r\n   * mode `rm`, or `Decimal.rounding` if `rm` is omitted, to the value of this Decimal.\r\n   *\r\n   * The return value will always have the same sign as this Decimal, unless either this Decimal\r\n   * or `y` is NaN, in which case the return value will be also be NaN.\r\n   *\r\n   * The return value is not affected by the value of `precision`.\r\n   *\r\n   * y {number|string|Decimal} The magnitude to round to a multiple of.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * 'toNearest() rounding mode not an integer: {rm}'\r\n   * 'toNearest() rounding mode out of range: {rm}'\r\n   *\r\n   */\r\n  P.toNearest = function (y, rm) {\r\n    var x = this,\r\n      Ctor = x.constructor;\r\n\r\n    x = new Ctor(x);\r\n\r\n    if (y == null) {\r\n\r\n      // If x is not finite, return x.\r\n      if (!x.d) return x;\r\n\r\n      y = new Ctor(1);\r\n      rm = Ctor.rounding;\r\n    } else {\r\n      y = new Ctor(y);\r\n      if (rm === void 0) {\r\n        rm = Ctor.rounding;\r\n      } else {\r\n        checkInt32(rm, 0, 8);\r\n      }\r\n\r\n      // If x is not finite, return x if y is not NaN, else NaN.\r\n      if (!x.d) return y.s ? x : y;\r\n\r\n      // If y is not finite, return Infinity with the sign of x if y is Infinity, else NaN.\r\n      if (!y.d) {\r\n        if (y.s) y.s = x.s;\r\n        return y;\r\n      }\r\n    }\r\n\r\n    // If y is not zero, calculate the nearest multiple of y to x.\r\n    if (y.d[0]) {\r\n      external = false;\r\n      x = divide(x, y, 0, rm, 1).times(y);\r\n      external = true;\r\n      finalise(x);\r\n\r\n    // If y is zero, return zero with the sign of x.\r\n    } else {\r\n      y.s = x.s;\r\n      x = y;\r\n    }\r\n\r\n    return x;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return the value of this Decimal converted to a number primitive.\r\n   * Zero keeps its sign.\r\n   *\r\n   */\r\n  P.toNumber = function () {\r\n    return +this;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Decimal in base 8, round to `sd` significant\r\n   * digits using rounding mode `rm`.\r\n   *\r\n   * If the optional `sd` argument is present then return binary exponential notation.\r\n   *\r\n   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   */\r\n  P.toOctal = function (sd, rm) {\r\n    return toStringBinary(this, 8, sd, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal raised to the power `y`, rounded\r\n   * to `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * ECMAScript compliant.\r\n   *\r\n   *   pow(x, NaN)                           = NaN\r\n   *   pow(x, ±0)                            = 1\r\n\r\n   *   pow(NaN, non-zero)                    = NaN\r\n   *   pow(abs(x) > 1, +Infinity)            = +Infinity\r\n   *   pow(abs(x) > 1, -Infinity)            = +0\r\n   *   pow(abs(x) == 1, ±Infinity)           = NaN\r\n   *   pow(abs(x) < 1, +Infinity)            = +0\r\n   *   pow(abs(x) < 1, -Infinity)            = +Infinity\r\n   *   pow(+Infinity, y > 0)                 = +Infinity\r\n   *   pow(+Infinity, y < 0)                 = +0\r\n   *   pow(-Infinity, odd integer > 0)       = -Infinity\r\n   *   pow(-Infinity, even integer > 0)      = +Infinity\r\n   *   pow(-Infinity, odd integer < 0)       = -0\r\n   *   pow(-Infinity, even integer < 0)      = +0\r\n   *   pow(+0, y > 0)                        = +0\r\n   *   pow(+0, y < 0)                        = +Infinity\r\n   *   pow(-0, odd integer > 0)              = -0\r\n   *   pow(-0, even integer > 0)             = +0\r\n   *   pow(-0, odd integer < 0)              = -Infinity\r\n   *   pow(-0, even integer < 0)             = +Infinity\r\n   *   pow(finite x < 0, finite non-integer) = NaN\r\n   *\r\n   * For non-integer or very large exponents pow(x, y) is calculated using\r\n   *\r\n   *   x^y = exp(y*ln(x))\r\n   *\r\n   * Assuming the first 15 rounding digits are each equally likely to be any digit 0-9, the\r\n   * probability of an incorrectly rounded result\r\n   * P([49]9{14} | [50]0{14}) = 2 * 0.2 * 10^-14 = 4e-15 = 1/2.5e+14\r\n   * i.e. 1 in 250,000,000,000,000\r\n   *\r\n   * If a result is incorrectly rounded the maximum error will be 1 ulp (unit in last place).\r\n   *\r\n   * y {number|string|Decimal} The power to which to raise this Decimal.\r\n   *\r\n   */\r\n  P.toPower = P.pow = function (y) {\r\n    var e, k, pr, r, rm, s,\r\n      x = this,\r\n      Ctor = x.constructor,\r\n      yn = +(y = new Ctor(y));\r\n\r\n    // Either ±Infinity, NaN or ±0?\r\n    if (!x.d || !y.d || !x.d[0] || !y.d[0]) return new Ctor(mathpow(+x, yn));\r\n\r\n    x = new Ctor(x);\r\n\r\n    if (x.eq(1)) return x;\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n\r\n    if (y.eq(1)) return finalise(x, pr, rm);\r\n\r\n    // y exponent\r\n    e = mathfloor(y.e / LOG_BASE);\r\n\r\n    // If y is a small integer use the 'exponentiation by squaring' algorithm.\r\n    if (e >= y.d.length - 1 && (k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {\r\n      r = intPow(Ctor, x, k, pr);\r\n      return y.s < 0 ? new Ctor(1).div(r) : finalise(r, pr, rm);\r\n    }\r\n\r\n    s = x.s;\r\n\r\n    // if x is negative\r\n    if (s < 0) {\r\n\r\n      // if y is not an integer\r\n      if (e < y.d.length - 1) return new Ctor(NaN);\r\n\r\n      // Result is positive if x is negative and the last digit of integer y is even.\r\n      if ((y.d[e] & 1) == 0) s = 1;\r\n\r\n      // if x.eq(-1)\r\n      if (x.e == 0 && x.d[0] == 1 && x.d.length == 1) {\r\n        x.s = s;\r\n        return x;\r\n      }\r\n    }\r\n\r\n    // Estimate result exponent.\r\n    // x^y = 10^e,  where e = y * log10(x)\r\n    // log10(x) = log10(x_significand) + x_exponent\r\n    // log10(x_significand) = ln(x_significand) / ln(10)\r\n    k = mathpow(+x, yn);\r\n    e = k == 0 || !isFinite(k)\r\n      ? mathfloor(yn * (Math.log('0.' + digitsToString(x.d)) / Math.LN10 + x.e + 1))\r\n      : new Ctor(k + '').e;\r\n\r\n    // Exponent estimate may be incorrect e.g. x: 0.999999999999999999, y: 2.29, e: 0, r.e: -1.\r\n\r\n    // Overflow/underflow?\r\n    if (e > Ctor.maxE + 1 || e < Ctor.minE - 1) return new Ctor(e > 0 ? s / 0 : 0);\r\n\r\n    external = false;\r\n    Ctor.rounding = x.s = 1;\r\n\r\n    // Estimate the extra guard digits needed to ensure five correct rounding digits from\r\n    // naturalLogarithm(x). Example of failure without these extra digits (precision: 10):\r\n    // new Decimal(2.32456).pow('2087987436534566.46411')\r\n    // should be 1.162377823e+764914905173815, but is 1.162355823e+764914905173815\r\n    k = Math.min(12, (e + '').length);\r\n\r\n    // r = x^y = exp(y*ln(x))\r\n    r = naturalExponential(y.times(naturalLogarithm(x, pr + k)), pr);\r\n\r\n    // r may be Infinity, e.g. (0.9999999999999999).pow(-1e+40)\r\n    if (r.d) {\r\n\r\n      // Truncate to the required precision plus five rounding digits.\r\n      r = finalise(r, pr + 5, 1);\r\n\r\n      // If the rounding digits are [49]9999 or [50]0000 increase the precision by 10 and recalculate\r\n      // the result.\r\n      if (checkRoundingDigits(r.d, pr, rm)) {\r\n        e = pr + 10;\r\n\r\n        // Truncate to the increased precision plus five rounding digits.\r\n        r = finalise(naturalExponential(y.times(naturalLogarithm(x, e + k)), e), e + 5, 1);\r\n\r\n        // Check for 14 nines from the 2nd rounding digit (the first rounding digit may be 4 or 9).\r\n        if (+digitsToString(r.d).slice(pr + 1, pr + 15) + 1 == 1e14) {\r\n          r = finalise(r, pr + 1, 0);\r\n        }\r\n      }\r\n    }\r\n\r\n    r.s = s;\r\n    external = true;\r\n    Ctor.rounding = rm;\r\n\r\n    return finalise(r, pr, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Decimal rounded to `sd` significant digits\r\n   * using rounding mode `rounding`.\r\n   *\r\n   * Return exponential notation if `sd` is less than the number of digits necessary to represent\r\n   * the integer part of the value in normal notation.\r\n   *\r\n   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   */\r\n  P.toPrecision = function (sd, rm) {\r\n    var str,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (sd === void 0) {\r\n      str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);\r\n    } else {\r\n      checkInt32(sd, 1, MAX_DIGITS);\r\n\r\n      if (rm === void 0) rm = Ctor.rounding;\r\n      else checkInt32(rm, 0, 8);\r\n\r\n      x = finalise(new Ctor(x), sd, rm);\r\n      str = finiteToString(x, sd <= x.e || x.e <= Ctor.toExpNeg, sd);\r\n    }\r\n\r\n    return x.isNeg() && !x.isZero() ? '-' + str : str;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `sd`\r\n   * significant digits using rounding mode `rm`, or to `precision` and `rounding` respectively if\r\n   * omitted.\r\n   *\r\n   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * 'toSD() digits out of range: {sd}'\r\n   * 'toSD() digits not an integer: {sd}'\r\n   * 'toSD() rounding mode not an integer: {rm}'\r\n   * 'toSD() rounding mode out of range: {rm}'\r\n   *\r\n   */\r\n  P.toSignificantDigits = P.toSD = function (sd, rm) {\r\n    var x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (sd === void 0) {\r\n      sd = Ctor.precision;\r\n      rm = Ctor.rounding;\r\n    } else {\r\n      checkInt32(sd, 1, MAX_DIGITS);\r\n\r\n      if (rm === void 0) rm = Ctor.rounding;\r\n      else checkInt32(rm, 0, 8);\r\n    }\r\n\r\n    return finalise(new Ctor(x), sd, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Decimal.\r\n   *\r\n   * Return exponential notation if this Decimal has a positive exponent equal to or greater than\r\n   * `toExpPos`, or a negative exponent equal to or less than `toExpNeg`.\r\n   *\r\n   */\r\n  P.toString = function () {\r\n    var x = this,\r\n      Ctor = x.constructor,\r\n      str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);\r\n\r\n    return x.isNeg() && !x.isZero() ? '-' + str : str;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal truncated to a whole number.\r\n   *\r\n   */\r\n  P.truncated = P.trunc = function () {\r\n    return finalise(new this.constructor(this), this.e + 1, 1);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Decimal.\r\n   * Unlike `toString`, negative zero will include the minus sign.\r\n   *\r\n   */\r\n  P.valueOf = P.toJSON = function () {\r\n    var x = this,\r\n      Ctor = x.constructor,\r\n      str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);\r\n\r\n    return x.isNeg() ? '-' + str : str;\r\n  };\r\n\r\n\r\n  // Helper functions for Decimal.prototype (P) and/or Decimal methods, and their callers.\r\n\r\n\r\n  /*\r\n   *  digitsToString           P.cubeRoot, P.logarithm, P.squareRoot, P.toFraction, P.toPower,\r\n   *                           finiteToString, naturalExponential, naturalLogarithm\r\n   *  checkInt32               P.toDecimalPlaces, P.toExponential, P.toFixed, P.toNearest,\r\n   *                           P.toPrecision, P.toSignificantDigits, toStringBinary, random\r\n   *  checkRoundingDigits      P.logarithm, P.toPower, naturalExponential, naturalLogarithm\r\n   *  convertBase              toStringBinary, parseOther\r\n   *  cos                      P.cos\r\n   *  divide                   P.atanh, P.cubeRoot, P.dividedBy, P.dividedToIntegerBy,\r\n   *                           P.logarithm, P.modulo, P.squareRoot, P.tan, P.tanh, P.toFraction,\r\n   *                           P.toNearest, toStringBinary, naturalExponential, naturalLogarithm,\r\n   *                           taylorSeries, atan2, parseOther\r\n   *  finalise                 P.absoluteValue, P.atan, P.atanh, P.ceil, P.cos, P.cosh,\r\n   *                           P.cubeRoot, P.dividedToIntegerBy, P.floor, P.logarithm, P.minus,\r\n   *                           P.modulo, P.negated, P.plus, P.round, P.sin, P.sinh, P.squareRoot,\r\n   *                           P.tan, P.times, P.toDecimalPlaces, P.toExponential, P.toFixed,\r\n   *                           P.toNearest, P.toPower, P.toPrecision, P.toSignificantDigits,\r\n   *                           P.truncated, divide, getLn10, getPi, naturalExponential,\r\n   *                           naturalLogarithm, ceil, floor, round, trunc\r\n   *  finiteToString           P.toExponential, P.toFixed, P.toPrecision, P.toString, P.valueOf,\r\n   *                           toStringBinary\r\n   *  getBase10Exponent        P.minus, P.plus, P.times, parseOther\r\n   *  getLn10                  P.logarithm, naturalLogarithm\r\n   *  getPi                    P.acos, P.asin, P.atan, toLessThanHalfPi, atan2\r\n   *  getPrecision             P.precision, P.toFraction\r\n   *  getZeroString            digitsToString, finiteToString\r\n   *  intPow                   P.toPower, parseOther\r\n   *  isOdd                    toLessThanHalfPi\r\n   *  maxOrMin                 max, min\r\n   *  naturalExponential       P.naturalExponential, P.toPower\r\n   *  naturalLogarithm         P.acosh, P.asinh, P.atanh, P.logarithm, P.naturalLogarithm,\r\n   *                           P.toPower, naturalExponential\r\n   *  nonFiniteToString        finiteToString, toStringBinary\r\n   *  parseDecimal             Decimal\r\n   *  parseOther               Decimal\r\n   *  sin                      P.sin\r\n   *  taylorSeries             P.cosh, P.sinh, cos, sin\r\n   *  toLessThanHalfPi         P.cos, P.sin\r\n   *  toStringBinary           P.toBinary, P.toHexadecimal, P.toOctal\r\n   *  truncate                 intPow\r\n   *\r\n   *  Throws:                  P.logarithm, P.precision, P.toFraction, checkInt32, getLn10, getPi,\r\n   *                           naturalLogarithm, config, parseOther, random, Decimal\r\n   */\r\n\r\n\r\n  function digitsToString(d) {\r\n    var i, k, ws,\r\n      indexOfLastWord = d.length - 1,\r\n      str = '',\r\n      w = d[0];\r\n\r\n    if (indexOfLastWord > 0) {\r\n      str += w;\r\n      for (i = 1; i < indexOfLastWord; i++) {\r\n        ws = d[i] + '';\r\n        k = LOG_BASE - ws.length;\r\n        if (k) str += getZeroString(k);\r\n        str += ws;\r\n      }\r\n\r\n      w = d[i];\r\n      ws = w + '';\r\n      k = LOG_BASE - ws.length;\r\n      if (k) str += getZeroString(k);\r\n    } else if (w === 0) {\r\n      return '0';\r\n    }\r\n\r\n    // Remove trailing zeros of last w.\r\n    for (; w % 10 === 0;) w /= 10;\r\n\r\n    return str + w;\r\n  }\r\n\r\n\r\n  function checkInt32(i, min, max) {\r\n    if (i !== ~~i || i < min || i > max) {\r\n      throw Error(invalidArgument + i);\r\n    }\r\n  }\r\n\r\n\r\n  /*\r\n   * Check 5 rounding digits if `repeating` is null, 4 otherwise.\r\n   * `repeating == null` if caller is `log` or `pow`,\r\n   * `repeating != null` if caller is `naturalLogarithm` or `naturalExponential`.\r\n   */\r\n  function checkRoundingDigits(d, i, rm, repeating) {\r\n    var di, k, r, rd;\r\n\r\n    // Get the length of the first word of the array d.\r\n    for (k = d[0]; k >= 10; k /= 10) --i;\r\n\r\n    // Is the rounding digit in the first word of d?\r\n    if (--i < 0) {\r\n      i += LOG_BASE;\r\n      di = 0;\r\n    } else {\r\n      di = Math.ceil((i + 1) / LOG_BASE);\r\n      i %= LOG_BASE;\r\n    }\r\n\r\n    // i is the index (0 - 6) of the rounding digit.\r\n    // E.g. if within the word 3487563 the first rounding digit is 5,\r\n    // then i = 4, k = 1000, rd = 3487563 % 1000 = 563\r\n    k = mathpow(10, LOG_BASE - i);\r\n    rd = d[di] % k | 0;\r\n\r\n    if (repeating == null) {\r\n      if (i < 3) {\r\n        if (i == 0) rd = rd / 100 | 0;\r\n        else if (i == 1) rd = rd / 10 | 0;\r\n        r = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 50000 || rd == 0;\r\n      } else {\r\n        r = (rm < 4 && rd + 1 == k || rm > 3 && rd + 1 == k / 2) &&\r\n          (d[di + 1] / k / 100 | 0) == mathpow(10, i - 2) - 1 ||\r\n            (rd == k / 2 || rd == 0) && (d[di + 1] / k / 100 | 0) == 0;\r\n      }\r\n    } else {\r\n      if (i < 4) {\r\n        if (i == 0) rd = rd / 1000 | 0;\r\n        else if (i == 1) rd = rd / 100 | 0;\r\n        else if (i == 2) rd = rd / 10 | 0;\r\n        r = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;\r\n      } else {\r\n        r = ((repeating || rm < 4) && rd + 1 == k ||\r\n        (!repeating && rm > 3) && rd + 1 == k / 2) &&\r\n          (d[di + 1] / k / 1000 | 0) == mathpow(10, i - 3) - 1;\r\n      }\r\n    }\r\n\r\n    return r;\r\n  }\r\n\r\n\r\n  // Convert string of `baseIn` to an array of numbers of `baseOut`.\r\n  // Eg. convertBase('255', 10, 16) returns [15, 15].\r\n  // Eg. convertBase('ff', 16, 10) returns [2, 5, 5].\r\n  function convertBase(str, baseIn, baseOut) {\r\n    var j,\r\n      arr = [0],\r\n      arrL,\r\n      i = 0,\r\n      strL = str.length;\r\n\r\n    for (; i < strL;) {\r\n      for (arrL = arr.length; arrL--;) arr[arrL] *= baseIn;\r\n      arr[0] += NUMERALS.indexOf(str.charAt(i++));\r\n      for (j = 0; j < arr.length; j++) {\r\n        if (arr[j] > baseOut - 1) {\r\n          if (arr[j + 1] === void 0) arr[j + 1] = 0;\r\n          arr[j + 1] += arr[j] / baseOut | 0;\r\n          arr[j] %= baseOut;\r\n        }\r\n      }\r\n    }\r\n\r\n    return arr.reverse();\r\n  }\r\n\r\n\r\n  /*\r\n   * cos(x) = 1 - x^2/2! + x^4/4! - ...\r\n   * |x| < pi/2\r\n   *\r\n   */\r\n  function cosine(Ctor, x) {\r\n    var k, len, y;\r\n\r\n    if (x.isZero()) return x;\r\n\r\n    // Argument reduction: cos(4x) = 8*(cos^4(x) - cos^2(x)) + 1\r\n    // i.e. cos(x) = 8*(cos^4(x/4) - cos^2(x/4)) + 1\r\n\r\n    // Estimate the optimum number of times to use the argument reduction.\r\n    len = x.d.length;\r\n    if (len < 32) {\r\n      k = Math.ceil(len / 3);\r\n      y = (1 / tinyPow(4, k)).toString();\r\n    } else {\r\n      k = 16;\r\n      y = '2.3283064365386962890625e-10';\r\n    }\r\n\r\n    Ctor.precision += k;\r\n\r\n    x = taylorSeries(Ctor, 1, x.times(y), new Ctor(1));\r\n\r\n    // Reverse argument reduction\r\n    for (var i = k; i--;) {\r\n      var cos2x = x.times(x);\r\n      x = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);\r\n    }\r\n\r\n    Ctor.precision -= k;\r\n\r\n    return x;\r\n  }\r\n\r\n\r\n  /*\r\n   * Perform division in the specified base.\r\n   */\r\n  var divide = (function () {\r\n\r\n    // Assumes non-zero x and k, and hence non-zero result.\r\n    function multiplyInteger(x, k, base) {\r\n      var temp,\r\n        carry = 0,\r\n        i = x.length;\r\n\r\n      for (x = x.slice(); i--;) {\r\n        temp = x[i] * k + carry;\r\n        x[i] = temp % base | 0;\r\n        carry = temp / base | 0;\r\n      }\r\n\r\n      if (carry) x.unshift(carry);\r\n\r\n      return x;\r\n    }\r\n\r\n    function compare(a, b, aL, bL) {\r\n      var i, r;\r\n\r\n      if (aL != bL) {\r\n        r = aL > bL ? 1 : -1;\r\n      } else {\r\n        for (i = r = 0; i < aL; i++) {\r\n          if (a[i] != b[i]) {\r\n            r = a[i] > b[i] ? 1 : -1;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      return r;\r\n    }\r\n\r\n    function subtract(a, b, aL, base) {\r\n      var i = 0;\r\n\r\n      // Subtract b from a.\r\n      for (; aL--;) {\r\n        a[aL] -= i;\r\n        i = a[aL] < b[aL] ? 1 : 0;\r\n        a[aL] = i * base + a[aL] - b[aL];\r\n      }\r\n\r\n      // Remove leading zeros.\r\n      for (; !a[0] && a.length > 1;) a.shift();\r\n    }\r\n\r\n    return function (x, y, pr, rm, dp, base) {\r\n      var cmp, e, i, k, logBase, more, prod, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0,\r\n        yL, yz,\r\n        Ctor = x.constructor,\r\n        sign = x.s == y.s ? 1 : -1,\r\n        xd = x.d,\r\n        yd = y.d;\r\n\r\n      // Either NaN, Infinity or 0?\r\n      if (!xd || !xd[0] || !yd || !yd[0]) {\r\n\r\n        return new Ctor(// Return NaN if either NaN, or both Infinity or 0.\r\n          !x.s || !y.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN :\r\n\r\n          // Return ±0 if x is 0 or y is ±Infinity, or return ±Infinity as y is 0.\r\n          xd && xd[0] == 0 || !yd ? sign * 0 : sign / 0);\r\n      }\r\n\r\n      if (base) {\r\n        logBase = 1;\r\n        e = x.e - y.e;\r\n      } else {\r\n        base = BASE;\r\n        logBase = LOG_BASE;\r\n        e = mathfloor(x.e / logBase) - mathfloor(y.e / logBase);\r\n      }\r\n\r\n      yL = yd.length;\r\n      xL = xd.length;\r\n      q = new Ctor(sign);\r\n      qd = q.d = [];\r\n\r\n      // Result exponent may be one less than e.\r\n      // The digit array of a Decimal from toStringBinary may have trailing zeros.\r\n      for (i = 0; yd[i] == (xd[i] || 0); i++);\r\n\r\n      if (yd[i] > (xd[i] || 0)) e--;\r\n\r\n      if (pr == null) {\r\n        sd = pr = Ctor.precision;\r\n        rm = Ctor.rounding;\r\n      } else if (dp) {\r\n        sd = pr + (x.e - y.e) + 1;\r\n      } else {\r\n        sd = pr;\r\n      }\r\n\r\n      if (sd < 0) {\r\n        qd.push(1);\r\n        more = true;\r\n      } else {\r\n\r\n        // Convert precision in number of base 10 digits to base 1e7 digits.\r\n        sd = sd / logBase + 2 | 0;\r\n        i = 0;\r\n\r\n        // divisor < 1e7\r\n        if (yL == 1) {\r\n          k = 0;\r\n          yd = yd[0];\r\n          sd++;\r\n\r\n          // k is the carry.\r\n          for (; (i < xL || k) && sd--; i++) {\r\n            t = k * base + (xd[i] || 0);\r\n            qd[i] = t / yd | 0;\r\n            k = t % yd | 0;\r\n          }\r\n\r\n          more = k || i < xL;\r\n\r\n        // divisor >= 1e7\r\n        } else {\r\n\r\n          // Normalise xd and yd so highest order digit of yd is >= base/2\r\n          k = base / (yd[0] + 1) | 0;\r\n\r\n          if (k > 1) {\r\n            yd = multiplyInteger(yd, k, base);\r\n            xd = multiplyInteger(xd, k, base);\r\n            yL = yd.length;\r\n            xL = xd.length;\r\n          }\r\n\r\n          xi = yL;\r\n          rem = xd.slice(0, yL);\r\n          remL = rem.length;\r\n\r\n          // Add zeros to make remainder as long as divisor.\r\n          for (; remL < yL;) rem[remL++] = 0;\r\n\r\n          yz = yd.slice();\r\n          yz.unshift(0);\r\n          yd0 = yd[0];\r\n\r\n          if (yd[1] >= base / 2) ++yd0;\r\n\r\n          do {\r\n            k = 0;\r\n\r\n            // Compare divisor and remainder.\r\n            cmp = compare(yd, rem, yL, remL);\r\n\r\n            // If divisor < remainder.\r\n            if (cmp < 0) {\r\n\r\n              // Calculate trial digit, k.\r\n              rem0 = rem[0];\r\n              if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);\r\n\r\n              // k will be how many times the divisor goes into the current remainder.\r\n              k = rem0 / yd0 | 0;\r\n\r\n              //  Algorithm:\r\n              //  1. product = divisor * trial digit (k)\r\n              //  2. if product > remainder: product -= divisor, k--\r\n              //  3. remainder -= product\r\n              //  4. if product was < remainder at 2:\r\n              //    5. compare new remainder and divisor\r\n              //    6. If remainder > divisor: remainder -= divisor, k++\r\n\r\n              if (k > 1) {\r\n                if (k >= base) k = base - 1;\r\n\r\n                // product = divisor * trial digit.\r\n                prod = multiplyInteger(yd, k, base);\r\n                prodL = prod.length;\r\n                remL = rem.length;\r\n\r\n                // Compare product and remainder.\r\n                cmp = compare(prod, rem, prodL, remL);\r\n\r\n                // product > remainder.\r\n                if (cmp == 1) {\r\n                  k--;\r\n\r\n                  // Subtract divisor from product.\r\n                  subtract(prod, yL < prodL ? yz : yd, prodL, base);\r\n                }\r\n              } else {\r\n\r\n                // cmp is -1.\r\n                // If k is 0, there is no need to compare yd and rem again below, so change cmp to 1\r\n                // to avoid it. If k is 1 there is a need to compare yd and rem again below.\r\n                if (k == 0) cmp = k = 1;\r\n                prod = yd.slice();\r\n              }\r\n\r\n              prodL = prod.length;\r\n              if (prodL < remL) prod.unshift(0);\r\n\r\n              // Subtract product from remainder.\r\n              subtract(rem, prod, remL, base);\r\n\r\n              // If product was < previous remainder.\r\n              if (cmp == -1) {\r\n                remL = rem.length;\r\n\r\n                // Compare divisor and new remainder.\r\n                cmp = compare(yd, rem, yL, remL);\r\n\r\n                // If divisor < new remainder, subtract divisor from remainder.\r\n                if (cmp < 1) {\r\n                  k++;\r\n\r\n                  // Subtract divisor from remainder.\r\n                  subtract(rem, yL < remL ? yz : yd, remL, base);\r\n                }\r\n              }\r\n\r\n              remL = rem.length;\r\n            } else if (cmp === 0) {\r\n              k++;\r\n              rem = [0];\r\n            }    // if cmp === 1, k will be 0\r\n\r\n            // Add the next digit, k, to the result array.\r\n            qd[i++] = k;\r\n\r\n            // Update the remainder.\r\n            if (cmp && rem[0]) {\r\n              rem[remL++] = xd[xi] || 0;\r\n            } else {\r\n              rem = [xd[xi]];\r\n              remL = 1;\r\n            }\r\n\r\n          } while ((xi++ < xL || rem[0] !== void 0) && sd--);\r\n\r\n          more = rem[0] !== void 0;\r\n        }\r\n\r\n        // Leading zero?\r\n        if (!qd[0]) qd.shift();\r\n      }\r\n\r\n      // logBase is 1 when divide is being used for base conversion.\r\n      if (logBase == 1) {\r\n        q.e = e;\r\n        inexact = more;\r\n      } else {\r\n\r\n        // To calculate q.e, first get the number of digits of qd[0].\r\n        for (i = 1, k = qd[0]; k >= 10; k /= 10) i++;\r\n        q.e = i + e * logBase - 1;\r\n\r\n        finalise(q, dp ? pr + q.e + 1 : pr, rm, more);\r\n      }\r\n\r\n      return q;\r\n    };\r\n  })();\r\n\r\n\r\n  /*\r\n   * Round `x` to `sd` significant digits using rounding mode `rm`.\r\n   * Check for over/under-flow.\r\n   */\r\n   function finalise(x, sd, rm, isTruncated) {\r\n    var digits, i, j, k, rd, roundUp, w, xd, xdi,\r\n      Ctor = x.constructor;\r\n\r\n    // Don't round if sd is null or undefined.\r\n    out: if (sd != null) {\r\n      xd = x.d;\r\n\r\n      // Infinity/NaN.\r\n      if (!xd) return x;\r\n\r\n      // rd: the rounding digit, i.e. the digit after the digit that may be rounded up.\r\n      // w: the word of xd containing rd, a base 1e7 number.\r\n      // xdi: the index of w within xd.\r\n      // digits: the number of digits of w.\r\n      // i: what would be the index of rd within w if all the numbers were 7 digits long (i.e. if\r\n      // they had leading zeros)\r\n      // j: if > 0, the actual index of rd within w (if < 0, rd is a leading zero).\r\n\r\n      // Get the length of the first word of the digits array xd.\r\n      for (digits = 1, k = xd[0]; k >= 10; k /= 10) digits++;\r\n      i = sd - digits;\r\n\r\n      // Is the rounding digit in the first word of xd?\r\n      if (i < 0) {\r\n        i += LOG_BASE;\r\n        j = sd;\r\n        w = xd[xdi = 0];\r\n\r\n        // Get the rounding digit at index j of w.\r\n        rd = w / mathpow(10, digits - j - 1) % 10 | 0;\r\n      } else {\r\n        xdi = Math.ceil((i + 1) / LOG_BASE);\r\n        k = xd.length;\r\n        if (xdi >= k) {\r\n          if (isTruncated) {\r\n\r\n            // Needed by `naturalExponential`, `naturalLogarithm` and `squareRoot`.\r\n            for (; k++ <= xdi;) xd.push(0);\r\n            w = rd = 0;\r\n            digits = 1;\r\n            i %= LOG_BASE;\r\n            j = i - LOG_BASE + 1;\r\n          } else {\r\n            break out;\r\n          }\r\n        } else {\r\n          w = k = xd[xdi];\r\n\r\n          // Get the number of digits of w.\r\n          for (digits = 1; k >= 10; k /= 10) digits++;\r\n\r\n          // Get the index of rd within w.\r\n          i %= LOG_BASE;\r\n\r\n          // Get the index of rd within w, adjusted for leading zeros.\r\n          // The number of leading zeros of w is given by LOG_BASE - digits.\r\n          j = i - LOG_BASE + digits;\r\n\r\n          // Get the rounding digit at index j of w.\r\n          rd = j < 0 ? 0 : w / mathpow(10, digits - j - 1) % 10 | 0;\r\n        }\r\n      }\r\n\r\n      // Are there any non-zero digits after the rounding digit?\r\n      isTruncated = isTruncated || sd < 0 ||\r\n        xd[xdi + 1] !== void 0 || (j < 0 ? w : w % mathpow(10, digits - j - 1));\r\n\r\n      // The expression `w % mathpow(10, digits - j - 1)` returns all the digits of w to the right\r\n      // of the digit at (left-to-right) index j, e.g. if w is 908714 and j is 2, the expression\r\n      // will give 714.\r\n\r\n      roundUp = rm < 4\r\n        ? (rd || isTruncated) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))\r\n        : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 &&\r\n\r\n          // Check whether the digit to the left of the rounding digit is odd.\r\n          ((i > 0 ? j > 0 ? w / mathpow(10, digits - j) : 0 : xd[xdi - 1]) % 10) & 1 ||\r\n            rm == (x.s < 0 ? 8 : 7));\r\n\r\n      if (sd < 1 || !xd[0]) {\r\n        xd.length = 0;\r\n        if (roundUp) {\r\n\r\n          // Convert sd to decimal places.\r\n          sd -= x.e + 1;\r\n\r\n          // 1, 0.1, 0.01, 0.001, 0.0001 etc.\r\n          xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);\r\n          x.e = -sd || 0;\r\n        } else {\r\n\r\n          // Zero.\r\n          xd[0] = x.e = 0;\r\n        }\r\n\r\n        return x;\r\n      }\r\n\r\n      // Remove excess digits.\r\n      if (i == 0) {\r\n        xd.length = xdi;\r\n        k = 1;\r\n        xdi--;\r\n      } else {\r\n        xd.length = xdi + 1;\r\n        k = mathpow(10, LOG_BASE - i);\r\n\r\n        // E.g. 56700 becomes 56000 if 7 is the rounding digit.\r\n        // j > 0 means i > number of leading zeros of w.\r\n        xd[xdi] = j > 0 ? (w / mathpow(10, digits - j) % mathpow(10, j) | 0) * k : 0;\r\n      }\r\n\r\n      if (roundUp) {\r\n        for (;;) {\r\n\r\n          // Is the digit to be rounded up in the first word of xd?\r\n          if (xdi == 0) {\r\n\r\n            // i will be the length of xd[0] before k is added.\r\n            for (i = 1, j = xd[0]; j >= 10; j /= 10) i++;\r\n            j = xd[0] += k;\r\n            for (k = 1; j >= 10; j /= 10) k++;\r\n\r\n            // if i != k the length has increased.\r\n            if (i != k) {\r\n              x.e++;\r\n              if (xd[0] == BASE) xd[0] = 1;\r\n            }\r\n\r\n            break;\r\n          } else {\r\n            xd[xdi] += k;\r\n            if (xd[xdi] != BASE) break;\r\n            xd[xdi--] = 0;\r\n            k = 1;\r\n          }\r\n        }\r\n      }\r\n\r\n      // Remove trailing zeros.\r\n      for (i = xd.length; xd[--i] === 0;) xd.pop();\r\n    }\r\n\r\n    if (external) {\r\n\r\n      // Overflow?\r\n      if (x.e > Ctor.maxE) {\r\n\r\n        // Infinity.\r\n        x.d = null;\r\n        x.e = NaN;\r\n\r\n      // Underflow?\r\n      } else if (x.e < Ctor.minE) {\r\n\r\n        // Zero.\r\n        x.e = 0;\r\n        x.d = [0];\r\n        // Ctor.underflow = true;\r\n      } // else Ctor.underflow = false;\r\n    }\r\n\r\n    return x;\r\n  }\r\n\r\n\r\n  function finiteToString(x, isExp, sd) {\r\n    if (!x.isFinite()) return nonFiniteToString(x);\r\n    var k,\r\n      e = x.e,\r\n      str = digitsToString(x.d),\r\n      len = str.length;\r\n\r\n    if (isExp) {\r\n      if (sd && (k = sd - len) > 0) {\r\n        str = str.charAt(0) + '.' + str.slice(1) + getZeroString(k);\r\n      } else if (len > 1) {\r\n        str = str.charAt(0) + '.' + str.slice(1);\r\n      }\r\n\r\n      str = str + (x.e < 0 ? 'e' : 'e+') + x.e;\r\n    } else if (e < 0) {\r\n      str = '0.' + getZeroString(-e - 1) + str;\r\n      if (sd && (k = sd - len) > 0) str += getZeroString(k);\r\n    } else if (e >= len) {\r\n      str += getZeroString(e + 1 - len);\r\n      if (sd && (k = sd - e - 1) > 0) str = str + '.' + getZeroString(k);\r\n    } else {\r\n      if ((k = e + 1) < len) str = str.slice(0, k) + '.' + str.slice(k);\r\n      if (sd && (k = sd - len) > 0) {\r\n        if (e + 1 === len) str += '.';\r\n        str += getZeroString(k);\r\n      }\r\n    }\r\n\r\n    return str;\r\n  }\r\n\r\n\r\n  // Calculate the base 10 exponent from the base 1e7 exponent.\r\n  function getBase10Exponent(digits, e) {\r\n    var w = digits[0];\r\n\r\n    // Add the number of digits of the first word of the digits array.\r\n    for ( e *= LOG_BASE; w >= 10; w /= 10) e++;\r\n    return e;\r\n  }\r\n\r\n\r\n  function getLn10(Ctor, sd, pr) {\r\n    if (sd > LN10_PRECISION) {\r\n\r\n      // Reset global state in case the exception is caught.\r\n      external = true;\r\n      if (pr) Ctor.precision = pr;\r\n      throw Error(precisionLimitExceeded);\r\n    }\r\n    return finalise(new Ctor(LN10), sd, 1, true);\r\n  }\r\n\r\n\r\n  function getPi(Ctor, sd, rm) {\r\n    if (sd > PI_PRECISION) throw Error(precisionLimitExceeded);\r\n    return finalise(new Ctor(PI), sd, rm, true);\r\n  }\r\n\r\n\r\n  function getPrecision(digits) {\r\n    var w = digits.length - 1,\r\n      len = w * LOG_BASE + 1;\r\n\r\n    w = digits[w];\r\n\r\n    // If non-zero...\r\n    if (w) {\r\n\r\n      // Subtract the number of trailing zeros of the last word.\r\n      for (; w % 10 == 0; w /= 10) len--;\r\n\r\n      // Add the number of digits of the first word.\r\n      for (w = digits[0]; w >= 10; w /= 10) len++;\r\n    }\r\n\r\n    return len;\r\n  }\r\n\r\n\r\n  function getZeroString(k) {\r\n    var zs = '';\r\n    for (; k--;) zs += '0';\r\n    return zs;\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of Decimal `x` to the power `n`, where `n` is an\r\n   * integer of type number.\r\n   *\r\n   * Implements 'exponentiation by squaring'. Called by `pow` and `parseOther`.\r\n   *\r\n   */\r\n  function intPow(Ctor, x, n, pr) {\r\n    var isTruncated,\r\n      r = new Ctor(1),\r\n\r\n      // Max n of 9007199254740991 takes 53 loop iterations.\r\n      // Maximum digits array length; leaves [28, 34] guard digits.\r\n      k = Math.ceil(pr / LOG_BASE + 4);\r\n\r\n    external = false;\r\n\r\n    for (;;) {\r\n      if (n % 2) {\r\n        r = r.times(x);\r\n        if (truncate(r.d, k)) isTruncated = true;\r\n      }\r\n\r\n      n = mathfloor(n / 2);\r\n      if (n === 0) {\r\n\r\n        // To ensure correct rounding when r.d is truncated, increment the last word if it is zero.\r\n        n = r.d.length - 1;\r\n        if (isTruncated && r.d[n] === 0) ++r.d[n];\r\n        break;\r\n      }\r\n\r\n      x = x.times(x);\r\n      truncate(x.d, k);\r\n    }\r\n\r\n    external = true;\r\n\r\n    return r;\r\n  }\r\n\r\n\r\n  function isOdd(n) {\r\n    return n.d[n.d.length - 1] & 1;\r\n  }\r\n\r\n\r\n  /*\r\n   * Handle `max` and `min`. `ltgt` is 'lt' or 'gt'.\r\n   */\r\n  function maxOrMin(Ctor, args, ltgt) {\r\n    var y,\r\n      x = new Ctor(args[0]),\r\n      i = 0;\r\n\r\n    for (; ++i < args.length;) {\r\n      y = new Ctor(args[i]);\r\n      if (!y.s) {\r\n        x = y;\r\n        break;\r\n      } else if (x[ltgt](y)) {\r\n        x = y;\r\n      }\r\n    }\r\n\r\n    return x;\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the natural exponential of `x` rounded to `sd` significant\r\n   * digits.\r\n   *\r\n   * Taylor/Maclaurin series.\r\n   *\r\n   * exp(x) = x^0/0! + x^1/1! + x^2/2! + x^3/3! + ...\r\n   *\r\n   * Argument reduction:\r\n   *   Repeat x = x / 32, k += 5, until |x| < 0.1\r\n   *   exp(x) = exp(x / 2^k)^(2^k)\r\n   *\r\n   * Previously, the argument was initially reduced by\r\n   * exp(x) = exp(r) * 10^k  where r = x - k * ln10, k = floor(x / ln10)\r\n   * to first put r in the range [0, ln10], before dividing by 32 until |x| < 0.1, but this was\r\n   * found to be slower than just dividing repeatedly by 32 as above.\r\n   *\r\n   * Max integer argument: exp('20723265836946413') = 6.3e+9000000000000000\r\n   * Min integer argument: exp('-20723265836946411') = 1.2e-9000000000000000\r\n   * (Math object integer min/max: Math.exp(709) = 8.2e+307, Math.exp(-745) = 5e-324)\r\n   *\r\n   *  exp(Infinity)  = Infinity\r\n   *  exp(-Infinity) = 0\r\n   *  exp(NaN)       = NaN\r\n   *  exp(±0)        = 1\r\n   *\r\n   *  exp(x) is non-terminating for any finite, non-zero x.\r\n   *\r\n   *  The result will always be correctly rounded.\r\n   *\r\n   */\r\n  function naturalExponential(x, sd) {\r\n    var denominator, guard, j, pow, sum, t, wpr,\r\n      rep = 0,\r\n      i = 0,\r\n      k = 0,\r\n      Ctor = x.constructor,\r\n      rm = Ctor.rounding,\r\n      pr = Ctor.precision;\r\n\r\n    // 0/NaN/Infinity?\r\n    if (!x.d || !x.d[0] || x.e > 17) {\r\n\r\n      return new Ctor(x.d\r\n        ? !x.d[0] ? 1 : x.s < 0 ? 0 : 1 / 0\r\n        : x.s ? x.s < 0 ? 0 : x : 0 / 0);\r\n    }\r\n\r\n    if (sd == null) {\r\n      external = false;\r\n      wpr = pr;\r\n    } else {\r\n      wpr = sd;\r\n    }\r\n\r\n    t = new Ctor(0.03125);\r\n\r\n    // while abs(x) >= 0.1\r\n    while (x.e > -2) {\r\n\r\n      // x = x / 2^5\r\n      x = x.times(t);\r\n      k += 5;\r\n    }\r\n\r\n    // Use 2 * log10(2^k) + 5 (empirically derived) to estimate the increase in precision\r\n    // necessary to ensure the first 4 rounding digits are correct.\r\n    guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;\r\n    wpr += guard;\r\n    denominator = pow = sum = new Ctor(1);\r\n    Ctor.precision = wpr;\r\n\r\n    for (;;) {\r\n      pow = finalise(pow.times(x), wpr, 1);\r\n      denominator = denominator.times(++i);\r\n      t = sum.plus(divide(pow, denominator, wpr, 1));\r\n\r\n      if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {\r\n        j = k;\r\n        while (j--) sum = finalise(sum.times(sum), wpr, 1);\r\n\r\n        // Check to see if the first 4 rounding digits are [49]999.\r\n        // If so, repeat the summation with a higher precision, otherwise\r\n        // e.g. with precision: 18, rounding: 1\r\n        // exp(18.404272462595034083567793919843761) = 98372560.1229999999 (should be 98372560.123)\r\n        // `wpr - guard` is the index of first rounding digit.\r\n        if (sd == null) {\r\n\r\n          if (rep < 3 && checkRoundingDigits(sum.d, wpr - guard, rm, rep)) {\r\n            Ctor.precision = wpr += 10;\r\n            denominator = pow = t = new Ctor(1);\r\n            i = 0;\r\n            rep++;\r\n          } else {\r\n            return finalise(sum, Ctor.precision = pr, rm, external = true);\r\n          }\r\n        } else {\r\n          Ctor.precision = pr;\r\n          return sum;\r\n        }\r\n      }\r\n\r\n      sum = t;\r\n    }\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the natural logarithm of `x` rounded to `sd` significant\r\n   * digits.\r\n   *\r\n   *  ln(-n)        = NaN\r\n   *  ln(0)         = -Infinity\r\n   *  ln(-0)        = -Infinity\r\n   *  ln(1)         = 0\r\n   *  ln(Infinity)  = Infinity\r\n   *  ln(-Infinity) = NaN\r\n   *  ln(NaN)       = NaN\r\n   *\r\n   *  ln(n) (n != 1) is non-terminating.\r\n   *\r\n   */\r\n  function naturalLogarithm(y, sd) {\r\n    var c, c0, denominator, e, numerator, rep, sum, t, wpr, x1, x2,\r\n      n = 1,\r\n      guard = 10,\r\n      x = y,\r\n      xd = x.d,\r\n      Ctor = x.constructor,\r\n      rm = Ctor.rounding,\r\n      pr = Ctor.precision;\r\n\r\n    // Is x negative or Infinity, NaN, 0 or 1?\r\n    if (x.s < 0 || !xd || !xd[0] || !x.e && xd[0] == 1 && xd.length == 1) {\r\n      return new Ctor(xd && !xd[0] ? -1 / 0 : x.s != 1 ? NaN : xd ? 0 : x);\r\n    }\r\n\r\n    if (sd == null) {\r\n      external = false;\r\n      wpr = pr;\r\n    } else {\r\n      wpr = sd;\r\n    }\r\n\r\n    Ctor.precision = wpr += guard;\r\n    c = digitsToString(xd);\r\n    c0 = c.charAt(0);\r\n\r\n    if (Math.abs(e = x.e) < 1.5e15) {\r\n\r\n      // Argument reduction.\r\n      // The series converges faster the closer the argument is to 1, so using\r\n      // ln(a^b) = b * ln(a),   ln(a) = ln(a^b) / b\r\n      // multiply the argument by itself until the leading digits of the significand are 7, 8, 9,\r\n      // 10, 11, 12 or 13, recording the number of multiplications so the sum of the series can\r\n      // later be divided by this number, then separate out the power of 10 using\r\n      // ln(a*10^b) = ln(a) + b*ln(10).\r\n\r\n      // max n is 21 (gives 0.9, 1.0 or 1.1) (9e15 / 21 = 4.2e14).\r\n      //while (c0 < 9 && c0 != 1 || c0 == 1 && c.charAt(1) > 1) {\r\n      // max n is 6 (gives 0.7 - 1.3)\r\n      while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {\r\n        x = x.times(y);\r\n        c = digitsToString(x.d);\r\n        c0 = c.charAt(0);\r\n        n++;\r\n      }\r\n\r\n      e = x.e;\r\n\r\n      if (c0 > 1) {\r\n        x = new Ctor('0.' + c);\r\n        e++;\r\n      } else {\r\n        x = new Ctor(c0 + '.' + c.slice(1));\r\n      }\r\n    } else {\r\n\r\n      // The argument reduction method above may result in overflow if the argument y is a massive\r\n      // number with exponent >= 1500000000000000 (9e15 / 6 = 1.5e15), so instead recall this\r\n      // function using ln(x*10^e) = ln(x) + e*ln(10).\r\n      t = getLn10(Ctor, wpr + 2, pr).times(e + '');\r\n      x = naturalLogarithm(new Ctor(c0 + '.' + c.slice(1)), wpr - guard).plus(t);\r\n      Ctor.precision = pr;\r\n\r\n      return sd == null ? finalise(x, pr, rm, external = true) : x;\r\n    }\r\n\r\n    // x1 is x reduced to a value near 1.\r\n    x1 = x;\r\n\r\n    // Taylor series.\r\n    // ln(y) = ln((1 + x)/(1 - x)) = 2(x + x^3/3 + x^5/5 + x^7/7 + ...)\r\n    // where x = (y - 1)/(y + 1)    (|x| < 1)\r\n    sum = numerator = x = divide(x.minus(1), x.plus(1), wpr, 1);\r\n    x2 = finalise(x.times(x), wpr, 1);\r\n    denominator = 3;\r\n\r\n    for (;;) {\r\n      numerator = finalise(numerator.times(x2), wpr, 1);\r\n      t = sum.plus(divide(numerator, new Ctor(denominator), wpr, 1));\r\n\r\n      if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {\r\n        sum = sum.times(2);\r\n\r\n        // Reverse the argument reduction. Check that e is not 0 because, besides preventing an\r\n        // unnecessary calculation, -0 + 0 = +0 and to ensure correct rounding -0 needs to stay -0.\r\n        if (e !== 0) sum = sum.plus(getLn10(Ctor, wpr + 2, pr).times(e + ''));\r\n        sum = divide(sum, new Ctor(n), wpr, 1);\r\n\r\n        // Is rm > 3 and the first 4 rounding digits 4999, or rm < 4 (or the summation has\r\n        // been repeated previously) and the first 4 rounding digits 9999?\r\n        // If so, restart the summation with a higher precision, otherwise\r\n        // e.g. with precision: 12, rounding: 1\r\n        // ln(135520028.6126091714265381533) = 18.7246299999 when it should be 18.72463.\r\n        // `wpr - guard` is the index of first rounding digit.\r\n        if (sd == null) {\r\n          if (checkRoundingDigits(sum.d, wpr - guard, rm, rep)) {\r\n            Ctor.precision = wpr += guard;\r\n            t = numerator = x = divide(x1.minus(1), x1.plus(1), wpr, 1);\r\n            x2 = finalise(x.times(x), wpr, 1);\r\n            denominator = rep = 1;\r\n          } else {\r\n            return finalise(sum, Ctor.precision = pr, rm, external = true);\r\n          }\r\n        } else {\r\n          Ctor.precision = pr;\r\n          return sum;\r\n        }\r\n      }\r\n\r\n      sum = t;\r\n      denominator += 2;\r\n    }\r\n  }\r\n\r\n\r\n  // ±Infinity, NaN.\r\n  function nonFiniteToString(x) {\r\n    // Unsigned.\r\n    return String(x.s * x.s / 0);\r\n  }\r\n\r\n\r\n  /*\r\n   * Parse the value of a new Decimal `x` from string `str`.\r\n   */\r\n  function parseDecimal(x, str) {\r\n    var e, i, len;\r\n\r\n    // Decimal point?\r\n    if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');\r\n\r\n    // Exponential form?\r\n    if ((i = str.search(/e/i)) > 0) {\r\n\r\n      // Determine exponent.\r\n      if (e < 0) e = i;\r\n      e += +str.slice(i + 1);\r\n      str = str.substring(0, i);\r\n    } else if (e < 0) {\r\n\r\n      // Integer.\r\n      e = str.length;\r\n    }\r\n\r\n    // Determine leading zeros.\r\n    for (i = 0; str.charCodeAt(i) === 48; i++);\r\n\r\n    // Determine trailing zeros.\r\n    for (len = str.length; str.charCodeAt(len - 1) === 48; --len);\r\n    str = str.slice(i, len);\r\n\r\n    if (str) {\r\n      len -= i;\r\n      x.e = e = e - i - 1;\r\n      x.d = [];\r\n\r\n      // Transform base\r\n\r\n      // e is the base 10 exponent.\r\n      // i is where to slice str to get the first word of the digits array.\r\n      i = (e + 1) % LOG_BASE;\r\n      if (e < 0) i += LOG_BASE;\r\n\r\n      if (i < len) {\r\n        if (i) x.d.push(+str.slice(0, i));\r\n        for (len -= LOG_BASE; i < len;) x.d.push(+str.slice(i, i += LOG_BASE));\r\n        str = str.slice(i);\r\n        i = LOG_BASE - str.length;\r\n      } else {\r\n        i -= len;\r\n      }\r\n\r\n      for (; i--;) str += '0';\r\n      x.d.push(+str);\r\n\r\n      if (external) {\r\n\r\n        // Overflow?\r\n        if (x.e > x.constructor.maxE) {\r\n\r\n          // Infinity.\r\n          x.d = null;\r\n          x.e = NaN;\r\n\r\n        // Underflow?\r\n        } else if (x.e < x.constructor.minE) {\r\n\r\n          // Zero.\r\n          x.e = 0;\r\n          x.d = [0];\r\n          // x.constructor.underflow = true;\r\n        } // else x.constructor.underflow = false;\r\n      }\r\n    } else {\r\n\r\n      // Zero.\r\n      x.e = 0;\r\n      x.d = [0];\r\n    }\r\n\r\n    return x;\r\n  }\r\n\r\n\r\n  /*\r\n   * Parse the value of a new Decimal `x` from a string `str`, which is not a decimal value.\r\n   */\r\n  function parseOther(x, str) {\r\n    var base, Ctor, divisor, i, isFloat, len, p, xd, xe;\r\n\r\n    if (str.indexOf('_') > -1) {\r\n      str = str.replace(/(\\d)_(?=\\d)/g, '$1');\r\n      if (isDecimal.test(str)) return parseDecimal(x, str);\r\n    } else if (str === 'Infinity' || str === 'NaN') {\r\n      if (!+str) x.s = NaN;\r\n      x.e = NaN;\r\n      x.d = null;\r\n      return x;\r\n    }\r\n\r\n    if (isHex.test(str))  {\r\n      base = 16;\r\n      str = str.toLowerCase();\r\n    } else if (isBinary.test(str))  {\r\n      base = 2;\r\n    } else if (isOctal.test(str))  {\r\n      base = 8;\r\n    } else {\r\n      throw Error(invalidArgument + str);\r\n    }\r\n\r\n    // Is there a binary exponent part?\r\n    i = str.search(/p/i);\r\n\r\n    if (i > 0) {\r\n      p = +str.slice(i + 1);\r\n      str = str.substring(2, i);\r\n    } else {\r\n      str = str.slice(2);\r\n    }\r\n\r\n    // Convert `str` as an integer then divide the result by `base` raised to a power such that the\r\n    // fraction part will be restored.\r\n    i = str.indexOf('.');\r\n    isFloat = i >= 0;\r\n    Ctor = x.constructor;\r\n\r\n    if (isFloat) {\r\n      str = str.replace('.', '');\r\n      len = str.length;\r\n      i = len - i;\r\n\r\n      // log[10](16) = 1.2041... , log[10](88) = 1.9444....\r\n      divisor = intPow(Ctor, new Ctor(base), i, i * 2);\r\n    }\r\n\r\n    xd = convertBase(str, base, BASE);\r\n    xe = xd.length - 1;\r\n\r\n    // Remove trailing zeros.\r\n    for (i = xe; xd[i] === 0; --i) xd.pop();\r\n    if (i < 0) return new Ctor(x.s * 0);\r\n    x.e = getBase10Exponent(xd, xe);\r\n    x.d = xd;\r\n    external = false;\r\n\r\n    // At what precision to perform the division to ensure exact conversion?\r\n    // maxDecimalIntegerPartDigitCount = ceil(log[10](b) * otherBaseIntegerPartDigitCount)\r\n    // log[10](2) = 0.30103, log[10](8) = 0.90309, log[10](16) = 1.20412\r\n    // E.g. ceil(1.2 * 3) = 4, so up to 4 decimal digits are needed to represent 3 hex int digits.\r\n    // maxDecimalFractionPartDigitCount = {Hex:4|Oct:3|Bin:1} * otherBaseFractionPartDigitCount\r\n    // Therefore using 4 * the number of digits of str will always be enough.\r\n    if (isFloat) x = divide(x, divisor, len * 4);\r\n\r\n    // Multiply by the binary exponent part if present.\r\n    if (p) x = x.times(Math.abs(p) < 54 ? mathpow(2, p) : Decimal.pow(2, p));\r\n    external = true;\r\n\r\n    return x;\r\n  }\r\n\r\n\r\n  /*\r\n   * sin(x) = x - x^3/3! + x^5/5! - ...\r\n   * |x| < pi/2\r\n   *\r\n   */\r\n  function sine(Ctor, x) {\r\n    var k,\r\n      len = x.d.length;\r\n\r\n    if (len < 3) {\r\n      return x.isZero() ? x : taylorSeries(Ctor, 2, x, x);\r\n    }\r\n\r\n    // Argument reduction: sin(5x) = 16*sin^5(x) - 20*sin^3(x) + 5*sin(x)\r\n    // i.e. sin(x) = 16*sin^5(x/5) - 20*sin^3(x/5) + 5*sin(x/5)\r\n    // and  sin(x) = sin(x/5)(5 + sin^2(x/5)(16sin^2(x/5) - 20))\r\n\r\n    // Estimate the optimum number of times to use the argument reduction.\r\n    k = 1.4 * Math.sqrt(len);\r\n    k = k > 16 ? 16 : k | 0;\r\n\r\n    x = x.times(1 / tinyPow(5, k));\r\n    x = taylorSeries(Ctor, 2, x, x);\r\n\r\n    // Reverse argument reduction\r\n    var sin2_x,\r\n      d5 = new Ctor(5),\r\n      d16 = new Ctor(16),\r\n      d20 = new Ctor(20);\r\n    for (; k--;) {\r\n      sin2_x = x.times(x);\r\n      x = x.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));\r\n    }\r\n\r\n    return x;\r\n  }\r\n\r\n\r\n  // Calculate Taylor series for `cos`, `cosh`, `sin` and `sinh`.\r\n  function taylorSeries(Ctor, n, x, y, isHyperbolic) {\r\n    var j, t, u, x2,\r\n      i = 1,\r\n      pr = Ctor.precision,\r\n      k = Math.ceil(pr / LOG_BASE);\r\n\r\n    external = false;\r\n    x2 = x.times(x);\r\n    u = new Ctor(y);\r\n\r\n    for (;;) {\r\n      t = divide(u.times(x2), new Ctor(n++ * n++), pr, 1);\r\n      u = isHyperbolic ? y.plus(t) : y.minus(t);\r\n      y = divide(t.times(x2), new Ctor(n++ * n++), pr, 1);\r\n      t = u.plus(y);\r\n\r\n      if (t.d[k] !== void 0) {\r\n        for (j = k; t.d[j] === u.d[j] && j--;);\r\n        if (j == -1) break;\r\n      }\r\n\r\n      j = u;\r\n      u = y;\r\n      y = t;\r\n      t = j;\r\n      i++;\r\n    }\r\n\r\n    external = true;\r\n    t.d.length = k + 1;\r\n\r\n    return t;\r\n  }\r\n\r\n\r\n  // Exponent e must be positive and non-zero.\r\n  function tinyPow(b, e) {\r\n    var n = b;\r\n    while (--e) n *= b;\r\n    return n;\r\n  }\r\n\r\n\r\n  // Return the absolute value of `x` reduced to less than or equal to half pi.\r\n  function toLessThanHalfPi(Ctor, x) {\r\n    var t,\r\n      isNeg = x.s < 0,\r\n      pi = getPi(Ctor, Ctor.precision, 1),\r\n      halfPi = pi.times(0.5);\r\n\r\n    x = x.abs();\r\n\r\n    if (x.lte(halfPi)) {\r\n      quadrant = isNeg ? 4 : 1;\r\n      return x;\r\n    }\r\n\r\n    t = x.divToInt(pi);\r\n\r\n    if (t.isZero()) {\r\n      quadrant = isNeg ? 3 : 2;\r\n    } else {\r\n      x = x.minus(t.times(pi));\r\n\r\n      // 0 <= x < pi\r\n      if (x.lte(halfPi)) {\r\n        quadrant = isOdd(t) ? (isNeg ? 2 : 3) : (isNeg ? 4 : 1);\r\n        return x;\r\n      }\r\n\r\n      quadrant = isOdd(t) ? (isNeg ? 1 : 4) : (isNeg ? 3 : 2);\r\n    }\r\n\r\n    return x.minus(pi).abs();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return the value of Decimal `x` as a string in base `baseOut`.\r\n   *\r\n   * If the optional `sd` argument is present include a binary exponent suffix.\r\n   */\r\n  function toStringBinary(x, baseOut, sd, rm) {\r\n    var base, e, i, k, len, roundUp, str, xd, y,\r\n      Ctor = x.constructor,\r\n      isExp = sd !== void 0;\r\n\r\n    if (isExp) {\r\n      checkInt32(sd, 1, MAX_DIGITS);\r\n      if (rm === void 0) rm = Ctor.rounding;\r\n      else checkInt32(rm, 0, 8);\r\n    } else {\r\n      sd = Ctor.precision;\r\n      rm = Ctor.rounding;\r\n    }\r\n\r\n    if (!x.isFinite()) {\r\n      str = nonFiniteToString(x);\r\n    } else {\r\n      str = finiteToString(x);\r\n      i = str.indexOf('.');\r\n\r\n      // Use exponential notation according to `toExpPos` and `toExpNeg`? No, but if required:\r\n      // maxBinaryExponent = floor((decimalExponent + 1) * log[2](10))\r\n      // minBinaryExponent = floor(decimalExponent * log[2](10))\r\n      // log[2](10) = 3.321928094887362347870319429489390175864\r\n\r\n      if (isExp) {\r\n        base = 2;\r\n        if (baseOut == 16) {\r\n          sd = sd * 4 - 3;\r\n        } else if (baseOut == 8) {\r\n          sd = sd * 3 - 2;\r\n        }\r\n      } else {\r\n        base = baseOut;\r\n      }\r\n\r\n      // Convert the number as an integer then divide the result by its base raised to a power such\r\n      // that the fraction part will be restored.\r\n\r\n      // Non-integer.\r\n      if (i >= 0) {\r\n        str = str.replace('.', '');\r\n        y = new Ctor(1);\r\n        y.e = str.length - i;\r\n        y.d = convertBase(finiteToString(y), 10, base);\r\n        y.e = y.d.length;\r\n      }\r\n\r\n      xd = convertBase(str, 10, base);\r\n      e = len = xd.length;\r\n\r\n      // Remove trailing zeros.\r\n      for (; xd[--len] == 0;) xd.pop();\r\n\r\n      if (!xd[0]) {\r\n        str = isExp ? '0p+0' : '0';\r\n      } else {\r\n        if (i < 0) {\r\n          e--;\r\n        } else {\r\n          x = new Ctor(x);\r\n          x.d = xd;\r\n          x.e = e;\r\n          x = divide(x, y, sd, rm, 0, base);\r\n          xd = x.d;\r\n          e = x.e;\r\n          roundUp = inexact;\r\n        }\r\n\r\n        // The rounding digit, i.e. the digit after the digit that may be rounded up.\r\n        i = xd[sd];\r\n        k = base / 2;\r\n        roundUp = roundUp || xd[sd + 1] !== void 0;\r\n\r\n        roundUp = rm < 4\r\n          ? (i !== void 0 || roundUp) && (rm === 0 || rm === (x.s < 0 ? 3 : 2))\r\n          : i > k || i === k && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 ||\r\n            rm === (x.s < 0 ? 8 : 7));\r\n\r\n        xd.length = sd;\r\n\r\n        if (roundUp) {\r\n\r\n          // Rounding up may mean the previous digit has to be rounded up and so on.\r\n          for (; ++xd[--sd] > base - 1;) {\r\n            xd[sd] = 0;\r\n            if (!sd) {\r\n              ++e;\r\n              xd.unshift(1);\r\n            }\r\n          }\r\n        }\r\n\r\n        // Determine trailing zeros.\r\n        for (len = xd.length; !xd[len - 1]; --len);\r\n\r\n        // E.g. [4, 11, 15] becomes 4bf.\r\n        for (i = 0, str = ''; i < len; i++) str += NUMERALS.charAt(xd[i]);\r\n\r\n        // Add binary exponent suffix?\r\n        if (isExp) {\r\n          if (len > 1) {\r\n            if (baseOut == 16 || baseOut == 8) {\r\n              i = baseOut == 16 ? 4 : 3;\r\n              for (--len; len % i; len++) str += '0';\r\n              xd = convertBase(str, base, baseOut);\r\n              for (len = xd.length; !xd[len - 1]; --len);\r\n\r\n              // xd[0] will always be be 1\r\n              for (i = 1, str = '1.'; i < len; i++) str += NUMERALS.charAt(xd[i]);\r\n            } else {\r\n              str = str.charAt(0) + '.' + str.slice(1);\r\n            }\r\n          }\r\n\r\n          str =  str + (e < 0 ? 'p' : 'p+') + e;\r\n        } else if (e < 0) {\r\n          for (; ++e;) str = '0' + str;\r\n          str = '0.' + str;\r\n        } else {\r\n          if (++e > len) for (e -= len; e-- ;) str += '0';\r\n          else if (e < len) str = str.slice(0, e) + '.' + str.slice(e);\r\n        }\r\n      }\r\n\r\n      str = (baseOut == 16 ? '0x' : baseOut == 2 ? '0b' : baseOut == 8 ? '0o' : '') + str;\r\n    }\r\n\r\n    return x.s < 0 ? '-' + str : str;\r\n  }\r\n\r\n\r\n  // Does not strip trailing zeros.\r\n  function truncate(arr, len) {\r\n    if (arr.length > len) {\r\n      arr.length = len;\r\n      return true;\r\n    }\r\n  }\r\n\r\n\r\n  // Decimal methods\r\n\r\n\r\n  /*\r\n   *  abs\r\n   *  acos\r\n   *  acosh\r\n   *  add\r\n   *  asin\r\n   *  asinh\r\n   *  atan\r\n   *  atanh\r\n   *  atan2\r\n   *  cbrt\r\n   *  ceil\r\n   *  clamp\r\n   *  clone\r\n   *  config\r\n   *  cos\r\n   *  cosh\r\n   *  div\r\n   *  exp\r\n   *  floor\r\n   *  hypot\r\n   *  ln\r\n   *  log\r\n   *  log2\r\n   *  log10\r\n   *  max\r\n   *  min\r\n   *  mod\r\n   *  mul\r\n   *  pow\r\n   *  random\r\n   *  round\r\n   *  set\r\n   *  sign\r\n   *  sin\r\n   *  sinh\r\n   *  sqrt\r\n   *  sub\r\n   *  sum\r\n   *  tan\r\n   *  tanh\r\n   *  trunc\r\n   */\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the absolute value of `x`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function abs(x) {\r\n    return new this(x).abs();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the arccosine in radians of `x`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function acos(x) {\r\n    return new this(x).acos();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the inverse of the hyperbolic cosine of `x`, rounded to\r\n   * `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\r\n  function acosh(x) {\r\n    return new this(x).acosh();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the sum of `x` and `y`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   * y {number|string|Decimal}\r\n   *\r\n   */\r\n  function add(x, y) {\r\n    return new this(x).plus(y);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the arcsine in radians of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function asin(x) {\r\n    return new this(x).asin();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the inverse of the hyperbolic sine of `x`, rounded to\r\n   * `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\r\n  function asinh(x) {\r\n    return new this(x).asinh();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the arctangent in radians of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function atan(x) {\r\n    return new this(x).atan();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the inverse of the hyperbolic tangent of `x`, rounded to\r\n   * `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\r\n  function atanh(x) {\r\n    return new this(x).atanh();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the arctangent in radians of `y/x` in the range -pi to pi\r\n   * (inclusive), rounded to `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-pi, pi]\r\n   *\r\n   * y {number|string|Decimal} The y-coordinate.\r\n   * x {number|string|Decimal} The x-coordinate.\r\n   *\r\n   * atan2(±0, -0)               = ±pi\r\n   * atan2(±0, +0)               = ±0\r\n   * atan2(±0, -x)               = ±pi for x > 0\r\n   * atan2(±0, x)                = ±0 for x > 0\r\n   * atan2(-y, ±0)               = -pi/2 for y > 0\r\n   * atan2(y, ±0)                = pi/2 for y > 0\r\n   * atan2(±y, -Infinity)        = ±pi for finite y > 0\r\n   * atan2(±y, +Infinity)        = ±0 for finite y > 0\r\n   * atan2(±Infinity, x)         = ±pi/2 for finite x\r\n   * atan2(±Infinity, -Infinity) = ±3*pi/4\r\n   * atan2(±Infinity, +Infinity) = ±pi/4\r\n   * atan2(NaN, x) = NaN\r\n   * atan2(y, NaN) = NaN\r\n   *\r\n   */\r\n  function atan2(y, x) {\r\n    y = new this(y);\r\n    x = new this(x);\r\n    var r,\r\n      pr = this.precision,\r\n      rm = this.rounding,\r\n      wpr = pr + 4;\r\n\r\n    // Either NaN\r\n    if (!y.s || !x.s) {\r\n      r = new this(NaN);\r\n\r\n    // Both ±Infinity\r\n    } else if (!y.d && !x.d) {\r\n      r = getPi(this, wpr, 1).times(x.s > 0 ? 0.25 : 0.75);\r\n      r.s = y.s;\r\n\r\n    // x is ±Infinity or y is ±0\r\n    } else if (!x.d || y.isZero()) {\r\n      r = x.s < 0 ? getPi(this, pr, rm) : new this(0);\r\n      r.s = y.s;\r\n\r\n    // y is ±Infinity or x is ±0\r\n    } else if (!y.d || x.isZero()) {\r\n      r = getPi(this, wpr, 1).times(0.5);\r\n      r.s = y.s;\r\n\r\n    // Both non-zero and finite\r\n    } else if (x.s < 0) {\r\n      this.precision = wpr;\r\n      this.rounding = 1;\r\n      r = this.atan(divide(y, x, wpr, 1));\r\n      x = getPi(this, wpr, 1);\r\n      this.precision = pr;\r\n      this.rounding = rm;\r\n      r = y.s < 0 ? r.minus(x) : r.plus(x);\r\n    } else {\r\n      r = this.atan(divide(y, x, wpr, 1));\r\n    }\r\n\r\n    return r;\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the cube root of `x`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function cbrt(x) {\r\n    return new this(x).cbrt();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` rounded to an integer using `ROUND_CEIL`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function ceil(x) {\r\n    return finalise(x = new this(x), x.e + 1, 2);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` clamped to the range delineated by `min` and `max`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   * min {number|string|Decimal}\r\n   * max {number|string|Decimal}\r\n   *\r\n   */\r\n  function clamp(x, min, max) {\r\n    return new this(x).clamp(min, max);\r\n  }\r\n\r\n\r\n  /*\r\n   * Configure global settings for a Decimal constructor.\r\n   *\r\n   * `obj` is an object with one or more of the following properties,\r\n   *\r\n   *   precision  {number}\r\n   *   rounding   {number}\r\n   *   toExpNeg   {number}\r\n   *   toExpPos   {number}\r\n   *   maxE       {number}\r\n   *   minE       {number}\r\n   *   modulo     {number}\r\n   *   crypto     {boolean|number}\r\n   *   defaults   {true}\r\n   *\r\n   * E.g. Decimal.config({ precision: 20, rounding: 4 })\r\n   *\r\n   */\r\n  function config(obj) {\r\n    if (!obj || typeof obj !== 'object') throw Error(decimalError + 'Object expected');\r\n    var i, p, v,\r\n      useDefaults = obj.defaults === true,\r\n      ps = [\r\n        'precision', 1, MAX_DIGITS,\r\n        'rounding', 0, 8,\r\n        'toExpNeg', -EXP_LIMIT, 0,\r\n        'toExpPos', 0, EXP_LIMIT,\r\n        'maxE', 0, EXP_LIMIT,\r\n        'minE', -EXP_LIMIT, 0,\r\n        'modulo', 0, 9\r\n      ];\r\n\r\n    for (i = 0; i < ps.length; i += 3) {\r\n      if (p = ps[i], useDefaults) this[p] = DEFAULTS[p];\r\n      if ((v = obj[p]) !== void 0) {\r\n        if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2]) this[p] = v;\r\n        else throw Error(invalidArgument + p + ': ' + v);\r\n      }\r\n    }\r\n\r\n    if (p = 'crypto', useDefaults) this[p] = DEFAULTS[p];\r\n    if ((v = obj[p]) !== void 0) {\r\n      if (v === true || v === false || v === 0 || v === 1) {\r\n        if (v) {\r\n          if (typeof crypto != 'undefined' && crypto &&\r\n            (crypto.getRandomValues || crypto.randomBytes)) {\r\n            this[p] = true;\r\n          } else {\r\n            throw Error(cryptoUnavailable);\r\n          }\r\n        } else {\r\n          this[p] = false;\r\n        }\r\n      } else {\r\n        throw Error(invalidArgument + p + ': ' + v);\r\n      }\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the cosine of `x`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\r\n  function cos(x) {\r\n    return new this(x).cos();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the hyperbolic cosine of `x`, rounded to precision\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\r\n  function cosh(x) {\r\n    return new this(x).cosh();\r\n  }\r\n\r\n\r\n  /*\r\n   * Create and return a Decimal constructor with the same configuration properties as this Decimal\r\n   * constructor.\r\n   *\r\n   */\r\n  function clone(obj) {\r\n    var i, p, ps;\r\n\r\n    /*\r\n     * The Decimal constructor and exported function.\r\n     * Return a new Decimal instance.\r\n     *\r\n     * v {number|string|Decimal} A numeric value.\r\n     *\r\n     */\r\n    function Decimal(v) {\r\n      var e, i, t,\r\n        x = this;\r\n\r\n      // Decimal called without new.\r\n      if (!(x instanceof Decimal)) return new Decimal(v);\r\n\r\n      // Retain a reference to this Decimal constructor, and shadow Decimal.prototype.constructor\r\n      // which points to Object.\r\n      x.constructor = Decimal;\r\n\r\n      // Duplicate.\r\n      if (isDecimalInstance(v)) {\r\n        x.s = v.s;\r\n\r\n        if (external) {\r\n          if (!v.d || v.e > Decimal.maxE) {\r\n\r\n            // Infinity.\r\n            x.e = NaN;\r\n            x.d = null;\r\n          } else if (v.e < Decimal.minE) {\r\n\r\n            // Zero.\r\n            x.e = 0;\r\n            x.d = [0];\r\n          } else {\r\n            x.e = v.e;\r\n            x.d = v.d.slice();\r\n          }\r\n        } else {\r\n          x.e = v.e;\r\n          x.d = v.d ? v.d.slice() : v.d;\r\n        }\r\n\r\n        return;\r\n      }\r\n\r\n      t = typeof v;\r\n\r\n      if (t === 'number') {\r\n        if (v === 0) {\r\n          x.s = 1 / v < 0 ? -1 : 1;\r\n          x.e = 0;\r\n          x.d = [0];\r\n          return;\r\n        }\r\n\r\n        if (v < 0) {\r\n          v = -v;\r\n          x.s = -1;\r\n        } else {\r\n          x.s = 1;\r\n        }\r\n\r\n        // Fast path for small integers.\r\n        if (v === ~~v && v < 1e7) {\r\n          for (e = 0, i = v; i >= 10; i /= 10) e++;\r\n\r\n          if (external) {\r\n            if (e > Decimal.maxE) {\r\n              x.e = NaN;\r\n              x.d = null;\r\n            } else if (e < Decimal.minE) {\r\n              x.e = 0;\r\n              x.d = [0];\r\n            } else {\r\n              x.e = e;\r\n              x.d = [v];\r\n            }\r\n          } else {\r\n            x.e = e;\r\n            x.d = [v];\r\n          }\r\n\r\n          return;\r\n\r\n        // Infinity, NaN.\r\n        } else if (v * 0 !== 0) {\r\n          if (!v) x.s = NaN;\r\n          x.e = NaN;\r\n          x.d = null;\r\n          return;\r\n        }\r\n\r\n        return parseDecimal(x, v.toString());\r\n\r\n      } else if (t !== 'string') {\r\n        throw Error(invalidArgument + v);\r\n      }\r\n\r\n      // Minus sign?\r\n      if ((i = v.charCodeAt(0)) === 45) {\r\n        v = v.slice(1);\r\n        x.s = -1;\r\n      } else {\r\n        // Plus sign?\r\n        if (i === 43) v = v.slice(1);\r\n        x.s = 1;\r\n      }\r\n\r\n      return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);\r\n    }\r\n\r\n    Decimal.prototype = P;\r\n\r\n    Decimal.ROUND_UP = 0;\r\n    Decimal.ROUND_DOWN = 1;\r\n    Decimal.ROUND_CEIL = 2;\r\n    Decimal.ROUND_FLOOR = 3;\r\n    Decimal.ROUND_HALF_UP = 4;\r\n    Decimal.ROUND_HALF_DOWN = 5;\r\n    Decimal.ROUND_HALF_EVEN = 6;\r\n    Decimal.ROUND_HALF_CEIL = 7;\r\n    Decimal.ROUND_HALF_FLOOR = 8;\r\n    Decimal.EUCLID = 9;\r\n\r\n    Decimal.config = Decimal.set = config;\r\n    Decimal.clone = clone;\r\n    Decimal.isDecimal = isDecimalInstance;\r\n\r\n    Decimal.abs = abs;\r\n    Decimal.acos = acos;\r\n    Decimal.acosh = acosh;        // ES6\r\n    Decimal.add = add;\r\n    Decimal.asin = asin;\r\n    Decimal.asinh = asinh;        // ES6\r\n    Decimal.atan = atan;\r\n    Decimal.atanh = atanh;        // ES6\r\n    Decimal.atan2 = atan2;\r\n    Decimal.cbrt = cbrt;          // ES6\r\n    Decimal.ceil = ceil;\r\n    Decimal.clamp = clamp;\r\n    Decimal.cos = cos;\r\n    Decimal.cosh = cosh;          // ES6\r\n    Decimal.div = div;\r\n    Decimal.exp = exp;\r\n    Decimal.floor = floor;\r\n    Decimal.hypot = hypot;        // ES6\r\n    Decimal.ln = ln;\r\n    Decimal.log = log;\r\n    Decimal.log10 = log10;        // ES6\r\n    Decimal.log2 = log2;          // ES6\r\n    Decimal.max = max;\r\n    Decimal.min = min;\r\n    Decimal.mod = mod;\r\n    Decimal.mul = mul;\r\n    Decimal.pow = pow;\r\n    Decimal.random = random;\r\n    Decimal.round = round;\r\n    Decimal.sign = sign;          // ES6\r\n    Decimal.sin = sin;\r\n    Decimal.sinh = sinh;          // ES6\r\n    Decimal.sqrt = sqrt;\r\n    Decimal.sub = sub;\r\n    Decimal.sum = sum;\r\n    Decimal.tan = tan;\r\n    Decimal.tanh = tanh;          // ES6\r\n    Decimal.trunc = trunc;        // ES6\r\n\r\n    if (obj === void 0) obj = {};\r\n    if (obj) {\r\n      if (obj.defaults !== true) {\r\n        ps = ['precision', 'rounding', 'toExpNeg', 'toExpPos', 'maxE', 'minE', 'modulo', 'crypto'];\r\n        for (i = 0; i < ps.length;) if (!obj.hasOwnProperty(p = ps[i++])) obj[p] = this[p];\r\n      }\r\n    }\r\n\r\n    Decimal.config(obj);\r\n\r\n    return Decimal;\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` divided by `y`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   * y {number|string|Decimal}\r\n   *\r\n   */\r\n  function div(x, y) {\r\n    return new this(x).div(y);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the natural exponential of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} The power to which to raise the base of the natural log.\r\n   *\r\n   */\r\n  function exp(x) {\r\n    return new this(x).exp();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` round to an integer using `ROUND_FLOOR`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function floor(x) {\r\n    return finalise(x = new this(x), x.e + 1, 3);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the square root of the sum of the squares of the arguments,\r\n   * rounded to `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * hypot(a, b, ...) = sqrt(a^2 + b^2 + ...)\r\n   *\r\n   * arguments {number|string|Decimal}\r\n   *\r\n   */\r\n  function hypot() {\r\n    var i, n,\r\n      t = new this(0);\r\n\r\n    external = false;\r\n\r\n    for (i = 0; i < arguments.length;) {\r\n      n = new this(arguments[i++]);\r\n      if (!n.d) {\r\n        if (n.s) {\r\n          external = true;\r\n          return new this(1 / 0);\r\n        }\r\n        t = n;\r\n      } else if (t.d) {\r\n        t = t.plus(n.times(n));\r\n      }\r\n    }\r\n\r\n    external = true;\r\n\r\n    return t.sqrt();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return true if object is a Decimal instance (where Decimal is any Decimal constructor),\r\n   * otherwise return false.\r\n   *\r\n   */\r\n  function isDecimalInstance(obj) {\r\n    return obj instanceof Decimal || obj && obj.toStringTag === tag || false;\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the natural logarithm of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function ln(x) {\r\n    return new this(x).ln();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the log of `x` to the base `y`, or to base 10 if no base\r\n   * is specified, rounded to `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * log[y](x)\r\n   *\r\n   * x {number|string|Decimal} The argument of the logarithm.\r\n   * y {number|string|Decimal} The base of the logarithm.\r\n   *\r\n   */\r\n  function log(x, y) {\r\n    return new this(x).log(y);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the base 2 logarithm of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function log2(x) {\r\n    return new this(x).log(2);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the base 10 logarithm of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function log10(x) {\r\n    return new this(x).log(10);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the maximum of the arguments.\r\n   *\r\n   * arguments {number|string|Decimal}\r\n   *\r\n   */\r\n  function max() {\r\n    return maxOrMin(this, arguments, 'lt');\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the minimum of the arguments.\r\n   *\r\n   * arguments {number|string|Decimal}\r\n   *\r\n   */\r\n  function min() {\r\n    return maxOrMin(this, arguments, 'gt');\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` modulo `y`, rounded to `precision` significant digits\r\n   * using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   * y {number|string|Decimal}\r\n   *\r\n   */\r\n  function mod(x, y) {\r\n    return new this(x).mod(y);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` multiplied by `y`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   * y {number|string|Decimal}\r\n   *\r\n   */\r\n  function mul(x, y) {\r\n    return new this(x).mul(y);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` raised to the power `y`, rounded to precision\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} The base.\r\n   * y {number|string|Decimal} The exponent.\r\n   *\r\n   */\r\n  function pow(x, y) {\r\n    return new this(x).pow(y);\r\n  }\r\n\r\n\r\n  /*\r\n   * Returns a new Decimal with a random value equal to or greater than 0 and less than 1, and with\r\n   * `sd`, or `Decimal.precision` if `sd` is omitted, significant digits (or less if trailing zeros\r\n   * are produced).\r\n   *\r\n   * [sd] {number} Significant digits. Integer, 0 to MAX_DIGITS inclusive.\r\n   *\r\n   */\r\n  function random(sd) {\r\n    var d, e, k, n,\r\n      i = 0,\r\n      r = new this(1),\r\n      rd = [];\r\n\r\n    if (sd === void 0) sd = this.precision;\r\n    else checkInt32(sd, 1, MAX_DIGITS);\r\n\r\n    k = Math.ceil(sd / LOG_BASE);\r\n\r\n    if (!this.crypto) {\r\n      for (; i < k;) rd[i++] = Math.random() * 1e7 | 0;\r\n\r\n    // Browsers supporting crypto.getRandomValues.\r\n    } else if (crypto.getRandomValues) {\r\n      d = crypto.getRandomValues(new Uint32Array(k));\r\n\r\n      for (; i < k;) {\r\n        n = d[i];\r\n\r\n        // 0 <= n < 4294967296\r\n        // Probability n >= 4.29e9, is 4967296 / 4294967296 = 0.00116 (1 in 865).\r\n        if (n >= 4.29e9) {\r\n          d[i] = crypto.getRandomValues(new Uint32Array(1))[0];\r\n        } else {\r\n\r\n          // 0 <= n <= 4289999999\r\n          // 0 <= (n % 1e7) <= 9999999\r\n          rd[i++] = n % 1e7;\r\n        }\r\n      }\r\n\r\n    // Node.js supporting crypto.randomBytes.\r\n    } else if (crypto.randomBytes) {\r\n\r\n      // buffer\r\n      d = crypto.randomBytes(k *= 4);\r\n\r\n      for (; i < k;) {\r\n\r\n        // 0 <= n < 2147483648\r\n        n = d[i] + (d[i + 1] << 8) + (d[i + 2] << 16) + ((d[i + 3] & 0x7f) << 24);\r\n\r\n        // Probability n >= 2.14e9, is 7483648 / 2147483648 = 0.0035 (1 in 286).\r\n        if (n >= 2.14e9) {\r\n          crypto.randomBytes(4).copy(d, i);\r\n        } else {\r\n\r\n          // 0 <= n <= 2139999999\r\n          // 0 <= (n % 1e7) <= 9999999\r\n          rd.push(n % 1e7);\r\n          i += 4;\r\n        }\r\n      }\r\n\r\n      i = k / 4;\r\n    } else {\r\n      throw Error(cryptoUnavailable);\r\n    }\r\n\r\n    k = rd[--i];\r\n    sd %= LOG_BASE;\r\n\r\n    // Convert trailing digits to zeros according to sd.\r\n    if (k && sd) {\r\n      n = mathpow(10, LOG_BASE - sd);\r\n      rd[i] = (k / n | 0) * n;\r\n    }\r\n\r\n    // Remove trailing words which are zero.\r\n    for (; rd[i] === 0; i--) rd.pop();\r\n\r\n    // Zero?\r\n    if (i < 0) {\r\n      e = 0;\r\n      rd = [0];\r\n    } else {\r\n      e = -1;\r\n\r\n      // Remove leading words which are zero and adjust exponent accordingly.\r\n      for (; rd[0] === 0; e -= LOG_BASE) rd.shift();\r\n\r\n      // Count the digits of the first word of rd to determine leading zeros.\r\n      for (k = 1, n = rd[0]; n >= 10; n /= 10) k++;\r\n\r\n      // Adjust the exponent for leading zeros of the first word of rd.\r\n      if (k < LOG_BASE) e -= LOG_BASE - k;\r\n    }\r\n\r\n    r.e = e;\r\n    r.d = rd;\r\n\r\n    return r;\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` rounded to an integer using rounding mode `rounding`.\r\n   *\r\n   * To emulate `Math.round`, set rounding to 7 (ROUND_HALF_CEIL).\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function round(x) {\r\n    return finalise(x = new this(x), x.e + 1, this.rounding);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return\r\n   *   1    if x > 0,\r\n   *  -1    if x < 0,\r\n   *   0    if x is 0,\r\n   *  -0    if x is -0,\r\n   *   NaN  otherwise\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function sign(x) {\r\n    x = new this(x);\r\n    return x.d ? (x.d[0] ? x.s : 0 * x.s) : x.s || NaN;\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the sine of `x`, rounded to `precision` significant digits\r\n   * using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\r\n  function sin(x) {\r\n    return new this(x).sin();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the hyperbolic sine of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\r\n  function sinh(x) {\r\n    return new this(x).sinh();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the square root of `x`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function sqrt(x) {\r\n    return new this(x).sqrt();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` minus `y`, rounded to `precision` significant digits\r\n   * using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   * y {number|string|Decimal}\r\n   *\r\n   */\r\n  function sub(x, y) {\r\n    return new this(x).sub(y);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the sum of the arguments, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * Only the result is rounded, not the intermediate calculations.\r\n   *\r\n   * arguments {number|string|Decimal}\r\n   *\r\n   */\r\n  function sum() {\r\n    var i = 0,\r\n      args = arguments,\r\n      x = new this(args[i]);\r\n\r\n    external = false;\r\n    for (; x.s && ++i < args.length;) x = x.plus(args[i]);\r\n    external = true;\r\n\r\n    return finalise(x, this.precision, this.rounding);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the tangent of `x`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\r\n  function tan(x) {\r\n    return new this(x).tan();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the hyperbolic tangent of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\r\n  function tanh(x) {\r\n    return new this(x).tanh();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` truncated to an integer.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function trunc(x) {\r\n    return finalise(x = new this(x), x.e + 1, 1);\r\n  }\r\n\r\n\r\n  // Create and configure initial Decimal constructor.\r\n  Decimal = clone(DEFAULTS);\r\n  Decimal.prototype.constructor = Decimal;\r\n  Decimal['default'] = Decimal.Decimal = Decimal;\r\n\r\n  // Create the internal constants from their string values.\r\n  LN10 = new Decimal(LN10);\r\n  PI = new Decimal(PI);\r\n\r\n\r\n  // Export.\r\n\r\n\r\n  // AMD.\r\n  if (typeof define == 'function' && define.amd) {\r\n    define(function () {\r\n      return Decimal;\r\n    });\r\n\r\n  // Node and other environments that support module.exports.\r\n  } else if (typeof module != 'undefined' && module.exports) {\r\n    if (typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol') {\r\n      P[Symbol['for']('nodejs.util.inspect.custom')] = P.toString;\r\n      P[Symbol.toStringTag] = 'Decimal';\r\n    }\r\n\r\n    module.exports = Decimal;\r\n\r\n  // Browser.\r\n  } else {\r\n    if (!globalScope) {\r\n      globalScope = typeof self != 'undefined' && self && self.self == self ? self : window;\r\n    }\r\n\r\n    noConflict = globalScope.Decimal;\r\n    Decimal.noConflict = function () {\r\n      globalScope.Decimal = noConflict;\r\n      return Decimal;\r\n    };\r\n\r\n    globalScope.Decimal = Decimal;\r\n  }\r\n})(this);\r\n","(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.Elucidator = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\n;(function (globalScope) {\r\n  'use strict';\r\n\r\n\r\n  /*!\r\n   *  decimal.js v10.4.3\r\n   *  An arbitrary-precision Decimal type for JavaScript.\r\n   *  https://github.com/MikeMcl/decimal.js\r\n   *  Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>\r\n   *  MIT Licence\r\n   */\r\n\r\n\r\n  // -----------------------------------  EDITABLE DEFAULTS  ------------------------------------ //\r\n\r\n\r\n    // The maximum exponent magnitude.\r\n    // The limit on the value of `toExpNeg`, `toExpPos`, `minE` and `maxE`.\r\n  var EXP_LIMIT = 9e15,                      // 0 to 9e15\r\n\r\n    // The limit on the value of `precision`, and on the value of the first argument to\r\n    // `toDecimalPlaces`, `toExponential`, `toFixed`, `toPrecision` and `toSignificantDigits`.\r\n    MAX_DIGITS = 1e9,                        // 0 to 1e9\r\n\r\n    // Base conversion alphabet.\r\n    NUMERALS = '0123456789abcdef',\r\n\r\n    // The natural logarithm of 10 (1025 digits).\r\n    LN10 = '2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058',\r\n\r\n    // Pi (1025 digits).\r\n    PI = '3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789',\r\n\r\n\r\n    // The initial configuration properties of the Decimal constructor.\r\n    DEFAULTS = {\r\n\r\n      // These values must be integers within the stated ranges (inclusive).\r\n      // Most of these values can be changed at run-time using the `Decimal.config` method.\r\n\r\n      // The maximum number of significant digits of the result of a calculation or base conversion.\r\n      // E.g. `Decimal.config({ precision: 20 });`\r\n      precision: 20,                         // 1 to MAX_DIGITS\r\n\r\n      // The rounding mode used when rounding to `precision`.\r\n      //\r\n      // ROUND_UP         0 Away from zero.\r\n      // ROUND_DOWN       1 Towards zero.\r\n      // ROUND_CEIL       2 Towards +Infinity.\r\n      // ROUND_FLOOR      3 Towards -Infinity.\r\n      // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.\r\n      // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.\r\n      // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.\r\n      // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.\r\n      // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.\r\n      //\r\n      // E.g.\r\n      // `Decimal.rounding = 4;`\r\n      // `Decimal.rounding = Decimal.ROUND_HALF_UP;`\r\n      rounding: 4,                           // 0 to 8\r\n\r\n      // The modulo mode used when calculating the modulus: a mod n.\r\n      // The quotient (q = a / n) is calculated according to the corresponding rounding mode.\r\n      // The remainder (r) is calculated as: r = a - n * q.\r\n      //\r\n      // UP         0 The remainder is positive if the dividend is negative, else is negative.\r\n      // DOWN       1 The remainder has the same sign as the dividend (JavaScript %).\r\n      // FLOOR      3 The remainder has the same sign as the divisor (Python %).\r\n      // HALF_EVEN  6 The IEEE 754 remainder function.\r\n      // EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.\r\n      //\r\n      // Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian\r\n      // division (9) are commonly used for the modulus operation. The other rounding modes can also\r\n      // be used, but they may not give useful results.\r\n      modulo: 1,                             // 0 to 9\r\n\r\n      // The exponent value at and beneath which `toString` returns exponential notation.\r\n      // JavaScript numbers: -7\r\n      toExpNeg: -7,                          // 0 to -EXP_LIMIT\r\n\r\n      // The exponent value at and above which `toString` returns exponential notation.\r\n      // JavaScript numbers: 21\r\n      toExpPos:  21,                         // 0 to EXP_LIMIT\r\n\r\n      // The minimum exponent value, beneath which underflow to zero occurs.\r\n      // JavaScript numbers: -324  (5e-324)\r\n      minE: -EXP_LIMIT,                      // -1 to -EXP_LIMIT\r\n\r\n      // The maximum exponent value, above which overflow to Infinity occurs.\r\n      // JavaScript numbers: 308  (1.7976931348623157e+308)\r\n      maxE: EXP_LIMIT,                       // 1 to EXP_LIMIT\r\n\r\n      // Whether to use cryptographically-secure random number generation, if available.\r\n      crypto: false                          // true/false\r\n    },\r\n\r\n\r\n  // ----------------------------------- END OF EDITABLE DEFAULTS ------------------------------- //\r\n\r\n\r\n    Decimal, inexact, noConflict, quadrant,\r\n    external = true,\r\n\r\n    decimalError = '[DecimalError] ',\r\n    invalidArgument = decimalError + 'Invalid argument: ',\r\n    precisionLimitExceeded = decimalError + 'Precision limit exceeded',\r\n    cryptoUnavailable = decimalError + 'crypto unavailable',\r\n    tag = '[object Decimal]',\r\n\r\n    mathfloor = Math.floor,\r\n    mathpow = Math.pow,\r\n\r\n    isBinary = /^0b([01]+(\\.[01]*)?|\\.[01]+)(p[+-]?\\d+)?$/i,\r\n    isHex = /^0x([0-9a-f]+(\\.[0-9a-f]*)?|\\.[0-9a-f]+)(p[+-]?\\d+)?$/i,\r\n    isOctal = /^0o([0-7]+(\\.[0-7]*)?|\\.[0-7]+)(p[+-]?\\d+)?$/i,\r\n    isDecimal = /^(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?$/i,\r\n\r\n    BASE = 1e7,\r\n    LOG_BASE = 7,\r\n    MAX_SAFE_INTEGER = 9007199254740991,\r\n\r\n    LN10_PRECISION = LN10.length - 1,\r\n    PI_PRECISION = PI.length - 1,\r\n\r\n    // Decimal.prototype object\r\n    P = { toStringTag: tag };\r\n\r\n\r\n  // Decimal prototype methods\r\n\r\n\r\n  /*\r\n   *  absoluteValue             abs\r\n   *  ceil\r\n   *  clampedTo                 clamp\r\n   *  comparedTo                cmp\r\n   *  cosine                    cos\r\n   *  cubeRoot                  cbrt\r\n   *  decimalPlaces             dp\r\n   *  dividedBy                 div\r\n   *  dividedToIntegerBy        divToInt\r\n   *  equals                    eq\r\n   *  floor\r\n   *  greaterThan               gt\r\n   *  greaterThanOrEqualTo      gte\r\n   *  hyperbolicCosine          cosh\r\n   *  hyperbolicSine            sinh\r\n   *  hyperbolicTangent         tanh\r\n   *  inverseCosine             acos\r\n   *  inverseHyperbolicCosine   acosh\r\n   *  inverseHyperbolicSine     asinh\r\n   *  inverseHyperbolicTangent  atanh\r\n   *  inverseSine               asin\r\n   *  inverseTangent            atan\r\n   *  isFinite\r\n   *  isInteger                 isInt\r\n   *  isNaN\r\n   *  isNegative                isNeg\r\n   *  isPositive                isPos\r\n   *  isZero\r\n   *  lessThan                  lt\r\n   *  lessThanOrEqualTo         lte\r\n   *  logarithm                 log\r\n   *  [maximum]                 [max]\r\n   *  [minimum]                 [min]\r\n   *  minus                     sub\r\n   *  modulo                    mod\r\n   *  naturalExponential        exp\r\n   *  naturalLogarithm          ln\r\n   *  negated                   neg\r\n   *  plus                      add\r\n   *  precision                 sd\r\n   *  round\r\n   *  sine                      sin\r\n   *  squareRoot                sqrt\r\n   *  tangent                   tan\r\n   *  times                     mul\r\n   *  toBinary\r\n   *  toDecimalPlaces           toDP\r\n   *  toExponential\r\n   *  toFixed\r\n   *  toFraction\r\n   *  toHexadecimal             toHex\r\n   *  toNearest\r\n   *  toNumber\r\n   *  toOctal\r\n   *  toPower                   pow\r\n   *  toPrecision\r\n   *  toSignificantDigits       toSD\r\n   *  toString\r\n   *  truncated                 trunc\r\n   *  valueOf                   toJSON\r\n   */\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the absolute value of this Decimal.\r\n   *\r\n   */\r\n  P.absoluteValue = P.abs = function () {\r\n    var x = new this.constructor(this);\r\n    if (x.s < 0) x.s = 1;\r\n    return finalise(x);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal rounded to a whole number in the\r\n   * direction of positive Infinity.\r\n   *\r\n   */\r\n  P.ceil = function () {\r\n    return finalise(new this.constructor(this), this.e + 1, 2);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal clamped to the range\r\n   * delineated by `min` and `max`.\r\n   *\r\n   * min {number|string|Decimal}\r\n   * max {number|string|Decimal}\r\n   *\r\n   */\r\n  P.clampedTo = P.clamp = function (min, max) {\r\n    var k,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n    min = new Ctor(min);\r\n    max = new Ctor(max);\r\n    if (!min.s || !max.s) return new Ctor(NaN);\r\n    if (min.gt(max)) throw Error(invalidArgument + max);\r\n    k = x.cmp(min);\r\n    return k < 0 ? min : x.cmp(max) > 0 ? max : new Ctor(x);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return\r\n   *   1    if the value of this Decimal is greater than the value of `y`,\r\n   *  -1    if the value of this Decimal is less than the value of `y`,\r\n   *   0    if they have the same value,\r\n   *   NaN  if the value of either Decimal is NaN.\r\n   *\r\n   */\r\n  P.comparedTo = P.cmp = function (y) {\r\n    var i, j, xdL, ydL,\r\n      x = this,\r\n      xd = x.d,\r\n      yd = (y = new x.constructor(y)).d,\r\n      xs = x.s,\r\n      ys = y.s;\r\n\r\n    // Either NaN or ±Infinity?\r\n    if (!xd || !yd) {\r\n      return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;\r\n    }\r\n\r\n    // Either zero?\r\n    if (!xd[0] || !yd[0]) return xd[0] ? xs : yd[0] ? -ys : 0;\r\n\r\n    // Signs differ?\r\n    if (xs !== ys) return xs;\r\n\r\n    // Compare exponents.\r\n    if (x.e !== y.e) return x.e > y.e ^ xs < 0 ? 1 : -1;\r\n\r\n    xdL = xd.length;\r\n    ydL = yd.length;\r\n\r\n    // Compare digit by digit.\r\n    for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) {\r\n      if (xd[i] !== yd[i]) return xd[i] > yd[i] ^ xs < 0 ? 1 : -1;\r\n    }\r\n\r\n    // Compare lengths.\r\n    return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the cosine of the value in radians of this Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-1, 1]\r\n   *\r\n   * cos(0)         = 1\r\n   * cos(-0)        = 1\r\n   * cos(Infinity)  = NaN\r\n   * cos(-Infinity) = NaN\r\n   * cos(NaN)       = NaN\r\n   *\r\n   */\r\n  P.cosine = P.cos = function () {\r\n    var pr, rm,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (!x.d) return new Ctor(NaN);\r\n\r\n    // cos(0) = cos(-0) = 1\r\n    if (!x.d[0]) return new Ctor(1);\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n    Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;\r\n    Ctor.rounding = 1;\r\n\r\n    x = cosine(Ctor, toLessThanHalfPi(Ctor, x));\r\n\r\n    Ctor.precision = pr;\r\n    Ctor.rounding = rm;\r\n\r\n    return finalise(quadrant == 2 || quadrant == 3 ? x.neg() : x, pr, rm, true);\r\n  };\r\n\r\n\r\n  /*\r\n   *\r\n   * Return a new Decimal whose value is the cube root of the value of this Decimal, rounded to\r\n   * `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   *  cbrt(0)  =  0\r\n   *  cbrt(-0) = -0\r\n   *  cbrt(1)  =  1\r\n   *  cbrt(-1) = -1\r\n   *  cbrt(N)  =  N\r\n   *  cbrt(-I) = -I\r\n   *  cbrt(I)  =  I\r\n   *\r\n   * Math.cbrt(x) = (x < 0 ? -Math.pow(-x, 1/3) : Math.pow(x, 1/3))\r\n   *\r\n   */\r\n  P.cubeRoot = P.cbrt = function () {\r\n    var e, m, n, r, rep, s, sd, t, t3, t3plusx,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (!x.isFinite() || x.isZero()) return new Ctor(x);\r\n    external = false;\r\n\r\n    // Initial estimate.\r\n    s = x.s * mathpow(x.s * x, 1 / 3);\r\n\r\n     // Math.cbrt underflow/overflow?\r\n     // Pass x to Math.pow as integer, then adjust the exponent of the result.\r\n    if (!s || Math.abs(s) == 1 / 0) {\r\n      n = digitsToString(x.d);\r\n      e = x.e;\r\n\r\n      // Adjust n exponent so it is a multiple of 3 away from x exponent.\r\n      if (s = (e - n.length + 1) % 3) n += (s == 1 || s == -2 ? '0' : '00');\r\n      s = mathpow(n, 1 / 3);\r\n\r\n      // Rarely, e may be one less than the result exponent value.\r\n      e = mathfloor((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2));\r\n\r\n      if (s == 1 / 0) {\r\n        n = '5e' + e;\r\n      } else {\r\n        n = s.toExponential();\r\n        n = n.slice(0, n.indexOf('e') + 1) + e;\r\n      }\r\n\r\n      r = new Ctor(n);\r\n      r.s = x.s;\r\n    } else {\r\n      r = new Ctor(s.toString());\r\n    }\r\n\r\n    sd = (e = Ctor.precision) + 3;\r\n\r\n    // Halley's method.\r\n    // TODO? Compare Newton's method.\r\n    for (;;) {\r\n      t = r;\r\n      t3 = t.times(t).times(t);\r\n      t3plusx = t3.plus(x);\r\n      r = divide(t3plusx.plus(x).times(t), t3plusx.plus(t3), sd + 2, 1);\r\n\r\n      // TODO? Replace with for-loop and checkRoundingDigits.\r\n      if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {\r\n        n = n.slice(sd - 3, sd + 1);\r\n\r\n        // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or 4999\r\n        // , i.e. approaching a rounding boundary, continue the iteration.\r\n        if (n == '9999' || !rep && n == '4999') {\r\n\r\n          // On the first iteration only, check to see if rounding up gives the exact result as the\r\n          // nines may infinitely repeat.\r\n          if (!rep) {\r\n            finalise(t, e + 1, 0);\r\n\r\n            if (t.times(t).times(t).eq(x)) {\r\n              r = t;\r\n              break;\r\n            }\r\n          }\r\n\r\n          sd += 4;\r\n          rep = 1;\r\n        } else {\r\n\r\n          // If the rounding digits are null, 0{0,4} or 50{0,3}, check for an exact result.\r\n          // If not, then there are further digits and m will be truthy.\r\n          if (!+n || !+n.slice(1) && n.charAt(0) == '5') {\r\n\r\n            // Truncate to the first rounding digit.\r\n            finalise(r, e + 1, 1);\r\n            m = !r.times(r).times(r).eq(x);\r\n          }\r\n\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    external = true;\r\n\r\n    return finalise(r, e, Ctor.rounding, m);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return the number of decimal places of the value of this Decimal.\r\n   *\r\n   */\r\n  P.decimalPlaces = P.dp = function () {\r\n    var w,\r\n      d = this.d,\r\n      n = NaN;\r\n\r\n    if (d) {\r\n      w = d.length - 1;\r\n      n = (w - mathfloor(this.e / LOG_BASE)) * LOG_BASE;\r\n\r\n      // Subtract the number of trailing zeros of the last word.\r\n      w = d[w];\r\n      if (w) for (; w % 10 == 0; w /= 10) n--;\r\n      if (n < 0) n = 0;\r\n    }\r\n\r\n    return n;\r\n  };\r\n\r\n\r\n  /*\r\n   *  n / 0 = I\r\n   *  n / N = N\r\n   *  n / I = 0\r\n   *  0 / n = 0\r\n   *  0 / 0 = N\r\n   *  0 / N = N\r\n   *  0 / I = 0\r\n   *  N / n = N\r\n   *  N / 0 = N\r\n   *  N / N = N\r\n   *  N / I = N\r\n   *  I / n = I\r\n   *  I / 0 = I\r\n   *  I / N = N\r\n   *  I / I = N\r\n   *\r\n   * Return a new Decimal whose value is the value of this Decimal divided by `y`, rounded to\r\n   * `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   */\r\n  P.dividedBy = P.div = function (y) {\r\n    return divide(this, new this.constructor(y));\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the integer part of dividing the value of this Decimal\r\n   * by the value of `y`, rounded to `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   */\r\n  P.dividedToIntegerBy = P.divToInt = function (y) {\r\n    var x = this,\r\n      Ctor = x.constructor;\r\n    return finalise(divide(x, new Ctor(y), 0, 1, 1), Ctor.precision, Ctor.rounding);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is equal to the value of `y`, otherwise return false.\r\n   *\r\n   */\r\n  P.equals = P.eq = function (y) {\r\n    return this.cmp(y) === 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal rounded to a whole number in the\r\n   * direction of negative Infinity.\r\n   *\r\n   */\r\n  P.floor = function () {\r\n    return finalise(new this.constructor(this), this.e + 1, 3);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is greater than the value of `y`, otherwise return\r\n   * false.\r\n   *\r\n   */\r\n  P.greaterThan = P.gt = function (y) {\r\n    return this.cmp(y) > 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is greater than or equal to the value of `y`,\r\n   * otherwise return false.\r\n   *\r\n   */\r\n  P.greaterThanOrEqualTo = P.gte = function (y) {\r\n    var k = this.cmp(y);\r\n    return k == 1 || k === 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the hyperbolic cosine of the value in radians of this\r\n   * Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [1, Infinity]\r\n   *\r\n   * cosh(x) = 1 + x^2/2! + x^4/4! + x^6/6! + ...\r\n   *\r\n   * cosh(0)         = 1\r\n   * cosh(-0)        = 1\r\n   * cosh(Infinity)  = Infinity\r\n   * cosh(-Infinity) = Infinity\r\n   * cosh(NaN)       = NaN\r\n   *\r\n   *  x        time taken (ms)   result\r\n   * 1000      9                 9.8503555700852349694e+433\r\n   * 10000     25                4.4034091128314607936e+4342\r\n   * 100000    171               1.4033316802130615897e+43429\r\n   * 1000000   3817              1.5166076984010437725e+434294\r\n   * 10000000  abandoned after 2 minute wait\r\n   *\r\n   * TODO? Compare performance of cosh(x) = 0.5 * (exp(x) + exp(-x))\r\n   *\r\n   */\r\n  P.hyperbolicCosine = P.cosh = function () {\r\n    var k, n, pr, rm, len,\r\n      x = this,\r\n      Ctor = x.constructor,\r\n      one = new Ctor(1);\r\n\r\n    if (!x.isFinite()) return new Ctor(x.s ? 1 / 0 : NaN);\r\n    if (x.isZero()) return one;\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n    Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;\r\n    Ctor.rounding = 1;\r\n    len = x.d.length;\r\n\r\n    // Argument reduction: cos(4x) = 1 - 8cos^2(x) + 8cos^4(x) + 1\r\n    // i.e. cos(x) = 1 - cos^2(x/4)(8 - 8cos^2(x/4))\r\n\r\n    // Estimate the optimum number of times to use the argument reduction.\r\n    // TODO? Estimation reused from cosine() and may not be optimal here.\r\n    if (len < 32) {\r\n      k = Math.ceil(len / 3);\r\n      n = (1 / tinyPow(4, k)).toString();\r\n    } else {\r\n      k = 16;\r\n      n = '2.3283064365386962890625e-10';\r\n    }\r\n\r\n    x = taylorSeries(Ctor, 1, x.times(n), new Ctor(1), true);\r\n\r\n    // Reverse argument reduction\r\n    var cosh2_x,\r\n      i = k,\r\n      d8 = new Ctor(8);\r\n    for (; i--;) {\r\n      cosh2_x = x.times(x);\r\n      x = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));\r\n    }\r\n\r\n    return finalise(x, Ctor.precision = pr, Ctor.rounding = rm, true);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the hyperbolic sine of the value in radians of this\r\n   * Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-Infinity, Infinity]\r\n   *\r\n   * sinh(x) = x + x^3/3! + x^5/5! + x^7/7! + ...\r\n   *\r\n   * sinh(0)         = 0\r\n   * sinh(-0)        = -0\r\n   * sinh(Infinity)  = Infinity\r\n   * sinh(-Infinity) = -Infinity\r\n   * sinh(NaN)       = NaN\r\n   *\r\n   * x        time taken (ms)\r\n   * 10       2 ms\r\n   * 100      5 ms\r\n   * 1000     14 ms\r\n   * 10000    82 ms\r\n   * 100000   886 ms            1.4033316802130615897e+43429\r\n   * 200000   2613 ms\r\n   * 300000   5407 ms\r\n   * 400000   8824 ms\r\n   * 500000   13026 ms          8.7080643612718084129e+217146\r\n   * 1000000  48543 ms\r\n   *\r\n   * TODO? Compare performance of sinh(x) = 0.5 * (exp(x) - exp(-x))\r\n   *\r\n   */\r\n  P.hyperbolicSine = P.sinh = function () {\r\n    var k, pr, rm, len,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (!x.isFinite() || x.isZero()) return new Ctor(x);\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n    Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;\r\n    Ctor.rounding = 1;\r\n    len = x.d.length;\r\n\r\n    if (len < 3) {\r\n      x = taylorSeries(Ctor, 2, x, x, true);\r\n    } else {\r\n\r\n      // Alternative argument reduction: sinh(3x) = sinh(x)(3 + 4sinh^2(x))\r\n      // i.e. sinh(x) = sinh(x/3)(3 + 4sinh^2(x/3))\r\n      // 3 multiplications and 1 addition\r\n\r\n      // Argument reduction: sinh(5x) = sinh(x)(5 + sinh^2(x)(20 + 16sinh^2(x)))\r\n      // i.e. sinh(x) = sinh(x/5)(5 + sinh^2(x/5)(20 + 16sinh^2(x/5)))\r\n      // 4 multiplications and 2 additions\r\n\r\n      // Estimate the optimum number of times to use the argument reduction.\r\n      k = 1.4 * Math.sqrt(len);\r\n      k = k > 16 ? 16 : k | 0;\r\n\r\n      x = x.times(1 / tinyPow(5, k));\r\n      x = taylorSeries(Ctor, 2, x, x, true);\r\n\r\n      // Reverse argument reduction\r\n      var sinh2_x,\r\n        d5 = new Ctor(5),\r\n        d16 = new Ctor(16),\r\n        d20 = new Ctor(20);\r\n      for (; k--;) {\r\n        sinh2_x = x.times(x);\r\n        x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));\r\n      }\r\n    }\r\n\r\n    Ctor.precision = pr;\r\n    Ctor.rounding = rm;\r\n\r\n    return finalise(x, pr, rm, true);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the hyperbolic tangent of the value in radians of this\r\n   * Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-1, 1]\r\n   *\r\n   * tanh(x) = sinh(x) / cosh(x)\r\n   *\r\n   * tanh(0)         = 0\r\n   * tanh(-0)        = -0\r\n   * tanh(Infinity)  = 1\r\n   * tanh(-Infinity) = -1\r\n   * tanh(NaN)       = NaN\r\n   *\r\n   */\r\n  P.hyperbolicTangent = P.tanh = function () {\r\n    var pr, rm,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (!x.isFinite()) return new Ctor(x.s);\r\n    if (x.isZero()) return new Ctor(x);\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n    Ctor.precision = pr + 7;\r\n    Ctor.rounding = 1;\r\n\r\n    return divide(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the arccosine (inverse cosine) in radians of the value of\r\n   * this Decimal.\r\n   *\r\n   * Domain: [-1, 1]\r\n   * Range: [0, pi]\r\n   *\r\n   * acos(x) = pi/2 - asin(x)\r\n   *\r\n   * acos(0)       = pi/2\r\n   * acos(-0)      = pi/2\r\n   * acos(1)       = 0\r\n   * acos(-1)      = pi\r\n   * acos(1/2)     = pi/3\r\n   * acos(-1/2)    = 2*pi/3\r\n   * acos(|x| > 1) = NaN\r\n   * acos(NaN)     = NaN\r\n   *\r\n   */\r\n  P.inverseCosine = P.acos = function () {\r\n    var halfPi,\r\n      x = this,\r\n      Ctor = x.constructor,\r\n      k = x.abs().cmp(1),\r\n      pr = Ctor.precision,\r\n      rm = Ctor.rounding;\r\n\r\n    if (k !== -1) {\r\n      return k === 0\r\n        // |x| is 1\r\n        ? x.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0)\r\n        // |x| > 1 or x is NaN\r\n        : new Ctor(NaN);\r\n    }\r\n\r\n    if (x.isZero()) return getPi(Ctor, pr + 4, rm).times(0.5);\r\n\r\n    // TODO? Special case acos(0.5) = pi/3 and acos(-0.5) = 2*pi/3\r\n\r\n    Ctor.precision = pr + 6;\r\n    Ctor.rounding = 1;\r\n\r\n    x = x.asin();\r\n    halfPi = getPi(Ctor, pr + 4, rm).times(0.5);\r\n\r\n    Ctor.precision = pr;\r\n    Ctor.rounding = rm;\r\n\r\n    return halfPi.minus(x);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the inverse of the hyperbolic cosine in radians of the\r\n   * value of this Decimal.\r\n   *\r\n   * Domain: [1, Infinity]\r\n   * Range: [0, Infinity]\r\n   *\r\n   * acosh(x) = ln(x + sqrt(x^2 - 1))\r\n   *\r\n   * acosh(x < 1)     = NaN\r\n   * acosh(NaN)       = NaN\r\n   * acosh(Infinity)  = Infinity\r\n   * acosh(-Infinity) = NaN\r\n   * acosh(0)         = NaN\r\n   * acosh(-0)        = NaN\r\n   * acosh(1)         = 0\r\n   * acosh(-1)        = NaN\r\n   *\r\n   */\r\n  P.inverseHyperbolicCosine = P.acosh = function () {\r\n    var pr, rm,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (x.lte(1)) return new Ctor(x.eq(1) ? 0 : NaN);\r\n    if (!x.isFinite()) return new Ctor(x);\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n    Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;\r\n    Ctor.rounding = 1;\r\n    external = false;\r\n\r\n    x = x.times(x).minus(1).sqrt().plus(x);\r\n\r\n    external = true;\r\n    Ctor.precision = pr;\r\n    Ctor.rounding = rm;\r\n\r\n    return x.ln();\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the inverse of the hyperbolic sine in radians of the value\r\n   * of this Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-Infinity, Infinity]\r\n   *\r\n   * asinh(x) = ln(x + sqrt(x^2 + 1))\r\n   *\r\n   * asinh(NaN)       = NaN\r\n   * asinh(Infinity)  = Infinity\r\n   * asinh(-Infinity) = -Infinity\r\n   * asinh(0)         = 0\r\n   * asinh(-0)        = -0\r\n   *\r\n   */\r\n  P.inverseHyperbolicSine = P.asinh = function () {\r\n    var pr, rm,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (!x.isFinite() || x.isZero()) return new Ctor(x);\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n    Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6;\r\n    Ctor.rounding = 1;\r\n    external = false;\r\n\r\n    x = x.times(x).plus(1).sqrt().plus(x);\r\n\r\n    external = true;\r\n    Ctor.precision = pr;\r\n    Ctor.rounding = rm;\r\n\r\n    return x.ln();\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the inverse of the hyperbolic tangent in radians of the\r\n   * value of this Decimal.\r\n   *\r\n   * Domain: [-1, 1]\r\n   * Range: [-Infinity, Infinity]\r\n   *\r\n   * atanh(x) = 0.5 * ln((1 + x) / (1 - x))\r\n   *\r\n   * atanh(|x| > 1)   = NaN\r\n   * atanh(NaN)       = NaN\r\n   * atanh(Infinity)  = NaN\r\n   * atanh(-Infinity) = NaN\r\n   * atanh(0)         = 0\r\n   * atanh(-0)        = -0\r\n   * atanh(1)         = Infinity\r\n   * atanh(-1)        = -Infinity\r\n   *\r\n   */\r\n  P.inverseHyperbolicTangent = P.atanh = function () {\r\n    var pr, rm, wpr, xsd,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (!x.isFinite()) return new Ctor(NaN);\r\n    if (x.e >= 0) return new Ctor(x.abs().eq(1) ? x.s / 0 : x.isZero() ? x : NaN);\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n    xsd = x.sd();\r\n\r\n    if (Math.max(xsd, pr) < 2 * -x.e - 1) return finalise(new Ctor(x), pr, rm, true);\r\n\r\n    Ctor.precision = wpr = xsd - x.e;\r\n\r\n    x = divide(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1);\r\n\r\n    Ctor.precision = pr + 4;\r\n    Ctor.rounding = 1;\r\n\r\n    x = x.ln();\r\n\r\n    Ctor.precision = pr;\r\n    Ctor.rounding = rm;\r\n\r\n    return x.times(0.5);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the arcsine (inverse sine) in radians of the value of this\r\n   * Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-pi/2, pi/2]\r\n   *\r\n   * asin(x) = 2*atan(x/(1 + sqrt(1 - x^2)))\r\n   *\r\n   * asin(0)       = 0\r\n   * asin(-0)      = -0\r\n   * asin(1/2)     = pi/6\r\n   * asin(-1/2)    = -pi/6\r\n   * asin(1)       = pi/2\r\n   * asin(-1)      = -pi/2\r\n   * asin(|x| > 1) = NaN\r\n   * asin(NaN)     = NaN\r\n   *\r\n   * TODO? Compare performance of Taylor series.\r\n   *\r\n   */\r\n  P.inverseSine = P.asin = function () {\r\n    var halfPi, k,\r\n      pr, rm,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (x.isZero()) return new Ctor(x);\r\n\r\n    k = x.abs().cmp(1);\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n\r\n    if (k !== -1) {\r\n\r\n      // |x| is 1\r\n      if (k === 0) {\r\n        halfPi = getPi(Ctor, pr + 4, rm).times(0.5);\r\n        halfPi.s = x.s;\r\n        return halfPi;\r\n      }\r\n\r\n      // |x| > 1 or x is NaN\r\n      return new Ctor(NaN);\r\n    }\r\n\r\n    // TODO? Special case asin(1/2) = pi/6 and asin(-1/2) = -pi/6\r\n\r\n    Ctor.precision = pr + 6;\r\n    Ctor.rounding = 1;\r\n\r\n    x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan();\r\n\r\n    Ctor.precision = pr;\r\n    Ctor.rounding = rm;\r\n\r\n    return x.times(2);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the arctangent (inverse tangent) in radians of the value\r\n   * of this Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-pi/2, pi/2]\r\n   *\r\n   * atan(x) = x - x^3/3 + x^5/5 - x^7/7 + ...\r\n   *\r\n   * atan(0)         = 0\r\n   * atan(-0)        = -0\r\n   * atan(1)         = pi/4\r\n   * atan(-1)        = -pi/4\r\n   * atan(Infinity)  = pi/2\r\n   * atan(-Infinity) = -pi/2\r\n   * atan(NaN)       = NaN\r\n   *\r\n   */\r\n  P.inverseTangent = P.atan = function () {\r\n    var i, j, k, n, px, t, r, wpr, x2,\r\n      x = this,\r\n      Ctor = x.constructor,\r\n      pr = Ctor.precision,\r\n      rm = Ctor.rounding;\r\n\r\n    if (!x.isFinite()) {\r\n      if (!x.s) return new Ctor(NaN);\r\n      if (pr + 4 <= PI_PRECISION) {\r\n        r = getPi(Ctor, pr + 4, rm).times(0.5);\r\n        r.s = x.s;\r\n        return r;\r\n      }\r\n    } else if (x.isZero()) {\r\n      return new Ctor(x);\r\n    } else if (x.abs().eq(1) && pr + 4 <= PI_PRECISION) {\r\n      r = getPi(Ctor, pr + 4, rm).times(0.25);\r\n      r.s = x.s;\r\n      return r;\r\n    }\r\n\r\n    Ctor.precision = wpr = pr + 10;\r\n    Ctor.rounding = 1;\r\n\r\n    // TODO? if (x >= 1 && pr <= PI_PRECISION) atan(x) = halfPi * x.s - atan(1 / x);\r\n\r\n    // Argument reduction\r\n    // Ensure |x| < 0.42\r\n    // atan(x) = 2 * atan(x / (1 + sqrt(1 + x^2)))\r\n\r\n    k = Math.min(28, wpr / LOG_BASE + 2 | 0);\r\n\r\n    for (i = k; i; --i) x = x.div(x.times(x).plus(1).sqrt().plus(1));\r\n\r\n    external = false;\r\n\r\n    j = Math.ceil(wpr / LOG_BASE);\r\n    n = 1;\r\n    x2 = x.times(x);\r\n    r = new Ctor(x);\r\n    px = x;\r\n\r\n    // atan(x) = x - x^3/3 + x^5/5 - x^7/7 + ...\r\n    for (; i !== -1;) {\r\n      px = px.times(x2);\r\n      t = r.minus(px.div(n += 2));\r\n\r\n      px = px.times(x2);\r\n      r = t.plus(px.div(n += 2));\r\n\r\n      if (r.d[j] !== void 0) for (i = j; r.d[i] === t.d[i] && i--;);\r\n    }\r\n\r\n    if (k) r = r.times(2 << (k - 1));\r\n\r\n    external = true;\r\n\r\n    return finalise(r, Ctor.precision = pr, Ctor.rounding = rm, true);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is a finite number, otherwise return false.\r\n   *\r\n   */\r\n  P.isFinite = function () {\r\n    return !!this.d;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is an integer, otherwise return false.\r\n   *\r\n   */\r\n  P.isInteger = P.isInt = function () {\r\n    return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is NaN, otherwise return false.\r\n   *\r\n   */\r\n  P.isNaN = function () {\r\n    return !this.s;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is negative, otherwise return false.\r\n   *\r\n   */\r\n  P.isNegative = P.isNeg = function () {\r\n    return this.s < 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is positive, otherwise return false.\r\n   *\r\n   */\r\n  P.isPositive = P.isPos = function () {\r\n    return this.s > 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is 0 or -0, otherwise return false.\r\n   *\r\n   */\r\n  P.isZero = function () {\r\n    return !!this.d && this.d[0] === 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is less than `y`, otherwise return false.\r\n   *\r\n   */\r\n  P.lessThan = P.lt = function (y) {\r\n    return this.cmp(y) < 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is less than or equal to `y`, otherwise return false.\r\n   *\r\n   */\r\n  P.lessThanOrEqualTo = P.lte = function (y) {\r\n    return this.cmp(y) < 1;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return the logarithm of the value of this Decimal to the specified base, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * If no base is specified, return log[10](arg).\r\n   *\r\n   * log[base](arg) = ln(arg) / ln(base)\r\n   *\r\n   * The result will always be correctly rounded if the base of the log is 10, and 'almost always'\r\n   * otherwise:\r\n   *\r\n   * Depending on the rounding mode, the result may be incorrectly rounded if the first fifteen\r\n   * rounding digits are [49]99999999999999 or [50]00000000000000. In that case, the maximum error\r\n   * between the result and the correctly rounded result will be one ulp (unit in the last place).\r\n   *\r\n   * log[-b](a)       = NaN\r\n   * log[0](a)        = NaN\r\n   * log[1](a)        = NaN\r\n   * log[NaN](a)      = NaN\r\n   * log[Infinity](a) = NaN\r\n   * log[b](0)        = -Infinity\r\n   * log[b](-0)       = -Infinity\r\n   * log[b](-a)       = NaN\r\n   * log[b](1)        = 0\r\n   * log[b](Infinity) = Infinity\r\n   * log[b](NaN)      = NaN\r\n   *\r\n   * [base] {number|string|Decimal} The base of the logarithm.\r\n   *\r\n   */\r\n  P.logarithm = P.log = function (base) {\r\n    var isBase10, d, denominator, k, inf, num, sd, r,\r\n      arg = this,\r\n      Ctor = arg.constructor,\r\n      pr = Ctor.precision,\r\n      rm = Ctor.rounding,\r\n      guard = 5;\r\n\r\n    // Default base is 10.\r\n    if (base == null) {\r\n      base = new Ctor(10);\r\n      isBase10 = true;\r\n    } else {\r\n      base = new Ctor(base);\r\n      d = base.d;\r\n\r\n      // Return NaN if base is negative, or non-finite, or is 0 or 1.\r\n      if (base.s < 0 || !d || !d[0] || base.eq(1)) return new Ctor(NaN);\r\n\r\n      isBase10 = base.eq(10);\r\n    }\r\n\r\n    d = arg.d;\r\n\r\n    // Is arg negative, non-finite, 0 or 1?\r\n    if (arg.s < 0 || !d || !d[0] || arg.eq(1)) {\r\n      return new Ctor(d && !d[0] ? -1 / 0 : arg.s != 1 ? NaN : d ? 0 : 1 / 0);\r\n    }\r\n\r\n    // The result will have a non-terminating decimal expansion if base is 10 and arg is not an\r\n    // integer power of 10.\r\n    if (isBase10) {\r\n      if (d.length > 1) {\r\n        inf = true;\r\n      } else {\r\n        for (k = d[0]; k % 10 === 0;) k /= 10;\r\n        inf = k !== 1;\r\n      }\r\n    }\r\n\r\n    external = false;\r\n    sd = pr + guard;\r\n    num = naturalLogarithm(arg, sd);\r\n    denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);\r\n\r\n    // The result will have 5 rounding digits.\r\n    r = divide(num, denominator, sd, 1);\r\n\r\n    // If at a rounding boundary, i.e. the result's rounding digits are [49]9999 or [50]0000,\r\n    // calculate 10 further digits.\r\n    //\r\n    // If the result is known to have an infinite decimal expansion, repeat this until it is clear\r\n    // that the result is above or below the boundary. Otherwise, if after calculating the 10\r\n    // further digits, the last 14 are nines, round up and assume the result is exact.\r\n    // Also assume the result is exact if the last 14 are zero.\r\n    //\r\n    // Example of a result that will be incorrectly rounded:\r\n    // log[1048576](4503599627370502) = 2.60000000000000009610279511444746...\r\n    // The above result correctly rounded using ROUND_CEIL to 1 decimal place should be 2.7, but it\r\n    // will be given as 2.6 as there are 15 zeros immediately after the requested decimal place, so\r\n    // the exact result would be assumed to be 2.6, which rounded using ROUND_CEIL to 1 decimal\r\n    // place is still 2.6.\r\n    if (checkRoundingDigits(r.d, k = pr, rm)) {\r\n\r\n      do {\r\n        sd += 10;\r\n        num = naturalLogarithm(arg, sd);\r\n        denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);\r\n        r = divide(num, denominator, sd, 1);\r\n\r\n        if (!inf) {\r\n\r\n          // Check for 14 nines from the 2nd rounding digit, as the first may be 4.\r\n          if (+digitsToString(r.d).slice(k + 1, k + 15) + 1 == 1e14) {\r\n            r = finalise(r, pr + 1, 0);\r\n          }\r\n\r\n          break;\r\n        }\r\n      } while (checkRoundingDigits(r.d, k += 10, rm));\r\n    }\r\n\r\n    external = true;\r\n\r\n    return finalise(r, pr, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the maximum of the arguments and the value of this Decimal.\r\n   *\r\n   * arguments {number|string|Decimal}\r\n   *\r\n  P.max = function () {\r\n    Array.prototype.push.call(arguments, this);\r\n    return maxOrMin(this.constructor, arguments, 'lt');\r\n  };\r\n   */\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the minimum of the arguments and the value of this Decimal.\r\n   *\r\n   * arguments {number|string|Decimal}\r\n   *\r\n  P.min = function () {\r\n    Array.prototype.push.call(arguments, this);\r\n    return maxOrMin(this.constructor, arguments, 'gt');\r\n  };\r\n   */\r\n\r\n\r\n  /*\r\n   *  n - 0 = n\r\n   *  n - N = N\r\n   *  n - I = -I\r\n   *  0 - n = -n\r\n   *  0 - 0 = 0\r\n   *  0 - N = N\r\n   *  0 - I = -I\r\n   *  N - n = N\r\n   *  N - 0 = N\r\n   *  N - N = N\r\n   *  N - I = N\r\n   *  I - n = I\r\n   *  I - 0 = I\r\n   *  I - N = N\r\n   *  I - I = N\r\n   *\r\n   * Return a new Decimal whose value is the value of this Decimal minus `y`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   */\r\n  P.minus = P.sub = function (y) {\r\n    var d, e, i, j, k, len, pr, rm, xd, xe, xLTy, yd,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    y = new Ctor(y);\r\n\r\n    // If either is not finite...\r\n    if (!x.d || !y.d) {\r\n\r\n      // Return NaN if either is NaN.\r\n      if (!x.s || !y.s) y = new Ctor(NaN);\r\n\r\n      // Return y negated if x is finite and y is ±Infinity.\r\n      else if (x.d) y.s = -y.s;\r\n\r\n      // Return x if y is finite and x is ±Infinity.\r\n      // Return x if both are ±Infinity with different signs.\r\n      // Return NaN if both are ±Infinity with the same sign.\r\n      else y = new Ctor(y.d || x.s !== y.s ? x : NaN);\r\n\r\n      return y;\r\n    }\r\n\r\n    // If signs differ...\r\n    if (x.s != y.s) {\r\n      y.s = -y.s;\r\n      return x.plus(y);\r\n    }\r\n\r\n    xd = x.d;\r\n    yd = y.d;\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n\r\n    // If either is zero...\r\n    if (!xd[0] || !yd[0]) {\r\n\r\n      // Return y negated if x is zero and y is non-zero.\r\n      if (yd[0]) y.s = -y.s;\r\n\r\n      // Return x if y is zero and x is non-zero.\r\n      else if (xd[0]) y = new Ctor(x);\r\n\r\n      // Return zero if both are zero.\r\n      // From IEEE 754 (2008) 6.3: 0 - 0 = -0 - -0 = -0 when rounding to -Infinity.\r\n      else return new Ctor(rm === 3 ? -0 : 0);\r\n\r\n      return external ? finalise(y, pr, rm) : y;\r\n    }\r\n\r\n    // x and y are finite, non-zero numbers with the same sign.\r\n\r\n    // Calculate base 1e7 exponents.\r\n    e = mathfloor(y.e / LOG_BASE);\r\n    xe = mathfloor(x.e / LOG_BASE);\r\n\r\n    xd = xd.slice();\r\n    k = xe - e;\r\n\r\n    // If base 1e7 exponents differ...\r\n    if (k) {\r\n      xLTy = k < 0;\r\n\r\n      if (xLTy) {\r\n        d = xd;\r\n        k = -k;\r\n        len = yd.length;\r\n      } else {\r\n        d = yd;\r\n        e = xe;\r\n        len = xd.length;\r\n      }\r\n\r\n      // Numbers with massively different exponents would result in a very high number of\r\n      // zeros needing to be prepended, but this can be avoided while still ensuring correct\r\n      // rounding by limiting the number of zeros to `Math.ceil(pr / LOG_BASE) + 2`.\r\n      i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;\r\n\r\n      if (k > i) {\r\n        k = i;\r\n        d.length = 1;\r\n      }\r\n\r\n      // Prepend zeros to equalise exponents.\r\n      d.reverse();\r\n      for (i = k; i--;) d.push(0);\r\n      d.reverse();\r\n\r\n    // Base 1e7 exponents equal.\r\n    } else {\r\n\r\n      // Check digits to determine which is the bigger number.\r\n\r\n      i = xd.length;\r\n      len = yd.length;\r\n      xLTy = i < len;\r\n      if (xLTy) len = i;\r\n\r\n      for (i = 0; i < len; i++) {\r\n        if (xd[i] != yd[i]) {\r\n          xLTy = xd[i] < yd[i];\r\n          break;\r\n        }\r\n      }\r\n\r\n      k = 0;\r\n    }\r\n\r\n    if (xLTy) {\r\n      d = xd;\r\n      xd = yd;\r\n      yd = d;\r\n      y.s = -y.s;\r\n    }\r\n\r\n    len = xd.length;\r\n\r\n    // Append zeros to `xd` if shorter.\r\n    // Don't add zeros to `yd` if shorter as subtraction only needs to start at `yd` length.\r\n    for (i = yd.length - len; i > 0; --i) xd[len++] = 0;\r\n\r\n    // Subtract yd from xd.\r\n    for (i = yd.length; i > k;) {\r\n\r\n      if (xd[--i] < yd[i]) {\r\n        for (j = i; j && xd[--j] === 0;) xd[j] = BASE - 1;\r\n        --xd[j];\r\n        xd[i] += BASE;\r\n      }\r\n\r\n      xd[i] -= yd[i];\r\n    }\r\n\r\n    // Remove trailing zeros.\r\n    for (; xd[--len] === 0;) xd.pop();\r\n\r\n    // Remove leading zeros and adjust exponent accordingly.\r\n    for (; xd[0] === 0; xd.shift()) --e;\r\n\r\n    // Zero?\r\n    if (!xd[0]) return new Ctor(rm === 3 ? -0 : 0);\r\n\r\n    y.d = xd;\r\n    y.e = getBase10Exponent(xd, e);\r\n\r\n    return external ? finalise(y, pr, rm) : y;\r\n  };\r\n\r\n\r\n  /*\r\n   *   n % 0 =  N\r\n   *   n % N =  N\r\n   *   n % I =  n\r\n   *   0 % n =  0\r\n   *  -0 % n = -0\r\n   *   0 % 0 =  N\r\n   *   0 % N =  N\r\n   *   0 % I =  0\r\n   *   N % n =  N\r\n   *   N % 0 =  N\r\n   *   N % N =  N\r\n   *   N % I =  N\r\n   *   I % n =  N\r\n   *   I % 0 =  N\r\n   *   I % N =  N\r\n   *   I % I =  N\r\n   *\r\n   * Return a new Decimal whose value is the value of this Decimal modulo `y`, rounded to\r\n   * `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * The result depends on the modulo mode.\r\n   *\r\n   */\r\n  P.modulo = P.mod = function (y) {\r\n    var q,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    y = new Ctor(y);\r\n\r\n    // Return NaN if x is ±Infinity or NaN, or y is NaN or ±0.\r\n    if (!x.d || !y.s || y.d && !y.d[0]) return new Ctor(NaN);\r\n\r\n    // Return x if y is ±Infinity or x is ±0.\r\n    if (!y.d || x.d && !x.d[0]) {\r\n      return finalise(new Ctor(x), Ctor.precision, Ctor.rounding);\r\n    }\r\n\r\n    // Prevent rounding of intermediate calculations.\r\n    external = false;\r\n\r\n    if (Ctor.modulo == 9) {\r\n\r\n      // Euclidian division: q = sign(y) * floor(x / abs(y))\r\n      // result = x - q * y    where  0 <= result < abs(y)\r\n      q = divide(x, y.abs(), 0, 3, 1);\r\n      q.s *= y.s;\r\n    } else {\r\n      q = divide(x, y, 0, Ctor.modulo, 1);\r\n    }\r\n\r\n    q = q.times(y);\r\n\r\n    external = true;\r\n\r\n    return x.minus(q);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the natural exponential of the value of this Decimal,\r\n   * i.e. the base e raised to the power the value of this Decimal, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   */\r\n  P.naturalExponential = P.exp = function () {\r\n    return naturalExponential(this);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the natural logarithm of the value of this Decimal,\r\n   * rounded to `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   */\r\n  P.naturalLogarithm = P.ln = function () {\r\n    return naturalLogarithm(this);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal negated, i.e. as if multiplied by\r\n   * -1.\r\n   *\r\n   */\r\n  P.negated = P.neg = function () {\r\n    var x = new this.constructor(this);\r\n    x.s = -x.s;\r\n    return finalise(x);\r\n  };\r\n\r\n\r\n  /*\r\n   *  n + 0 = n\r\n   *  n + N = N\r\n   *  n + I = I\r\n   *  0 + n = n\r\n   *  0 + 0 = 0\r\n   *  0 + N = N\r\n   *  0 + I = I\r\n   *  N + n = N\r\n   *  N + 0 = N\r\n   *  N + N = N\r\n   *  N + I = N\r\n   *  I + n = I\r\n   *  I + 0 = I\r\n   *  I + N = N\r\n   *  I + I = I\r\n   *\r\n   * Return a new Decimal whose value is the value of this Decimal plus `y`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   */\r\n  P.plus = P.add = function (y) {\r\n    var carry, d, e, i, k, len, pr, rm, xd, yd,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    y = new Ctor(y);\r\n\r\n    // If either is not finite...\r\n    if (!x.d || !y.d) {\r\n\r\n      // Return NaN if either is NaN.\r\n      if (!x.s || !y.s) y = new Ctor(NaN);\r\n\r\n      // Return x if y is finite and x is ±Infinity.\r\n      // Return x if both are ±Infinity with the same sign.\r\n      // Return NaN if both are ±Infinity with different signs.\r\n      // Return y if x is finite and y is ±Infinity.\r\n      else if (!x.d) y = new Ctor(y.d || x.s === y.s ? x : NaN);\r\n\r\n      return y;\r\n    }\r\n\r\n     // If signs differ...\r\n    if (x.s != y.s) {\r\n      y.s = -y.s;\r\n      return x.minus(y);\r\n    }\r\n\r\n    xd = x.d;\r\n    yd = y.d;\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n\r\n    // If either is zero...\r\n    if (!xd[0] || !yd[0]) {\r\n\r\n      // Return x if y is zero.\r\n      // Return y if y is non-zero.\r\n      if (!yd[0]) y = new Ctor(x);\r\n\r\n      return external ? finalise(y, pr, rm) : y;\r\n    }\r\n\r\n    // x and y are finite, non-zero numbers with the same sign.\r\n\r\n    // Calculate base 1e7 exponents.\r\n    k = mathfloor(x.e / LOG_BASE);\r\n    e = mathfloor(y.e / LOG_BASE);\r\n\r\n    xd = xd.slice();\r\n    i = k - e;\r\n\r\n    // If base 1e7 exponents differ...\r\n    if (i) {\r\n\r\n      if (i < 0) {\r\n        d = xd;\r\n        i = -i;\r\n        len = yd.length;\r\n      } else {\r\n        d = yd;\r\n        e = k;\r\n        len = xd.length;\r\n      }\r\n\r\n      // Limit number of zeros prepended to max(ceil(pr / LOG_BASE), len) + 1.\r\n      k = Math.ceil(pr / LOG_BASE);\r\n      len = k > len ? k + 1 : len + 1;\r\n\r\n      if (i > len) {\r\n        i = len;\r\n        d.length = 1;\r\n      }\r\n\r\n      // Prepend zeros to equalise exponents. Note: Faster to use reverse then do unshifts.\r\n      d.reverse();\r\n      for (; i--;) d.push(0);\r\n      d.reverse();\r\n    }\r\n\r\n    len = xd.length;\r\n    i = yd.length;\r\n\r\n    // If yd is longer than xd, swap xd and yd so xd points to the longer array.\r\n    if (len - i < 0) {\r\n      i = len;\r\n      d = yd;\r\n      yd = xd;\r\n      xd = d;\r\n    }\r\n\r\n    // Only start adding at yd.length - 1 as the further digits of xd can be left as they are.\r\n    for (carry = 0; i;) {\r\n      carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;\r\n      xd[i] %= BASE;\r\n    }\r\n\r\n    if (carry) {\r\n      xd.unshift(carry);\r\n      ++e;\r\n    }\r\n\r\n    // Remove trailing zeros.\r\n    // No need to check for zero, as +x + +y != 0 && -x + -y != 0\r\n    for (len = xd.length; xd[--len] == 0;) xd.pop();\r\n\r\n    y.d = xd;\r\n    y.e = getBase10Exponent(xd, e);\r\n\r\n    return external ? finalise(y, pr, rm) : y;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return the number of significant digits of the value of this Decimal.\r\n   *\r\n   * [z] {boolean|number} Whether to count integer-part trailing zeros: true, false, 1 or 0.\r\n   *\r\n   */\r\n  P.precision = P.sd = function (z) {\r\n    var k,\r\n      x = this;\r\n\r\n    if (z !== void 0 && z !== !!z && z !== 1 && z !== 0) throw Error(invalidArgument + z);\r\n\r\n    if (x.d) {\r\n      k = getPrecision(x.d);\r\n      if (z && x.e + 1 > k) k = x.e + 1;\r\n    } else {\r\n      k = NaN;\r\n    }\r\n\r\n    return k;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal rounded to a whole number using\r\n   * rounding mode `rounding`.\r\n   *\r\n   */\r\n  P.round = function () {\r\n    var x = this,\r\n      Ctor = x.constructor;\r\n\r\n    return finalise(new Ctor(x), x.e + 1, Ctor.rounding);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the sine of the value in radians of this Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-1, 1]\r\n   *\r\n   * sin(x) = x - x^3/3! + x^5/5! - ...\r\n   *\r\n   * sin(0)         = 0\r\n   * sin(-0)        = -0\r\n   * sin(Infinity)  = NaN\r\n   * sin(-Infinity) = NaN\r\n   * sin(NaN)       = NaN\r\n   *\r\n   */\r\n  P.sine = P.sin = function () {\r\n    var pr, rm,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (!x.isFinite()) return new Ctor(NaN);\r\n    if (x.isZero()) return new Ctor(x);\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n    Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;\r\n    Ctor.rounding = 1;\r\n\r\n    x = sine(Ctor, toLessThanHalfPi(Ctor, x));\r\n\r\n    Ctor.precision = pr;\r\n    Ctor.rounding = rm;\r\n\r\n    return finalise(quadrant > 2 ? x.neg() : x, pr, rm, true);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the square root of this Decimal, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   *  sqrt(-n) =  N\r\n   *  sqrt(N)  =  N\r\n   *  sqrt(-I) =  N\r\n   *  sqrt(I)  =  I\r\n   *  sqrt(0)  =  0\r\n   *  sqrt(-0) = -0\r\n   *\r\n   */\r\n  P.squareRoot = P.sqrt = function () {\r\n    var m, n, sd, r, rep, t,\r\n      x = this,\r\n      d = x.d,\r\n      e = x.e,\r\n      s = x.s,\r\n      Ctor = x.constructor;\r\n\r\n    // Negative/NaN/Infinity/zero?\r\n    if (s !== 1 || !d || !d[0]) {\r\n      return new Ctor(!s || s < 0 && (!d || d[0]) ? NaN : d ? x : 1 / 0);\r\n    }\r\n\r\n    external = false;\r\n\r\n    // Initial estimate.\r\n    s = Math.sqrt(+x);\r\n\r\n    // Math.sqrt underflow/overflow?\r\n    // Pass x to Math.sqrt as integer, then adjust the exponent of the result.\r\n    if (s == 0 || s == 1 / 0) {\r\n      n = digitsToString(d);\r\n\r\n      if ((n.length + e) % 2 == 0) n += '0';\r\n      s = Math.sqrt(n);\r\n      e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);\r\n\r\n      if (s == 1 / 0) {\r\n        n = '5e' + e;\r\n      } else {\r\n        n = s.toExponential();\r\n        n = n.slice(0, n.indexOf('e') + 1) + e;\r\n      }\r\n\r\n      r = new Ctor(n);\r\n    } else {\r\n      r = new Ctor(s.toString());\r\n    }\r\n\r\n    sd = (e = Ctor.precision) + 3;\r\n\r\n    // Newton-Raphson iteration.\r\n    for (;;) {\r\n      t = r;\r\n      r = t.plus(divide(x, t, sd + 2, 1)).times(0.5);\r\n\r\n      // TODO? Replace with for-loop and checkRoundingDigits.\r\n      if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {\r\n        n = n.slice(sd - 3, sd + 1);\r\n\r\n        // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or\r\n        // 4999, i.e. approaching a rounding boundary, continue the iteration.\r\n        if (n == '9999' || !rep && n == '4999') {\r\n\r\n          // On the first iteration only, check to see if rounding up gives the exact result as the\r\n          // nines may infinitely repeat.\r\n          if (!rep) {\r\n            finalise(t, e + 1, 0);\r\n\r\n            if (t.times(t).eq(x)) {\r\n              r = t;\r\n              break;\r\n            }\r\n          }\r\n\r\n          sd += 4;\r\n          rep = 1;\r\n        } else {\r\n\r\n          // If the rounding digits are null, 0{0,4} or 50{0,3}, check for an exact result.\r\n          // If not, then there are further digits and m will be truthy.\r\n          if (!+n || !+n.slice(1) && n.charAt(0) == '5') {\r\n\r\n            // Truncate to the first rounding digit.\r\n            finalise(r, e + 1, 1);\r\n            m = !r.times(r).eq(x);\r\n          }\r\n\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    external = true;\r\n\r\n    return finalise(r, e, Ctor.rounding, m);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the tangent of the value in radians of this Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-Infinity, Infinity]\r\n   *\r\n   * tan(0)         = 0\r\n   * tan(-0)        = -0\r\n   * tan(Infinity)  = NaN\r\n   * tan(-Infinity) = NaN\r\n   * tan(NaN)       = NaN\r\n   *\r\n   */\r\n  P.tangent = P.tan = function () {\r\n    var pr, rm,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (!x.isFinite()) return new Ctor(NaN);\r\n    if (x.isZero()) return new Ctor(x);\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n    Ctor.precision = pr + 10;\r\n    Ctor.rounding = 1;\r\n\r\n    x = x.sin();\r\n    x.s = 1;\r\n    x = divide(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);\r\n\r\n    Ctor.precision = pr;\r\n    Ctor.rounding = rm;\r\n\r\n    return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);\r\n  };\r\n\r\n\r\n  /*\r\n   *  n * 0 = 0\r\n   *  n * N = N\r\n   *  n * I = I\r\n   *  0 * n = 0\r\n   *  0 * 0 = 0\r\n   *  0 * N = N\r\n   *  0 * I = N\r\n   *  N * n = N\r\n   *  N * 0 = N\r\n   *  N * N = N\r\n   *  N * I = N\r\n   *  I * n = I\r\n   *  I * 0 = N\r\n   *  I * N = N\r\n   *  I * I = I\r\n   *\r\n   * Return a new Decimal whose value is this Decimal times `y`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   */\r\n  P.times = P.mul = function (y) {\r\n    var carry, e, i, k, r, rL, t, xdL, ydL,\r\n      x = this,\r\n      Ctor = x.constructor,\r\n      xd = x.d,\r\n      yd = (y = new Ctor(y)).d;\r\n\r\n    y.s *= x.s;\r\n\r\n     // If either is NaN, ±Infinity or ±0...\r\n    if (!xd || !xd[0] || !yd || !yd[0]) {\r\n\r\n      return new Ctor(!y.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd\r\n\r\n        // Return NaN if either is NaN.\r\n        // Return NaN if x is ±0 and y is ±Infinity, or y is ±0 and x is ±Infinity.\r\n        ? NaN\r\n\r\n        // Return ±Infinity if either is ±Infinity.\r\n        // Return ±0 if either is ±0.\r\n        : !xd || !yd ? y.s / 0 : y.s * 0);\r\n    }\r\n\r\n    e = mathfloor(x.e / LOG_BASE) + mathfloor(y.e / LOG_BASE);\r\n    xdL = xd.length;\r\n    ydL = yd.length;\r\n\r\n    // Ensure xd points to the longer array.\r\n    if (xdL < ydL) {\r\n      r = xd;\r\n      xd = yd;\r\n      yd = r;\r\n      rL = xdL;\r\n      xdL = ydL;\r\n      ydL = rL;\r\n    }\r\n\r\n    // Initialise the result array with zeros.\r\n    r = [];\r\n    rL = xdL + ydL;\r\n    for (i = rL; i--;) r.push(0);\r\n\r\n    // Multiply!\r\n    for (i = ydL; --i >= 0;) {\r\n      carry = 0;\r\n      for (k = xdL + i; k > i;) {\r\n        t = r[k] + yd[i] * xd[k - i - 1] + carry;\r\n        r[k--] = t % BASE | 0;\r\n        carry = t / BASE | 0;\r\n      }\r\n\r\n      r[k] = (r[k] + carry) % BASE | 0;\r\n    }\r\n\r\n    // Remove trailing zeros.\r\n    for (; !r[--rL];) r.pop();\r\n\r\n    if (carry) ++e;\r\n    else r.shift();\r\n\r\n    y.d = r;\r\n    y.e = getBase10Exponent(r, e);\r\n\r\n    return external ? finalise(y, Ctor.precision, Ctor.rounding) : y;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Decimal in base 2, round to `sd` significant\r\n   * digits using rounding mode `rm`.\r\n   *\r\n   * If the optional `sd` argument is present then return binary exponential notation.\r\n   *\r\n   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   */\r\n  P.toBinary = function (sd, rm) {\r\n    return toStringBinary(this, 2, sd, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `dp`\r\n   * decimal places using rounding mode `rm` or `rounding` if `rm` is omitted.\r\n   *\r\n   * If `dp` is omitted, return a new Decimal whose value is the value of this Decimal.\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   */\r\n  P.toDecimalPlaces = P.toDP = function (dp, rm) {\r\n    var x = this,\r\n      Ctor = x.constructor;\r\n\r\n    x = new Ctor(x);\r\n    if (dp === void 0) return x;\r\n\r\n    checkInt32(dp, 0, MAX_DIGITS);\r\n\r\n    if (rm === void 0) rm = Ctor.rounding;\r\n    else checkInt32(rm, 0, 8);\r\n\r\n    return finalise(x, dp + x.e + 1, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Decimal in exponential notation rounded to\r\n   * `dp` fixed decimal places using rounding mode `rounding`.\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   */\r\n  P.toExponential = function (dp, rm) {\r\n    var str,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (dp === void 0) {\r\n      str = finiteToString(x, true);\r\n    } else {\r\n      checkInt32(dp, 0, MAX_DIGITS);\r\n\r\n      if (rm === void 0) rm = Ctor.rounding;\r\n      else checkInt32(rm, 0, 8);\r\n\r\n      x = finalise(new Ctor(x), dp + 1, rm);\r\n      str = finiteToString(x, true, dp + 1);\r\n    }\r\n\r\n    return x.isNeg() && !x.isZero() ? '-' + str : str;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Decimal in normal (fixed-point) notation to\r\n   * `dp` fixed decimal places and rounded using rounding mode `rm` or `rounding` if `rm` is\r\n   * omitted.\r\n   *\r\n   * As with JavaScript numbers, (-0).toFixed(0) is '0', but e.g. (-0.00001).toFixed(0) is '-0'.\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * (-0).toFixed(0) is '0', but (-0.1).toFixed(0) is '-0'.\r\n   * (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.\r\n   * (-0).toFixed(3) is '0.000'.\r\n   * (-0.5).toFixed(0) is '-0'.\r\n   *\r\n   */\r\n  P.toFixed = function (dp, rm) {\r\n    var str, y,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (dp === void 0) {\r\n      str = finiteToString(x);\r\n    } else {\r\n      checkInt32(dp, 0, MAX_DIGITS);\r\n\r\n      if (rm === void 0) rm = Ctor.rounding;\r\n      else checkInt32(rm, 0, 8);\r\n\r\n      y = finalise(new Ctor(x), dp + x.e + 1, rm);\r\n      str = finiteToString(y, false, dp + y.e + 1);\r\n    }\r\n\r\n    // To determine whether to add the minus sign look at the value before it was rounded,\r\n    // i.e. look at `x` rather than `y`.\r\n    return x.isNeg() && !x.isZero() ? '-' + str : str;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return an array representing the value of this Decimal as a simple fraction with an integer\r\n   * numerator and an integer denominator.\r\n   *\r\n   * The denominator will be a positive non-zero value less than or equal to the specified maximum\r\n   * denominator. If a maximum denominator is not specified, the denominator will be the lowest\r\n   * value necessary to represent the number exactly.\r\n   *\r\n   * [maxD] {number|string|Decimal} Maximum denominator. Integer >= 1 and < Infinity.\r\n   *\r\n   */\r\n  P.toFraction = function (maxD) {\r\n    var d, d0, d1, d2, e, k, n, n0, n1, pr, q, r,\r\n      x = this,\r\n      xd = x.d,\r\n      Ctor = x.constructor;\r\n\r\n    if (!xd) return new Ctor(x);\r\n\r\n    n1 = d0 = new Ctor(1);\r\n    d1 = n0 = new Ctor(0);\r\n\r\n    d = new Ctor(d1);\r\n    e = d.e = getPrecision(xd) - x.e - 1;\r\n    k = e % LOG_BASE;\r\n    d.d[0] = mathpow(10, k < 0 ? LOG_BASE + k : k);\r\n\r\n    if (maxD == null) {\r\n\r\n      // d is 10**e, the minimum max-denominator needed.\r\n      maxD = e > 0 ? d : n1;\r\n    } else {\r\n      n = new Ctor(maxD);\r\n      if (!n.isInt() || n.lt(n1)) throw Error(invalidArgument + n);\r\n      maxD = n.gt(d) ? (e > 0 ? d : n1) : n;\r\n    }\r\n\r\n    external = false;\r\n    n = new Ctor(digitsToString(xd));\r\n    pr = Ctor.precision;\r\n    Ctor.precision = e = xd.length * LOG_BASE * 2;\r\n\r\n    for (;;)  {\r\n      q = divide(n, d, 0, 1, 1);\r\n      d2 = d0.plus(q.times(d1));\r\n      if (d2.cmp(maxD) == 1) break;\r\n      d0 = d1;\r\n      d1 = d2;\r\n      d2 = n1;\r\n      n1 = n0.plus(q.times(d2));\r\n      n0 = d2;\r\n      d2 = d;\r\n      d = n.minus(q.times(d2));\r\n      n = d2;\r\n    }\r\n\r\n    d2 = divide(maxD.minus(d0), d1, 0, 1, 1);\r\n    n0 = n0.plus(d2.times(n1));\r\n    d0 = d0.plus(d2.times(d1));\r\n    n0.s = n1.s = x.s;\r\n\r\n    // Determine which fraction is closer to x, n0/d0 or n1/d1?\r\n    r = divide(n1, d1, e, 1).minus(x).abs().cmp(divide(n0, d0, e, 1).minus(x).abs()) < 1\r\n        ? [n1, d1] : [n0, d0];\r\n\r\n    Ctor.precision = pr;\r\n    external = true;\r\n\r\n    return r;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Decimal in base 16, round to `sd` significant\r\n   * digits using rounding mode `rm`.\r\n   *\r\n   * If the optional `sd` argument is present then return binary exponential notation.\r\n   *\r\n   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   */\r\n  P.toHexadecimal = P.toHex = function (sd, rm) {\r\n    return toStringBinary(this, 16, sd, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Returns a new Decimal whose value is the nearest multiple of `y` in the direction of rounding\r\n   * mode `rm`, or `Decimal.rounding` if `rm` is omitted, to the value of this Decimal.\r\n   *\r\n   * The return value will always have the same sign as this Decimal, unless either this Decimal\r\n   * or `y` is NaN, in which case the return value will be also be NaN.\r\n   *\r\n   * The return value is not affected by the value of `precision`.\r\n   *\r\n   * y {number|string|Decimal} The magnitude to round to a multiple of.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * 'toNearest() rounding mode not an integer: {rm}'\r\n   * 'toNearest() rounding mode out of range: {rm}'\r\n   *\r\n   */\r\n  P.toNearest = function (y, rm) {\r\n    var x = this,\r\n      Ctor = x.constructor;\r\n\r\n    x = new Ctor(x);\r\n\r\n    if (y == null) {\r\n\r\n      // If x is not finite, return x.\r\n      if (!x.d) return x;\r\n\r\n      y = new Ctor(1);\r\n      rm = Ctor.rounding;\r\n    } else {\r\n      y = new Ctor(y);\r\n      if (rm === void 0) {\r\n        rm = Ctor.rounding;\r\n      } else {\r\n        checkInt32(rm, 0, 8);\r\n      }\r\n\r\n      // If x is not finite, return x if y is not NaN, else NaN.\r\n      if (!x.d) return y.s ? x : y;\r\n\r\n      // If y is not finite, return Infinity with the sign of x if y is Infinity, else NaN.\r\n      if (!y.d) {\r\n        if (y.s) y.s = x.s;\r\n        return y;\r\n      }\r\n    }\r\n\r\n    // If y is not zero, calculate the nearest multiple of y to x.\r\n    if (y.d[0]) {\r\n      external = false;\r\n      x = divide(x, y, 0, rm, 1).times(y);\r\n      external = true;\r\n      finalise(x);\r\n\r\n    // If y is zero, return zero with the sign of x.\r\n    } else {\r\n      y.s = x.s;\r\n      x = y;\r\n    }\r\n\r\n    return x;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return the value of this Decimal converted to a number primitive.\r\n   * Zero keeps its sign.\r\n   *\r\n   */\r\n  P.toNumber = function () {\r\n    return +this;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Decimal in base 8, round to `sd` significant\r\n   * digits using rounding mode `rm`.\r\n   *\r\n   * If the optional `sd` argument is present then return binary exponential notation.\r\n   *\r\n   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   */\r\n  P.toOctal = function (sd, rm) {\r\n    return toStringBinary(this, 8, sd, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal raised to the power `y`, rounded\r\n   * to `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * ECMAScript compliant.\r\n   *\r\n   *   pow(x, NaN)                           = NaN\r\n   *   pow(x, ±0)                            = 1\r\n\r\n   *   pow(NaN, non-zero)                    = NaN\r\n   *   pow(abs(x) > 1, +Infinity)            = +Infinity\r\n   *   pow(abs(x) > 1, -Infinity)            = +0\r\n   *   pow(abs(x) == 1, ±Infinity)           = NaN\r\n   *   pow(abs(x) < 1, +Infinity)            = +0\r\n   *   pow(abs(x) < 1, -Infinity)            = +Infinity\r\n   *   pow(+Infinity, y > 0)                 = +Infinity\r\n   *   pow(+Infinity, y < 0)                 = +0\r\n   *   pow(-Infinity, odd integer > 0)       = -Infinity\r\n   *   pow(-Infinity, even integer > 0)      = +Infinity\r\n   *   pow(-Infinity, odd integer < 0)       = -0\r\n   *   pow(-Infinity, even integer < 0)      = +0\r\n   *   pow(+0, y > 0)                        = +0\r\n   *   pow(+0, y < 0)                        = +Infinity\r\n   *   pow(-0, odd integer > 0)              = -0\r\n   *   pow(-0, even integer > 0)             = +0\r\n   *   pow(-0, odd integer < 0)              = -Infinity\r\n   *   pow(-0, even integer < 0)             = +Infinity\r\n   *   pow(finite x < 0, finite non-integer) = NaN\r\n   *\r\n   * For non-integer or very large exponents pow(x, y) is calculated using\r\n   *\r\n   *   x^y = exp(y*ln(x))\r\n   *\r\n   * Assuming the first 15 rounding digits are each equally likely to be any digit 0-9, the\r\n   * probability of an incorrectly rounded result\r\n   * P([49]9{14} | [50]0{14}) = 2 * 0.2 * 10^-14 = 4e-15 = 1/2.5e+14\r\n   * i.e. 1 in 250,000,000,000,000\r\n   *\r\n   * If a result is incorrectly rounded the maximum error will be 1 ulp (unit in last place).\r\n   *\r\n   * y {number|string|Decimal} The power to which to raise this Decimal.\r\n   *\r\n   */\r\n  P.toPower = P.pow = function (y) {\r\n    var e, k, pr, r, rm, s,\r\n      x = this,\r\n      Ctor = x.constructor,\r\n      yn = +(y = new Ctor(y));\r\n\r\n    // Either ±Infinity, NaN or ±0?\r\n    if (!x.d || !y.d || !x.d[0] || !y.d[0]) return new Ctor(mathpow(+x, yn));\r\n\r\n    x = new Ctor(x);\r\n\r\n    if (x.eq(1)) return x;\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n\r\n    if (y.eq(1)) return finalise(x, pr, rm);\r\n\r\n    // y exponent\r\n    e = mathfloor(y.e / LOG_BASE);\r\n\r\n    // If y is a small integer use the 'exponentiation by squaring' algorithm.\r\n    if (e >= y.d.length - 1 && (k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {\r\n      r = intPow(Ctor, x, k, pr);\r\n      return y.s < 0 ? new Ctor(1).div(r) : finalise(r, pr, rm);\r\n    }\r\n\r\n    s = x.s;\r\n\r\n    // if x is negative\r\n    if (s < 0) {\r\n\r\n      // if y is not an integer\r\n      if (e < y.d.length - 1) return new Ctor(NaN);\r\n\r\n      // Result is positive if x is negative and the last digit of integer y is even.\r\n      if ((y.d[e] & 1) == 0) s = 1;\r\n\r\n      // if x.eq(-1)\r\n      if (x.e == 0 && x.d[0] == 1 && x.d.length == 1) {\r\n        x.s = s;\r\n        return x;\r\n      }\r\n    }\r\n\r\n    // Estimate result exponent.\r\n    // x^y = 10^e,  where e = y * log10(x)\r\n    // log10(x) = log10(x_significand) + x_exponent\r\n    // log10(x_significand) = ln(x_significand) / ln(10)\r\n    k = mathpow(+x, yn);\r\n    e = k == 0 || !isFinite(k)\r\n      ? mathfloor(yn * (Math.log('0.' + digitsToString(x.d)) / Math.LN10 + x.e + 1))\r\n      : new Ctor(k + '').e;\r\n\r\n    // Exponent estimate may be incorrect e.g. x: 0.999999999999999999, y: 2.29, e: 0, r.e: -1.\r\n\r\n    // Overflow/underflow?\r\n    if (e > Ctor.maxE + 1 || e < Ctor.minE - 1) return new Ctor(e > 0 ? s / 0 : 0);\r\n\r\n    external = false;\r\n    Ctor.rounding = x.s = 1;\r\n\r\n    // Estimate the extra guard digits needed to ensure five correct rounding digits from\r\n    // naturalLogarithm(x). Example of failure without these extra digits (precision: 10):\r\n    // new Decimal(2.32456).pow('2087987436534566.46411')\r\n    // should be 1.162377823e+764914905173815, but is 1.162355823e+764914905173815\r\n    k = Math.min(12, (e + '').length);\r\n\r\n    // r = x^y = exp(y*ln(x))\r\n    r = naturalExponential(y.times(naturalLogarithm(x, pr + k)), pr);\r\n\r\n    // r may be Infinity, e.g. (0.9999999999999999).pow(-1e+40)\r\n    if (r.d) {\r\n\r\n      // Truncate to the required precision plus five rounding digits.\r\n      r = finalise(r, pr + 5, 1);\r\n\r\n      // If the rounding digits are [49]9999 or [50]0000 increase the precision by 10 and recalculate\r\n      // the result.\r\n      if (checkRoundingDigits(r.d, pr, rm)) {\r\n        e = pr + 10;\r\n\r\n        // Truncate to the increased precision plus five rounding digits.\r\n        r = finalise(naturalExponential(y.times(naturalLogarithm(x, e + k)), e), e + 5, 1);\r\n\r\n        // Check for 14 nines from the 2nd rounding digit (the first rounding digit may be 4 or 9).\r\n        if (+digitsToString(r.d).slice(pr + 1, pr + 15) + 1 == 1e14) {\r\n          r = finalise(r, pr + 1, 0);\r\n        }\r\n      }\r\n    }\r\n\r\n    r.s = s;\r\n    external = true;\r\n    Ctor.rounding = rm;\r\n\r\n    return finalise(r, pr, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Decimal rounded to `sd` significant digits\r\n   * using rounding mode `rounding`.\r\n   *\r\n   * Return exponential notation if `sd` is less than the number of digits necessary to represent\r\n   * the integer part of the value in normal notation.\r\n   *\r\n   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   */\r\n  P.toPrecision = function (sd, rm) {\r\n    var str,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (sd === void 0) {\r\n      str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);\r\n    } else {\r\n      checkInt32(sd, 1, MAX_DIGITS);\r\n\r\n      if (rm === void 0) rm = Ctor.rounding;\r\n      else checkInt32(rm, 0, 8);\r\n\r\n      x = finalise(new Ctor(x), sd, rm);\r\n      str = finiteToString(x, sd <= x.e || x.e <= Ctor.toExpNeg, sd);\r\n    }\r\n\r\n    return x.isNeg() && !x.isZero() ? '-' + str : str;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `sd`\r\n   * significant digits using rounding mode `rm`, or to `precision` and `rounding` respectively if\r\n   * omitted.\r\n   *\r\n   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * 'toSD() digits out of range: {sd}'\r\n   * 'toSD() digits not an integer: {sd}'\r\n   * 'toSD() rounding mode not an integer: {rm}'\r\n   * 'toSD() rounding mode out of range: {rm}'\r\n   *\r\n   */\r\n  P.toSignificantDigits = P.toSD = function (sd, rm) {\r\n    var x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (sd === void 0) {\r\n      sd = Ctor.precision;\r\n      rm = Ctor.rounding;\r\n    } else {\r\n      checkInt32(sd, 1, MAX_DIGITS);\r\n\r\n      if (rm === void 0) rm = Ctor.rounding;\r\n      else checkInt32(rm, 0, 8);\r\n    }\r\n\r\n    return finalise(new Ctor(x), sd, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Decimal.\r\n   *\r\n   * Return exponential notation if this Decimal has a positive exponent equal to or greater than\r\n   * `toExpPos`, or a negative exponent equal to or less than `toExpNeg`.\r\n   *\r\n   */\r\n  P.toString = function () {\r\n    var x = this,\r\n      Ctor = x.constructor,\r\n      str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);\r\n\r\n    return x.isNeg() && !x.isZero() ? '-' + str : str;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal truncated to a whole number.\r\n   *\r\n   */\r\n  P.truncated = P.trunc = function () {\r\n    return finalise(new this.constructor(this), this.e + 1, 1);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Decimal.\r\n   * Unlike `toString`, negative zero will include the minus sign.\r\n   *\r\n   */\r\n  P.valueOf = P.toJSON = function () {\r\n    var x = this,\r\n      Ctor = x.constructor,\r\n      str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);\r\n\r\n    return x.isNeg() ? '-' + str : str;\r\n  };\r\n\r\n\r\n  // Helper functions for Decimal.prototype (P) and/or Decimal methods, and their callers.\r\n\r\n\r\n  /*\r\n   *  digitsToString           P.cubeRoot, P.logarithm, P.squareRoot, P.toFraction, P.toPower,\r\n   *                           finiteToString, naturalExponential, naturalLogarithm\r\n   *  checkInt32               P.toDecimalPlaces, P.toExponential, P.toFixed, P.toNearest,\r\n   *                           P.toPrecision, P.toSignificantDigits, toStringBinary, random\r\n   *  checkRoundingDigits      P.logarithm, P.toPower, naturalExponential, naturalLogarithm\r\n   *  convertBase              toStringBinary, parseOther\r\n   *  cos                      P.cos\r\n   *  divide                   P.atanh, P.cubeRoot, P.dividedBy, P.dividedToIntegerBy,\r\n   *                           P.logarithm, P.modulo, P.squareRoot, P.tan, P.tanh, P.toFraction,\r\n   *                           P.toNearest, toStringBinary, naturalExponential, naturalLogarithm,\r\n   *                           taylorSeries, atan2, parseOther\r\n   *  finalise                 P.absoluteValue, P.atan, P.atanh, P.ceil, P.cos, P.cosh,\r\n   *                           P.cubeRoot, P.dividedToIntegerBy, P.floor, P.logarithm, P.minus,\r\n   *                           P.modulo, P.negated, P.plus, P.round, P.sin, P.sinh, P.squareRoot,\r\n   *                           P.tan, P.times, P.toDecimalPlaces, P.toExponential, P.toFixed,\r\n   *                           P.toNearest, P.toPower, P.toPrecision, P.toSignificantDigits,\r\n   *                           P.truncated, divide, getLn10, getPi, naturalExponential,\r\n   *                           naturalLogarithm, ceil, floor, round, trunc\r\n   *  finiteToString           P.toExponential, P.toFixed, P.toPrecision, P.toString, P.valueOf,\r\n   *                           toStringBinary\r\n   *  getBase10Exponent        P.minus, P.plus, P.times, parseOther\r\n   *  getLn10                  P.logarithm, naturalLogarithm\r\n   *  getPi                    P.acos, P.asin, P.atan, toLessThanHalfPi, atan2\r\n   *  getPrecision             P.precision, P.toFraction\r\n   *  getZeroString            digitsToString, finiteToString\r\n   *  intPow                   P.toPower, parseOther\r\n   *  isOdd                    toLessThanHalfPi\r\n   *  maxOrMin                 max, min\r\n   *  naturalExponential       P.naturalExponential, P.toPower\r\n   *  naturalLogarithm         P.acosh, P.asinh, P.atanh, P.logarithm, P.naturalLogarithm,\r\n   *                           P.toPower, naturalExponential\r\n   *  nonFiniteToString        finiteToString, toStringBinary\r\n   *  parseDecimal             Decimal\r\n   *  parseOther               Decimal\r\n   *  sin                      P.sin\r\n   *  taylorSeries             P.cosh, P.sinh, cos, sin\r\n   *  toLessThanHalfPi         P.cos, P.sin\r\n   *  toStringBinary           P.toBinary, P.toHexadecimal, P.toOctal\r\n   *  truncate                 intPow\r\n   *\r\n   *  Throws:                  P.logarithm, P.precision, P.toFraction, checkInt32, getLn10, getPi,\r\n   *                           naturalLogarithm, config, parseOther, random, Decimal\r\n   */\r\n\r\n\r\n  function digitsToString(d) {\r\n    var i, k, ws,\r\n      indexOfLastWord = d.length - 1,\r\n      str = '',\r\n      w = d[0];\r\n\r\n    if (indexOfLastWord > 0) {\r\n      str += w;\r\n      for (i = 1; i < indexOfLastWord; i++) {\r\n        ws = d[i] + '';\r\n        k = LOG_BASE - ws.length;\r\n        if (k) str += getZeroString(k);\r\n        str += ws;\r\n      }\r\n\r\n      w = d[i];\r\n      ws = w + '';\r\n      k = LOG_BASE - ws.length;\r\n      if (k) str += getZeroString(k);\r\n    } else if (w === 0) {\r\n      return '0';\r\n    }\r\n\r\n    // Remove trailing zeros of last w.\r\n    for (; w % 10 === 0;) w /= 10;\r\n\r\n    return str + w;\r\n  }\r\n\r\n\r\n  function checkInt32(i, min, max) {\r\n    if (i !== ~~i || i < min || i > max) {\r\n      throw Error(invalidArgument + i);\r\n    }\r\n  }\r\n\r\n\r\n  /*\r\n   * Check 5 rounding digits if `repeating` is null, 4 otherwise.\r\n   * `repeating == null` if caller is `log` or `pow`,\r\n   * `repeating != null` if caller is `naturalLogarithm` or `naturalExponential`.\r\n   */\r\n  function checkRoundingDigits(d, i, rm, repeating) {\r\n    var di, k, r, rd;\r\n\r\n    // Get the length of the first word of the array d.\r\n    for (k = d[0]; k >= 10; k /= 10) --i;\r\n\r\n    // Is the rounding digit in the first word of d?\r\n    if (--i < 0) {\r\n      i += LOG_BASE;\r\n      di = 0;\r\n    } else {\r\n      di = Math.ceil((i + 1) / LOG_BASE);\r\n      i %= LOG_BASE;\r\n    }\r\n\r\n    // i is the index (0 - 6) of the rounding digit.\r\n    // E.g. if within the word 3487563 the first rounding digit is 5,\r\n    // then i = 4, k = 1000, rd = 3487563 % 1000 = 563\r\n    k = mathpow(10, LOG_BASE - i);\r\n    rd = d[di] % k | 0;\r\n\r\n    if (repeating == null) {\r\n      if (i < 3) {\r\n        if (i == 0) rd = rd / 100 | 0;\r\n        else if (i == 1) rd = rd / 10 | 0;\r\n        r = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 50000 || rd == 0;\r\n      } else {\r\n        r = (rm < 4 && rd + 1 == k || rm > 3 && rd + 1 == k / 2) &&\r\n          (d[di + 1] / k / 100 | 0) == mathpow(10, i - 2) - 1 ||\r\n            (rd == k / 2 || rd == 0) && (d[di + 1] / k / 100 | 0) == 0;\r\n      }\r\n    } else {\r\n      if (i < 4) {\r\n        if (i == 0) rd = rd / 1000 | 0;\r\n        else if (i == 1) rd = rd / 100 | 0;\r\n        else if (i == 2) rd = rd / 10 | 0;\r\n        r = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;\r\n      } else {\r\n        r = ((repeating || rm < 4) && rd + 1 == k ||\r\n        (!repeating && rm > 3) && rd + 1 == k / 2) &&\r\n          (d[di + 1] / k / 1000 | 0) == mathpow(10, i - 3) - 1;\r\n      }\r\n    }\r\n\r\n    return r;\r\n  }\r\n\r\n\r\n  // Convert string of `baseIn` to an array of numbers of `baseOut`.\r\n  // Eg. convertBase('255', 10, 16) returns [15, 15].\r\n  // Eg. convertBase('ff', 16, 10) returns [2, 5, 5].\r\n  function convertBase(str, baseIn, baseOut) {\r\n    var j,\r\n      arr = [0],\r\n      arrL,\r\n      i = 0,\r\n      strL = str.length;\r\n\r\n    for (; i < strL;) {\r\n      for (arrL = arr.length; arrL--;) arr[arrL] *= baseIn;\r\n      arr[0] += NUMERALS.indexOf(str.charAt(i++));\r\n      for (j = 0; j < arr.length; j++) {\r\n        if (arr[j] > baseOut - 1) {\r\n          if (arr[j + 1] === void 0) arr[j + 1] = 0;\r\n          arr[j + 1] += arr[j] / baseOut | 0;\r\n          arr[j] %= baseOut;\r\n        }\r\n      }\r\n    }\r\n\r\n    return arr.reverse();\r\n  }\r\n\r\n\r\n  /*\r\n   * cos(x) = 1 - x^2/2! + x^4/4! - ...\r\n   * |x| < pi/2\r\n   *\r\n   */\r\n  function cosine(Ctor, x) {\r\n    var k, len, y;\r\n\r\n    if (x.isZero()) return x;\r\n\r\n    // Argument reduction: cos(4x) = 8*(cos^4(x) - cos^2(x)) + 1\r\n    // i.e. cos(x) = 8*(cos^4(x/4) - cos^2(x/4)) + 1\r\n\r\n    // Estimate the optimum number of times to use the argument reduction.\r\n    len = x.d.length;\r\n    if (len < 32) {\r\n      k = Math.ceil(len / 3);\r\n      y = (1 / tinyPow(4, k)).toString();\r\n    } else {\r\n      k = 16;\r\n      y = '2.3283064365386962890625e-10';\r\n    }\r\n\r\n    Ctor.precision += k;\r\n\r\n    x = taylorSeries(Ctor, 1, x.times(y), new Ctor(1));\r\n\r\n    // Reverse argument reduction\r\n    for (var i = k; i--;) {\r\n      var cos2x = x.times(x);\r\n      x = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);\r\n    }\r\n\r\n    Ctor.precision -= k;\r\n\r\n    return x;\r\n  }\r\n\r\n\r\n  /*\r\n   * Perform division in the specified base.\r\n   */\r\n  var divide = (function () {\r\n\r\n    // Assumes non-zero x and k, and hence non-zero result.\r\n    function multiplyInteger(x, k, base) {\r\n      var temp,\r\n        carry = 0,\r\n        i = x.length;\r\n\r\n      for (x = x.slice(); i--;) {\r\n        temp = x[i] * k + carry;\r\n        x[i] = temp % base | 0;\r\n        carry = temp / base | 0;\r\n      }\r\n\r\n      if (carry) x.unshift(carry);\r\n\r\n      return x;\r\n    }\r\n\r\n    function compare(a, b, aL, bL) {\r\n      var i, r;\r\n\r\n      if (aL != bL) {\r\n        r = aL > bL ? 1 : -1;\r\n      } else {\r\n        for (i = r = 0; i < aL; i++) {\r\n          if (a[i] != b[i]) {\r\n            r = a[i] > b[i] ? 1 : -1;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      return r;\r\n    }\r\n\r\n    function subtract(a, b, aL, base) {\r\n      var i = 0;\r\n\r\n      // Subtract b from a.\r\n      for (; aL--;) {\r\n        a[aL] -= i;\r\n        i = a[aL] < b[aL] ? 1 : 0;\r\n        a[aL] = i * base + a[aL] - b[aL];\r\n      }\r\n\r\n      // Remove leading zeros.\r\n      for (; !a[0] && a.length > 1;) a.shift();\r\n    }\r\n\r\n    return function (x, y, pr, rm, dp, base) {\r\n      var cmp, e, i, k, logBase, more, prod, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0,\r\n        yL, yz,\r\n        Ctor = x.constructor,\r\n        sign = x.s == y.s ? 1 : -1,\r\n        xd = x.d,\r\n        yd = y.d;\r\n\r\n      // Either NaN, Infinity or 0?\r\n      if (!xd || !xd[0] || !yd || !yd[0]) {\r\n\r\n        return new Ctor(// Return NaN if either NaN, or both Infinity or 0.\r\n          !x.s || !y.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN :\r\n\r\n          // Return ±0 if x is 0 or y is ±Infinity, or return ±Infinity as y is 0.\r\n          xd && xd[0] == 0 || !yd ? sign * 0 : sign / 0);\r\n      }\r\n\r\n      if (base) {\r\n        logBase = 1;\r\n        e = x.e - y.e;\r\n      } else {\r\n        base = BASE;\r\n        logBase = LOG_BASE;\r\n        e = mathfloor(x.e / logBase) - mathfloor(y.e / logBase);\r\n      }\r\n\r\n      yL = yd.length;\r\n      xL = xd.length;\r\n      q = new Ctor(sign);\r\n      qd = q.d = [];\r\n\r\n      // Result exponent may be one less than e.\r\n      // The digit array of a Decimal from toStringBinary may have trailing zeros.\r\n      for (i = 0; yd[i] == (xd[i] || 0); i++);\r\n\r\n      if (yd[i] > (xd[i] || 0)) e--;\r\n\r\n      if (pr == null) {\r\n        sd = pr = Ctor.precision;\r\n        rm = Ctor.rounding;\r\n      } else if (dp) {\r\n        sd = pr + (x.e - y.e) + 1;\r\n      } else {\r\n        sd = pr;\r\n      }\r\n\r\n      if (sd < 0) {\r\n        qd.push(1);\r\n        more = true;\r\n      } else {\r\n\r\n        // Convert precision in number of base 10 digits to base 1e7 digits.\r\n        sd = sd / logBase + 2 | 0;\r\n        i = 0;\r\n\r\n        // divisor < 1e7\r\n        if (yL == 1) {\r\n          k = 0;\r\n          yd = yd[0];\r\n          sd++;\r\n\r\n          // k is the carry.\r\n          for (; (i < xL || k) && sd--; i++) {\r\n            t = k * base + (xd[i] || 0);\r\n            qd[i] = t / yd | 0;\r\n            k = t % yd | 0;\r\n          }\r\n\r\n          more = k || i < xL;\r\n\r\n        // divisor >= 1e7\r\n        } else {\r\n\r\n          // Normalise xd and yd so highest order digit of yd is >= base/2\r\n          k = base / (yd[0] + 1) | 0;\r\n\r\n          if (k > 1) {\r\n            yd = multiplyInteger(yd, k, base);\r\n            xd = multiplyInteger(xd, k, base);\r\n            yL = yd.length;\r\n            xL = xd.length;\r\n          }\r\n\r\n          xi = yL;\r\n          rem = xd.slice(0, yL);\r\n          remL = rem.length;\r\n\r\n          // Add zeros to make remainder as long as divisor.\r\n          for (; remL < yL;) rem[remL++] = 0;\r\n\r\n          yz = yd.slice();\r\n          yz.unshift(0);\r\n          yd0 = yd[0];\r\n\r\n          if (yd[1] >= base / 2) ++yd0;\r\n\r\n          do {\r\n            k = 0;\r\n\r\n            // Compare divisor and remainder.\r\n            cmp = compare(yd, rem, yL, remL);\r\n\r\n            // If divisor < remainder.\r\n            if (cmp < 0) {\r\n\r\n              // Calculate trial digit, k.\r\n              rem0 = rem[0];\r\n              if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);\r\n\r\n              // k will be how many times the divisor goes into the current remainder.\r\n              k = rem0 / yd0 | 0;\r\n\r\n              //  Algorithm:\r\n              //  1. product = divisor * trial digit (k)\r\n              //  2. if product > remainder: product -= divisor, k--\r\n              //  3. remainder -= product\r\n              //  4. if product was < remainder at 2:\r\n              //    5. compare new remainder and divisor\r\n              //    6. If remainder > divisor: remainder -= divisor, k++\r\n\r\n              if (k > 1) {\r\n                if (k >= base) k = base - 1;\r\n\r\n                // product = divisor * trial digit.\r\n                prod = multiplyInteger(yd, k, base);\r\n                prodL = prod.length;\r\n                remL = rem.length;\r\n\r\n                // Compare product and remainder.\r\n                cmp = compare(prod, rem, prodL, remL);\r\n\r\n                // product > remainder.\r\n                if (cmp == 1) {\r\n                  k--;\r\n\r\n                  // Subtract divisor from product.\r\n                  subtract(prod, yL < prodL ? yz : yd, prodL, base);\r\n                }\r\n              } else {\r\n\r\n                // cmp is -1.\r\n                // If k is 0, there is no need to compare yd and rem again below, so change cmp to 1\r\n                // to avoid it. If k is 1 there is a need to compare yd and rem again below.\r\n                if (k == 0) cmp = k = 1;\r\n                prod = yd.slice();\r\n              }\r\n\r\n              prodL = prod.length;\r\n              if (prodL < remL) prod.unshift(0);\r\n\r\n              // Subtract product from remainder.\r\n              subtract(rem, prod, remL, base);\r\n\r\n              // If product was < previous remainder.\r\n              if (cmp == -1) {\r\n                remL = rem.length;\r\n\r\n                // Compare divisor and new remainder.\r\n                cmp = compare(yd, rem, yL, remL);\r\n\r\n                // If divisor < new remainder, subtract divisor from remainder.\r\n                if (cmp < 1) {\r\n                  k++;\r\n\r\n                  // Subtract divisor from remainder.\r\n                  subtract(rem, yL < remL ? yz : yd, remL, base);\r\n                }\r\n              }\r\n\r\n              remL = rem.length;\r\n            } else if (cmp === 0) {\r\n              k++;\r\n              rem = [0];\r\n            }    // if cmp === 1, k will be 0\r\n\r\n            // Add the next digit, k, to the result array.\r\n            qd[i++] = k;\r\n\r\n            // Update the remainder.\r\n            if (cmp && rem[0]) {\r\n              rem[remL++] = xd[xi] || 0;\r\n            } else {\r\n              rem = [xd[xi]];\r\n              remL = 1;\r\n            }\r\n\r\n          } while ((xi++ < xL || rem[0] !== void 0) && sd--);\r\n\r\n          more = rem[0] !== void 0;\r\n        }\r\n\r\n        // Leading zero?\r\n        if (!qd[0]) qd.shift();\r\n      }\r\n\r\n      // logBase is 1 when divide is being used for base conversion.\r\n      if (logBase == 1) {\r\n        q.e = e;\r\n        inexact = more;\r\n      } else {\r\n\r\n        // To calculate q.e, first get the number of digits of qd[0].\r\n        for (i = 1, k = qd[0]; k >= 10; k /= 10) i++;\r\n        q.e = i + e * logBase - 1;\r\n\r\n        finalise(q, dp ? pr + q.e + 1 : pr, rm, more);\r\n      }\r\n\r\n      return q;\r\n    };\r\n  })();\r\n\r\n\r\n  /*\r\n   * Round `x` to `sd` significant digits using rounding mode `rm`.\r\n   * Check for over/under-flow.\r\n   */\r\n   function finalise(x, sd, rm, isTruncated) {\r\n    var digits, i, j, k, rd, roundUp, w, xd, xdi,\r\n      Ctor = x.constructor;\r\n\r\n    // Don't round if sd is null or undefined.\r\n    out: if (sd != null) {\r\n      xd = x.d;\r\n\r\n      // Infinity/NaN.\r\n      if (!xd) return x;\r\n\r\n      // rd: the rounding digit, i.e. the digit after the digit that may be rounded up.\r\n      // w: the word of xd containing rd, a base 1e7 number.\r\n      // xdi: the index of w within xd.\r\n      // digits: the number of digits of w.\r\n      // i: what would be the index of rd within w if all the numbers were 7 digits long (i.e. if\r\n      // they had leading zeros)\r\n      // j: if > 0, the actual index of rd within w (if < 0, rd is a leading zero).\r\n\r\n      // Get the length of the first word of the digits array xd.\r\n      for (digits = 1, k = xd[0]; k >= 10; k /= 10) digits++;\r\n      i = sd - digits;\r\n\r\n      // Is the rounding digit in the first word of xd?\r\n      if (i < 0) {\r\n        i += LOG_BASE;\r\n        j = sd;\r\n        w = xd[xdi = 0];\r\n\r\n        // Get the rounding digit at index j of w.\r\n        rd = w / mathpow(10, digits - j - 1) % 10 | 0;\r\n      } else {\r\n        xdi = Math.ceil((i + 1) / LOG_BASE);\r\n        k = xd.length;\r\n        if (xdi >= k) {\r\n          if (isTruncated) {\r\n\r\n            // Needed by `naturalExponential`, `naturalLogarithm` and `squareRoot`.\r\n            for (; k++ <= xdi;) xd.push(0);\r\n            w = rd = 0;\r\n            digits = 1;\r\n            i %= LOG_BASE;\r\n            j = i - LOG_BASE + 1;\r\n          } else {\r\n            break out;\r\n          }\r\n        } else {\r\n          w = k = xd[xdi];\r\n\r\n          // Get the number of digits of w.\r\n          for (digits = 1; k >= 10; k /= 10) digits++;\r\n\r\n          // Get the index of rd within w.\r\n          i %= LOG_BASE;\r\n\r\n          // Get the index of rd within w, adjusted for leading zeros.\r\n          // The number of leading zeros of w is given by LOG_BASE - digits.\r\n          j = i - LOG_BASE + digits;\r\n\r\n          // Get the rounding digit at index j of w.\r\n          rd = j < 0 ? 0 : w / mathpow(10, digits - j - 1) % 10 | 0;\r\n        }\r\n      }\r\n\r\n      // Are there any non-zero digits after the rounding digit?\r\n      isTruncated = isTruncated || sd < 0 ||\r\n        xd[xdi + 1] !== void 0 || (j < 0 ? w : w % mathpow(10, digits - j - 1));\r\n\r\n      // The expression `w % mathpow(10, digits - j - 1)` returns all the digits of w to the right\r\n      // of the digit at (left-to-right) index j, e.g. if w is 908714 and j is 2, the expression\r\n      // will give 714.\r\n\r\n      roundUp = rm < 4\r\n        ? (rd || isTruncated) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))\r\n        : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 &&\r\n\r\n          // Check whether the digit to the left of the rounding digit is odd.\r\n          ((i > 0 ? j > 0 ? w / mathpow(10, digits - j) : 0 : xd[xdi - 1]) % 10) & 1 ||\r\n            rm == (x.s < 0 ? 8 : 7));\r\n\r\n      if (sd < 1 || !xd[0]) {\r\n        xd.length = 0;\r\n        if (roundUp) {\r\n\r\n          // Convert sd to decimal places.\r\n          sd -= x.e + 1;\r\n\r\n          // 1, 0.1, 0.01, 0.001, 0.0001 etc.\r\n          xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);\r\n          x.e = -sd || 0;\r\n        } else {\r\n\r\n          // Zero.\r\n          xd[0] = x.e = 0;\r\n        }\r\n\r\n        return x;\r\n      }\r\n\r\n      // Remove excess digits.\r\n      if (i == 0) {\r\n        xd.length = xdi;\r\n        k = 1;\r\n        xdi--;\r\n      } else {\r\n        xd.length = xdi + 1;\r\n        k = mathpow(10, LOG_BASE - i);\r\n\r\n        // E.g. 56700 becomes 56000 if 7 is the rounding digit.\r\n        // j > 0 means i > number of leading zeros of w.\r\n        xd[xdi] = j > 0 ? (w / mathpow(10, digits - j) % mathpow(10, j) | 0) * k : 0;\r\n      }\r\n\r\n      if (roundUp) {\r\n        for (;;) {\r\n\r\n          // Is the digit to be rounded up in the first word of xd?\r\n          if (xdi == 0) {\r\n\r\n            // i will be the length of xd[0] before k is added.\r\n            for (i = 1, j = xd[0]; j >= 10; j /= 10) i++;\r\n            j = xd[0] += k;\r\n            for (k = 1; j >= 10; j /= 10) k++;\r\n\r\n            // if i != k the length has increased.\r\n            if (i != k) {\r\n              x.e++;\r\n              if (xd[0] == BASE) xd[0] = 1;\r\n            }\r\n\r\n            break;\r\n          } else {\r\n            xd[xdi] += k;\r\n            if (xd[xdi] != BASE) break;\r\n            xd[xdi--] = 0;\r\n            k = 1;\r\n          }\r\n        }\r\n      }\r\n\r\n      // Remove trailing zeros.\r\n      for (i = xd.length; xd[--i] === 0;) xd.pop();\r\n    }\r\n\r\n    if (external) {\r\n\r\n      // Overflow?\r\n      if (x.e > Ctor.maxE) {\r\n\r\n        // Infinity.\r\n        x.d = null;\r\n        x.e = NaN;\r\n\r\n      // Underflow?\r\n      } else if (x.e < Ctor.minE) {\r\n\r\n        // Zero.\r\n        x.e = 0;\r\n        x.d = [0];\r\n        // Ctor.underflow = true;\r\n      } // else Ctor.underflow = false;\r\n    }\r\n\r\n    return x;\r\n  }\r\n\r\n\r\n  function finiteToString(x, isExp, sd) {\r\n    if (!x.isFinite()) return nonFiniteToString(x);\r\n    var k,\r\n      e = x.e,\r\n      str = digitsToString(x.d),\r\n      len = str.length;\r\n\r\n    if (isExp) {\r\n      if (sd && (k = sd - len) > 0) {\r\n        str = str.charAt(0) + '.' + str.slice(1) + getZeroString(k);\r\n      } else if (len > 1) {\r\n        str = str.charAt(0) + '.' + str.slice(1);\r\n      }\r\n\r\n      str = str + (x.e < 0 ? 'e' : 'e+') + x.e;\r\n    } else if (e < 0) {\r\n      str = '0.' + getZeroString(-e - 1) + str;\r\n      if (sd && (k = sd - len) > 0) str += getZeroString(k);\r\n    } else if (e >= len) {\r\n      str += getZeroString(e + 1 - len);\r\n      if (sd && (k = sd - e - 1) > 0) str = str + '.' + getZeroString(k);\r\n    } else {\r\n      if ((k = e + 1) < len) str = str.slice(0, k) + '.' + str.slice(k);\r\n      if (sd && (k = sd - len) > 0) {\r\n        if (e + 1 === len) str += '.';\r\n        str += getZeroString(k);\r\n      }\r\n    }\r\n\r\n    return str;\r\n  }\r\n\r\n\r\n  // Calculate the base 10 exponent from the base 1e7 exponent.\r\n  function getBase10Exponent(digits, e) {\r\n    var w = digits[0];\r\n\r\n    // Add the number of digits of the first word of the digits array.\r\n    for ( e *= LOG_BASE; w >= 10; w /= 10) e++;\r\n    return e;\r\n  }\r\n\r\n\r\n  function getLn10(Ctor, sd, pr) {\r\n    if (sd > LN10_PRECISION) {\r\n\r\n      // Reset global state in case the exception is caught.\r\n      external = true;\r\n      if (pr) Ctor.precision = pr;\r\n      throw Error(precisionLimitExceeded);\r\n    }\r\n    return finalise(new Ctor(LN10), sd, 1, true);\r\n  }\r\n\r\n\r\n  function getPi(Ctor, sd, rm) {\r\n    if (sd > PI_PRECISION) throw Error(precisionLimitExceeded);\r\n    return finalise(new Ctor(PI), sd, rm, true);\r\n  }\r\n\r\n\r\n  function getPrecision(digits) {\r\n    var w = digits.length - 1,\r\n      len = w * LOG_BASE + 1;\r\n\r\n    w = digits[w];\r\n\r\n    // If non-zero...\r\n    if (w) {\r\n\r\n      // Subtract the number of trailing zeros of the last word.\r\n      for (; w % 10 == 0; w /= 10) len--;\r\n\r\n      // Add the number of digits of the first word.\r\n      for (w = digits[0]; w >= 10; w /= 10) len++;\r\n    }\r\n\r\n    return len;\r\n  }\r\n\r\n\r\n  function getZeroString(k) {\r\n    var zs = '';\r\n    for (; k--;) zs += '0';\r\n    return zs;\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of Decimal `x` to the power `n`, where `n` is an\r\n   * integer of type number.\r\n   *\r\n   * Implements 'exponentiation by squaring'. Called by `pow` and `parseOther`.\r\n   *\r\n   */\r\n  function intPow(Ctor, x, n, pr) {\r\n    var isTruncated,\r\n      r = new Ctor(1),\r\n\r\n      // Max n of 9007199254740991 takes 53 loop iterations.\r\n      // Maximum digits array length; leaves [28, 34] guard digits.\r\n      k = Math.ceil(pr / LOG_BASE + 4);\r\n\r\n    external = false;\r\n\r\n    for (;;) {\r\n      if (n % 2) {\r\n        r = r.times(x);\r\n        if (truncate(r.d, k)) isTruncated = true;\r\n      }\r\n\r\n      n = mathfloor(n / 2);\r\n      if (n === 0) {\r\n\r\n        // To ensure correct rounding when r.d is truncated, increment the last word if it is zero.\r\n        n = r.d.length - 1;\r\n        if (isTruncated && r.d[n] === 0) ++r.d[n];\r\n        break;\r\n      }\r\n\r\n      x = x.times(x);\r\n      truncate(x.d, k);\r\n    }\r\n\r\n    external = true;\r\n\r\n    return r;\r\n  }\r\n\r\n\r\n  function isOdd(n) {\r\n    return n.d[n.d.length - 1] & 1;\r\n  }\r\n\r\n\r\n  /*\r\n   * Handle `max` and `min`. `ltgt` is 'lt' or 'gt'.\r\n   */\r\n  function maxOrMin(Ctor, args, ltgt) {\r\n    var y,\r\n      x = new Ctor(args[0]),\r\n      i = 0;\r\n\r\n    for (; ++i < args.length;) {\r\n      y = new Ctor(args[i]);\r\n      if (!y.s) {\r\n        x = y;\r\n        break;\r\n      } else if (x[ltgt](y)) {\r\n        x = y;\r\n      }\r\n    }\r\n\r\n    return x;\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the natural exponential of `x` rounded to `sd` significant\r\n   * digits.\r\n   *\r\n   * Taylor/Maclaurin series.\r\n   *\r\n   * exp(x) = x^0/0! + x^1/1! + x^2/2! + x^3/3! + ...\r\n   *\r\n   * Argument reduction:\r\n   *   Repeat x = x / 32, k += 5, until |x| < 0.1\r\n   *   exp(x) = exp(x / 2^k)^(2^k)\r\n   *\r\n   * Previously, the argument was initially reduced by\r\n   * exp(x) = exp(r) * 10^k  where r = x - k * ln10, k = floor(x / ln10)\r\n   * to first put r in the range [0, ln10], before dividing by 32 until |x| < 0.1, but this was\r\n   * found to be slower than just dividing repeatedly by 32 as above.\r\n   *\r\n   * Max integer argument: exp('20723265836946413') = 6.3e+9000000000000000\r\n   * Min integer argument: exp('-20723265836946411') = 1.2e-9000000000000000\r\n   * (Math object integer min/max: Math.exp(709) = 8.2e+307, Math.exp(-745) = 5e-324)\r\n   *\r\n   *  exp(Infinity)  = Infinity\r\n   *  exp(-Infinity) = 0\r\n   *  exp(NaN)       = NaN\r\n   *  exp(±0)        = 1\r\n   *\r\n   *  exp(x) is non-terminating for any finite, non-zero x.\r\n   *\r\n   *  The result will always be correctly rounded.\r\n   *\r\n   */\r\n  function naturalExponential(x, sd) {\r\n    var denominator, guard, j, pow, sum, t, wpr,\r\n      rep = 0,\r\n      i = 0,\r\n      k = 0,\r\n      Ctor = x.constructor,\r\n      rm = Ctor.rounding,\r\n      pr = Ctor.precision;\r\n\r\n    // 0/NaN/Infinity?\r\n    if (!x.d || !x.d[0] || x.e > 17) {\r\n\r\n      return new Ctor(x.d\r\n        ? !x.d[0] ? 1 : x.s < 0 ? 0 : 1 / 0\r\n        : x.s ? x.s < 0 ? 0 : x : 0 / 0);\r\n    }\r\n\r\n    if (sd == null) {\r\n      external = false;\r\n      wpr = pr;\r\n    } else {\r\n      wpr = sd;\r\n    }\r\n\r\n    t = new Ctor(0.03125);\r\n\r\n    // while abs(x) >= 0.1\r\n    while (x.e > -2) {\r\n\r\n      // x = x / 2^5\r\n      x = x.times(t);\r\n      k += 5;\r\n    }\r\n\r\n    // Use 2 * log10(2^k) + 5 (empirically derived) to estimate the increase in precision\r\n    // necessary to ensure the first 4 rounding digits are correct.\r\n    guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;\r\n    wpr += guard;\r\n    denominator = pow = sum = new Ctor(1);\r\n    Ctor.precision = wpr;\r\n\r\n    for (;;) {\r\n      pow = finalise(pow.times(x), wpr, 1);\r\n      denominator = denominator.times(++i);\r\n      t = sum.plus(divide(pow, denominator, wpr, 1));\r\n\r\n      if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {\r\n        j = k;\r\n        while (j--) sum = finalise(sum.times(sum), wpr, 1);\r\n\r\n        // Check to see if the first 4 rounding digits are [49]999.\r\n        // If so, repeat the summation with a higher precision, otherwise\r\n        // e.g. with precision: 18, rounding: 1\r\n        // exp(18.404272462595034083567793919843761) = 98372560.1229999999 (should be 98372560.123)\r\n        // `wpr - guard` is the index of first rounding digit.\r\n        if (sd == null) {\r\n\r\n          if (rep < 3 && checkRoundingDigits(sum.d, wpr - guard, rm, rep)) {\r\n            Ctor.precision = wpr += 10;\r\n            denominator = pow = t = new Ctor(1);\r\n            i = 0;\r\n            rep++;\r\n          } else {\r\n            return finalise(sum, Ctor.precision = pr, rm, external = true);\r\n          }\r\n        } else {\r\n          Ctor.precision = pr;\r\n          return sum;\r\n        }\r\n      }\r\n\r\n      sum = t;\r\n    }\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the natural logarithm of `x` rounded to `sd` significant\r\n   * digits.\r\n   *\r\n   *  ln(-n)        = NaN\r\n   *  ln(0)         = -Infinity\r\n   *  ln(-0)        = -Infinity\r\n   *  ln(1)         = 0\r\n   *  ln(Infinity)  = Infinity\r\n   *  ln(-Infinity) = NaN\r\n   *  ln(NaN)       = NaN\r\n   *\r\n   *  ln(n) (n != 1) is non-terminating.\r\n   *\r\n   */\r\n  function naturalLogarithm(y, sd) {\r\n    var c, c0, denominator, e, numerator, rep, sum, t, wpr, x1, x2,\r\n      n = 1,\r\n      guard = 10,\r\n      x = y,\r\n      xd = x.d,\r\n      Ctor = x.constructor,\r\n      rm = Ctor.rounding,\r\n      pr = Ctor.precision;\r\n\r\n    // Is x negative or Infinity, NaN, 0 or 1?\r\n    if (x.s < 0 || !xd || !xd[0] || !x.e && xd[0] == 1 && xd.length == 1) {\r\n      return new Ctor(xd && !xd[0] ? -1 / 0 : x.s != 1 ? NaN : xd ? 0 : x);\r\n    }\r\n\r\n    if (sd == null) {\r\n      external = false;\r\n      wpr = pr;\r\n    } else {\r\n      wpr = sd;\r\n    }\r\n\r\n    Ctor.precision = wpr += guard;\r\n    c = digitsToString(xd);\r\n    c0 = c.charAt(0);\r\n\r\n    if (Math.abs(e = x.e) < 1.5e15) {\r\n\r\n      // Argument reduction.\r\n      // The series converges faster the closer the argument is to 1, so using\r\n      // ln(a^b) = b * ln(a),   ln(a) = ln(a^b) / b\r\n      // multiply the argument by itself until the leading digits of the significand are 7, 8, 9,\r\n      // 10, 11, 12 or 13, recording the number of multiplications so the sum of the series can\r\n      // later be divided by this number, then separate out the power of 10 using\r\n      // ln(a*10^b) = ln(a) + b*ln(10).\r\n\r\n      // max n is 21 (gives 0.9, 1.0 or 1.1) (9e15 / 21 = 4.2e14).\r\n      //while (c0 < 9 && c0 != 1 || c0 == 1 && c.charAt(1) > 1) {\r\n      // max n is 6 (gives 0.7 - 1.3)\r\n      while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {\r\n        x = x.times(y);\r\n        c = digitsToString(x.d);\r\n        c0 = c.charAt(0);\r\n        n++;\r\n      }\r\n\r\n      e = x.e;\r\n\r\n      if (c0 > 1) {\r\n        x = new Ctor('0.' + c);\r\n        e++;\r\n      } else {\r\n        x = new Ctor(c0 + '.' + c.slice(1));\r\n      }\r\n    } else {\r\n\r\n      // The argument reduction method above may result in overflow if the argument y is a massive\r\n      // number with exponent >= 1500000000000000 (9e15 / 6 = 1.5e15), so instead recall this\r\n      // function using ln(x*10^e) = ln(x) + e*ln(10).\r\n      t = getLn10(Ctor, wpr + 2, pr).times(e + '');\r\n      x = naturalLogarithm(new Ctor(c0 + '.' + c.slice(1)), wpr - guard).plus(t);\r\n      Ctor.precision = pr;\r\n\r\n      return sd == null ? finalise(x, pr, rm, external = true) : x;\r\n    }\r\n\r\n    // x1 is x reduced to a value near 1.\r\n    x1 = x;\r\n\r\n    // Taylor series.\r\n    // ln(y) = ln((1 + x)/(1 - x)) = 2(x + x^3/3 + x^5/5 + x^7/7 + ...)\r\n    // where x = (y - 1)/(y + 1)    (|x| < 1)\r\n    sum = numerator = x = divide(x.minus(1), x.plus(1), wpr, 1);\r\n    x2 = finalise(x.times(x), wpr, 1);\r\n    denominator = 3;\r\n\r\n    for (;;) {\r\n      numerator = finalise(numerator.times(x2), wpr, 1);\r\n      t = sum.plus(divide(numerator, new Ctor(denominator), wpr, 1));\r\n\r\n      if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {\r\n        sum = sum.times(2);\r\n\r\n        // Reverse the argument reduction. Check that e is not 0 because, besides preventing an\r\n        // unnecessary calculation, -0 + 0 = +0 and to ensure correct rounding -0 needs to stay -0.\r\n        if (e !== 0) sum = sum.plus(getLn10(Ctor, wpr + 2, pr).times(e + ''));\r\n        sum = divide(sum, new Ctor(n), wpr, 1);\r\n\r\n        // Is rm > 3 and the first 4 rounding digits 4999, or rm < 4 (or the summation has\r\n        // been repeated previously) and the first 4 rounding digits 9999?\r\n        // If so, restart the summation with a higher precision, otherwise\r\n        // e.g. with precision: 12, rounding: 1\r\n        // ln(135520028.6126091714265381533) = 18.7246299999 when it should be 18.72463.\r\n        // `wpr - guard` is the index of first rounding digit.\r\n        if (sd == null) {\r\n          if (checkRoundingDigits(sum.d, wpr - guard, rm, rep)) {\r\n            Ctor.precision = wpr += guard;\r\n            t = numerator = x = divide(x1.minus(1), x1.plus(1), wpr, 1);\r\n            x2 = finalise(x.times(x), wpr, 1);\r\n            denominator = rep = 1;\r\n          } else {\r\n            return finalise(sum, Ctor.precision = pr, rm, external = true);\r\n          }\r\n        } else {\r\n          Ctor.precision = pr;\r\n          return sum;\r\n        }\r\n      }\r\n\r\n      sum = t;\r\n      denominator += 2;\r\n    }\r\n  }\r\n\r\n\r\n  // ±Infinity, NaN.\r\n  function nonFiniteToString(x) {\r\n    // Unsigned.\r\n    return String(x.s * x.s / 0);\r\n  }\r\n\r\n\r\n  /*\r\n   * Parse the value of a new Decimal `x` from string `str`.\r\n   */\r\n  function parseDecimal(x, str) {\r\n    var e, i, len;\r\n\r\n    // Decimal point?\r\n    if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');\r\n\r\n    // Exponential form?\r\n    if ((i = str.search(/e/i)) > 0) {\r\n\r\n      // Determine exponent.\r\n      if (e < 0) e = i;\r\n      e += +str.slice(i + 1);\r\n      str = str.substring(0, i);\r\n    } else if (e < 0) {\r\n\r\n      // Integer.\r\n      e = str.length;\r\n    }\r\n\r\n    // Determine leading zeros.\r\n    for (i = 0; str.charCodeAt(i) === 48; i++);\r\n\r\n    // Determine trailing zeros.\r\n    for (len = str.length; str.charCodeAt(len - 1) === 48; --len);\r\n    str = str.slice(i, len);\r\n\r\n    if (str) {\r\n      len -= i;\r\n      x.e = e = e - i - 1;\r\n      x.d = [];\r\n\r\n      // Transform base\r\n\r\n      // e is the base 10 exponent.\r\n      // i is where to slice str to get the first word of the digits array.\r\n      i = (e + 1) % LOG_BASE;\r\n      if (e < 0) i += LOG_BASE;\r\n\r\n      if (i < len) {\r\n        if (i) x.d.push(+str.slice(0, i));\r\n        for (len -= LOG_BASE; i < len;) x.d.push(+str.slice(i, i += LOG_BASE));\r\n        str = str.slice(i);\r\n        i = LOG_BASE - str.length;\r\n      } else {\r\n        i -= len;\r\n      }\r\n\r\n      for (; i--;) str += '0';\r\n      x.d.push(+str);\r\n\r\n      if (external) {\r\n\r\n        // Overflow?\r\n        if (x.e > x.constructor.maxE) {\r\n\r\n          // Infinity.\r\n          x.d = null;\r\n          x.e = NaN;\r\n\r\n        // Underflow?\r\n        } else if (x.e < x.constructor.minE) {\r\n\r\n          // Zero.\r\n          x.e = 0;\r\n          x.d = [0];\r\n          // x.constructor.underflow = true;\r\n        } // else x.constructor.underflow = false;\r\n      }\r\n    } else {\r\n\r\n      // Zero.\r\n      x.e = 0;\r\n      x.d = [0];\r\n    }\r\n\r\n    return x;\r\n  }\r\n\r\n\r\n  /*\r\n   * Parse the value of a new Decimal `x` from a string `str`, which is not a decimal value.\r\n   */\r\n  function parseOther(x, str) {\r\n    var base, Ctor, divisor, i, isFloat, len, p, xd, xe;\r\n\r\n    if (str.indexOf('_') > -1) {\r\n      str = str.replace(/(\\d)_(?=\\d)/g, '$1');\r\n      if (isDecimal.test(str)) return parseDecimal(x, str);\r\n    } else if (str === 'Infinity' || str === 'NaN') {\r\n      if (!+str) x.s = NaN;\r\n      x.e = NaN;\r\n      x.d = null;\r\n      return x;\r\n    }\r\n\r\n    if (isHex.test(str))  {\r\n      base = 16;\r\n      str = str.toLowerCase();\r\n    } else if (isBinary.test(str))  {\r\n      base = 2;\r\n    } else if (isOctal.test(str))  {\r\n      base = 8;\r\n    } else {\r\n      throw Error(invalidArgument + str);\r\n    }\r\n\r\n    // Is there a binary exponent part?\r\n    i = str.search(/p/i);\r\n\r\n    if (i > 0) {\r\n      p = +str.slice(i + 1);\r\n      str = str.substring(2, i);\r\n    } else {\r\n      str = str.slice(2);\r\n    }\r\n\r\n    // Convert `str` as an integer then divide the result by `base` raised to a power such that the\r\n    // fraction part will be restored.\r\n    i = str.indexOf('.');\r\n    isFloat = i >= 0;\r\n    Ctor = x.constructor;\r\n\r\n    if (isFloat) {\r\n      str = str.replace('.', '');\r\n      len = str.length;\r\n      i = len - i;\r\n\r\n      // log[10](16) = 1.2041... , log[10](88) = 1.9444....\r\n      divisor = intPow(Ctor, new Ctor(base), i, i * 2);\r\n    }\r\n\r\n    xd = convertBase(str, base, BASE);\r\n    xe = xd.length - 1;\r\n\r\n    // Remove trailing zeros.\r\n    for (i = xe; xd[i] === 0; --i) xd.pop();\r\n    if (i < 0) return new Ctor(x.s * 0);\r\n    x.e = getBase10Exponent(xd, xe);\r\n    x.d = xd;\r\n    external = false;\r\n\r\n    // At what precision to perform the division to ensure exact conversion?\r\n    // maxDecimalIntegerPartDigitCount = ceil(log[10](b) * otherBaseIntegerPartDigitCount)\r\n    // log[10](2) = 0.30103, log[10](8) = 0.90309, log[10](16) = 1.20412\r\n    // E.g. ceil(1.2 * 3) = 4, so up to 4 decimal digits are needed to represent 3 hex int digits.\r\n    // maxDecimalFractionPartDigitCount = {Hex:4|Oct:3|Bin:1} * otherBaseFractionPartDigitCount\r\n    // Therefore using 4 * the number of digits of str will always be enough.\r\n    if (isFloat) x = divide(x, divisor, len * 4);\r\n\r\n    // Multiply by the binary exponent part if present.\r\n    if (p) x = x.times(Math.abs(p) < 54 ? mathpow(2, p) : Decimal.pow(2, p));\r\n    external = true;\r\n\r\n    return x;\r\n  }\r\n\r\n\r\n  /*\r\n   * sin(x) = x - x^3/3! + x^5/5! - ...\r\n   * |x| < pi/2\r\n   *\r\n   */\r\n  function sine(Ctor, x) {\r\n    var k,\r\n      len = x.d.length;\r\n\r\n    if (len < 3) {\r\n      return x.isZero() ? x : taylorSeries(Ctor, 2, x, x);\r\n    }\r\n\r\n    // Argument reduction: sin(5x) = 16*sin^5(x) - 20*sin^3(x) + 5*sin(x)\r\n    // i.e. sin(x) = 16*sin^5(x/5) - 20*sin^3(x/5) + 5*sin(x/5)\r\n    // and  sin(x) = sin(x/5)(5 + sin^2(x/5)(16sin^2(x/5) - 20))\r\n\r\n    // Estimate the optimum number of times to use the argument reduction.\r\n    k = 1.4 * Math.sqrt(len);\r\n    k = k > 16 ? 16 : k | 0;\r\n\r\n    x = x.times(1 / tinyPow(5, k));\r\n    x = taylorSeries(Ctor, 2, x, x);\r\n\r\n    // Reverse argument reduction\r\n    var sin2_x,\r\n      d5 = new Ctor(5),\r\n      d16 = new Ctor(16),\r\n      d20 = new Ctor(20);\r\n    for (; k--;) {\r\n      sin2_x = x.times(x);\r\n      x = x.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));\r\n    }\r\n\r\n    return x;\r\n  }\r\n\r\n\r\n  // Calculate Taylor series for `cos`, `cosh`, `sin` and `sinh`.\r\n  function taylorSeries(Ctor, n, x, y, isHyperbolic) {\r\n    var j, t, u, x2,\r\n      i = 1,\r\n      pr = Ctor.precision,\r\n      k = Math.ceil(pr / LOG_BASE);\r\n\r\n    external = false;\r\n    x2 = x.times(x);\r\n    u = new Ctor(y);\r\n\r\n    for (;;) {\r\n      t = divide(u.times(x2), new Ctor(n++ * n++), pr, 1);\r\n      u = isHyperbolic ? y.plus(t) : y.minus(t);\r\n      y = divide(t.times(x2), new Ctor(n++ * n++), pr, 1);\r\n      t = u.plus(y);\r\n\r\n      if (t.d[k] !== void 0) {\r\n        for (j = k; t.d[j] === u.d[j] && j--;);\r\n        if (j == -1) break;\r\n      }\r\n\r\n      j = u;\r\n      u = y;\r\n      y = t;\r\n      t = j;\r\n      i++;\r\n    }\r\n\r\n    external = true;\r\n    t.d.length = k + 1;\r\n\r\n    return t;\r\n  }\r\n\r\n\r\n  // Exponent e must be positive and non-zero.\r\n  function tinyPow(b, e) {\r\n    var n = b;\r\n    while (--e) n *= b;\r\n    return n;\r\n  }\r\n\r\n\r\n  // Return the absolute value of `x` reduced to less than or equal to half pi.\r\n  function toLessThanHalfPi(Ctor, x) {\r\n    var t,\r\n      isNeg = x.s < 0,\r\n      pi = getPi(Ctor, Ctor.precision, 1),\r\n      halfPi = pi.times(0.5);\r\n\r\n    x = x.abs();\r\n\r\n    if (x.lte(halfPi)) {\r\n      quadrant = isNeg ? 4 : 1;\r\n      return x;\r\n    }\r\n\r\n    t = x.divToInt(pi);\r\n\r\n    if (t.isZero()) {\r\n      quadrant = isNeg ? 3 : 2;\r\n    } else {\r\n      x = x.minus(t.times(pi));\r\n\r\n      // 0 <= x < pi\r\n      if (x.lte(halfPi)) {\r\n        quadrant = isOdd(t) ? (isNeg ? 2 : 3) : (isNeg ? 4 : 1);\r\n        return x;\r\n      }\r\n\r\n      quadrant = isOdd(t) ? (isNeg ? 1 : 4) : (isNeg ? 3 : 2);\r\n    }\r\n\r\n    return x.minus(pi).abs();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return the value of Decimal `x` as a string in base `baseOut`.\r\n   *\r\n   * If the optional `sd` argument is present include a binary exponent suffix.\r\n   */\r\n  function toStringBinary(x, baseOut, sd, rm) {\r\n    var base, e, i, k, len, roundUp, str, xd, y,\r\n      Ctor = x.constructor,\r\n      isExp = sd !== void 0;\r\n\r\n    if (isExp) {\r\n      checkInt32(sd, 1, MAX_DIGITS);\r\n      if (rm === void 0) rm = Ctor.rounding;\r\n      else checkInt32(rm, 0, 8);\r\n    } else {\r\n      sd = Ctor.precision;\r\n      rm = Ctor.rounding;\r\n    }\r\n\r\n    if (!x.isFinite()) {\r\n      str = nonFiniteToString(x);\r\n    } else {\r\n      str = finiteToString(x);\r\n      i = str.indexOf('.');\r\n\r\n      // Use exponential notation according to `toExpPos` and `toExpNeg`? No, but if required:\r\n      // maxBinaryExponent = floor((decimalExponent + 1) * log[2](10))\r\n      // minBinaryExponent = floor(decimalExponent * log[2](10))\r\n      // log[2](10) = 3.321928094887362347870319429489390175864\r\n\r\n      if (isExp) {\r\n        base = 2;\r\n        if (baseOut == 16) {\r\n          sd = sd * 4 - 3;\r\n        } else if (baseOut == 8) {\r\n          sd = sd * 3 - 2;\r\n        }\r\n      } else {\r\n        base = baseOut;\r\n      }\r\n\r\n      // Convert the number as an integer then divide the result by its base raised to a power such\r\n      // that the fraction part will be restored.\r\n\r\n      // Non-integer.\r\n      if (i >= 0) {\r\n        str = str.replace('.', '');\r\n        y = new Ctor(1);\r\n        y.e = str.length - i;\r\n        y.d = convertBase(finiteToString(y), 10, base);\r\n        y.e = y.d.length;\r\n      }\r\n\r\n      xd = convertBase(str, 10, base);\r\n      e = len = xd.length;\r\n\r\n      // Remove trailing zeros.\r\n      for (; xd[--len] == 0;) xd.pop();\r\n\r\n      if (!xd[0]) {\r\n        str = isExp ? '0p+0' : '0';\r\n      } else {\r\n        if (i < 0) {\r\n          e--;\r\n        } else {\r\n          x = new Ctor(x);\r\n          x.d = xd;\r\n          x.e = e;\r\n          x = divide(x, y, sd, rm, 0, base);\r\n          xd = x.d;\r\n          e = x.e;\r\n          roundUp = inexact;\r\n        }\r\n\r\n        // The rounding digit, i.e. the digit after the digit that may be rounded up.\r\n        i = xd[sd];\r\n        k = base / 2;\r\n        roundUp = roundUp || xd[sd + 1] !== void 0;\r\n\r\n        roundUp = rm < 4\r\n          ? (i !== void 0 || roundUp) && (rm === 0 || rm === (x.s < 0 ? 3 : 2))\r\n          : i > k || i === k && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 ||\r\n            rm === (x.s < 0 ? 8 : 7));\r\n\r\n        xd.length = sd;\r\n\r\n        if (roundUp) {\r\n\r\n          // Rounding up may mean the previous digit has to be rounded up and so on.\r\n          for (; ++xd[--sd] > base - 1;) {\r\n            xd[sd] = 0;\r\n            if (!sd) {\r\n              ++e;\r\n              xd.unshift(1);\r\n            }\r\n          }\r\n        }\r\n\r\n        // Determine trailing zeros.\r\n        for (len = xd.length; !xd[len - 1]; --len);\r\n\r\n        // E.g. [4, 11, 15] becomes 4bf.\r\n        for (i = 0, str = ''; i < len; i++) str += NUMERALS.charAt(xd[i]);\r\n\r\n        // Add binary exponent suffix?\r\n        if (isExp) {\r\n          if (len > 1) {\r\n            if (baseOut == 16 || baseOut == 8) {\r\n              i = baseOut == 16 ? 4 : 3;\r\n              for (--len; len % i; len++) str += '0';\r\n              xd = convertBase(str, base, baseOut);\r\n              for (len = xd.length; !xd[len - 1]; --len);\r\n\r\n              // xd[0] will always be be 1\r\n              for (i = 1, str = '1.'; i < len; i++) str += NUMERALS.charAt(xd[i]);\r\n            } else {\r\n              str = str.charAt(0) + '.' + str.slice(1);\r\n            }\r\n          }\r\n\r\n          str =  str + (e < 0 ? 'p' : 'p+') + e;\r\n        } else if (e < 0) {\r\n          for (; ++e;) str = '0' + str;\r\n          str = '0.' + str;\r\n        } else {\r\n          if (++e > len) for (e -= len; e-- ;) str += '0';\r\n          else if (e < len) str = str.slice(0, e) + '.' + str.slice(e);\r\n        }\r\n      }\r\n\r\n      str = (baseOut == 16 ? '0x' : baseOut == 2 ? '0b' : baseOut == 8 ? '0o' : '') + str;\r\n    }\r\n\r\n    return x.s < 0 ? '-' + str : str;\r\n  }\r\n\r\n\r\n  // Does not strip trailing zeros.\r\n  function truncate(arr, len) {\r\n    if (arr.length > len) {\r\n      arr.length = len;\r\n      return true;\r\n    }\r\n  }\r\n\r\n\r\n  // Decimal methods\r\n\r\n\r\n  /*\r\n   *  abs\r\n   *  acos\r\n   *  acosh\r\n   *  add\r\n   *  asin\r\n   *  asinh\r\n   *  atan\r\n   *  atanh\r\n   *  atan2\r\n   *  cbrt\r\n   *  ceil\r\n   *  clamp\r\n   *  clone\r\n   *  config\r\n   *  cos\r\n   *  cosh\r\n   *  div\r\n   *  exp\r\n   *  floor\r\n   *  hypot\r\n   *  ln\r\n   *  log\r\n   *  log2\r\n   *  log10\r\n   *  max\r\n   *  min\r\n   *  mod\r\n   *  mul\r\n   *  pow\r\n   *  random\r\n   *  round\r\n   *  set\r\n   *  sign\r\n   *  sin\r\n   *  sinh\r\n   *  sqrt\r\n   *  sub\r\n   *  sum\r\n   *  tan\r\n   *  tanh\r\n   *  trunc\r\n   */\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the absolute value of `x`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function abs(x) {\r\n    return new this(x).abs();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the arccosine in radians of `x`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function acos(x) {\r\n    return new this(x).acos();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the inverse of the hyperbolic cosine of `x`, rounded to\r\n   * `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\r\n  function acosh(x) {\r\n    return new this(x).acosh();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the sum of `x` and `y`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   * y {number|string|Decimal}\r\n   *\r\n   */\r\n  function add(x, y) {\r\n    return new this(x).plus(y);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the arcsine in radians of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function asin(x) {\r\n    return new this(x).asin();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the inverse of the hyperbolic sine of `x`, rounded to\r\n   * `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\r\n  function asinh(x) {\r\n    return new this(x).asinh();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the arctangent in radians of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function atan(x) {\r\n    return new this(x).atan();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the inverse of the hyperbolic tangent of `x`, rounded to\r\n   * `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\r\n  function atanh(x) {\r\n    return new this(x).atanh();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the arctangent in radians of `y/x` in the range -pi to pi\r\n   * (inclusive), rounded to `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-pi, pi]\r\n   *\r\n   * y {number|string|Decimal} The y-coordinate.\r\n   * x {number|string|Decimal} The x-coordinate.\r\n   *\r\n   * atan2(±0, -0)               = ±pi\r\n   * atan2(±0, +0)               = ±0\r\n   * atan2(±0, -x)               = ±pi for x > 0\r\n   * atan2(±0, x)                = ±0 for x > 0\r\n   * atan2(-y, ±0)               = -pi/2 for y > 0\r\n   * atan2(y, ±0)                = pi/2 for y > 0\r\n   * atan2(±y, -Infinity)        = ±pi for finite y > 0\r\n   * atan2(±y, +Infinity)        = ±0 for finite y > 0\r\n   * atan2(±Infinity, x)         = ±pi/2 for finite x\r\n   * atan2(±Infinity, -Infinity) = ±3*pi/4\r\n   * atan2(±Infinity, +Infinity) = ±pi/4\r\n   * atan2(NaN, x) = NaN\r\n   * atan2(y, NaN) = NaN\r\n   *\r\n   */\r\n  function atan2(y, x) {\r\n    y = new this(y);\r\n    x = new this(x);\r\n    var r,\r\n      pr = this.precision,\r\n      rm = this.rounding,\r\n      wpr = pr + 4;\r\n\r\n    // Either NaN\r\n    if (!y.s || !x.s) {\r\n      r = new this(NaN);\r\n\r\n    // Both ±Infinity\r\n    } else if (!y.d && !x.d) {\r\n      r = getPi(this, wpr, 1).times(x.s > 0 ? 0.25 : 0.75);\r\n      r.s = y.s;\r\n\r\n    // x is ±Infinity or y is ±0\r\n    } else if (!x.d || y.isZero()) {\r\n      r = x.s < 0 ? getPi(this, pr, rm) : new this(0);\r\n      r.s = y.s;\r\n\r\n    // y is ±Infinity or x is ±0\r\n    } else if (!y.d || x.isZero()) {\r\n      r = getPi(this, wpr, 1).times(0.5);\r\n      r.s = y.s;\r\n\r\n    // Both non-zero and finite\r\n    } else if (x.s < 0) {\r\n      this.precision = wpr;\r\n      this.rounding = 1;\r\n      r = this.atan(divide(y, x, wpr, 1));\r\n      x = getPi(this, wpr, 1);\r\n      this.precision = pr;\r\n      this.rounding = rm;\r\n      r = y.s < 0 ? r.minus(x) : r.plus(x);\r\n    } else {\r\n      r = this.atan(divide(y, x, wpr, 1));\r\n    }\r\n\r\n    return r;\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the cube root of `x`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function cbrt(x) {\r\n    return new this(x).cbrt();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` rounded to an integer using `ROUND_CEIL`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function ceil(x) {\r\n    return finalise(x = new this(x), x.e + 1, 2);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` clamped to the range delineated by `min` and `max`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   * min {number|string|Decimal}\r\n   * max {number|string|Decimal}\r\n   *\r\n   */\r\n  function clamp(x, min, max) {\r\n    return new this(x).clamp(min, max);\r\n  }\r\n\r\n\r\n  /*\r\n   * Configure global settings for a Decimal constructor.\r\n   *\r\n   * `obj` is an object with one or more of the following properties,\r\n   *\r\n   *   precision  {number}\r\n   *   rounding   {number}\r\n   *   toExpNeg   {number}\r\n   *   toExpPos   {number}\r\n   *   maxE       {number}\r\n   *   minE       {number}\r\n   *   modulo     {number}\r\n   *   crypto     {boolean|number}\r\n   *   defaults   {true}\r\n   *\r\n   * E.g. Decimal.config({ precision: 20, rounding: 4 })\r\n   *\r\n   */\r\n  function config(obj) {\r\n    if (!obj || typeof obj !== 'object') throw Error(decimalError + 'Object expected');\r\n    var i, p, v,\r\n      useDefaults = obj.defaults === true,\r\n      ps = [\r\n        'precision', 1, MAX_DIGITS,\r\n        'rounding', 0, 8,\r\n        'toExpNeg', -EXP_LIMIT, 0,\r\n        'toExpPos', 0, EXP_LIMIT,\r\n        'maxE', 0, EXP_LIMIT,\r\n        'minE', -EXP_LIMIT, 0,\r\n        'modulo', 0, 9\r\n      ];\r\n\r\n    for (i = 0; i < ps.length; i += 3) {\r\n      if (p = ps[i], useDefaults) this[p] = DEFAULTS[p];\r\n      if ((v = obj[p]) !== void 0) {\r\n        if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2]) this[p] = v;\r\n        else throw Error(invalidArgument + p + ': ' + v);\r\n      }\r\n    }\r\n\r\n    if (p = 'crypto', useDefaults) this[p] = DEFAULTS[p];\r\n    if ((v = obj[p]) !== void 0) {\r\n      if (v === true || v === false || v === 0 || v === 1) {\r\n        if (v) {\r\n          if (typeof crypto != 'undefined' && crypto &&\r\n            (crypto.getRandomValues || crypto.randomBytes)) {\r\n            this[p] = true;\r\n          } else {\r\n            throw Error(cryptoUnavailable);\r\n          }\r\n        } else {\r\n          this[p] = false;\r\n        }\r\n      } else {\r\n        throw Error(invalidArgument + p + ': ' + v);\r\n      }\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the cosine of `x`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\r\n  function cos(x) {\r\n    return new this(x).cos();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the hyperbolic cosine of `x`, rounded to precision\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\r\n  function cosh(x) {\r\n    return new this(x).cosh();\r\n  }\r\n\r\n\r\n  /*\r\n   * Create and return a Decimal constructor with the same configuration properties as this Decimal\r\n   * constructor.\r\n   *\r\n   */\r\n  function clone(obj) {\r\n    var i, p, ps;\r\n\r\n    /*\r\n     * The Decimal constructor and exported function.\r\n     * Return a new Decimal instance.\r\n     *\r\n     * v {number|string|Decimal} A numeric value.\r\n     *\r\n     */\r\n    function Decimal(v) {\r\n      var e, i, t,\r\n        x = this;\r\n\r\n      // Decimal called without new.\r\n      if (!(x instanceof Decimal)) return new Decimal(v);\r\n\r\n      // Retain a reference to this Decimal constructor, and shadow Decimal.prototype.constructor\r\n      // which points to Object.\r\n      x.constructor = Decimal;\r\n\r\n      // Duplicate.\r\n      if (isDecimalInstance(v)) {\r\n        x.s = v.s;\r\n\r\n        if (external) {\r\n          if (!v.d || v.e > Decimal.maxE) {\r\n\r\n            // Infinity.\r\n            x.e = NaN;\r\n            x.d = null;\r\n          } else if (v.e < Decimal.minE) {\r\n\r\n            // Zero.\r\n            x.e = 0;\r\n            x.d = [0];\r\n          } else {\r\n            x.e = v.e;\r\n            x.d = v.d.slice();\r\n          }\r\n        } else {\r\n          x.e = v.e;\r\n          x.d = v.d ? v.d.slice() : v.d;\r\n        }\r\n\r\n        return;\r\n      }\r\n\r\n      t = typeof v;\r\n\r\n      if (t === 'number') {\r\n        if (v === 0) {\r\n          x.s = 1 / v < 0 ? -1 : 1;\r\n          x.e = 0;\r\n          x.d = [0];\r\n          return;\r\n        }\r\n\r\n        if (v < 0) {\r\n          v = -v;\r\n          x.s = -1;\r\n        } else {\r\n          x.s = 1;\r\n        }\r\n\r\n        // Fast path for small integers.\r\n        if (v === ~~v && v < 1e7) {\r\n          for (e = 0, i = v; i >= 10; i /= 10) e++;\r\n\r\n          if (external) {\r\n            if (e > Decimal.maxE) {\r\n              x.e = NaN;\r\n              x.d = null;\r\n            } else if (e < Decimal.minE) {\r\n              x.e = 0;\r\n              x.d = [0];\r\n            } else {\r\n              x.e = e;\r\n              x.d = [v];\r\n            }\r\n          } else {\r\n            x.e = e;\r\n            x.d = [v];\r\n          }\r\n\r\n          return;\r\n\r\n        // Infinity, NaN.\r\n        } else if (v * 0 !== 0) {\r\n          if (!v) x.s = NaN;\r\n          x.e = NaN;\r\n          x.d = null;\r\n          return;\r\n        }\r\n\r\n        return parseDecimal(x, v.toString());\r\n\r\n      } else if (t !== 'string') {\r\n        throw Error(invalidArgument + v);\r\n      }\r\n\r\n      // Minus sign?\r\n      if ((i = v.charCodeAt(0)) === 45) {\r\n        v = v.slice(1);\r\n        x.s = -1;\r\n      } else {\r\n        // Plus sign?\r\n        if (i === 43) v = v.slice(1);\r\n        x.s = 1;\r\n      }\r\n\r\n      return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);\r\n    }\r\n\r\n    Decimal.prototype = P;\r\n\r\n    Decimal.ROUND_UP = 0;\r\n    Decimal.ROUND_DOWN = 1;\r\n    Decimal.ROUND_CEIL = 2;\r\n    Decimal.ROUND_FLOOR = 3;\r\n    Decimal.ROUND_HALF_UP = 4;\r\n    Decimal.ROUND_HALF_DOWN = 5;\r\n    Decimal.ROUND_HALF_EVEN = 6;\r\n    Decimal.ROUND_HALF_CEIL = 7;\r\n    Decimal.ROUND_HALF_FLOOR = 8;\r\n    Decimal.EUCLID = 9;\r\n\r\n    Decimal.config = Decimal.set = config;\r\n    Decimal.clone = clone;\r\n    Decimal.isDecimal = isDecimalInstance;\r\n\r\n    Decimal.abs = abs;\r\n    Decimal.acos = acos;\r\n    Decimal.acosh = acosh;        // ES6\r\n    Decimal.add = add;\r\n    Decimal.asin = asin;\r\n    Decimal.asinh = asinh;        // ES6\r\n    Decimal.atan = atan;\r\n    Decimal.atanh = atanh;        // ES6\r\n    Decimal.atan2 = atan2;\r\n    Decimal.cbrt = cbrt;          // ES6\r\n    Decimal.ceil = ceil;\r\n    Decimal.clamp = clamp;\r\n    Decimal.cos = cos;\r\n    Decimal.cosh = cosh;          // ES6\r\n    Decimal.div = div;\r\n    Decimal.exp = exp;\r\n    Decimal.floor = floor;\r\n    Decimal.hypot = hypot;        // ES6\r\n    Decimal.ln = ln;\r\n    Decimal.log = log;\r\n    Decimal.log10 = log10;        // ES6\r\n    Decimal.log2 = log2;          // ES6\r\n    Decimal.max = max;\r\n    Decimal.min = min;\r\n    Decimal.mod = mod;\r\n    Decimal.mul = mul;\r\n    Decimal.pow = pow;\r\n    Decimal.random = random;\r\n    Decimal.round = round;\r\n    Decimal.sign = sign;          // ES6\r\n    Decimal.sin = sin;\r\n    Decimal.sinh = sinh;          // ES6\r\n    Decimal.sqrt = sqrt;\r\n    Decimal.sub = sub;\r\n    Decimal.sum = sum;\r\n    Decimal.tan = tan;\r\n    Decimal.tanh = tanh;          // ES6\r\n    Decimal.trunc = trunc;        // ES6\r\n\r\n    if (obj === void 0) obj = {};\r\n    if (obj) {\r\n      if (obj.defaults !== true) {\r\n        ps = ['precision', 'rounding', 'toExpNeg', 'toExpPos', 'maxE', 'minE', 'modulo', 'crypto'];\r\n        for (i = 0; i < ps.length;) if (!obj.hasOwnProperty(p = ps[i++])) obj[p] = this[p];\r\n      }\r\n    }\r\n\r\n    Decimal.config(obj);\r\n\r\n    return Decimal;\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` divided by `y`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   * y {number|string|Decimal}\r\n   *\r\n   */\r\n  function div(x, y) {\r\n    return new this(x).div(y);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the natural exponential of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} The power to which to raise the base of the natural log.\r\n   *\r\n   */\r\n  function exp(x) {\r\n    return new this(x).exp();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` round to an integer using `ROUND_FLOOR`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function floor(x) {\r\n    return finalise(x = new this(x), x.e + 1, 3);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the square root of the sum of the squares of the arguments,\r\n   * rounded to `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * hypot(a, b, ...) = sqrt(a^2 + b^2 + ...)\r\n   *\r\n   * arguments {number|string|Decimal}\r\n   *\r\n   */\r\n  function hypot() {\r\n    var i, n,\r\n      t = new this(0);\r\n\r\n    external = false;\r\n\r\n    for (i = 0; i < arguments.length;) {\r\n      n = new this(arguments[i++]);\r\n      if (!n.d) {\r\n        if (n.s) {\r\n          external = true;\r\n          return new this(1 / 0);\r\n        }\r\n        t = n;\r\n      } else if (t.d) {\r\n        t = t.plus(n.times(n));\r\n      }\r\n    }\r\n\r\n    external = true;\r\n\r\n    return t.sqrt();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return true if object is a Decimal instance (where Decimal is any Decimal constructor),\r\n   * otherwise return false.\r\n   *\r\n   */\r\n  function isDecimalInstance(obj) {\r\n    return obj instanceof Decimal || obj && obj.toStringTag === tag || false;\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the natural logarithm of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function ln(x) {\r\n    return new this(x).ln();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the log of `x` to the base `y`, or to base 10 if no base\r\n   * is specified, rounded to `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * log[y](x)\r\n   *\r\n   * x {number|string|Decimal} The argument of the logarithm.\r\n   * y {number|string|Decimal} The base of the logarithm.\r\n   *\r\n   */\r\n  function log(x, y) {\r\n    return new this(x).log(y);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the base 2 logarithm of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function log2(x) {\r\n    return new this(x).log(2);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the base 10 logarithm of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function log10(x) {\r\n    return new this(x).log(10);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the maximum of the arguments.\r\n   *\r\n   * arguments {number|string|Decimal}\r\n   *\r\n   */\r\n  function max() {\r\n    return maxOrMin(this, arguments, 'lt');\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the minimum of the arguments.\r\n   *\r\n   * arguments {number|string|Decimal}\r\n   *\r\n   */\r\n  function min() {\r\n    return maxOrMin(this, arguments, 'gt');\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` modulo `y`, rounded to `precision` significant digits\r\n   * using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   * y {number|string|Decimal}\r\n   *\r\n   */\r\n  function mod(x, y) {\r\n    return new this(x).mod(y);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` multiplied by `y`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   * y {number|string|Decimal}\r\n   *\r\n   */\r\n  function mul(x, y) {\r\n    return new this(x).mul(y);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` raised to the power `y`, rounded to precision\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} The base.\r\n   * y {number|string|Decimal} The exponent.\r\n   *\r\n   */\r\n  function pow(x, y) {\r\n    return new this(x).pow(y);\r\n  }\r\n\r\n\r\n  /*\r\n   * Returns a new Decimal with a random value equal to or greater than 0 and less than 1, and with\r\n   * `sd`, or `Decimal.precision` if `sd` is omitted, significant digits (or less if trailing zeros\r\n   * are produced).\r\n   *\r\n   * [sd] {number} Significant digits. Integer, 0 to MAX_DIGITS inclusive.\r\n   *\r\n   */\r\n  function random(sd) {\r\n    var d, e, k, n,\r\n      i = 0,\r\n      r = new this(1),\r\n      rd = [];\r\n\r\n    if (sd === void 0) sd = this.precision;\r\n    else checkInt32(sd, 1, MAX_DIGITS);\r\n\r\n    k = Math.ceil(sd / LOG_BASE);\r\n\r\n    if (!this.crypto) {\r\n      for (; i < k;) rd[i++] = Math.random() * 1e7 | 0;\r\n\r\n    // Browsers supporting crypto.getRandomValues.\r\n    } else if (crypto.getRandomValues) {\r\n      d = crypto.getRandomValues(new Uint32Array(k));\r\n\r\n      for (; i < k;) {\r\n        n = d[i];\r\n\r\n        // 0 <= n < 4294967296\r\n        // Probability n >= 4.29e9, is 4967296 / 4294967296 = 0.00116 (1 in 865).\r\n        if (n >= 4.29e9) {\r\n          d[i] = crypto.getRandomValues(new Uint32Array(1))[0];\r\n        } else {\r\n\r\n          // 0 <= n <= 4289999999\r\n          // 0 <= (n % 1e7) <= 9999999\r\n          rd[i++] = n % 1e7;\r\n        }\r\n      }\r\n\r\n    // Node.js supporting crypto.randomBytes.\r\n    } else if (crypto.randomBytes) {\r\n\r\n      // buffer\r\n      d = crypto.randomBytes(k *= 4);\r\n\r\n      for (; i < k;) {\r\n\r\n        // 0 <= n < 2147483648\r\n        n = d[i] + (d[i + 1] << 8) + (d[i + 2] << 16) + ((d[i + 3] & 0x7f) << 24);\r\n\r\n        // Probability n >= 2.14e9, is 7483648 / 2147483648 = 0.0035 (1 in 286).\r\n        if (n >= 2.14e9) {\r\n          crypto.randomBytes(4).copy(d, i);\r\n        } else {\r\n\r\n          // 0 <= n <= 2139999999\r\n          // 0 <= (n % 1e7) <= 9999999\r\n          rd.push(n % 1e7);\r\n          i += 4;\r\n        }\r\n      }\r\n\r\n      i = k / 4;\r\n    } else {\r\n      throw Error(cryptoUnavailable);\r\n    }\r\n\r\n    k = rd[--i];\r\n    sd %= LOG_BASE;\r\n\r\n    // Convert trailing digits to zeros according to sd.\r\n    if (k && sd) {\r\n      n = mathpow(10, LOG_BASE - sd);\r\n      rd[i] = (k / n | 0) * n;\r\n    }\r\n\r\n    // Remove trailing words which are zero.\r\n    for (; rd[i] === 0; i--) rd.pop();\r\n\r\n    // Zero?\r\n    if (i < 0) {\r\n      e = 0;\r\n      rd = [0];\r\n    } else {\r\n      e = -1;\r\n\r\n      // Remove leading words which are zero and adjust exponent accordingly.\r\n      for (; rd[0] === 0; e -= LOG_BASE) rd.shift();\r\n\r\n      // Count the digits of the first word of rd to determine leading zeros.\r\n      for (k = 1, n = rd[0]; n >= 10; n /= 10) k++;\r\n\r\n      // Adjust the exponent for leading zeros of the first word of rd.\r\n      if (k < LOG_BASE) e -= LOG_BASE - k;\r\n    }\r\n\r\n    r.e = e;\r\n    r.d = rd;\r\n\r\n    return r;\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` rounded to an integer using rounding mode `rounding`.\r\n   *\r\n   * To emulate `Math.round`, set rounding to 7 (ROUND_HALF_CEIL).\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function round(x) {\r\n    return finalise(x = new this(x), x.e + 1, this.rounding);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return\r\n   *   1    if x > 0,\r\n   *  -1    if x < 0,\r\n   *   0    if x is 0,\r\n   *  -0    if x is -0,\r\n   *   NaN  otherwise\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function sign(x) {\r\n    x = new this(x);\r\n    return x.d ? (x.d[0] ? x.s : 0 * x.s) : x.s || NaN;\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the sine of `x`, rounded to `precision` significant digits\r\n   * using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\r\n  function sin(x) {\r\n    return new this(x).sin();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the hyperbolic sine of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\r\n  function sinh(x) {\r\n    return new this(x).sinh();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the square root of `x`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function sqrt(x) {\r\n    return new this(x).sqrt();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` minus `y`, rounded to `precision` significant digits\r\n   * using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   * y {number|string|Decimal}\r\n   *\r\n   */\r\n  function sub(x, y) {\r\n    return new this(x).sub(y);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the sum of the arguments, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * Only the result is rounded, not the intermediate calculations.\r\n   *\r\n   * arguments {number|string|Decimal}\r\n   *\r\n   */\r\n  function sum() {\r\n    var i = 0,\r\n      args = arguments,\r\n      x = new this(args[i]);\r\n\r\n    external = false;\r\n    for (; x.s && ++i < args.length;) x = x.plus(args[i]);\r\n    external = true;\r\n\r\n    return finalise(x, this.precision, this.rounding);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the tangent of `x`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\r\n  function tan(x) {\r\n    return new this(x).tan();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the hyperbolic tangent of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\r\n  function tanh(x) {\r\n    return new this(x).tanh();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` truncated to an integer.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function trunc(x) {\r\n    return finalise(x = new this(x), x.e + 1, 1);\r\n  }\r\n\r\n\r\n  // Create and configure initial Decimal constructor.\r\n  Decimal = clone(DEFAULTS);\r\n  Decimal.prototype.constructor = Decimal;\r\n  Decimal['default'] = Decimal.Decimal = Decimal;\r\n\r\n  // Create the internal constants from their string values.\r\n  LN10 = new Decimal(LN10);\r\n  PI = new Decimal(PI);\r\n\r\n\r\n  // Export.\r\n\r\n\r\n  // AMD.\r\n  if (typeof define == 'function' && define.amd) {\r\n    define(function () {\r\n      return Decimal;\r\n    });\r\n\r\n  // Node and other environments that support module.exports.\r\n  } else if (typeof module != 'undefined' && module.exports) {\r\n    if (typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol') {\r\n      P[Symbol['for']('nodejs.util.inspect.custom')] = P.toString;\r\n      P[Symbol.toStringTag] = 'Decimal';\r\n    }\r\n\r\n    module.exports = Decimal;\r\n\r\n  // Browser.\r\n  } else {\r\n    if (!globalScope) {\r\n      globalScope = typeof self != 'undefined' && self && self.self == self ? self : window;\r\n    }\r\n\r\n    noConflict = globalScope.Decimal;\r\n    Decimal.noConflict = function () {\r\n      globalScope.Decimal = noConflict;\r\n      return Decimal;\r\n    };\r\n\r\n    globalScope.Decimal = Decimal;\r\n  }\r\n})(this);\r\n\n},{}],2:[function(require,module,exports){\n/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\n\n/**\n* Instruction Set Bace Class.\n*\n* @class ElucidatorInstructionSet\n*/\nclass ElucidatorInstructionSet\n{\n    constructor(pElucidator)\n    {\n        this.elucidator = pElucidator;\n\n        this.namespace = 'default';\n    }\n\n    // Create an empty namespace for instructions and operations if either one doesn't exist\n    initializeNamespace(pNamespace)\n    {\n        if (typeof(pNamespace) == 'string')\n        {\n            this.namespace = pNamespace;\n        }\n        if (!this.elucidator.instructionSets.hasOwnProperty(this.namespace))\n        {\n            this.elucidator.instructionSets[this.namespace.toLowerCase()] = {};\n        }\n        if (!this.elucidator.operationSets.hasOwnProperty(this.namespace))\n        {\n            this.elucidator.operationSets[this.namespace.toLowerCase()] = {};\n        }\n    }\n\n    // Add an instruction to the set\n    addInstruction(pInstructionHash, fInstructionFunction)\n    {\n        if (typeof(pInstructionHash) != 'string')\n        {\n            this.elucidator.logError(`Attempted to add an instruction with an invalid hash; expected a string but the instruction hash type was ${typeof(pInstructionHash)}`);\n            return false;\n        }\n        if (typeof(fInstructionFunction) != 'function')\n        {\n            this.elucidator.logError(`Attempted to add an instruction with an invalid function; expected a function but type was ${typeof(fInstructionFunction)}`);\n            return false;\n        }\n\n        this.elucidator.instructionSets[this.namespace.toLowerCase()][pInstructionHash] = fInstructionFunction;\n        return true;\n    }\n\n    initializeInstructions()\n    {\n        // This is where we map in the instructions.\n        // If the extending class calls super it will inject a harmless noop into the scope.\n        // It isn't recommended to do these inline as lambdas, but this code is generally not expected to be called.\n        // Unless the developer wants a noop in their instruction set...........\n        this.addInstruction('noop', \n            (pOperation) =>\n            {\n                pOperation.logInfo('Executing a no-operation operation.');\n                return true;\n            });\n\n        return true;\n    }\n\n    // Add an operation to the set\n    addOperation(pOperationHash, pOperation)\n    {\n        if (typeof(pOperationHash) != 'string')\n        {\n            this.elucidator.logError(`Attempted to add an operation with an invalid hash; expected a string but the operation hash type was ${typeof(pOperationHash)}`, pOperation);\n            return false;\n        }\n        if (typeof(pOperation) != 'object')\n        {\n            this.elucidator.logError(`Attempted to add an invalid operation; expected an object data type but the type was ${typeof(pOperation)}`, pOperation);\n            return false;\n        }\n        // Validate the Description subobject, which is key to functioning.\n        if (!pOperation.hasOwnProperty(\"Description\"))\n        {\n            this.elucidator.logError(`Attempted to add an operation with an invalid description; no Description subobject set.`, pOperation);\n            return false;\n        }\n        if (typeof(pOperation.Description) != 'object')\n        {\n            this.elucidator.logError(`Attempted to add an operation with an invalid description; Description subobject was not an object.  The type was ${typeof(pOperation.Description)}.`, pOperation);\n            return false;\n        }\n        if (typeof(pOperation.Description.Hash) != 'string')\n        {\n            if (typeof(pOperation.Description.Operation) == 'string')\n            {\n                // Use the \"Operation\" as the \"Hash\"\n                pOperation.Description.Hash = pOperation.Description.Operation;\n            }\n            else\n            {\n                this.elucidator.logError(`Attempted to add an operation with an invalid description; Description subobject did not contain a valid Hash which is required to call the operation.`, pOperation);\n                return false;\n            }\n        }\n\n        // Now auto create data if it is missing or wrong in the Description\n        if ((typeof(pOperation.Description.Namespace) != 'string') || (pOperation.Description.Namespace != this.namespace))\n        {\n            pOperation.Description.Namespace = this.namespace;\n        }\n        if (typeof(pOperation.Description.Summary) != 'string')\n        {\n            pOperation.Description.Summary = `[${pOperation.Description.Namespace}] [${pOperation.Description.Hash}] operation.`;\n        }\n\n        // If there are no inputs, or outputs, or steps, add them.\n        if (!pOperation.hasOwnProperty('Inputs'))\n        {\n            pOperation.Inputs = {};\n        }\n        if (!pOperation.hasOwnProperty('Outputs'))\n        {\n            pOperation.Outputs = {};\n        }\n        if (!pOperation.hasOwnProperty('Steps'))\n        {\n            pOperation.Steps = [];\n        }\n\n        // If there are no inputs, or outputs, or steps, add them.\n        // TODO: Add a step where we try to load this into Manyfest and see that it's valid.\n        if (typeof(pOperation.Inputs) !== 'object')\n        {\n            this.elucidator.logError(`Attempted to add an operation with an invalid Inputs object.`, pOperation);\n            return false;\n        }\n        // If there are no inputs, or outputs, or steps, add them.\n        // TODO: Add a step where we try to load this into Manyfest and see that it's valid.\n        if (typeof(pOperation.Outputs) !== 'object')\n        {\n            this.elucidator.logError(`Attempted to add an operation with an invalid Outputs object.`, pOperation);\n            return false;\n        }\n        if (!Array.isArray(pOperation.Steps))\n        {\n            this.elucidator.logError(`Attempted to add an operation with an invalid Steps array.`, pOperation);\n            return false;\n        }\n\n\n        this.elucidator.operationSets[this.namespace.toLowerCase()][pOperationHash.toLowerCase()] = pOperation;\n        return true;\n    }\n\n    initializeOperations()\n    {\n        this.addOperation('noop', \n            {\n                \"Description\":\n                {\n                    \"Operation\": \"noop\",\n                    \"Description\": \"No operation - no affect on any data.\"\n                }\n            });\n\n        return true;\n    }\n};\n\nmodule.exports = ElucidatorInstructionSet;\n},{}],3:[function(require,module,exports){\n/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\n\n/**\n* Elucidator simple logging shim (for browser and dependency-free running)\n*/\n\nconst logToConsole = (pLogLine, pLogObject, pLogLevel) =>\n{\n    let tmpLogLine = (typeof(pLogLine) === 'string') ? pLogLine : '';\n    let tmpLogLevel = (typeof(pLogLevel) === 'string') ? pLogLevel : 'INFO';\n\n    console.log(`[Elucidator:${tmpLogLevel}] ${tmpLogLine}`);\n\n    if (pLogObject) console.log(JSON.stringify(pLogObject,null,4)+\"\\n\");\n};\n\nconst logInfo = (pLogLine, pLogObject) =>\n{\n    logToConsole(pLogLine, pLogObject, 'Info');\n};\n\n\nconst logWarning = (pLogLine, pLogObject) =>\n{\n    logToConsole(pLogLine, pLogObject, 'Warning');\n};\n\n\nconst logError = (pLogLine, pLogObject) =>\n{\n    logToConsole(pLogLine, pLogObject, 'Error');\n};\n\nmodule.exports = (\n{\n    logToConsole: logToConsole,\n    info: logInfo,\n    warning: logWarning,\n    error: logError\n});\n},{}],4:[function(require,module,exports){\n/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\nconst libSimpleLog = require('./Elucidator-LogToConsole.js');\nconst libManyfest = require('manyfest');\nconst libPrecedent = require('precedent');\n\nconst libElucidatorInstructionSet = require('./Elucidator-InstructionSet.js');\n\n/**\n* Elucidator object address-based descriptions and manipulations.\n*\n* @class Elucidator\n*/\nclass Elucidator\n{\n    constructor(pOperations, fInfoLog, fErrorLog)\n    {\n        // Wire in logging\n        this.logInfo = (typeof(fInfoLog) === 'function') ? fInfoLog : libSimpleLog.info;\n        this.logWarning = (typeof(fWarningLog) === 'function') ? fWarningLog : libSimpleLog.warning;\n        this.logError = (typeof(fErrorLog) === 'function') ? fErrorLog : libSimpleLog.error;\n\n\t\t// Instructions are the basic building blocks for operations\n\t\tthis.instructionSets = {};\n\n\t\t// Operations are the solvers that can be called (instructions can't be called directly)\n\t\t// These can be added at run-time as well\n\t\tthis.operationSets = {};\n\n\t\t// Decide later how to make this truly unique.\n\t\tthis.UUID = 0;\n\n\t\tthis.loadDefaultInstructionSets();\n\n\t\tif (pOperations)\n\t\t{\n\t\t\tlet tmpSolverHashes = Object.keys(pOperations);\n\t\t\tfor (let i = 0; i < tmpSolverHashes.length; i++)\n\t\t\t{\n\t\t\t\tthis.addOperation('Custom',tmpSolverHashes[i], pOperations[tmpSolverHashes[i]]);\n\t\t\t}\n\t\t}\n    }\n\n\t// Load an instruction set\n\tloadInstructionSet(cInstructionSet)\n\t{\n\t\tlet tmpInstructionSet = new cInstructionSet(this);\n\t\t// Setup the namespace\n\t\ttmpInstructionSet.initializeNamespace();\n\t\ttmpInstructionSet.initializeInstructions();\n\t\ttmpInstructionSet.initializeOperations();\n\t}\n\n\tloadDefaultInstructionSets()\n\t{\n\t\t// The javascript math instructions and operations\n\t\t// These provide the \"Math\" namespace\n\t\tthis.loadInstructionSet(require(`./InstructionSets/Math-Javascript.js`));\n\n\t\t// A precision javascript math library that is consistent across browsers, stable and without mantissa issues\n\t\t// Uses Decimal.js\n\t\t// These provide the \"PreciseMath\" namespace\n\t\tthis.loadInstructionSet(require(`./InstructionSets/PreciseMath-Decimal.js`));\n\n\t\t// The abstract geometry instructions and operations (rectangle area, circle area, etc.)\n\t\t// These provide the \"Geometry\" namespace\n\t\tthis.loadInstructionSet(require(`./InstructionSets/Geometry.js`));\n\n\t\t// The logic operations (if, execution of instructions, etc.)\n\t\t// These provide the \"Logic\" namespace\n\t\tthis.loadInstructionSet(require(`./InstructionSets/Logic.js`));\n\n\t\t// Basic string manipulation instructions and operations\n\t\t// These provide the \"String\" namespace\n\t\tthis.loadInstructionSet(require(`./InstructionSets/String.js`));\n\n\t\t// Basic set manipulation instructions and operations\n\t\t// These provide the \"Set\" namespace\n\t\tthis.loadInstructionSet(require(`./InstructionSets/Set.js`));\n\t}\n\n\toperationExists(pNamespace, pOperationHash)\n\t{\n\t\tif ((typeof(pNamespace) != 'string') || (typeof(pOperationHash) != 'string'))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\tlet tmpNamespace = pNamespace.toLowerCase();\n\t\treturn (this.operationSets.hasOwnProperty(tmpNamespace) && this.operationSets[tmpNamespace].hasOwnProperty(pOperationHash.toLowerCase()));\n\t}\n\n\taddOperation(pNamespace, pOperationHash, pOperation)\n\t{\n        if (typeof(pNamespace) != 'string')\n        {\n            this.logError(`Attempted to add an operation at runtime via Elucidator.addOperation with an invalid namespace; expected a string but the type was ${typeof(pNamespace)}`, pOperation);\n            return false;\n        }\n\n\t\tlet tmpOperationInjector = new libElucidatorInstructionSet(this);\n\t\ttmpOperationInjector.initializeNamespace(pNamespace);\n\n\t\treturn tmpOperationInjector.addOperation(pOperationHash, pOperation);\n\t}\n\n\tsolveInternalOperation(pNamespace, pOperationHash, pInputObject, pOutputObject, pDescriptionManyfest, pInputAddressMapping, pOutputAddressMapping, pSolutionContext)\n\t{\n\t\tif (!this.operationExists(pNamespace, pOperationHash))\n\t\t{\n\t\t\tthis.logError(`Attempted to solveInternalOperation for namespace ${pNamespace} operationHash ${pOperationHash} but the operation was not found.`);\n\t\t\t// TODO: Should this return something with an error log populated?\n\t\t\treturn false;\n\t\t}\n\t\tlet tmpOperation = this.operationSets[pNamespace.toLowerCase()][pOperationHash.toLowerCase()];\n\t\treturn this.solveOperation(tmpOperation, pInputObject, pOutputObject, pDescriptionManyfest, pInputAddressMapping, pOutputAddressMapping, pSolutionContext);\n\t}\n\n\tsolveOperation(pOperationObject, pInputObject, pOutputObject, pDescriptionManyfest, pInputAddressMapping, pOutputAddressMapping, pSolutionContext)\n\t{\n\t\tlet tmpOperation = JSON.parse(JSON.stringify(pOperationObject));\n\n\t\tif (typeof(pInputObject) != 'object')\n\t\t{\n            this.logError(`Attempted to run a solve but the passed in Input was not an object.  The type was ${typeof(pInputObject)}.`);\n\t\t\treturn false;\n\t\t}\n\t\tlet tmpInputObject = pInputObject;\n\n\t\t// Default to reusing the input object as the output object.\n\t\tlet tmpOutputObject = tmpInputObject;\n\n\t\t// This is how recursive solutions bind their context together.\n\t\tlet tmpSolutionContext = pSolutionContext;\n\t\tif (typeof(tmpSolutionContext) === 'undefined')\n\t\t{\n\t\t\ttmpSolutionContext = (\n\t\t\t\t{\n\t\t\t\t\t\"SolutionGUID\": `Solution-${this.UUID++}`, \n\t\t\t\t\t\"SolutionBaseNamespace\": pOperationObject.Description.Namespace,\n\t\t\t\t\t\"SolutionBaseOperation\": pOperationObject.Description.Operation,\n\t\t\t\t\t\"SolutionLog\": []\n\t\t\t\t});\n\t\t\t\n\t\t\t// This is the root operation, see if there are Inputs and Outputs created ... if not, create them.\n\t\t\tif (!tmpOperation.hasOwnProperty('Inputs'))\n\t\t\t{\n\t\t\t\ttmpOperation.Inputs = {};\n\t\t\t}\n\t\t\tif (!tmpOperation.hasOwnProperty('Outputs'))\n\t\t\t{\n\t\t\t\ttmpOperation.Outputs = {};\n\t\t\t}\n\n\t\t\t// This is the root Operation, see if there is a hash translation available for either side (input or output)\n\t\t\tif (tmpOperation.hasOwnProperty('InputHashTranslationTable'))\n\t\t\t{\n\t\t\t\ttmpSolutionContext.InputHashMapping = JSON.parse(JSON.stringify(tmpOperation.InputHashTranslationTable));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttmpSolutionContext.InputHashMapping = {};\n\t\t\t}\n\n\t\t\tif (tmpOperation.hasOwnProperty('OutputHashTranslationTable'))\n\t\t\t{\n\t\t\t\ttmpSolutionContext.OutputHashMapping = JSON.parse(JSON.stringify(tmpOperation.OutputHashTranslationTable));\n\t\t\t}\n\n\t\t\tif ((typeof(pOutputObject) != 'object')\n\t\t\t\t&& (typeof(tmpOutputHashMapping) == 'undefined') \n\t\t\t\t&& (typeof(tmpInputHashMapping) != 'undefined'))\n\t\t\t{\n\t\t\t\t// Reuse the input hash mapping if:\n\t\t\t\t//   1) we auto-mapped the input hash mapping to the output because only an input object was supplied\n\t\t\t\t//   2) there *was not* an output hash mapping supplied\n\t\t\t\t//   3) there *was* an input hash mapping supplied\n\t\t\t\t//\n\t\t\t\t// This seems simple at first but exposes some really interesting behaviors in terms of\n\t\t\t\t// reusing the same object and schema for input and output, but having different hash\n\t\t\t\t// mappings for each of them.\n\t\t\t\ttmpSolutionContext.OutputHashMapping = tmpSolutionContext.InputHashMapping;\n\t\t\t}\n\t\t}\n\n\t\tif (typeof(pOutputObject) == 'object')\n\t\t{\n\t\t\t// If the call defined an explicit, different output object from the input object use that instead.\n\t\t\ttmpOutputObject = pOutputObject;\n\t\t}\n\n\t\tlet tmpDescriptionManyfest = false;\n\t\tif (typeof(pDescriptionManyfest) === 'undefined')\n\t\t{\n\t\t\t// We are going to use this for some clever schema manipulations, then recreate the object\n\t\t\ttmpDescriptionManyfest = new libManyfest();\n\t\t\t// Synthesize a manyfest from the Input and Output properties\n\t\t\tlet tmpManyfestSchema = (\n\t\t\t\t{\n\t\t\t\t\tScope: 'Solver Data Part Descriptions',\n\t\t\t\t\tDescriptors: tmpDescriptionManyfest.schemaManipulations.mergeAddressMappings(tmpOperation.Inputs, tmpOperation.Outputs)\n\t\t\t\t});\n\t\t\t}\n\t\telse\n\t\t{\n\t\t\t// Clone the passed-in manyfest, so mutations do not alter the upstream version\n\t\t\ttmpDescriptionManyfest = pDescriptionManyfest.clone();\n\t\t}\n\t\t// Now that the operation object has been created uniquely, apply any passed-in address-hash and hash-hash remappings\n\t\tif (pInputAddressMapping)\n\t\t{\n\t\t\ttmpDescriptionManyfest.schemaManipulations.resolveAddressMappings(tmpOperation.Inputs, pInputAddressMapping);\n\t\t}\n\t\tif (pOutputAddressMapping)\n\t\t{\n\t\t\ttmpDescriptionManyfest.schemaManipulations.resolveAddressMappings(tmpOperation.Inputs, pOutputAddressMapping);\n\t\t}\n\t\tif (tmpSolutionContext.InputHashMapping)\n\t\t{\n\t\t\ttmpDescriptionManyfest.hashTranslations.addTranslation(tmpSolutionContext.InputHashMapping);\n\t\t}\n\t\tif (tmpSolutionContext.OutputHashMapping)\n\t\t{\n\t\t\ttmpDescriptionManyfest.hashTranslations.addTranslation(tmpSolutionContext.OutputHashMapping);\t\t\t\n\t\t}\n\n\n\t\t// Set some kind of unique identifier for the operation\n\t\ttmpOperation.UUID = this.UUID++;\n\t\ttmpOperation.SolutionContext = tmpSolutionContext;\n\n\t\tif (tmpOperation.Description.Synopsys)\n\t\t{\n\t\t\ttmpSolutionContext.SolutionLog.push(`[${tmpOperation.UUID}]: Solver running operation ${tmpOperation.Description.Synopsys}`);\n\t\t}\n\n\t\tlet tmpPrecedent = new libPrecedent();\n\t\ttmpPrecedent.addPattern('{{Name:', '}}',\n\t\t\t(pHash)=>\n\t\t\t{\n\t\t\t\tlet tmpHash = pHash.trim();\n\t\t\t\tlet tmpDescriptor = tmpDescriptionManyfest.getDescriptorByHash(tmpHash)\n\n\t\t\t\t// Return a human readable value\n\t\t\t\tif ((typeof(tmpDescriptor) == 'object')  && tmpDescriptor.hasOwnProperty('Name'))\n\t\t\t\t{\n\t\t\t\t\treturn tmpDescriptor.Name;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treturn tmpHash;\n\t\t\t\t}\n\t\t\t});\n\t\ttmpPrecedent.addPattern('{{InputValue:', '}}',\n\t\t\t(pHash)=>\n\t\t\t{\n\t\t\t\tlet tmpHash = pHash.trim();\n\t\t\t\treturn tmpDescriptionManyfest.getValueByHash(tmpInputObject,tmpHash);\n\t\t\t});\n\t\ttmpPrecedent.addPattern('{{OutputValue:', '}}',\n\t\t\t(pHash)=>\n\t\t\t{\n\t\t\t\tlet tmpHash = pHash.trim();\n\t\t\t\treturn tmpDescriptionManyfest.getValueByHash(tmpOutputObject,tmpHash);\n\t\t\t});\n\n\t\tif (tmpOperation.hasOwnProperty('Log') && tmpOperation.Log.hasOwnProperty('PreOperation'))\n\t\t{\n\t\t\tif (typeof(tmpOperation.Log.PreOperation) == 'string')\n\t\t\t{\n\t\t\t\ttmpOperation.SolutionContext.SolutionLog.push(tmpPrecedent.parseString(tmpOperation.Log.PreOperation));\n\t\t\t}\n\t\t\telse if (Array.isArray(tmpOperation.Log.PreOperation))\n\t\t\t{\n\t\t\t\tfor (let i = 0; i < tmpOperation.Log.PreOperation.length; i++)\n\t\t\t\t{\n\t\t\t\t\tif ((typeof(tmpOperation.Log.PreOperation[i]) == 'string'))\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpOperation.SolutionContext.SolutionLog.push(tmpPrecedent.parseString(tmpOperation.Log.PreOperation[i]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Now step through each operation and solve\n\t\tfor (let i = 0; i < tmpOperation.Steps.length; i++)\n\t\t{\n\t\t\tlet tmpStep = tmpOperation.Steps[i];\n\n\t\t\t// Instructions are always endpoints -- they *do not* recurse.\n\t\t\tif (tmpStep.hasOwnProperty('Instruction'))\n\t\t\t{\n\t\t\t\tlet tmpInputSchema = (\n\t\t\t\t\t{\n\t\t\t\t\t\t\"Scope\": \"InputObject\",\n\t\t\t\t\t\t\"Descriptors\": JSON.parse(JSON.stringify(tmpOperation.Inputs))\n\t\t\t\t\t});\n\t\t\t\t// Perform step-specific address mappings.\n\t\t\t\ttmpDescriptionManyfest.schemaManipulations.resolveAddressMappings(tmpInputSchema.Descriptors, tmpStep.InputHashAddressMap);\n\t\t\t\tlet tmpInputManyfest = new libManyfest(tmpInputSchema);\n\t\t\t\tif (tmpSolutionContext.InputHashMapping)\n\t\t\t\t{\n\t\t\t\t\ttmpInputManyfest.hashTranslations.addTranslation(tmpSolutionContext.InputHashMapping);\n\t\t\t\t}\n\n\t\t\t\tlet tmpOutputSchema = (\n\t\t\t\t\t{\n\t\t\t\t\t\t\"Scope\": \"OutputObject\",\n\t\t\t\t\t\t\"Descriptors\": JSON.parse(JSON.stringify(tmpOperation.Outputs))\n\t\t\t\t\t});\n\t\t\t\t\ttmpDescriptionManyfest.schemaManipulations.resolveAddressMappings(tmpOutputSchema.Descriptors, tmpStep.OutputHashAddressMap);\n\t\t\t\tlet tmpOutputManyfest = new libManyfest(tmpOutputSchema);\n\t\t\t\tif (tmpSolutionContext.OutputHashMapping)\n\t\t\t\t{\n\t\t\t\t\ttmpOutputManyfest.hashTranslations.addTranslation(tmpSolutionContext.OutputHashMapping);\n\t\t\t\t}\n\t\n\t\t\t\t// Construct the instruction state object\n\t\t\t\tlet tmpInstructionState = (\n\t\t\t\t{\n\t\t\t\t\tElucidator: this,\n\n\t\t\t\t\tNamespace: tmpStep.Namespace.toLowerCase(),\n\t\t\t\t\tInstruction: tmpStep.Instruction.toLowerCase(),\n\n\t\t\t\t\tOperation: tmpOperation,\n\n\t\t\t\t\tSolutionContext: tmpSolutionContext,\n\n\t\t\t\t\tDescriptionManyfest: tmpDescriptionManyfest,\n\n\t\t\t\t\tInputObject: tmpInputObject,\n\t\t\t\t\tInputManyfest: tmpInputManyfest,\n\n\t\t\t\t\tOutputObject: tmpOutputObject,\n\t\t\t\t\tOutputManyfest: tmpOutputManyfest\n\t\t\t\t});\n\n\t\t\t\ttmpInstructionState.logError = \n\t\t\t\t\t(pMessage) => \n\t\t\t\t\t{\n\t\t\t\t\t\ttmpSolutionContext.SolutionLog.push(`[ERROR][Operation ${tmpInstructionState.Operation.Description.Namespace}:${tmpInstructionState.Operation.Description.Hash} - Step #${i}:${tmpStep.Namespace}:${tmpStep.Instruction}] ${pMessage}`)\n\t\t\t\t\t};\n\n\t\t\t\ttmpInstructionState.logInfo = \n\t\t\t\t\t(pMessage) => \n\t\t\t\t\t{\n\t\t\t\t\t\ttmpSolutionContext.SolutionLog.push(`[INFO][Operation ${tmpInstructionState.Operation.Description.Namespace}:${tmpInstructionState.Operation.Description.Hash} - Step #${i}:${tmpStep.Namespace}:${tmpStep.Instruction}] ${pMessage}`)\n\t\t\t\t\t};\n\n\t\t\t\tif (this.instructionSets[tmpInstructionState.Namespace].hasOwnProperty(tmpInstructionState.Instruction))\n\t\t\t\t{\n\t\t\t\t\tlet fInstruction = this.instructionSets[tmpInstructionState.Namespace][tmpInstructionState.Instruction];\n\t\t\t\t\tfInstruction(tmpInstructionState);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Operations recurse.\n\t\t\tif (tmpStep.hasOwnProperty('Operation'))\n\t\t\t{\n\t\t\t\tif (typeof(tmpStep.Operation) == 'string')\n\t\t\t\t{\n\t\t\t\t\tthis.solveInternalOperation(tmpStep.Namespace, tmpStep.Operation, tmpInputObject, tmpOutputObject, tmpDescriptionManyfest, tmpStep.InputHashAddressMap, tmpStep.OutputHashAddressMap, tmpSolutionContext);\n\t\t\t\t}\n\t\t\t\telse if (typeof(tmpStep.Operation) == 'object')\n\t\t\t\t{\n\t\t\t\t\t// You can even define an inline object operation!  This gets crazy fast\n\t\t\t\t\tthis.solveOperation(tmpStep.Operation, tmpInputObject, tmpOutputObject, tmpDescriptionManyfest, tmpStep.InputHashAddressMap, tmpStep.OutputHashAddressMap, tmpSolutionContext);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (tmpOperation.hasOwnProperty('Log') && tmpOperation.Log.hasOwnProperty('PostOperation'))\n\t\t{\n\t\t\tif (typeof(tmpOperation.Log.PostOperation) == 'string')\n\t\t\t{\n\t\t\t\ttmpOperation.SolutionContext.SolutionLog.push(tmpPrecedent.parseString(tmpOperation.Log.PostOperation));\n\t\t\t}\n\t\t\telse if (Array.isArray(tmpOperation.Log.PreOperation))\n\t\t\t{\n\t\t\t\tfor (let i = 0; i < tmpOperation.Log.PostOperation.length; i++)\n\t\t\t\t{\n\t\t\t\t\tif ((typeof(tmpOperation.Log.PostOperation[i]) == 'string'))\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpOperation.SolutionContext.SolutionLog.push(tmpPrecedent.parseString(tmpOperation.Log.PostOperation[i]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn tmpSolutionContext;\n\t}\n};\n\nmodule.exports = Elucidator;\n},{\"./Elucidator-InstructionSet.js\":2,\"./Elucidator-LogToConsole.js\":3,\"./InstructionSets/Geometry.js\":5,\"./InstructionSets/Logic.js\":6,\"./InstructionSets/Math-Javascript.js\":7,\"./InstructionSets/PreciseMath-Decimal.js\":31,\"./InstructionSets/Set.js\":32,\"./InstructionSets/String.js\":33,\"manyfest\":43,\"precedent\":44}],5:[function(require,module,exports){\n// Solution providers are meant to be stateless, and not classes.\n// These solution providers are akin to drivers, connecting code libraries or \n// other types of behavior to mapping operations.\n\nlet libElucidatorInstructionSet = require('../Elucidator-InstructionSet.js');\n\nclass Geometry extends libElucidatorInstructionSet\n{\n    constructor(pElucidator)\n    {\n        super(pElucidator);\n        this.namespace = 'Geometry';\n    }\n\n    // Geometry provides no instructions\n    initializeInstructions()\n    {\n        return true;\n    }\n\n    initializeOperations()\n    {\n        this.addOperation('rectanglearea', require(`./Operations/Geometry-RectangleArea.json`));\n\n        return true;\n    }\n}\n\nmodule.exports = Geometry;\n},{\"../Elucidator-InstructionSet.js\":2,\"./Operations/Geometry-RectangleArea.json\":8}],6:[function(require,module,exports){\n// Solution providers are meant to be stateless, and not classes.\n// These solution providers are akin to drivers, connecting code libraries or \n// other types of behavior to mapping operations.\n\nlet libElucidatorInstructionSet = require('../Elucidator-InstructionSet.js');\n\nconst ifInstruction = (pOperation) =>\n{\n    let tmpLeftValue = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'leftValue');\n    let tmpRightValue = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'rightValue');\n    let tmpComparator = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'comparator').toString().toLowerCase();\n\n    let tmpComparisonOperator = 'equal';\n\n    // This may eventually come from configuration; for now just leave it here.\n    let tmpComparisonOperatorMapping = (\n        {\n            '==':'equal',\n            'eq':'equal',\n            'equal':'equal',\n\n            '!=':'notequal',\n            'noteq':'notequal',\n            'notequal':'notequal',\n\n            '===':'identity',\n            'id':'identity',\n            'identity':'identity',\n\n            '>':'greaterthan',\n            'gt':'greaterthan',\n            'greaterthan':'greaterthan',\n\n            '>=':'greaterthanorequal',\n            'gte':'greaterthanorequal',\n            'greaterthanorequal':'greaterthanorequal',\n\n            '<':'lessthan',\n            'lt':'lessthan',\n            'lessthan':'lessthan',\n\n            '<=':'lessthanorequal',\n            'lte':'lessthanorequal',\n            'lessthanorequal':'lessthanorequal'\n        });\n\n    if (tmpComparisonOperatorMapping.hasOwnProperty(tmpComparator))\n    {\n        tmpComparisonOperator = tmpComparisonOperatorMapping[tmpComparator];\n    }\n\n    let tmpTrueNamespace = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'trueNamespace');\n    let tmpTrueOperation = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'trueOperation');\n\n    let tmpFalseNamespace = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'falseNamespace');\n    let tmpFalseOperation = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'falseOperation');\n\n    let tmpTruthiness = null;\n\n    switch(tmpComparisonOperator)\n    {\n        case 'equal':\n            tmpTruthiness = (tmpLeftValue == tmpRightValue);\n            break;\n        case 'identity':\n            tmpTruthiness = (tmpLeftValue === tmpRightValue);\n            break;\n        case 'notequal':\n            tmpTruthiness = (tmpLeftValue != tmpRightValue);\n            break;\n        case 'greaterthan':\n            tmpTruthiness = (tmpLeftValue > tmpRightValue);\n            break;\n        case 'greaterthanorequal':\n            tmpTruthiness = (tmpLeftValue >= tmpRightValue);\n            break;\n        case 'lessthan':\n            tmpTruthiness = (tmpLeftValue < tmpRightValue);\n            break;\n        case 'lessthanorequal':\n            tmpTruthiness = (tmpLeftValue <= tmpRightValue);\n            break;\n    }\n\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'truthinessResult', tmpTruthiness);\n\n    // Now execute the operations (unless it is a noop or a bunk operation)\n    // This is, frankly, kindof a mind-blowing amount of recursion possibility.\n    // Both of these are falling back on the base solution hash mapping.\n    // --> Not certain if this is the correct approach and the only way to tell will be through exercise of this\n    if (tmpTruthiness && (typeof(tmpTrueNamespace) == 'string') && (typeof(tmpTrueOperation) == 'string') && (tmpTrueOperation != 'noop'))\n    {\n        pOperation.Elucidator.solveInternalOperation(tmpTrueNamespace, tmpTrueOperation, pOperation.InputObject, pOperation.OutputObject, pOperation.DescriptionManyfest, pOperation.SolutionContext.InputHashMapping, pOperation.SolutionContext.OutputHashMapping, pOperation.SolutionContext);\n    }\n    else if ((typeof(tmpFalseNamespace) == 'string') &&  (typeof(tmpFalseOperation) == 'string') && (tmpFalseOperation != 'noop'))\n    {\n        pOperation.Elucidator.solveInternalOperation(tmpFalseNamespace, tmpFalseOperation, pOperation.InputObject, pOperation.OutputObject, pOperation.DescriptionManyfest, pOperation.SolutionContext.InputHashMapping, pOperation.SolutionContext.OutputHashMapping, pOperation.SolutionContext);\n    }\n\n    return true;\n};\n\nconst executeOperation = (pOperation) =>\n{\n    let tmpNamespace = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'namespace');\n    let tmpOperation = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'operation');\n\n    pOperation.Elucidator.solveInternalOperation(tmpNamespace, tmpOperation, pOperation.InputObject, pOperation.OutputObject, pOperation.DescriptionManyfest, pOperation.SolutionContext.InputHashMapping, pOperation.SolutionContext.OutputHashMapping, pOperation.SolutionContext);\n\n    return true;\n}\n\nclass Logic extends libElucidatorInstructionSet\n{\n    constructor(pElucidator)\n    {\n        super(pElucidator);\n        this.namespace = 'Logic';\n    }\n\n    initializeInstructions()\n    {\n        // Logic actually wants a noop instruction!\n        super.initializeInstructions();\n\n        this.addInstruction('if', ifInstruction);\n        this.addInstruction('execute', executeOperation);\n\n        return true;\n    }\n\n    initializeOperations()\n    {\n        this.addOperation('if', require(`./Operations/Logic-If.json`));\n        this.addOperation('execute', require(`./Operations/Logic-Execute.json`));\n\n        return true;\n    }\n}\n\nmodule.exports = Logic;\n},{\"../Elucidator-InstructionSet.js\":2,\"./Operations/Logic-Execute.json\":9,\"./Operations/Logic-If.json\":10}],7:[function(require,module,exports){\n// Solution providers are meant to be stateless, and not classes.\n// These solution providers are akin to drivers, connecting code libraries or \n// other types of behavior to mapping operations.\n\nlet libElucidatorInstructionSet = require('../Elucidator-InstructionSet.js');\n\nlet add = (pOperation) =>\n{\n    // This could be done in one line, but, would be more difficult to comprehend.\n    let tmpA = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'a');\n    let tmpB = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'b');\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'x', tmpA + tmpB);\n    return true;\n};\n\nlet subtract = (pOperation) =>\n{\n    // This could be done in one line, but, would be more difficult to comprehend.\n    let tmpA = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'a');\n    let tmpB = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'b');\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'x', tmpA - tmpB);\n    return true;\n};\n\nlet multiply = (pOperation) =>\n{\n    // This could be done in one line, but, would be more difficult to comprehend.\n    let tmpA = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'a');\n    let tmpB = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'b');\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'x', tmpA * tmpB);\n    return true;\n};\n\nlet divide = (pOperation) =>\n{\n    // This could be done in one line, but, would be more difficult to comprehend.\n    let tmpA = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'a');\n    let tmpB = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'b');\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'x', tmpA / tmpB);\n    return true;\n};\n\nlet aggregate = (pOperation) =>\n{\n    let tmpA = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'a');\n\n    let tmpObjectType = typeof(tmpA);\n\n    let tmpAggregationValue = 0;\n\n    if (tmpObjectType == 'object')\n    {\n        if (Array.isArray(tmpA))\n        {\n            for (let i = 0; i < tmpA.length; i++)\n            {\n                // If this is an array, enumerate it and try to aggregate each number\n                let tmpValue = parseInt(tmpA[i]);\n\n                if (isNaN(tmpValue))\n                {\n                    pOperation.logError(`Array element index [${i}] could not be parsed as a number; skipping.  (${tmpA[i]})`);\n                }\n                else\n                {\n                    tmpAggregationValue += tmpValue;\n                    pOperation.logInfo(`Adding element [${i}] value ${tmpValue} totaling: ${tmpAggregationValue}`)\n                }\n            }\n        }\n        else\n        {\n            let tmpObjectKeys = Object.keys(tmpA);\n            for (let i = 0; i < tmpObjectKeys.length; i++)\n            {\n                let tmpValue = parseInt(tmpA[tmpObjectKeys[i]]);\n\n                if (isNaN(tmpValue))\n                {\n                    pOperation.logError(`Object property [${tmpObjectKeys[i]}] could not be parsed as a number; skipping.  (${tmpA[tmpObjectKeys[i]]})`);\n                }\n                else\n                {\n                    tmpAggregationValue += tmpValue;\n                    pOperation.logInfo(`Adding object property [${tmpObjectKeys[i]}] value ${tmpValue} totaling: ${tmpAggregationValue}`)\n                }\n            }\n        }\n    }\n    else\n    {\n        let tmpValue = parseInt(tmpA);\n\n        if (isNaN(tmpValue))\n        {\n            pOperation.logError(`Direct value could not be parsed as a number; skipping.  (${tmpA})`);\n        }\n        else\n        {\n            tmpAggregationValue += tmpValue;\n        }\n    }\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'x', tmpAggregationValue);\n    return true;\n};\n\nclass MathJavascript extends libElucidatorInstructionSet\n{\n    constructor(pElucidator)\n    {\n        super(pElucidator);\n        this.namespace = 'Math';\n    }\n\n    initializeInstructions()\n    {\n        this.addInstruction('add', add);\n\n        this.addInstruction('subtract', subtract);\n        this.addInstruction('sub', subtract);\n\n        this.addInstruction('multiply', multiply);\n        this.addInstruction('mul', multiply);\n\n        this.addInstruction('divide', divide);\n        this.addInstruction('div', divide);\n\n        this.addInstruction('aggregate', aggregate);\n\n        return true;\n    }\n\n    initializeOperations()\n    {\n        this.addOperation('add', require(`./Operations/Math-Add.json`));\n        this.addOperation('subtract', require(`./Operations/Math-Subtract.json`));\n        this.addOperation('multiply', require(`./Operations/Math-Multiply.json`));\n        this.addOperation('divide', require(`./Operations/Math-Divide.json`));\n\n        this.addOperation('aggregate', require(`./Operations/Math-Aggregate.json`));\n\n        return true;\n    }\n}\n\nmodule.exports = MathJavascript;\n},{\"../Elucidator-InstructionSet.js\":2,\"./Operations/Math-Add.json\":11,\"./Operations/Math-Aggregate.json\":12,\"./Operations/Math-Divide.json\":13,\"./Operations/Math-Multiply.json\":14,\"./Operations/Math-Subtract.json\":15}],8:[function(require,module,exports){\nmodule.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"Geometry\",\n\t\t\"Operation\": \"RectangleArea\",\n\t\t\"Synopsis\": \"Solve for the area of a rectangle:  Area = Width * Height\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"Width\": { \"Hash\":\"Width\", \"Type\":\"Number\" },\n\t\t\"Height\": { \"Hash\":\"Height\", \"Type\":\"Number\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"Area\": { \"Hash\":\"Area\", \"Name\": \"Area of the Rectangle\"},\n\t\t\"Ratio\": { \"Hash\":\"Ratio\", \"Name\": \"The Ratio between the Width and the Height\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Solve for [ {{Name:Area}} ] based on [ {{Name:Width}} ] and [ {{Name:Height}} ].\",\n\t\t\"PostOperation\": \"Operation complete; [ {{Name:Area}} ] = {{InputValue:Width}} * {{InputValue:Height}} = {{OutputValue:Area}}\"\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"PreciseMath\",\n\t\t\t\"Instruction\": \"multiply\",\n\t\t\t\"InputHashAddressMap\": \n\t\t\t\t{\n\t\t\t\t\t\"a\": \"Width\",\n\t\t\t\t\t\"b\": \"Height\"\n\t\t\t\t},\n\t\t\t\"OutputHashAddressMap\":\n\t\t\t\t{\n\t\t\t\t\t\"x\": \"Area\"\n\t\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"Namespace\": \"PreciseMath\",\n\t\t\t\"Instruction\": \"divide\",\n\t\t\t\"InputHashAddressMap\": \n\t\t\t\t{\n\t\t\t\t\t\"a\": \"Width\",\n\t\t\t\t\t\"b\": \"Height\"\n\t\t\t\t},\n\t\t\t\"OutputHashAddressMap\":\n\t\t\t\t{\n\t\t\t\t\t\"x\": \"Ratio\"\n\t\t\t\t}\n\t\t}\n\t]\n}\n},{}],9:[function(require,module,exports){\nmodule.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"Logic\",\n\t\t\"Operation\": \"Execute\",\n\t\t\"Synopsis\": \"Execute an operation based on namespace and operation.\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"namespace\": { \"Hash\": \"namespace\", \"Type\": \"string\", \"Default\":\"logic\" },\n\t\t\"operation\": { \"Hash\": \"operation\", \"Type\": \"string\", \"Default\":\"noop\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Execute the {{InputValue:operation}} operation in namespace {{InputValue:namespace}}.\",\n\t\t\"PostOperation\": \"Operation [{{InputValue:namespace}}:{{InputValue:operation}}] execution complete.\"\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"Logic\",\n\t\t\t\"Instruction\": \"execute\"\n\t\t}\n\t]\n}\n},{}],10:[function(require,module,exports){\nmodule.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"Logic\",\n\t\t\"Operation\": \"If\",\n\t\t\"Synopsis\": \"Comparison-based if of leftValue and RightValue based on comparator.  Executes trueNamespace:trueOperation or falseNamespace:falseOperation based on truthiness of result.  Also outputs a true or false to truthinessResult.\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"leftValue\": { \"Hash\":\"leftValue\", \"Type\":\"Any\" },\n\t\t\"rightValue\": { \"Hash\":\"rightValue\", \"Type\":\"Any\", \"Default\": true },\n\t\t\"comparator\": { \"Hash\":\"comparator\", \"Type\":\"String\", \"Default\":\"==\" },\n\n\t\t\"trueNamespace\": {\"Hash\":\"trueNamespace\", \"Type\":\"String\", \"Default\":\"logic\" },\n\t\t\"trueOperation\": {\"Hash\":\"trueOperation\", \"Type\":\"String\", \"Default\":\"noop\" },\n\n\t\t\"falseNamespace\": {\"Hash\":\"falseNamespace\", \"Type\":\"String\", \"Default\":\"logic\" },\n\t\t\"falseOperation\": {\"Hash\":\"falseOperation\", \"Type\":\"String\", \"Default\":\"noop\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"truthinessResult\": { \"Hash\": \"truthinessResult\", \"Type\": \"Boolean\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Compare {{Name:leftValue}} and {{Name:rightValue}} with the {{InputValue:comparator}} operator, storing the truthiness in {{Name:truthinessResult}}.\",\n\t\t\"PostOperation\": \"Operation complete: {{InputValue:leftValue}} {{InputValue:comparator}} {{InputValue:rightValue}} evaluated to {{OutputValue:truthinessResult}}\"\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"Logic\",\n\t\t\t\"Instruction\": \"If\"\n\t\t}\n\t]\n}\n},{}],11:[function(require,module,exports){\nmodule.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"Math\",\n\t\t\"Operation\": \"Add\",\n\t\t\"Synopsis\": \"Add two numbers:  x = a + b\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"a\": { \"Hash\": \"a\", \"Type\": \"Number\" },\n\t\t\"b\": { \"Hash\": \"b\", \"Type\": \"Number\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"x\": { \"Hash\": \"x\", \"Type\": \"Number\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Add {{Name:a}} and {{Name:b}}, storing the value in {{Name:x}}.\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:x}} = {{InputValue:a}} + {{InputValue:b}} = {{OutputValue:x}}\"\t\t\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"Math\",\n\t\t\t\"Instruction\": \"add\"\n\t\t}\n\t]\n}\n},{}],12:[function(require,module,exports){\nmodule.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"Math\",\n\t\t\"Operation\": \"Aggregate\",\n\t\t\"Synopsis\": \"Aggregate a set of numbers (from array or object address):  x = a + b + ... + z\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"a\": { \"Hash\": \"a\", \"Type\": \"Set\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"x\": { \"Hash\": \"x\", \"Type\": \"Number\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Aggregate all numeric values in {{Name:a}}, storing the resultant in {{Name:x}}.\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:x}} = {{OutputValue:x}}\"\t\t\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"Math\",\n\t\t\t\"Instruction\": \"aggregate\"\n\t\t}\n\t]\n}\n},{}],13:[function(require,module,exports){\nmodule.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"Math\",\n\t\t\"Operation\": \"Divide\",\n\t\t\"Synopsis\": \"Divide two numbers:  x = a / b\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"a\": { \"Hash\": \"a\", \"Type\": \"Number\" },\n\t\t\"b\": { \"Hash\": \"b\", \"Type\": \"Number\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"x\": { \"Hash\": \"x\", \"Type\": \"Number\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Divide {{Name:a}} over {{Name:b}}, storing the value in {{Name:x}}.\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:x}} = {{InputValue:a}} / {{InputValue:b}} = {{OutputValue:x}}\"\t\t\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"Math\",\n\t\t\t\"Instruction\": \"divide\"\n\t\t}\n\t]\n}\n},{}],14:[function(require,module,exports){\nmodule.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"Math\",\n\t\t\"Operation\": \"Multiply\",\n\t\t\"Synopsis\": \"Multiply two numbers:  x = a * b\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"a\": { \"Hash\": \"a\", \"Type\": \"Number\" },\n\t\t\"b\": { \"Hash\": \"b\", \"Type\": \"Number\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"x\": { \"Hash\": \"x\", \"Type\": \"Number\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Multiply {{Name:a}} and {{Name:b}}, storing the value in {{Name:x}}.\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:x}} = {{InputValue:a}} * {{InputValue:b}} = {{OutputValue:x}}\"\t\t\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"Math\",\n\t\t\t\"Instruction\": \"multiply\"\n\t\t}\n\t]\n}\n},{}],15:[function(require,module,exports){\nmodule.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"Math\",\n\t\t\"Operation\": \"Subtract\",\n\t\t\"Synopsis\": \"Subtract two numbers:  x = a - b\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"a\": { \"Hash\": \"a\", \"Type\": \"Number\" },\n\t\t\"b\": { \"Hash\": \"b\", \"Type\": \"Number\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"x\": { \"Hash\": \"x\", \"Type\": \"Number\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Subtract {{Name:a}} and {{Name:b}}, storing the value in {{Name:x}}.\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:x}} = {{InputValue:a}} - {{InputValue:b}} = {{OutputValue:x}}\"\t\t\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"Math\",\n\t\t\t\"Instruction\": \"subtract\"\n\t\t}\n\t]\n}\n},{}],16:[function(require,module,exports){\nmodule.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"PreciseMath\",\n\t\t\"Operation\": \"Add\",\n\t\t\"Synopsis\": \"Precisely add two numbers:  x = a + b\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"a\": { \"Hash\": \"a\", \"Type\": \"Number\" },\n\t\t\"b\": { \"Hash\": \"b\", \"Type\": \"Number\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"x\": { \"Hash\": \"x\", \"Type\": \"Number\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Add {{Name:a}} and {{Name:b}}, storing the value in {{Name:x}}.\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:x}} = {{InputValue:a}} + {{InputValue:b}} = {{OutputValue:x}}\"\t\t\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"PreciseMath\",\n\t\t\t\"Instruction\": \"add\"\n\t\t}\n\t]\n}\n},{}],17:[function(require,module,exports){\nmodule.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"PreciseMath\",\n\t\t\"Operation\": \"Aggregate\",\n\t\t\"Synopsis\": \"Precisely aggregate a set of numbers (from array or object address):  x = a + b + ... + z\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"a\": { \"Hash\": \"a\", \"Type\": \"Set\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"x\": { \"Hash\": \"x\", \"Type\": \"Number\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Aggregate all numeric values in {{Name:a}}, storing the resultant in {{Name:x}}.\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:x}} = {{OutputValue:x}}\"\t\t\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"PreciseMath\",\n\t\t\t\"Instruction\": \"aggregate\"\n\t\t}\n\t]\n}\n},{}],18:[function(require,module,exports){\nmodule.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"PreciseMath\",\n\t\t\"Operation\": \"Divide\",\n\t\t\"Synopsis\": \"Precisely divide two numbers:  x = a / b\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"a\": { \"Hash\": \"a\", \"Type\": \"Number\" },\n\t\t\"b\": { \"Hash\": \"b\", \"Type\": \"Number\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"x\": { \"Hash\": \"x\", \"Type\": \"Number\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Divide {{Name:a}} over {{Name:b}}, storing the value in {{Name:x}}.\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:x}} = {{InputValue:a}} / {{InputValue:b}} = {{OutputValue:x}}\"\t\t\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"PreciseMath\",\n\t\t\t\"Instruction\": \"divide\"\n\t\t}\n\t]\n}\n},{}],19:[function(require,module,exports){\nmodule.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"PreciseMath\",\n\t\t\"Operation\": \"GroupValuesAndAggregate\",\n\t\t\"Synopsis\": \"Group values in a set and aggregate the set of numbers (from array or object addresses)\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"inputDataSet\": { \"Hash\":\"inputDataSet\", \"Type\":\"Set\" },\n\t\t\"groupByProperty\": { \"Hash\":\"groupByProperty\", \"Type\":\"Any\"},\n\t\t\"groupValueProperty\": { \"Hash\":\"groupValueProperty\", \"Type\":\"Any\"},\n\t\t\"recordIndicatorProperty\": { \"Hash\":\"recordIndicatorProperty\", \"Type\":\"String\", \"Default\":false}\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"outputDataSet\": { \"Hash\": \"outputDataSet\", \"Type\": \"Set\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Group {{Name:inputDataSet}} by {{Name:groupByProperty}} and create a map, storing the resultant in {{Name:outputDataSet}}.\",\n\t\t\"PostOperation\": \"Operation complete: Grouping {{Name:inputDataSet}} by {{Name:groupByProperty}} into aggregated values in {{Name:outputDataSet}}\"\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"PreciseMath\",\n\t\t\t\"Instruction\": \"groupvaluesandaggregate\"\n\t\t}\n\t]\n}\n},{}],20:[function(require,module,exports){\nmodule.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"PreciseMath\",\n\t\t\"Operation\": \"Multiply\",\n\t\t\"Synopsis\": \"Precisely multiply two numbers:  x = a * b\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"a\": { \"Hash\": \"a\", \"Type\": \"Number\" },\n\t\t\"b\": { \"Hash\": \"b\", \"Type\": \"Number\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"x\": { \"Hash\": \"x\", \"Type\": \"Number\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Multiply {{Name:a}} and {{Name:b}}, storing the value in {{Name:x}}.\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:x}} = {{InputValue:a}} * {{InputValue:b}} = {{OutputValue:x}}\"\t\t\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"PreciseMath\",\n\t\t\t\"Instruction\": \"multiply\"\n\t\t}\n\t]\n}\n},{}],21:[function(require,module,exports){\nmodule.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"PreciseMath\",\n\t\t\"Operation\": \"Round\",\n\t\t\"Synopsis\": \"Precisely round a number.\"\n\t},\n\n\t\"Inputs\":\n\t{\n\t\t\"a\": { \"Hash\": \"a\", \"Type\": \"Number\" },\n\t\t\"precision\": { \"Hash\": \"precision\", \"Type\": \"Number\" },\n\t\t\"roundingmode\": { \"Hash\": \"roundingmode\", \"Type\":\"String\" }\n\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"x\": { \"Hash\": \"x\", \"Type\": \"Number\" }\n\t},\n\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Round {{Name:a}}, storing the value in {{Name:x}}.\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:x}} = Round({{InputValue:a}}) = {{OutputValue:x}}\"\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"PreciseMath\",\n\t\t\t\"Instruction\": \"round\"\n\t\t}\n\t]\n}\n},{}],22:[function(require,module,exports){\nmodule.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"PreciseMath\",\n\t\t\"Operation\": \"SetPrecision\",\n\t\t\"Synopsis\": \"Set the precision.\"\n\t},\n\n\t\"Inputs\":\n\t{\n\t\t\"precision\": { \"Hash\": \"precision\", \"Type\":\"Number\", \"Default\":2}\n\n\t},\n\n\t\"Outputs\":\n\t{\n\t},\n\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Set precision to {{InputValue:precision}}.\",\n\t\t\"PostOperation\": \"Operation complete: Default precision set to {{InputValue:precision}}.\"\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"PreciseMath\",\n\t\t\t\"Instruction\": \"setprecision\"\n\t\t}\n\t]\n}\n},{}],23:[function(require,module,exports){\nmodule.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"PreciseMath\",\n\t\t\"Operation\": \"SetRoundingMode\",\n\t\t\"Synopsis\": \"Set the rounding mode.\"\n\t},\n\n\t\"Inputs\":\n\t{\n\t\t\"roundingmode\": { \"Hash\": \"roundingmode\", \"Type\":\"String\", \"Default\":\"ROUND_HALF_UP\"}\n\n\t},\n\n\t\"Outputs\":\n\t{\n\t},\n\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Set rounding mode to {{InputValue:roundingmode}}.\",\n\t\t\"PostOperation\": \"Operation complete: Default rounding mode set to {{InputValue:roundingmode}}.\"\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"PreciseMath\",\n\t\t\t\"Instruction\": \"setroundingmode\"\n\t\t}\n\t]\n}\n},{}],24:[function(require,module,exports){\nmodule.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"PreciseMath\",\n\t\t\"Operation\": \"Subtract\",\n\t\t\"Synopsis\": \"Precisely subtract two numbers:  x = a - b\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"a\": { \"Hash\": \"a\", \"Type\": \"Number\" },\n\t\t\"b\": { \"Hash\": \"b\", \"Type\": \"Number\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"x\": { \"Hash\": \"x\", \"Type\": \"Number\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Subtract {{Name:a}} and {{Name:b}}, storing the value in {{Name:x}}.\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:x}} = {{InputValue:a}} - {{InputValue:b}} = {{OutputValue:x}}\"\t\t\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"PreciseMath\",\n\t\t\t\"Instruction\": \"subtract\"\n\t\t}\n\t]\n}\n},{}],25:[function(require,module,exports){\nmodule.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"PreciseMath\",\n\t\t\"Operation\": \"ToDecimalPlaces\",\n\t\t\"Synopsis\": \"Precisely round a number to a certain number of decimal places.\"\n\t},\n\n\t\"Inputs\":\n\t{\n\t\t\"a\": { \"Hash\": \"a\", \"Type\": \"Number\" },\n\t\t\"decimalplaces\": { \"Hash\": \"decimalplaces\", \"Type\": \"Number\", \"Default\":2 },\n\t\t\"roundingmode\": { \"Hash\": \"roundingmode\", \"Type\":\"String\" }\n\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"x\": { \"Hash\": \"x\", \"Type\": \"Number\" }\n\t},\n\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Round {{Name:a}} to {{Value:decimalplaces}} decimal places, storing the value in {{Name:x}}.\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:x}} = Round({{InputValue:a}} TO {{Value:decimalplaces}} decimal places) = {{OutputValue:x}}\"\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"PreciseMath\",\n\t\t\t\"Instruction\": \"todecimalplaces\"\n\t\t}\n\t]\n}\n},{}],26:[function(require,module,exports){\nmodule.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"PreciseMath\",\n\t\t\"Operation\": \"ToSignificantDigits\",\n\t\t\"Synopsis\": \"Precisely round a number to a specific number of significant digits.\"\n\t},\n\n\t\"Inputs\":\n\t{\n\t\t\"a\": { \"Hash\": \"a\", \"Type\": \"Number\" },\n\t\t\"digits\": { \"Hash\": \"digits\", \"Type\": \"Number\", \"Default\":12 },\n\t\t\"roundingmode\": { \"Hash\": \"roundingmode\", \"Type\":\"String\" }\n\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"x\": { \"Hash\": \"x\", \"Type\": \"Number\" }\n\t},\n\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Round {{Name:a}} to {{InputValue:digits}}, storing the value in {{Name:x}}.\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:x}} = Round({{InputValue:a}} TO {{InputValue:digits}}) = {{OutputValue:x}}\"\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"PreciseMath\",\n\t\t\t\"Instruction\": \"tosignificantdigits\"\n\t\t}\n\t]\n}\n},{}],27:[function(require,module,exports){\nmodule.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"Set\",\n\t\t\"Operation\": \"GroupValuesBy\",\n\t\t\"Synopsis\": \"Group set of Sub object values by another property in the objects.\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"inputDataSet\": { \"Hash\":\"inputDataSet\", \"Type\":\"Set\" },\n\t\t\"groupByProperty\": { \"Hash\":\"groupByProperty\", \"Type\":\"Any\"},\n\t\t\"groupValueProperty\": { \"Hash\":\"groupValueProperty\", \"Type\":\"Any\"}\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"outputDataSet\": { \"Hash\": \"outputDataSet\", \"Type\": \"Set\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Group {{Name:inputDataSet}} by {{Name:groupByProperty}} and create a mapped result set into {{Name:outputDataSet}}.\",\n\t\t\"PostOperation\": \"Operation complete: Grouping {{Name:inputDataSet}} by {{Name:groupByProperty}} into {{Name:outputDataSet}}\"\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"Set\",\n\t\t\t\"Instruction\": \"GroupValuesBy\"\n\t\t}\n\t]\n}\n},{}],28:[function(require,module,exports){\nmodule.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"String\",\n\t\t\"Operation\": \"Replace\",\n\t\t\"Synopsis\": \"Replace all instances of searchFor with replaceWith in inputString\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"inputString\": { \"Hash\": \"inputString\", \"Type\": \"String\" },\n\t\t\"searchFor\": { \"Hash\": \"searchFor\", \"Type\": \"String\" },\n\t\t\"replaceWith\": { \"Hash\": \"replaceWith\", \"Type\": \"String\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"outputString\": { \"Hash\": \"outputString\", \"Type\": \"String\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Search for [{{InputValue:searchFor}}] and replace it with [{{InputValue:replaceWith}}] in [{{InputValue:inputString}}].\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:outputString}} = [{{OutputValue:outputString}}] from [{{InputValue:inputString}}] replacing [{{InputValue:searchFor}}] with [{{InputValue:replaceWith}}].\"\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"String\",\n\t\t\t\"Instruction\": \"replace\"\n\t\t}\n\t]\n}\n},{}],29:[function(require,module,exports){\nmodule.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"String\",\n\t\t\"Operation\": \"Substring\",\n\t\t\"Synopsis\": \"Get all characters between indexStart and indexEnd (optional) for a given inputString.\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"inputString\": { \"Hash\": \"inputString\", \"Type\": \"String\" },\n\t\t\"indexStart\": { \"Hash\": \"indexStart\", \"Type\": \"Number\", \"Default\":0 },\n\t\t\"indexEnd\": { \"Hash\": \"indexEnd\", \"Type\": \"String\", \"Default\":null }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"outputString\": { \"Hash\": \"outputString\", \"Type\": \"String\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Get all characters between {{InputValue:indexStart}} and {{InputValue:indexEnd}} in [{{InputValue:inputString}}].\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:outputString}} = [{{OutputValue:outputString}}] from [{{InputValue:inputString}}] between {{InputValue:indexStart}} and {{InputValue:indexEnd}}.\"\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"String\",\n\t\t\t\"Instruction\": \"substring\"\n\t\t}\n\t]\n}\n},{}],30:[function(require,module,exports){\nmodule.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"String\",\n\t\t\"Operation\": \"Trim\",\n\t\t\"Synopsis\": \"Trim whitespace off the end of string in inputString, putting the result in outputString\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"inputString\": { \"Hash\": \"inputString\", \"Type\": \"String\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"outputString\": { \"Hash\": \"outputString\", \"Type\": \"String\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Trim the whitespace from value [{{InputValue:inputString}}].\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:outputString}} = [{{OutputValue:outputString}}] from [{{InputValue:inputString}}]\"\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"String\",\n\t\t\t\"Instruction\": \"trim\"\n\t\t}\n\t]\n}\n},{}],31:[function(require,module,exports){\nlet libElucidatorInstructionSet = require('../Elucidator-InstructionSet.js');\n\nconst libDecimal = require('decimal.js');\n\nlet add = (pOperation) =>\n{\n    // This could be done in one line, but, would be more difficult to comprehend.\n    let tmpA = new libDecimal(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'a'));\n    let tmpB = new libDecimal(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'b'));\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'x', tmpA.plus(tmpB).toString());\n    return true;\n};\n\nlet subtract = (pOperation) =>\n{\n    // This could be done in one line, but, would be more difficult to comprehend.\n    let tmpA = new libDecimal(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'a'));\n    let tmpB = new libDecimal(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'b'));\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'x', tmpA.sub(tmpB).toString());\n    return true;\n};\n\nlet multiply = (pOperation) =>\n{\n    // This could be done in one line, but, would be more difficult to comprehend.\n    let tmpA = new libDecimal(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'a'));\n    let tmpB = new libDecimal(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'b'));\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'x', tmpA.mul(tmpB).toString());\n    return true;\n};\n\nlet divide = (pOperation) =>\n{\n    // This could be done in one line, but, would be more difficult to comprehend.\n    let tmpA = new libDecimal(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'a'));\n    let tmpB = new libDecimal(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'b'));\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'x', tmpA.div(tmpB).toString());\n    return true;\n};\n\nlet round = (pOperation) =>\n{\n    let tmpA = new libDecimal(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'a'));\n\n    let tmpPrecision = parseInt(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'precision'));\n    let tmpRoundingMode = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'roundingmode')\n\n    // Eventually don't set this every time...\n    if (tmpRoundingMode)\n    {\n        switch (tmpRoundingMode.toString().toLowerCase())\n        {\n            case 'round_up':\n                libDecimal.set({ rounding: libDecimal.ROUND_UP });\n                break;\n            case 'round_down':\n                libDecimal.set({ rounding: libDecimal.ROUND_DOWN });\n                break;\n            case 'round_ceil':\n                libDecimal.set({ rounding: libDecimal.ROUND_CEIL });\n                break;\n            case 'round_floor':\n                libDecimal.set({ rounding: libDecimal.ROUND_FLOOR });\n                break;\n            default:\n            case 'round_half_up':\n                libDecimal.set({ rounding: libDecimal.ROUND_HALF_UP });\n                break;\n            case 'round_half_down':\n                libDecimal.set({ rounding: libDecimal.ROUND_HALF_DOWN });\n                break;\n            case 'round_half_even':\n                libDecimal.set({ rounding: libDecimal.ROUND_HALF_EVEN });\n                break;\n            case 'round_half_ceil':\n                libDecimal.set({ rounding: libDecimal.ROUND_HALF_CEIL });\n                break;\n            case 'round_half_floor':\n                libDecimal.set({ rounding: libDecimal.ROUND_HALF_FLOOR });\n                break;\n            case 'euclid':\n                libDecimal.set({ rounding: libDecimal.EUCLID });\n                break;\n        }\n    }\n    \n    if (!isNaN(tmpPrecision))\n    {\n        libDecimal.set({ precision: tmpPrecision });\n    }\n\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'x', libDecimal.round(tmpA).toString());\n};\n\n\nlet tosignificantdigits = (pOperation) =>\n{\n    let tmpA = new libDecimal(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'a'));\n\n    let tmpDigits = parseInt(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'digits'));\n    let tmpRoundingMode = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'roundingmode')\n\n    // Eventually don't set this every time...\n    if (tmpRoundingMode)\n    {\n        switch (tmpRoundingMode.toString().toLowerCase())\n        {\n            case 'round_up':\n                libDecimal.set({ rounding: libDecimal.ROUND_UP });\n                break;\n            case 'round_down':\n                libDecimal.set({ rounding: libDecimal.ROUND_DOWN });\n                break;\n            case 'round_ceil':\n                libDecimal.set({ rounding: libDecimal.ROUND_CEIL });\n                break;\n            case 'round_floor':\n                libDecimal.set({ rounding: libDecimal.ROUND_FLOOR });\n                break;\n            default:\n            case 'round_half_up':\n                libDecimal.set({ rounding: libDecimal.ROUND_HALF_UP });\n                break;\n            case 'round_half_down':\n                libDecimal.set({ rounding: libDecimal.ROUND_HALF_DOWN });\n                break;\n            case 'round_half_even':\n                libDecimal.set({ rounding: libDecimal.ROUND_HALF_EVEN });\n                break;\n            case 'round_half_ceil':\n                libDecimal.set({ rounding: libDecimal.ROUND_HALF_CEIL });\n                break;\n            case 'round_half_floor':\n                libDecimal.set({ rounding: libDecimal.ROUND_HALF_FLOOR });\n                break;\n            case 'euclid':\n                libDecimal.set({ rounding: libDecimal.EUCLID });\n                break;\n        }\n    }\n    \n    if (isNaN(tmpDigits))\n    {\n        tmpDigits = 12;\n    }\n\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'x', tmpA.toSignificantDigits(tmpDigits).toString());\n};\n\nlet todecimalplaces = (pOperation) =>\n{\n    let tmpA = new libDecimal(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'a'));\n\n    let tmpDecimalPlaces = parseInt(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'decimalplaces'));\n    let tmpRoundingMode = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'roundingmode')\n\n    // Eventually don't set this every time...\n    if (tmpRoundingMode)\n    {\n        switch (tmpRoundingMode.toString().toLowerCase())\n        {\n            case 'round_up':\n                libDecimal.set({ rounding: libDecimal.ROUND_UP });\n                break;\n            case 'round_down':\n                libDecimal.set({ rounding: libDecimal.ROUND_DOWN });\n                break;\n            case 'round_ceil':\n                libDecimal.set({ rounding: libDecimal.ROUND_CEIL });\n                break;\n            case 'round_floor':\n                libDecimal.set({ rounding: libDecimal.ROUND_FLOOR });\n                break;\n            default:\n            case 'round_half_up':\n                libDecimal.set({ rounding: libDecimal.ROUND_HALF_UP });\n                break;\n            case 'round_half_down':\n                libDecimal.set({ rounding: libDecimal.ROUND_HALF_DOWN });\n                break;\n            case 'round_half_even':\n                libDecimal.set({ rounding: libDecimal.ROUND_HALF_EVEN });\n                break;\n            case 'round_half_ceil':\n                libDecimal.set({ rounding: libDecimal.ROUND_HALF_CEIL });\n                break;\n            case 'round_half_floor':\n                libDecimal.set({ rounding: libDecimal.ROUND_HALF_FLOOR });\n                break;\n            case 'euclid':\n                libDecimal.set({ rounding: libDecimal.EUCLID });\n                break;\n        }\n    }\n    \n    if (isNaN(tmpDecimalPlaces))\n    {\n        tmpDecimalPlaces = 2;\n    }\n\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'x', tmpA.toDecimalPlaces(tmpDecimalPlaces).toString());\n};\n\nlet setprecision = (pOperation) =>\n{\n    let tmpPrecision = parseInt(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'precision'));\n    \n    console.log(tmpPrecision)\n    if (!isNaN(tmpPrecision))\n    {\n        libDecimal.set({ precision: tmpPrecision });\n    }\n};\n\nlet setroundingmode = (pOperation) =>\n{\n    let tmpRoundingMode = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'roundingmode')\n\n    // Eventually don't set this every time...\n    if (tmpRoundingMode)\n    {\n        switch (tmpRoundingMode.toString().toLowerCase())\n        {\n            case 'round_up':\n                libDecimal.set({ rounding: libDecimal.ROUND_UP });\n                break;\n            case 'round_down':\n                libDecimal.set({ rounding: libDecimal.ROUND_DOWN });\n                break;\n            case 'round_ceil':\n                libDecimal.set({ rounding: libDecimal.ROUND_CEIL });\n                break;\n            case 'round_floor':\n                libDecimal.set({ rounding: libDecimal.ROUND_FLOOR });\n                break;\n            default:\n            case 'round_half_up':\n                libDecimal.set({ rounding: libDecimal.ROUND_HALF_UP });\n                break;\n            case 'round_half_down':\n                libDecimal.set({ rounding: libDecimal.ROUND_HALF_DOWN });\n                break;\n            case 'round_half_even':\n                libDecimal.set({ rounding: libDecimal.ROUND_HALF_EVEN });\n                break;\n            case 'round_half_ceil':\n                libDecimal.set({ rounding: libDecimal.ROUND_HALF_CEIL });\n                break;\n            case 'round_half_floor':\n                libDecimal.set({ rounding: libDecimal.ROUND_HALF_FLOOR });\n                break;\n            case 'euclid':\n                libDecimal.set({ rounding: libDecimal.EUCLID });\n                break;\n        }\n    }\n};\n\nlet aggregate = (pOperation) =>\n{\n    let tmpA = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'a');\n\n    let tmpObjectType = typeof(tmpA);\n\n    let tmpAggregationValue = new libDecimal(0);\n\n    if (tmpObjectType == 'object')\n    {\n        if (Array.isArray(tmpA))\n        {\n            for (let i = 0; i < tmpA.length; i++)\n            {\n                // If this is an array, enumerate it and try to aggregate each number\n                let tmpValue = new libDecimal(tmpA[i]);\n\n                if (isNaN(tmpValue))\n                {\n                    pOperation.logError(`Array element index [${i}] could not be parsed as a number by Decimal.js; skipping.  (${tmpA[i]})`);\n                }\n                else\n                {\n                    tmpAggregationValue = tmpAggregationValue.plus(tmpValue);\n                    pOperation.logInfo(`Adding element [${i}] value ${tmpValue} totaling: ${tmpAggregationValue}`)\n                }\n            }\n        }\n        else\n        {\n            let tmpObjectKeys = Object.keys(tmpA);\n            for (let i = 0; i < tmpObjectKeys.length; i++)\n            {\n                let tmpValue = new libDecimal(tmpA[tmpObjectKeys[i]]);\n\n                if (isNaN(tmpValue))\n                {\n                    pOperation.logError(`Object property [${tmpObjectKeys[i]}] could not be parsed as a number; skipping.  (${tmpA[tmpObjectKeys[i]]})`);\n                }\n                else\n                {\n                    tmpAggregationValue = tmpAggregationValue.plus(tmpValue);\n                    pOperation.logInfo(`Adding object property [${tmpObjectKeys[i]}] value ${tmpValue} totaling: ${tmpAggregationValue}`)\n                }\n            }\n        }\n    }\n    else\n    {\n        let tmpValue = new libDecimal(tmpA);\n\n        if (isNaN(tmpValue))\n        {\n            pOperation.logError(`Direct value could not be parsed as a number; skipping.  (${tmpA})`);\n        }\n        else\n        {\n            tmpAggregationValue = tmpValue;\n        }\n    }\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'x', tmpAggregationValue.toString());\n    return true;\n};\n\nconst groupValuesAndAggregate = (pOperation) =>\n{\n    let tmpInputDataSet = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'inputDataSet');\n    let tmpGroupByProperty = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'groupByProperty');\n    let tmpGroupValueProperty = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'groupValueProperty');\n\n    let tmpOutputDataSet = {};\n    let tmpProcessedOutputDataSet = {};\n \n    let tmpObjectType = typeof(tmpInputDataSet);\n\n    if (tmpObjectType == 'object')\n    {\n        if (Array.isArray(tmpInputDataSet))\n        {\n            for (let i = 0; i < tmpInputDataSet.length; i++)\n            {\n                if (typeof(tmpInputDataSet[i]) !== 'object')\n                {\n                    pOperation.logInfo(`Element [${i}] was not an object; skipping group operation.`);\n                }\n                else\n                {\n                    let tmpValue = tmpInputDataSet[i];\n                    let tmpGroupByValue = tmpValue[tmpGroupByProperty];\n                    if (!tmpValue.hasOwnProperty(tmpGroupByProperty))\n                    {\n                        pOperation.logInfo(`Element [${i}] doesn't have the group by property [${tmpGroupByProperty}]; setting group to [__NO_GROUP].`);\n                        tmpGroupByValue = '__NO_GROUP';\n                    }\n\n                    if (!tmpValue.hasOwnProperty(tmpGroupValueProperty))\n                    {\n                        pOperation.logInfo(`Element [${i}] doesn't have the group value property [${tmpGroupValueProperty}]; skipping group operation.`);\n                    }\n                    else\n                    {\n                        let tmpDecimalValue = new libDecimal(tmpValue[tmpGroupValueProperty]);\n\n                        if (isNaN(tmpDecimalValue))\n                        {\n                            pOperation.logError(`Object property [${i}] could not be parsed as a number; skipping.  (${tmpValue[tmpGroupValueProperty]})`);\n                        }\n                        else\n                        {\n                            if (!tmpOutputDataSet.hasOwnProperty(tmpGroupByValue))\n                            {\n                                tmpOutputDataSet[tmpGroupByValue] = tmpDecimalValue;\n                            }\n                            else\n                            {\n                                tmpOutputDataSet[tmpGroupByValue] = tmpOutputDataSet[tmpGroupByValue].plus(tmpDecimalValue);\n                            }\n                            pOperation.logInfo(`Adding object property [${i}] value ${tmpDecimalValue} totaling: ${tmpOutputDataSet[tmpGroupByValue]}`)\n                        }\n                    }\n                }\n            }\n        }\n        else\n        {\n            let tmpObjectKeys = Object.keys(tmpInputDataSet);\n            for (let i = 0; i < tmpObjectKeys.length; i++)\n            {\n                if (typeof(tmpInputDataSet[tmpObjectKeys[i]]) !== 'object')\n                {\n                    pOperation.logInfo(`Element [${i}] was not an object; skipping group operation.`);\n                }\n                else\n                {\n                    let tmpValue = tmpInputDataSet[tmpObjectKeys[i]];\n                    let tmpGroupByValue = tmpValue[tmpGroupByProperty];\n                    if (!tmpValue.hasOwnProperty(tmpGroupByProperty))\n                    {\n                        pOperation.logInfo(`Element [${tmpObjectKeys[i]}][${i}] doesn't have the group by property [${tmpGroupByProperty}]; setting group to [__NO_GROUP].`);\n                        tmpGroupByValue = '__NO_GROUP';\n                    }\n\n                    if (!tmpValue.hasOwnProperty(tmpGroupValueProperty))\n                    {\n                        pOperation.logInfo(`Element [${tmpObjectKeys[i]}][${i}] doesn't have the group value property [${tmpGroupValueProperty}]; skipping group operation.`);\n                    }\n                    else\n                    {\n                        let tmpDecimalValue = new libDecimal(tmpValue[tmpGroupValueProperty]);\n\n                        if (isNaN(tmpDecimalValue))\n                        {\n                            pOperation.logError(`Object property [${tmpObjectKeys[i]}][${i}] to group ${tmpGroupByValue} could not be parsed as a number; skipping.  (${tmpValue[tmpGroupValueProperty]})`);\n                        }\n                        else\n                        {\n                            if (!tmpOutputDataSet.hasOwnProperty(tmpGroupByValue))\n                            {\n                                tmpOutputDataSet[tmpGroupByValue] = tmpDecimalValue;\n                            }\n                            else\n                            {\n                                tmpOutputDataSet[tmpGroupByValue] = tmpOutputDataSet[tmpGroupByValue].plus(tmpDecimalValue);\n                            }\n                            pOperation.logInfo(`Adding object property [${tmpObjectKeys[i]}][${i}] to group ${tmpGroupByValue} value ${tmpDecimalValue} totaling: ${tmpOutputDataSet[tmpGroupByValue]}`)\n                        }\n                    }\n                }\n            }\n        }\n\n        // Now marshal the aggregated values\n        let tmpOutputGroups = Object.keys(tmpOutputDataSet);\n        for (let j = 0; j < tmpOutputGroups.length; j++)\n        {\n            tmpProcessedOutputDataSet[tmpOutputGroups[j]] = tmpOutputDataSet[tmpOutputGroups[j]].toString();\n        }\n    }\n    else\n    {\n        pOperation.logError(`Input set is neither an Array nor an Object`);\n    }\n\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'outputDataSet', tmpProcessedOutputDataSet);\n\n    return true;\n}\n\nlet toFraction = (pOperation) =>\n{\n    // This could be done in one line, but, would be more difficult to comprehend.\n    let tmpA = new libDecimal(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'a'));\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'x', tmpA.toFraction().toString());\n    return true;\n};\n\n\nclass PreciseMath extends libElucidatorInstructionSet\n{\n    constructor(pElucidator)\n    {\n        super(pElucidator);\n        this.namespace = 'PreciseMath';\n    }\n\n    initializeInstructions()\n    {\n        this.addInstruction('add', add);\n\n        this.addInstruction('subtract', subtract);\n        this.addInstruction('sub', subtract);\n\n        this.addInstruction('multiply', multiply);\n        this.addInstruction('mul', multiply);\n\n        this.addInstruction('divide', divide);\n        this.addInstruction('div', divide);\n\n        this.addInstruction('aggregate', aggregate);\n        this.addInstruction('groupvaluesandaggregate', groupValuesAndAggregate);\n\n        this.addInstruction('setprecision', setprecision);\n        this.addInstruction('setroundingmode', setroundingmode);\n\n        this.addInstruction('todecimalplaces', todecimalplaces);\n        this.addInstruction('tosignificantdigits', tosignificantdigits);\n        this.addInstruction('round', round);\n        this.addInstruction('tofraction', toFraction);\n\n\n        return true;\n    }\n\n    initializeOperations()\n    {\n        this.addOperation('add', require(`./Operations/PreciseMath-Add.json`));\n        this.addOperation('subtract', require(`./Operations/PreciseMath-Subtract.json`));\n        this.addOperation('multiply', require(`./Operations/PreciseMath-Multiply.json`));\n        this.addOperation('divide', require(`./Operations/PreciseMath-Divide.json`));\n\n        this.addOperation('aggregate', require('./Operations/PreciseMath-Aggregate.json'));\n        this.addOperation('groupvaluesandaggregate', require('./Operations/PreciseMath-GroupValuesAndAggregate.json'));\n\n        this.addOperation('setprecision', require('./Operations/PreciseMath-SetPrecision.json'));\n        this.addOperation('setroundingmode', require('./Operations/PreciseMath-SetRoundingMode.json'));\n\n        this.addOperation('tosignificantdigits', require('./Operations/PreciseMath-ToSignificantDigits.json'));\n        this.addOperation('todecimalplaces', require('./Operations/PreciseMath-ToDecimalPlaces.json'));\n        this.addOperation('round', require('./Operations/PreciseMath-Round.json'));\n\n        return true;\n    }\n}\n\nmodule.exports = PreciseMath;\n},{\"../Elucidator-InstructionSet.js\":2,\"./Operations/PreciseMath-Add.json\":16,\"./Operations/PreciseMath-Aggregate.json\":17,\"./Operations/PreciseMath-Divide.json\":18,\"./Operations/PreciseMath-GroupValuesAndAggregate.json\":19,\"./Operations/PreciseMath-Multiply.json\":20,\"./Operations/PreciseMath-Round.json\":21,\"./Operations/PreciseMath-SetPrecision.json\":22,\"./Operations/PreciseMath-SetRoundingMode.json\":23,\"./Operations/PreciseMath-Subtract.json\":24,\"./Operations/PreciseMath-ToDecimalPlaces.json\":25,\"./Operations/PreciseMath-ToSignificantDigits.json\":26,\"decimal.js\":1}],32:[function(require,module,exports){\n// Solution providers are meant to be stateless, and not classes.\n// These solution providers are akin to drivers, connecting code libraries or \n// other types of behavior to mapping operations.\n\nlet libElucidatorInstructionSet = require('../Elucidator-InstructionSet.js');\n\nconst groupValuesBy = (pOperation) =>\n{\n    let tmpInputDataSet = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'inputDataSet');\n    let tmpGroupByProperty = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'groupByProperty');\n    let tmpGroupValueProperty = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'groupValueProperty');\n\n    let tmpOutputDataSet = {};\n \n    let tmpObjectType = typeof(tmpInputDataSet);\n\n    if (tmpObjectType == 'object')\n    {\n        if (Array.isArray(tmpInputDataSet))\n        {\n            for (let i = 0; i < tmpInputDataSet.length; i++)\n            {\n                if (typeof(tmpInputDataSet[i]) !== 'object')\n                {\n                    pOperation.logInfo(`Element [${i}] was not an object; skipping group operation.`);\n                }\n                else\n                {\n                    let tmpValue = tmpInputDataSet[i];\n                    let tmpGroupByValue = tmpValue[tmpGroupByProperty];\n                    if (!tmpValue.hasOwnProperty(tmpGroupByProperty))\n                    {\n                        pOperation.logInfo(`Element [${i}] doesn't have the group by property [${tmpGroupByProperty}]; setting group to [__NO_GROUP].`);\n                        tmpGroupByValue = '__NO_GROUP';\n                    }\n\n                    if (!tmpValue.hasOwnProperty(tmpGroupValueProperty))\n                    {\n                        pOperation.logInfo(`Element [${i}] doesn't have the group value property [${tmpGroupValueProperty}]; skipping group operation.`);\n                    }\n                    else\n                    {\n                        if (!tmpOutputDataSet.hasOwnProperty(tmpGroupByValue))\n                        {\n                            // Create a new grouped value\n                            pOperation.logInfo(`Creating a new group [${tmpGroupByValue}] for element [${i}].`);\n                            tmpOutputDataSet[tmpGroupByValue] = [];\n                        }\n\n                        tmpOutputDataSet[tmpGroupByValue].push(tmpValue[tmpGroupValueProperty]);\n                    }\n                }\n            }\n        }\n        else\n        {\n            let tmpObjectKeys = Object.keys(tmpInputDataSet);\n            for (let i = 0; i < tmpObjectKeys.length; i++)\n            {\n                if (typeof(tmpInputDataSet[tmpObjectKeys[i]]) !== 'object')\n                {\n                    pOperation.logInfo(`Element [${i}] was not an object; skipping group operation.`);\n                }\n                else\n                {\n                    let tmpValue = tmpInputDataSet[tmpObjectKeys[i]];\n                    let tmpGroupByValue = tmpValue[tmpGroupByProperty];\n                    if (!tmpValue.hasOwnProperty(tmpGroupByProperty))\n                    {\n                        pOperation.logInfo(`Element [${tmpObjectKeys[i]}][${i}] doesn't have the group by property [${tmpGroupByProperty}]; setting group to [__NO_GROUP].`);\n                        tmpGroupByValue = '__NO_GROUP';\n                    }\n\n                    if (!tmpValue.hasOwnProperty(tmpGroupValueProperty))\n                    {\n                        pOperation.logInfo(`Element [${tmpObjectKeys[i]}][${i}] doesn't have the group value property [${tmpGroupValueProperty}]; skipping group operation.`);\n                    }\n                    else\n                    {\n                        if (!tmpOutputDataSet.hasOwnProperty(tmpGroupByValue))\n                        {\n                            // Create a new grouped value\n                            pOperation.logInfo(`Creating a new group [${tmpGroupByValue}] for element [${tmpObjectKeys[i]}][${i}].`);\n                            tmpOutputDataSet[tmpGroupByValue] = [];\n                        }\n\n                        tmpOutputDataSet[tmpGroupByValue].push(tmpValue[tmpGroupValueProperty]);\n                    }\n                }\n            }\n        }\n    }\n    else\n    {\n        pOperation.logError(`Input set is neither an Array nor an Object`);\n    }\n\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'outputDataSet', tmpOutputDataSet);\n\n    return true;\n}\n\nclass Set extends libElucidatorInstructionSet\n{\n    constructor(pElucidator)\n    {\n        super(pElucidator);\n        this.namespace = 'Set';\n    }\n\n    initializeInstructions()\n    {\n        // Logic actually wants a noop instruction!\n        super.initializeInstructions();\n\n        this.addInstruction('groupvaluesby', groupValuesBy);\n\n        return true;\n    }\n\n    initializeOperations()\n    {\n        this.addOperation('groupvaluesby', require(`./Operations/Set-GroupValuesBy.json`));\n\n        return true;\n    }\n}\n\nmodule.exports = Set;\n},{\"../Elucidator-InstructionSet.js\":2,\"./Operations/Set-GroupValuesBy.json\":27}],33:[function(require,module,exports){\n// Solution providers are meant to be stateless, and not classes.\n// These solution providers are akin to drivers, connecting code libraries or \n// other types of behavior to mapping operations.\n\nlet libElucidatorInstructionSet = require('../Elucidator-InstructionSet.js');\n\nlet trim = (pOperation) =>\n{\n    let tmpInputString = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'inputString');\n\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'outputString', tmpInputString.trim());\n\n    return true;\n};\n\nlet replace = (pOperation) =>\n{\n    let tmpInputString = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'inputString');\n    let tmpSearchFor = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'searchFor');\n    let tmpReplaceWith = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'replaceWith');\n\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'outputString', tmpInputString.replace(tmpSearchFor, tmpReplaceWith));\n\n    return true;\n};\n\nlet substring = (pOperation) =>\n{\n    let tmpInputString = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'inputString');\n    let indexStart = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'indexStart');\n    let indexEnd = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'indexEnd');\n\n    if (indexEnd != null)\n    {\n        pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'outputString', tmpInputString.substring(indexStart, indexEnd));\n    }\n    else\n    {\n        pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'outputString', tmpInputString.substring(indexStart));\n    }\n\n    return true;\n};\n\nclass StringOperations extends libElucidatorInstructionSet\n{\n    constructor(pElucidator)\n    {\n        super(pElucidator);\n        this.namespace = 'String';\n    }\n\n    initializeInstructions()\n    {\n        this.addInstruction('trim', trim);\n        this.addInstruction('replace', replace);\n        this.addInstruction('substring', substring);\n\n        return true;\n    }\n\n    initializeOperations()\n    {\n        this.addOperation('trim', require(`./Operations/String-Trim.json`));\n        this.addOperation('replace', require(`./Operations/String-Replace.json`));\n        this.addOperation('substring', require(`./Operations/String-Substring.json`));\n\n        return true;\n    }\n}\n\nmodule.exports = StringOperations;\n},{\"../Elucidator-InstructionSet.js\":2,\"./Operations/String-Replace.json\":28,\"./Operations/String-Substring.json\":29,\"./Operations/String-Trim.json\":30}],34:[function(require,module,exports){\n// When a boxed property is passed in, it should have quotes of some\n// kind around it.\n//\n// For instance:\n// \t\tMyValues['Name']\n// \t\tMyValues[\"Age\"]\n// \t\tMyValues[`Cost`]\n//\n// This function removes the wrapping quotes.\n//\n// Please note it *DOES NOT PARSE* template literals, so backticks just\n// end up doing the same thing as other quote types.\n//\n// TODO: Should template literals be processed?  If so what state do they have access to?  That should happen here if so.\n// TODO: Make a simple class include library with these\nlet cleanWrapCharacters = (pCharacter, pString) =>\n{\n\tif (pString.startsWith(pCharacter) && pString.endsWith(pCharacter))\n\t{\n\t\treturn pString.substring(1, pString.length - 1);\n\t}\n\telse\n\t{\n\t\treturn pString;\n\t}\n};\n\nmodule.exports = cleanWrapCharacters;\n},{}],35:[function(require,module,exports){\n/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\nlet libSimpleLog = require('./Manyfest-LogToConsole.js');\n\n/**\n* Hash Translation\n*\n* This is a very simple translation table for hashes, which allows the same schema to resolve\n* differently based on a loaded translation table.\n*\n* This is to prevent the requirement for mutating schemas over and over again when we want to\n* reuse the structure but look up data elements by different addresses.\n*\n* One side-effect of this is that a translation table can \"override\" the built-in hashes, since\n* this is always used to resolve hashes before any of the functionCallByHash(pHash, ...) perform\n* their lookups by hash.\n*\n* @class ManyfestHashTranslation\n*/\nclass ManyfestHashTranslation\n{\n\tconstructor(pInfoLog, pErrorLog)\n\t{\n\t\t// Wire in logging\n\t\tthis.logInfo = (typeof(pInfoLog) === 'function') ? pInfoLog : libSimpleLog;\n\t\tthis.logError = (typeof(pErrorLog) === 'function') ? pErrorLog : libSimpleLog;\n\n        this.translationTable = {};\n\t}\n\n    translationCount()\n    {\n        return Object.keys(this.translationTable).length;\n    }\n\n    addTranslation(pTranslation)\n    {\n        // This adds a translation in the form of:\n        // { \"SourceHash\": \"DestinationHash\", \"SecondSourceHash\":\"SecondDestinationHash\" }\n        if (typeof(pTranslation) != 'object')\n        {\n            this.logError(`Hash translation addTranslation expected a translation be type object but was passed in ${typeof(pTranslation)}`);\n            return false;\n        }\n\n        let tmpTranslationSources = Object.keys(pTranslation)\n\n        tmpTranslationSources.forEach(\n            (pTranslationSource) =>\n            {\n                if (typeof(pTranslation[pTranslationSource]) != 'string')\n                {\n                    this.logError(`Hash translation addTranslation expected a translation destination hash for [${pTranslationSource}] to be a string but the referrant was a ${typeof(pTranslation[pTranslationSource])}`);\n                }\n                else\n                {\n                    this.translationTable[pTranslationSource] = pTranslation[pTranslationSource];\n                }\n            });\n    }\n\n    removeTranslationHash(pTranslationHash)\n    {\n        if (this.translationTable.hasOwnProperty(pTranslationHash))\n        {\n            delete this.translationTable[pTranslationHash];\n        }\n    }\n\n    // This removes translations.\n    // If passed a string, just removes the single one.\n    // If passed an object, it does all the source keys.\n    removeTranslation(pTranslation)\n    {\n        if (typeof(pTranslation) == 'string')\n        {\n            this.removeTranslationHash(pTranslation);\n            return true;\n        }\n        else if (typeof(pTranslation) == 'object')\n        {\n            let tmpTranslationSources = Object.keys(pTranslation)\n\n            tmpTranslationSources.forEach(\n                (pTranslationSource) =>\n                {\n                    this.removeTranslation(pTranslationSource);\n                });\n            return true;\n        }\n        else\n        {\n            this.logError(`Hash translation removeTranslation expected either a string or an object but the passed-in translation was type ${typeof(pTranslation)}`);\n            return false;\n        }\n    }\n\n    clearTranslations()\n    {\n        this.translationTable = {};\n    }\n\n    translate(pTranslation)\n    {\n        if (this.translationTable.hasOwnProperty(pTranslation))\n        {\n            return this.translationTable[pTranslation];\n        }\n        else\n        {\n            return pTranslation;\n        }\n    }\n}\n\nmodule.exports = ManyfestHashTranslation;\n},{\"./Manyfest-LogToConsole.js\":36}],36:[function(require,module,exports){\n/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\n\n/**\n* Manyfest simple logging shim (for browser and dependency-free running)\n*/\n\nconst logToConsole = (pLogLine, pLogObject) =>\n{\n    let tmpLogLine = (typeof(pLogLine) === 'string') ? pLogLine : '';\n\n    console.log(`[Manyfest] ${tmpLogLine}`);\n\n    if (pLogObject) console.log(JSON.stringify(pLogObject));\n};\n\nmodule.exports = logToConsole;\n},{}],37:[function(require,module,exports){\n/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\nlet libSimpleLog = require('./Manyfest-LogToConsole.js');\n\n/**\n* Object Address Resolver\n*\n* IMPORTANT NOTE: This code is intentionally more verbose than necessary, to\n*                 be extremely clear what is going on in the recursion for\n*                 each of the three address resolution functions.\n*\n*                 Although there is some opportunity to repeat ourselves a\n*                 bit less in this codebase (e.g. with detection of arrays\n*                 versus objects versus direct properties), it can make\n*                 debugging.. challenging.  The minified version of the code\n*                 optimizes out almost anything repeated in here.  So please\n*                 be kind and rewind... meaning please keep the codebase less\n*                 terse and more verbose so humans can comprehend it.\n*\n*\n* @class ManyfestObjectAddressResolverCheckAddressExists\n*/\nclass ManyfestObjectAddressResolverCheckAddressExists\n{\n\tconstructor(pInfoLog, pErrorLog)\n\t{\n\t\t// Wire in logging\n\t\tthis.logInfo = (typeof(pInfoLog) == 'function') ? pInfoLog : libSimpleLog;\n\t\tthis.logError = (typeof(pErrorLog) == 'function') ? pErrorLog : libSimpleLog;\n\n\t\tthis.elucidatorSolver = false;\n\t\tthis.elucidatorSolverState = {};\n\t}\n\n\t// Check if an address exists.\n\t//\n\t// This is necessary because the getValueAtAddress function is ambiguous on\n\t// whether the element/property is actually there or not (it returns\n\t// undefined whether the property exists or not).  This function checks for\n\t// existance and returns true or false dependent.\n\tcheckAddressExists (pObject, pAddress)\n\t{\n\t\t// TODO: Should these throw an error?\n\t\t// Make sure pObject is an object\n\t\tif (typeof(pObject) != 'object') return false;\n\t\t// Make sure pAddress is a string\n\t\tif (typeof(pAddress) != 'string') return false;\n\n\t\t// TODO: Make this work for things like SomeRootObject.Metadata[\"Some.People.Use.Bad.Object.Property.Names\"]\n\t\tlet tmpSeparatorIndex = pAddress.indexOf('.');\n\n\t\t// This is the terminal address string (no more dots so the RECUSION ENDS IN HERE somehow)\n\t\tif (tmpSeparatorIndex == -1)\n\t\t{\n\t\t\t// Check if the address refers to a boxed property\n\t\t\tlet tmpBracketStartIndex = pAddress.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = pAddress.indexOf(']');\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[10]\n\t\t\t// \t\tMyValues['Name']\n\t\t\t// \t\tMyValues[\"Age\"]\n\t\t\t// \t\tMyValues[`Cost`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpBracketStartIndex > 0)\n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex)\n\t\t\t//    3) There is data\n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 1))\n\t\t\t{\n\t\t\t\t// The \"Name\" of the Object contained too the left of the bracket\n\t\t\t\tlet tmpBoxedPropertyName = pAddress.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\t// If the subproperty doesn't test as a proper Object, none of the rest of this is possible.\n\t\t\t\t// This is a rare case where Arrays testing as Objects is useful\n\t\t\t\tif (typeof(pObject[tmpBoxedPropertyName]) !== 'object')\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// The \"Reference\" to the property within it, either an array element or object property\n\t\t\t\tlet tmpBoxedPropertyReference = pAddress.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\t\t\t\t// Attempt to parse the reference as a number, which will be used as an array element\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to treat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynamic object property.\n\t\t\t\t\t// We would expect the property to be wrapped in some kind of quotes so strip them\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\t// Check if the property exists.\n\t\t\t\t\treturn pObject[tmpBoxedPropertyName].hasOwnProperty(tmpBoxedPropertyReference);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Use the new in operator to see if the element is in the array\n\t\t\t\t\treturn (tmpBoxedPropertyNumber in pObject[tmpBoxedPropertyName]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Check if the property exists\n\t\t\t\treturn pObject.hasOwnProperty(pAddress);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlet tmpSubObjectName = pAddress.substring(0, tmpSeparatorIndex);\n\t\t\tlet tmpNewAddress = pAddress.substring(tmpSeparatorIndex+1);\n\n\t\t\t// Test if the tmpNewAddress is an array or object\n\t\t\t// Check if it's a boxed property\n\t\t\tlet tmpBracketStartIndex = tmpSubObjectName.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = tmpSubObjectName.indexOf(']');\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[42]\n\t\t\t// \t\tMyValues['Color']\n\t\t\t// \t\tMyValues[\"Weight\"]\n\t\t\t// \t\tMyValues[`Diameter`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpBracketStartIndex > 0)\n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex)\n\t\t\t//    3) There is data\n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 1))\n\t\t\t{\n\t\t\t\tlet tmpBoxedPropertyName = tmpSubObjectName.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyReference = tmpSubObjectName.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[1].Tardy\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an object, so the [1].Tardy is not possible to access\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[\"JaneDoe\"].Grade\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an array, so the [\"JaneDoe\"].Grade is not possible to access\n\t\t\t\t// TODO: Should this be an error or something?  Should we keep a log of failures like this?\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// Because this is an impossible address, the property doesn't exist\n\t\t\t\t\t// TODO: Should we throw an error in this condition?\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t//This is a bracketed value\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to reat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynanmic object property.\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\t// Recurse directly into the subobject\n\t\t\t\t\treturn this.checkAddressExists(pObject[tmpBoxedPropertyName][tmpBoxedPropertyReference], tmpNewAddress);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// We parsed a valid number out of the boxed property name, so recurse into the array\n\t\t\t\t\treturn this.checkAddressExists(pObject[tmpBoxedPropertyName][tmpBoxedPropertyNumber], tmpNewAddress);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If there is an object property already named for the sub object, but it isn't an object\n\t\t\t// then the system can't set the value in there.  Error and abort!\n\t\t\tif (pObject.hasOwnProperty(tmpSubObjectName) && typeof(pObject[tmpSubObjectName]) !== 'object')\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse if (pObject.hasOwnProperty(tmpSubObjectName))\n\t\t\t{\n\t\t\t\t// If there is already a subobject pass that to the recursive thingy\n\t\t\t\treturn this.checkAddressExists(pObject[tmpSubObjectName], tmpNewAddress);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Create a subobject and then pass that\n\t\t\t\tpObject[tmpSubObjectName] = {};\n\t\t\t\treturn this.checkAddressExists(pObject[tmpSubObjectName], tmpNewAddress);\n\t\t\t}\n\t\t}\n\t}\n};\n\nmodule.exports = ManyfestObjectAddressResolverCheckAddressExists;\n},{\"./Manyfest-LogToConsole.js\":36}],38:[function(require,module,exports){\n/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\nlet libSimpleLog = require('./Manyfest-LogToConsole.js');\nlet libPrecedent = require('precedent');\nlet fCleanWrapCharacters = require('./Manyfest-CleanWrapCharacters.js');\n\n/**\n* Object Address Resolver - DeleteValue\n*\n* IMPORTANT NOTE: This code is intentionally more verbose than necessary, to\n*                 be extremely clear what is going on in the recursion for\n*                 each of the three address resolution functions.\n*\n*                 Although there is some opportunity to repeat ourselves a\n*                 bit less in this codebase (e.g. with detection of arrays\n*                 versus objects versus direct properties), it can make\n*                 debugging.. challenging.  The minified version of the code\n*                 optimizes out almost anything repeated in here.  So please\n*                 be kind and rewind... meaning please keep the codebase less\n*                 terse and more verbose so humans can comprehend it.\n*\n* TODO: Once we validate this pattern is good to go, break these out into\n*       three separate modules.\n*\n* @class ManyfestObjectAddressResolverDeleteValue\n*/\nclass ManyfestObjectAddressResolverDeleteValue\n{\n\tconstructor(pInfoLog, pErrorLog)\n\t{\n\t\t// Wire in logging\n\t\tthis.logInfo = (typeof(pInfoLog) == 'function') ? pInfoLog : libSimpleLog;\n\t\tthis.logError = (typeof(pErrorLog) == 'function') ? pErrorLog : libSimpleLog;\n\n\t\tthis.elucidatorSolver = false;\n\t\tthis.elucidatorSolverState = {};\n\n\t\tthis.cleanWrapCharacters = fCleanWrapCharacters;\n\t}\n\n\tcheckFilters(pAddress, pRecord)\n\t{\n\t\tlet tmpPrecedent = new libPrecedent();\n\t\t// If we don't copy the string, precedent takes it out for good.\n\t\t// TODO: Consider adding a \"don't replace\" option for precedent\n\t\tlet tmpAddress = pAddress;\n\n\t\tif (!this.elucidatorSolver)\n\t\t{\n\t\t\t// Again, manage against circular dependencies\n\t\t\tlet libElucidator = require('elucidator');\n\t\t\tthis.elucidatorSolver = new libElucidator({}, this.logInfo, this.logError);\n\t\t}\n\n\t\tif (this.elucidatorSolver)\n\t\t{\n\t\t\t// This allows the magic filtration with elucidator configuration\n\t\t\t// TODO: We could pass more state in (e.g. parent address, object, etc.)\n\t\t\t// TODO: Discuss this metaprogramming AT LENGTH\n\t\t\tlet tmpFilterState = (\n\t\t\t\t{\n\t\t\t\t\tRecord: pRecord,\n\t\t\t\t\tkeepRecord: true\n\t\t\t\t});\n\n\t\t\t// This is about as complex as it gets.\n\t\t\t// TODO: Optimize this so it is only initialized once.\n\t\t\t// TODO: That means figuring out a healthy pattern for passing in state to this\n\t\t\ttmpPrecedent.addPattern('<<~~', '~~>>',\n\t\t\t\t(pInstructionHash) =>\n\t\t\t\t{\n\t\t\t\t\t// This is for internal config on the solution steps.  Right now config is not shared across steps.\n\t\t\t\t\tif (this.elucidatorSolverState.hasOwnProperty(pInstructionHash))\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpFilterState.SolutionState = this.elucidatorSolverState[pInstructionHash];\n\t\t\t\t\t}\n\t\t\t\t\tthis.elucidatorSolver.solveInternalOperation('Custom', pInstructionHash, tmpFilterState);\n\t\t\t\t});\n\t\t\ttmpPrecedent.addPattern('<<~?', '?~>>',\n\t\t\t\t(pMagicSearchExpression) =>\n\t\t\t\t{\n\t\t\t\t\tif (typeof(pMagicSearchExpression) !== 'string')\n\t\t\t\t\t{\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\t// This expects a comma separated expression:\n\t\t\t\t\t//     Some.Address.In.The.Object,==,Search Term to Match\n\t\t\t\t\tlet tmpMagicComparisonPatternSet = pMagicSearchExpression.split(',');\n\n\t\t\t\t\tlet tmpSearchAddress = tmpMagicComparisonPatternSet[0];\n\t\t\t\t\tlet tmpSearchComparator = tmpMagicComparisonPatternSet[1];\n\t\t\t\t\tlet tmpSearchValue = tmpMagicComparisonPatternSet[2];\n\n\t\t\t\t\ttmpFilterState.ComparisonState = (\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tSearchAddress: tmpSearchAddress,\n\t\t\t\t\t\t\tComparator: tmpSearchComparator,\n\t\t\t\t\t\t\tSearchTerm: tmpSearchValue\n\t\t\t\t\t\t});\n\n\t\t\t\t\tthis.elucidatorSolver.solveOperation(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"Description\":\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"Operation\": \"Simple_If\",\n\t\t\t\t\t\t\t\t\"Synopsis\": \"Test for \"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"Steps\":\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\"Namespace\": \"Logic\",\n\t\t\t\t\t\t\t\t\t\"Instruction\": \"if\",\n\n\t\t\t\t\t\t\t\t\t\"InputHashAddressMap\":\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t// This is ... dynamically assigning the address in the instruction\n\t\t\t\t\t\t\t\t\t\t\t// The complexity is astounding.\n\t\t\t\t\t\t\t\t\t\t\t\"leftValue\": `Record.${tmpSearchAddress}`,\n\t\t\t\t\t\t\t\t\t\t\t\"rightValue\": \"ComparisonState.SearchTerm\",\n\t\t\t\t\t\t\t\t\t\t\t\"comparator\": \"ComparisonState.Comparator\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\"OutputHashAddressMap\": { \"truthinessResult\":\"keepRecord\" }\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t}, tmpFilterState);\n\t\t\t\t});\n\t\t\ttmpPrecedent.parseString(tmpAddress);\n\n\t\t\t// It is expected that the operation will mutate this to some truthy value\n\t\t\treturn tmpFilterState.keepRecord;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t// Delete the value of an element at an address\n\tdeleteValueAtAddress (pObject, pAddress, pParentAddress)\n\t{\n\t\t// Make sure pObject (the object we are meant to be recursing) is an object (which could be an array or object)\n\t\tif (typeof(pObject) != 'object') return undefined;\n\t\t// Make sure pAddress (the address we are resolving) is a string\n\t\tif (typeof(pAddress) != 'string') return undefined;\n\t\t// Stash the parent address for later resolution\n\t\tlet tmpParentAddress = \"\";\n\t\tif (typeof(pParentAddress) == 'string')\n\t\t{\n\t\t\ttmpParentAddress = pParentAddress;\n\t\t}\n\n\t\t// TODO: Make this work for things like SomeRootObject.Metadata[\"Some.People.Use.Bad.Object.Property.Names\"]\n\t\tlet tmpSeparatorIndex = pAddress.indexOf('.');\n\n\t\t// This is the terminal address string (no more dots so the RECUSION ENDS IN HERE somehow)\n\t\tif (tmpSeparatorIndex == -1)\n\t\t{\n\t\t\t// Check if the address refers to a boxed property\n\t\t\tlet tmpBracketStartIndex = pAddress.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = pAddress.indexOf(']');\n\n\t\t\t// Check for the Object Set Type marker.\n\t\t\t// Note this will not work with a bracket in the same address box set\n\t\t\tlet tmpObjectTypeMarkerIndex = pAddress.indexOf('{}');\n\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[10]\n\t\t\t// \t\tMyValues['Name']\n\t\t\t// \t\tMyValues[\"Age\"]\n\t\t\t// \t\tMyValues[`Cost`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpBracketStartIndex > 0)\n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex)\n\t\t\t//    3) There is data\n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 1))\n\t\t\t{\n\t\t\t\t// The \"Name\" of the Object contained too the left of the bracket\n\t\t\t\tlet tmpBoxedPropertyName = pAddress.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\t// If the subproperty doesn't test as a proper Object, none of the rest of this is possible.\n\t\t\t\t// This is a rare case where Arrays testing as Objects is useful\n\t\t\t\tif (typeof(pObject[tmpBoxedPropertyName]) !== 'object')\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// The \"Reference\" to the property within it, either an array element or object property\n\t\t\t\tlet tmpBoxedPropertyReference = pAddress.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\t\t\t\t// Attempt to parse the reference as a number, which will be used as an array element\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to treat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynamic object property.\n\t\t\t\t\t// We would expect the property to be wrapped in some kind of quotes so strip them\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\t// Return the value in the property\n\t\t\t\t\tdelete pObject[tmpBoxedPropertyName][tmpBoxedPropertyReference];\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdelete pObject[tmpBoxedPropertyName][tmpBoxedPropertyNumber];\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// The requirements to detect a boxed set element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\telse if ((tmpBracketStartIndex > 0)\n\t\t\t//    2) The end bracket is after the start bracket\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex)\n\t\t\t//    3) There is nothing in the brackets\n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex == 1))\n\t\t\t{\n\t\t\t\tlet tmpBoxedPropertyName = pAddress.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\tif (!Array.isArray(pObject[tmpBoxedPropertyName]))\n\t\t\t\t{\n\t\t\t\t\t// We asked for a set from an array but it isnt' an array.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tlet tmpInputArray = pObject[tmpBoxedPropertyName];\n\t\t\t\t// Count from the end to the beginning so splice doesn't %&%#$ up the array\n\t\t\t\tfor (let i = tmpInputArray.length - 1; i >= 0; i--)\n\t\t\t\t{\n\t\t\t\t\t// The filtering is complex but allows config-based metaprogramming directly from schema\n\t\t\t\t\tlet tmpKeepRecord = this.checkFilters(pAddress, tmpInputArray[i]);\n\t\t\t\t\tif (tmpKeepRecord)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Delete elements end to beginning\n\t\t\t\t\t\ttmpInputArray.splice(i, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t// The object has been flagged as an object set, so treat it as such\n\t\t\telse if (tmpObjectTypeMarkerIndex > 0)\n\t\t\t{\n\t\t\t\tlet tmpObjectPropertyName = pAddress.substring(0, tmpObjectTypeMarkerIndex).trim();\n\n\t\t\t\tif (typeof(pObject[tmpObjectPropertyName]) != 'object')\n\t\t\t\t{\n\t\t\t\t\t// We asked for a set from an array but it isnt' an array.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tdelete pObject[tmpObjectPropertyName];\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Now is the point in recursion to return the value in the address\n\t\t\t\tdelete pObject[pAddress];\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlet tmpSubObjectName = pAddress.substring(0, tmpSeparatorIndex);\n\t\t\tlet tmpNewAddress = pAddress.substring(tmpSeparatorIndex+1);\n\n\t\t\t// BOXED ELEMENTS\n\t\t\t// Test if the tmpNewAddress is an array or object\n\t\t\t// Check if it's a boxed property\n\t\t\tlet tmpBracketStartIndex = tmpSubObjectName.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = tmpSubObjectName.indexOf(']');\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[42]\n\t\t\t// \t\tMyValues['Color']\n\t\t\t// \t\tMyValues[\"Weight\"]\n\t\t\t// \t\tMyValues[`Diameter`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpBracketStartIndex > 0)\n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex)\n\t\t\t//    3) There is data\n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 1))\n\t\t\t{\n\t\t\t\tlet tmpBoxedPropertyName = tmpSubObjectName.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyReference = tmpSubObjectName.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[1].Tardy\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an object, so the [1].Tardy is not possible to access\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[\"JaneDoe\"].Grade\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an array, so the [\"JaneDoe\"].Grade is not possible to access\n\t\t\t\t// TODO: Should this be an error or something?  Should we keep a log of failures like this?\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t// Check if the boxed property is an object.\n\t\t\t\tif (typeof(pObject[tmpBoxedPropertyName]) != 'object')\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\n\t\t\t\t//This is a bracketed value\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to reat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynanmic object property.\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\t// Continue to manage the parent address for recursion\n\t\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpSubObjectName}`;\n\t\t\t\t\t// Recurse directly into the subobject\n\t\t\t\t\treturn this.deleteValueAtAddress(pObject[tmpBoxedPropertyName][tmpBoxedPropertyReference], tmpNewAddress, tmpParentAddress);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Continue to manage the parent address for recursion\n\t\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpSubObjectName}`;\n\t\t\t\t\t// We parsed a valid number out of the boxed property name, so recurse into the array\n\t\t\t\t\treturn this.deleteValueAtAddress(pObject[tmpBoxedPropertyName][tmpBoxedPropertyNumber], tmpNewAddress, tmpParentAddress);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// The requirements to detect a boxed set element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\telse if ((tmpBracketStartIndex > 0)\n\t\t\t//    2) The end bracket is after the start bracket\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex)\n\t\t\t//    3) There is nothing in the brackets\n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex == 1))\n\t\t\t{\n\t\t\t\tlet tmpBoxedPropertyName = pAddress.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\tif (!Array.isArray(pObject[tmpBoxedPropertyName]))\n\t\t\t\t{\n\t\t\t\t\t// We asked for a set from an array but it isnt' an array.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// We need to enumerate the array and grab the addresses from there.\n\t\t\t\tlet tmpArrayProperty = pObject[tmpBoxedPropertyName];\n\t\t\t\t// Managing the parent address is a bit more complex here -- the box will be added for each element.\n\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpBoxedPropertyName}`;\n\t\t\t\t// The container object is where we have the \"Address\":SOMEVALUE pairs\n\t\t\t\tlet tmpContainerObject = {};\n\t\t\t\tfor (let i = 0; i < tmpArrayProperty.length; i++)\n\t\t\t\t{\n\t\t\t\t\tlet tmpPropertyParentAddress = `${tmpParentAddress}[${i}]`;\n\t\t\t\t\tlet tmpValue = this.deleteValueAtAddress(pObject[tmpBoxedPropertyName][i], tmpNewAddress, tmpPropertyParentAddress);\n\n\t\t\t\t\ttmpContainerObject[`${tmpPropertyParentAddress}.${tmpNewAddress}`] = tmpValue;\n\t\t\t\t}\n\n\t\t\t\treturn tmpContainerObject;\n\t\t\t}\n\n\t\t\t// OBJECT SET\n\t\t\t// Note this will not work with a bracket in the same address box set\n\t\t\tlet tmpObjectTypeMarkerIndex = pAddress.indexOf('{}');\n\t\t\tif (tmpObjectTypeMarkerIndex > 0)\n\t\t\t{\n\t\t\t\tlet tmpObjectPropertyName = pAddress.substring(0, tmpObjectTypeMarkerIndex).trim();\n\n\t\t\t\tif (typeof(pObject[tmpObjectPropertyName]) != 'object')\n\t\t\t\t{\n\t\t\t\t\t// We asked for a set from an array but it isnt' an array.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// We need to enumerate the Object and grab the addresses from there.\n\t\t\t\tlet tmpObjectProperty = pObject[tmpObjectPropertyName];\n\t\t\t\tlet tmpObjectPropertyKeys = Object.keys(tmpObjectProperty);\n\t\t\t\t// Managing the parent address is a bit more complex here -- the box will be added for each element.\n\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpObjectPropertyName}`;\n\t\t\t\t// The container object is where we have the \"Address\":SOMEVALUE pairs\n\t\t\t\tlet tmpContainerObject = {};\n\t\t\t\tfor (let i = 0; i < tmpObjectPropertyKeys.length; i++)\n\t\t\t\t{\n\t\t\t\t\tlet tmpPropertyParentAddress = `${tmpParentAddress}.${tmpObjectPropertyKeys[i]}`;\n\t\t\t\t\tlet tmpValue = this.deleteValueAtAddress(pObject[tmpObjectPropertyName][tmpObjectPropertyKeys[i]], tmpNewAddress, tmpPropertyParentAddress);\n\n\t\t\t\t\t// The filtering is complex but allows config-based metaprogramming directly from schema\n\t\t\t\t\tlet tmpKeepRecord = this.checkFilters(pAddress, tmpValue);\n\t\t\t\t\tif (tmpKeepRecord)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpContainerObject[`${tmpPropertyParentAddress}.${tmpNewAddress}`] = tmpValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn tmpContainerObject;\n\t\t\t}\n\n\t\t\t// If there is an object property already named for the sub object, but it isn't an object\n\t\t\t// then the system can't set the value in there.  Error and abort!\n\t\t\tif (pObject.hasOwnProperty(tmpSubObjectName) && typeof(pObject[tmpSubObjectName]) !== 'object')\n\t\t\t{\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\telse if (pObject.hasOwnProperty(tmpSubObjectName))\n\t\t\t{\n\t\t\t\t// If there is already a subobject pass that to the recursive thingy\n\t\t\t\t// Continue to manage the parent address for recursion\n\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpSubObjectName}`;\n\t\t\t\treturn this.deleteValueAtAddress(pObject[tmpSubObjectName], tmpNewAddress, tmpParentAddress);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Create a subobject and then pass that\n\t\t\t\t// Continue to manage the parent address for recursion\n\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpSubObjectName}`;\n\t\t\t\tpObject[tmpSubObjectName] = {};\n\t\t\t\treturn this.deleteValueAtAddress(pObject[tmpSubObjectName], tmpNewAddress, tmpParentAddress);\n\t\t\t}\n\t\t}\n\t}\n};\n\nmodule.exports = ManyfestObjectAddressResolverDeleteValue;\n},{\"./Manyfest-CleanWrapCharacters.js\":34,\"./Manyfest-LogToConsole.js\":36,\"elucidator\":4,\"precedent\":44}],39:[function(require,module,exports){\n/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\nlet libSimpleLog = require('./Manyfest-LogToConsole.js');\nlet libPrecedent = require('precedent');\nlet fCleanWrapCharacters = require('./Manyfest-CleanWrapCharacters.js');\n\n/**\n* Object Address Resolver - GetValue\n*\n* IMPORTANT NOTE: This code is intentionally more verbose than necessary, to\n*                 be extremely clear what is going on in the recursion for\n*                 each of the three address resolution functions.\n*\n*                 Although there is some opportunity to repeat ourselves a\n*                 bit less in this codebase (e.g. with detection of arrays\n*                 versus objects versus direct properties), it can make\n*                 debugging.. challenging.  The minified version of the code\n*                 optimizes out almost anything repeated in here.  So please\n*                 be kind and rewind... meaning please keep the codebase less\n*                 terse and more verbose so humans can comprehend it.\n*\n* TODO: Once we validate this pattern is good to go, break these out into\n*       three separate modules.\n*\n* @class ManyfestObjectAddressResolverGetValue\n*/\nclass ManyfestObjectAddressResolverGetValue\n{\n\tconstructor(pInfoLog, pErrorLog)\n\t{\n\t\t// Wire in logging\n\t\tthis.logInfo = (typeof(pInfoLog) == 'function') ? pInfoLog : libSimpleLog;\n\t\tthis.logError = (typeof(pErrorLog) == 'function') ? pErrorLog : libSimpleLog;\n\n\t\tthis.elucidatorSolver = false;\n\t\tthis.elucidatorSolverState = {};\n\n\t\tthis.cleanWrapCharacters = fCleanWrapCharacters;\n\t}\n\n\tcheckFilters(pAddress, pRecord)\n\t{\n\t\tlet tmpPrecedent = new libPrecedent();\n\t\t// If we don't copy the string, precedent takes it out for good.\n\t\t// TODO: Consider adding a \"don't replace\" option for precedent\n\t\tlet tmpAddress = pAddress;\n\n\t\tif (!this.elucidatorSolver)\n\t\t{\n\t\t\t// Again, manage against circular dependencies\n\t\t\tlet libElucidator = require('elucidator');\n\t\t\tthis.elucidatorSolver = new libElucidator({}, this.logInfo, this.logError);\n\t\t}\n\n\t\tif (this.elucidatorSolver)\n\t\t{\n\t\t\t// This allows the magic filtration with elucidator configuration\n\t\t\t// TODO: We could pass more state in (e.g. parent address, object, etc.)\n\t\t\t// TODO: Discuss this metaprogramming AT LENGTH\n\t\t\tlet tmpFilterState = (\n\t\t\t\t{\n\t\t\t\t\tRecord: pRecord,\n\t\t\t\t\tkeepRecord: true\n\t\t\t\t});\n\n\t\t\t// This is about as complex as it gets.\n\t\t\t// TODO: Optimize this so it is only initialized once.\n\t\t\t// TODO: That means figuring out a healthy pattern for passing in state to this\n\t\t\ttmpPrecedent.addPattern('<<~~', '~~>>',\n\t\t\t\t(pInstructionHash) =>\n\t\t\t\t{\n\t\t\t\t\t// This is for internal config on the solution steps.  Right now config is not shared across steps.\n\t\t\t\t\tif (this.elucidatorSolverState.hasOwnProperty(pInstructionHash))\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpFilterState.SolutionState = this.elucidatorSolverState[pInstructionHash];\n\t\t\t\t\t}\n\t\t\t\t\tthis.elucidatorSolver.solveInternalOperation('Custom', pInstructionHash, tmpFilterState);\n\t\t\t\t});\n\t\t\ttmpPrecedent.addPattern('<<~?', '?~>>',\n\t\t\t\t(pMagicSearchExpression) =>\n\t\t\t\t{\n\t\t\t\t\tif (typeof(pMagicSearchExpression) !== 'string')\n\t\t\t\t\t{\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\t// This expects a comma separated expression:\n\t\t\t\t\t//     Some.Address.In.The.Object,==,Search Term to Match\n\t\t\t\t\tlet tmpMagicComparisonPatternSet = pMagicSearchExpression.split(',');\n\n\t\t\t\t\tlet tmpSearchAddress = tmpMagicComparisonPatternSet[0];\n\t\t\t\t\tlet tmpSearchComparator = tmpMagicComparisonPatternSet[1];\n\t\t\t\t\tlet tmpSearchValue = tmpMagicComparisonPatternSet[2];\n\n\t\t\t\t\ttmpFilterState.ComparisonState = (\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tSearchAddress: tmpSearchAddress,\n\t\t\t\t\t\t\tComparator: tmpSearchComparator,\n\t\t\t\t\t\t\tSearchTerm: tmpSearchValue\n\t\t\t\t\t\t});\n\n\t\t\t\t\tthis.elucidatorSolver.solveOperation(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"Description\":\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"Operation\": \"Simple_If\",\n\t\t\t\t\t\t\t\t\"Synopsis\": \"Test for \"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"Steps\":\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\"Namespace\": \"Logic\",\n\t\t\t\t\t\t\t\t\t\"Instruction\": \"if\",\n\n\t\t\t\t\t\t\t\t\t\"InputHashAddressMap\":\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t// This is ... dynamically assigning the address in the instruction\n\t\t\t\t\t\t\t\t\t\t\t// The complexity is astounding.\n\t\t\t\t\t\t\t\t\t\t\t\"leftValue\": `Record.${tmpSearchAddress}`,\n\t\t\t\t\t\t\t\t\t\t\t\"rightValue\": \"ComparisonState.SearchTerm\",\n\t\t\t\t\t\t\t\t\t\t\t\"comparator\": \"ComparisonState.Comparator\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\"OutputHashAddressMap\": { \"truthinessResult\":\"keepRecord\" }\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t}, tmpFilterState);\n\t\t\t\t});\n\t\t\ttmpPrecedent.parseString(tmpAddress);\n\n\t\t\t// It is expected that the operation will mutate this to some truthy value\n\t\t\treturn tmpFilterState.keepRecord;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t// Get the value of an element at an address\n\tgetValueAtAddress (pObject, pAddress, pParentAddress)\n\t{\n\t\t// Make sure pObject (the object we are meant to be recursing) is an object (which could be an array or object)\n\t\tif (typeof(pObject) != 'object') return undefined;\n\t\t// Make sure pAddress (the address we are resolving) is a string\n\t\tif (typeof(pAddress) != 'string') return undefined;\n\t\t// Stash the parent address for later resolution\n\t\tlet tmpParentAddress = \"\";\n\t\tif (typeof(pParentAddress) == 'string')\n\t\t{\n\t\t\ttmpParentAddress = pParentAddress;\n\t\t}\n\n\t\t// TODO: Make this work for things like SomeRootObject.Metadata[\"Some.People.Use.Bad.Object.Property.Names\"]\n\t\tlet tmpSeparatorIndex = pAddress.indexOf('.');\n\n\t\t// This is the terminal address string (no more dots so the RECUSION ENDS IN HERE somehow)\n\t\tif (tmpSeparatorIndex == -1)\n\t\t{\n\t\t\t// Check if the address refers to a boxed property\n\t\t\tlet tmpBracketStartIndex = pAddress.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = pAddress.indexOf(']');\n\n\t\t\t// Check for the Object Set Type marker.\n\t\t\t// Note this will not work with a bracket in the same address box set\n\t\t\tlet tmpObjectTypeMarkerIndex = pAddress.indexOf('{}');\n\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[10]\n\t\t\t// \t\tMyValues['Name']\n\t\t\t// \t\tMyValues[\"Age\"]\n\t\t\t// \t\tMyValues[`Cost`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpBracketStartIndex > 0)\n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex)\n\t\t\t//    3) There is data\n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 1))\n\t\t\t{\n\t\t\t\t// The \"Name\" of the Object contained too the left of the bracket\n\t\t\t\tlet tmpBoxedPropertyName = pAddress.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\t// If the subproperty doesn't test as a proper Object, none of the rest of this is possible.\n\t\t\t\t// This is a rare case where Arrays testing as Objects is useful\n\t\t\t\tif (typeof(pObject[tmpBoxedPropertyName]) !== 'object')\n\t\t\t\t{\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\t// The \"Reference\" to the property within it, either an array element or object property\n\t\t\t\tlet tmpBoxedPropertyReference = pAddress.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\t\t\t\t// Attempt to parse the reference as a number, which will be used as an array element\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to treat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynamic object property.\n\t\t\t\t\t// We would expect the property to be wrapped in some kind of quotes so strip them\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\t// Return the value in the property\n\t\t\t\t\treturn pObject[tmpBoxedPropertyName][tmpBoxedPropertyReference];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treturn pObject[tmpBoxedPropertyName][tmpBoxedPropertyNumber];\n\t\t\t\t}\n\t\t\t}\n\t\t\t// The requirements to detect a boxed set element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\telse if ((tmpBracketStartIndex > 0)\n\t\t\t//    2) The end bracket is after the start bracket\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex)\n\t\t\t//    3) There is nothing in the brackets\n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex == 1))\n\t\t\t{\n\t\t\t\tlet tmpBoxedPropertyName = pAddress.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\tif (!Array.isArray(pObject[tmpBoxedPropertyName]))\n\t\t\t\t{\n\t\t\t\t\t// We asked for a set from an array but it isnt' an array.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tlet tmpInputArray = pObject[tmpBoxedPropertyName];\n\t\t\t\tlet tmpOutputArray = [];\n\t\t\t\tfor (let i = 0; i < tmpInputArray.length; i++)\n\t\t\t\t{\n\t\t\t\t\t// The filtering is complex but allows config-based metaprogramming directly from schema\n\t\t\t\t\tlet tmpKeepRecord = this.checkFilters(pAddress, tmpInputArray[i]);\n\t\t\t\t\tif (tmpKeepRecord)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpOutputArray.push(tmpInputArray[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn tmpOutputArray;\n\t\t\t}\n\t\t\t// The object has been flagged as an object set, so treat it as such\n\t\t\telse if (tmpObjectTypeMarkerIndex > 0)\n\t\t\t{\n\t\t\t\tlet tmpObjectPropertyName = pAddress.substring(0, tmpObjectTypeMarkerIndex).trim();\n\n\t\t\t\tif (typeof(pObject[tmpObjectPropertyName]) != 'object')\n\t\t\t\t{\n\t\t\t\t\t// We asked for a set from an array but it isnt' an array.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\treturn pObject[tmpObjectPropertyName];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Now is the point in recursion to return the value in the address\n\t\t\t\treturn pObject[pAddress];\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlet tmpSubObjectName = pAddress.substring(0, tmpSeparatorIndex);\n\t\t\tlet tmpNewAddress = pAddress.substring(tmpSeparatorIndex+1);\n\n\t\t\t// BOXED ELEMENTS\n\t\t\t// Test if the tmpNewAddress is an array or object\n\t\t\t// Check if it's a boxed property\n\t\t\tlet tmpBracketStartIndex = tmpSubObjectName.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = tmpSubObjectName.indexOf(']');\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[42]\n\t\t\t// \t\tMyValues['Color']\n\t\t\t// \t\tMyValues[\"Weight\"]\n\t\t\t// \t\tMyValues[`Diameter`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpBracketStartIndex > 0)\n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex)\n\t\t\t//    3) There is data\n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 1))\n\t\t\t{\n\t\t\t\tlet tmpBoxedPropertyName = tmpSubObjectName.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyReference = tmpSubObjectName.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[1].Tardy\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an object, so the [1].Tardy is not possible to access\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[\"JaneDoe\"].Grade\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an array, so the [\"JaneDoe\"].Grade is not possible to access\n\t\t\t\t// TODO: Should this be an error or something?  Should we keep a log of failures like this?\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t\t// Check if the boxed property is an object.\n\t\t\t\tif (typeof(pObject[tmpBoxedPropertyName]) != 'object')\n\t\t\t\t{\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\n\t\t\t\t//This is a bracketed value\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to reat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynanmic object property.\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\t// Continue to manage the parent address for recursion\n\t\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpSubObjectName}`;\n\t\t\t\t\t// Recurse directly into the subobject\n\t\t\t\t\treturn this.getValueAtAddress(pObject[tmpBoxedPropertyName][tmpBoxedPropertyReference], tmpNewAddress, tmpParentAddress);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Continue to manage the parent address for recursion\n\t\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpSubObjectName}`;\n\t\t\t\t\t// We parsed a valid number out of the boxed property name, so recurse into the array\n\t\t\t\t\treturn this.getValueAtAddress(pObject[tmpBoxedPropertyName][tmpBoxedPropertyNumber], tmpNewAddress, tmpParentAddress);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// The requirements to detect a boxed set element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\telse if ((tmpBracketStartIndex > 0)\n\t\t\t//    2) The end bracket is after the start bracket\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex)\n\t\t\t//    3) There is nothing in the brackets\n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex == 1))\n\t\t\t{\n\t\t\t\tlet tmpBoxedPropertyName = pAddress.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\tif (!Array.isArray(pObject[tmpBoxedPropertyName]))\n\t\t\t\t{\n\t\t\t\t\t// We asked for a set from an array but it isnt' an array.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// We need to enumerate the array and grab the addresses from there.\n\t\t\t\tlet tmpArrayProperty = pObject[tmpBoxedPropertyName];\n\t\t\t\t// Managing the parent address is a bit more complex here -- the box will be added for each element.\n\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpBoxedPropertyName}`;\n\t\t\t\t// The container object is where we have the \"Address\":SOMEVALUE pairs\n\t\t\t\tlet tmpContainerObject = {};\n\t\t\t\tfor (let i = 0; i < tmpArrayProperty.length; i++)\n\t\t\t\t{\n\t\t\t\t\tlet tmpPropertyParentAddress = `${tmpParentAddress}[${i}]`;\n\t\t\t\t\tlet tmpValue = this.getValueAtAddress(pObject[tmpBoxedPropertyName][i], tmpNewAddress, tmpPropertyParentAddress);\n\n\t\t\t\t\ttmpContainerObject[`${tmpPropertyParentAddress}.${tmpNewAddress}`] = tmpValue;\n\t\t\t\t}\n\n\t\t\t\treturn tmpContainerObject;\n\t\t\t}\n\n\t\t\t// OBJECT SET\n\t\t\t// Note this will not work with a bracket in the same address box set\n\t\t\tlet tmpObjectTypeMarkerIndex = pAddress.indexOf('{}');\n\t\t\tif (tmpObjectTypeMarkerIndex > 0)\n\t\t\t{\n\t\t\t\tlet tmpObjectPropertyName = pAddress.substring(0, tmpObjectTypeMarkerIndex).trim();\n\n\t\t\t\tif (typeof(pObject[tmpObjectPropertyName]) != 'object')\n\t\t\t\t{\n\t\t\t\t\t// We asked for a set from an array but it isnt' an array.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// We need to enumerate the Object and grab the addresses from there.\n\t\t\t\tlet tmpObjectProperty = pObject[tmpObjectPropertyName];\n\t\t\t\tlet tmpObjectPropertyKeys = Object.keys(tmpObjectProperty);\n\t\t\t\t// Managing the parent address is a bit more complex here -- the box will be added for each element.\n\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpObjectPropertyName}`;\n\t\t\t\t// The container object is where we have the \"Address\":SOMEVALUE pairs\n\t\t\t\tlet tmpContainerObject = {};\n\t\t\t\tfor (let i = 0; i < tmpObjectPropertyKeys.length; i++)\n\t\t\t\t{\n\t\t\t\t\tlet tmpPropertyParentAddress = `${tmpParentAddress}.${tmpObjectPropertyKeys[i]}`;\n\t\t\t\t\tlet tmpValue = this.getValueAtAddress(pObject[tmpObjectPropertyName][tmpObjectPropertyKeys[i]], tmpNewAddress, tmpPropertyParentAddress);\n\n\t\t\t\t\t// The filtering is complex but allows config-based metaprogramming directly from schema\n\t\t\t\t\tlet tmpKeepRecord = this.checkFilters(pAddress, tmpValue);\n\t\t\t\t\tif (tmpKeepRecord)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpContainerObject[`${tmpPropertyParentAddress}.${tmpNewAddress}`] = tmpValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn tmpContainerObject;\n\t\t\t}\n\n\t\t\t// If there is an object property already named for the sub object, but it isn't an object\n\t\t\t// then the system can't set the value in there.  Error and abort!\n\t\t\tif (pObject.hasOwnProperty(tmpSubObjectName) && typeof(pObject[tmpSubObjectName]) !== 'object')\n\t\t\t{\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\telse if (pObject.hasOwnProperty(tmpSubObjectName))\n\t\t\t{\n\t\t\t\t// If there is already a subobject pass that to the recursive thingy\n\t\t\t\t// Continue to manage the parent address for recursion\n\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpSubObjectName}`;\n\t\t\t\treturn this.getValueAtAddress(pObject[tmpSubObjectName], tmpNewAddress, tmpParentAddress);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Create a subobject and then pass that\n\t\t\t\t// Continue to manage the parent address for recursion\n\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpSubObjectName}`;\n\t\t\t\tpObject[tmpSubObjectName] = {};\n\t\t\t\treturn this.getValueAtAddress(pObject[tmpSubObjectName], tmpNewAddress, tmpParentAddress);\n\t\t\t}\n\t\t}\n\t}\n};\n\nmodule.exports = ManyfestObjectAddressResolverGetValue;\n},{\"./Manyfest-CleanWrapCharacters.js\":34,\"./Manyfest-LogToConsole.js\":36,\"elucidator\":4,\"precedent\":44}],40:[function(require,module,exports){\n/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\nlet libSimpleLog = require('./Manyfest-LogToConsole.js');\nlet libPrecedent = require('precedent');\nlet fCleanWrapCharacters = require('./Manyfest-CleanWrapCharacters.js');\n\n/**\n* Object Address Resolver - SetValue\n*\n* IMPORTANT NOTE: This code is intentionally more verbose than necessary, to\n*                 be extremely clear what is going on in the recursion for\n*                 each of the three address resolution functions.\n*\n*                 Although there is some opportunity to repeat ourselves a\n*                 bit less in this codebase (e.g. with detection of arrays\n*                 versus objects versus direct properties), it can make\n*                 debugging.. challenging.  The minified version of the code\n*                 optimizes out almost anything repeated in here.  So please\n*                 be kind and rewind... meaning please keep the codebase less\n*                 terse and more verbose so humans can comprehend it.\n*\n*\n* @class ManyfestObjectAddressSetValue\n*/\nclass ManyfestObjectAddressSetValue\n{\n\tconstructor(pInfoLog, pErrorLog)\n\t{\n\t\t// Wire in logging\n\t\tthis.logInfo = (typeof(pInfoLog) == 'function') ? pInfoLog : libSimpleLog;\n\t\tthis.logError = (typeof(pErrorLog) == 'function') ? pErrorLog : libSimpleLog;\n\n\t\tthis.elucidatorSolver = false;\n\t\tthis.elucidatorSolverState = {};\n\n\t\tthis.cleanWrapCharacters = fCleanWrapCharacters;\n\t}\n\n\t// Set the value of an element at an address\n\tsetValueAtAddress (pObject, pAddress, pValue)\n\t{\n\t\t// Make sure pObject is an object\n\t\tif (typeof(pObject) != 'object') return false;\n\t\t// Make sure pAddress is a string\n\t\tif (typeof(pAddress) != 'string') return false;\n\n\t\tlet tmpSeparatorIndex = pAddress.indexOf('.');\n\n\t\tif (tmpSeparatorIndex == -1)\n\t\t{\n\t\t\t// Check if it's a boxed property\n\t\t\tlet tmpBracketStartIndex = pAddress.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = pAddress.indexOf(']');\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[10]\n\t\t\t// \t\tMyValues['Name']\n\t\t\t// \t\tMyValues[\"Age\"]\n\t\t\t// \t\tMyValues[`Cost`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpBracketStartIndex > 0)\n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex)\n\t\t\t//    3) There is data\n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 1))\n\t\t\t{\n\t\t\t\t// The \"Name\" of the Object contained too the left of the bracket\n\t\t\t\tlet tmpBoxedPropertyName = pAddress.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\t// If the subproperty doesn't test as a proper Object, none of the rest of this is possible.\n\t\t\t\t// This is a rare case where Arrays testing as Objects is useful\n\t\t\t\tif (typeof(pObject[tmpBoxedPropertyName]) !== 'object')\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// The \"Reference\" to the property within it, either an array element or object property\n\t\t\t\tlet tmpBoxedPropertyReference = pAddress.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\t\t\t\t// Attempt to parse the reference as a number, which will be used as an array element\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to treat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynamic object property.\n\t\t\t\t\t// We would expect the property to be wrapped in some kind of quotes so strip them\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\t// Return the value in the property\n\t\t\t\t\tpObject[tmpBoxedPropertyName][tmpBoxedPropertyReference] = pValue;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tpObject[tmpBoxedPropertyName][tmpBoxedPropertyNumber] = pValue;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Now is the time in recursion to set the value in the object\n\t\t\t\tpObject[pAddress] = pValue;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlet tmpSubObjectName = pAddress.substring(0, tmpSeparatorIndex);\n\t\t\tlet tmpNewAddress = pAddress.substring(tmpSeparatorIndex+1);\n\n\t\t\t// Test if the tmpNewAddress is an array or object\n\t\t\t// Check if it's a boxed property\n\t\t\tlet tmpBracketStartIndex = tmpSubObjectName.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = tmpSubObjectName.indexOf(']');\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[42]\n\t\t\t// \t\tMyValues['Color']\n\t\t\t// \t\tMyValues[\"Weight\"]\n\t\t\t// \t\tMyValues[`Diameter`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpBracketStartIndex > 0)\n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex)\n\t\t\t//    3) There is data\n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 1))\n\t\t\t{\n\t\t\t\tlet tmpBoxedPropertyName = tmpSubObjectName.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyReference = tmpSubObjectName.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[1].Tardy\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an object, so the [1].Tardy is not possible to access\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[\"JaneDoe\"].Grade\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an array, so the [\"JaneDoe\"].Grade is not possible to access\n\t\t\t\t// TODO: Should this be an error or something?  Should we keep a log of failures like this?\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t//This is a bracketed value\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to reat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynanmic object property.\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\t// Recurse directly into the subobject\n\t\t\t\t\treturn this.setValueAtAddress(pObject[tmpBoxedPropertyName][tmpBoxedPropertyReference], tmpNewAddress, pValue);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// We parsed a valid number out of the boxed property name, so recurse into the array\n\t\t\t\t\treturn this.setValueAtAddress(pObject[tmpBoxedPropertyName][tmpBoxedPropertyNumber], tmpNewAddress, pValue);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If there is an object property already named for the sub object, but it isn't an object\n\t\t\t// then the system can't set the value in there.  Error and abort!\n\t\t\tif (pObject.hasOwnProperty(tmpSubObjectName) && typeof(pObject[tmpSubObjectName]) !== 'object')\n\t\t\t{\n\t\t\t\tif (!pObject.hasOwnProperty('__ERROR'))\n\t\t\t\t\tpObject['__ERROR'] = {};\n\t\t\t\t// Put it in an error object so data isn't lost\n\t\t\t\tpObject['__ERROR'][pAddress] = pValue;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse if (pObject.hasOwnProperty(tmpSubObjectName))\n\t\t\t{\n\t\t\t\t// If there is already a subobject pass that to the recursive thingy\n\t\t\t\treturn this.setValueAtAddress(pObject[tmpSubObjectName], tmpNewAddress, pValue);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Create a subobject and then pass that\n\t\t\t\tpObject[tmpSubObjectName] = {};\n\t\t\t\treturn this.setValueAtAddress(pObject[tmpSubObjectName], tmpNewAddress, pValue);\n\t\t\t}\n\t\t}\n\t}\n};\n\nmodule.exports = ManyfestObjectAddressSetValue;\n},{\"./Manyfest-CleanWrapCharacters.js\":34,\"./Manyfest-LogToConsole.js\":36,\"precedent\":44}],41:[function(require,module,exports){\n/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\nlet libSimpleLog = require('./Manyfest-LogToConsole.js');\n\n/**\n* Object Address Generation\n*\n* Automagically generate addresses and properties based on a passed-in object,\n* to be used for easy creation of schemas.  Meant to simplify the lives of\n* developers wanting to create schemas without typing a bunch of stuff.\n*\n* IMPORTANT NOTE: This code is intentionally more verbose than necessary, to\n*                 be extremely clear what is going on in the recursion for\n*                 each of the three address resolution functions.\n*\n*                 Although there is some opportunity to repeat ourselves a\n*                 bit less in this codebase (e.g. with detection of arrays\n*                 versus objects versus direct properties), it can make\n*                 debugging.. challenging.  The minified version of the code\n*                 optimizes out almost anything repeated in here.  So please\n*                 be kind and rewind... meaning please keep the codebase less\n*                 terse and more verbose so humans can comprehend it.\n*\n*\n* @class ManyfestObjectAddressGeneration\n*/\nclass ManyfestObjectAddressGeneration\n{\n\tconstructor(pInfoLog, pErrorLog)\n\t{\n\t\t// Wire in logging\n\t\tthis.logInfo = (typeof(pInfoLog) == 'function') ? pInfoLog : libSimpleLog;\n\t\tthis.logError = (typeof(pErrorLog) == 'function') ? pErrorLog : libSimpleLog;\n\t}\n\n\t// generateAddressses\n\t//\n\t// This flattens an object into a set of key:value pairs for *EVERY SINGLE\n\t// POSSIBLE ADDRESS* in the object.  It can get ... really insane really\n\t// quickly.  This is not meant to be used directly to generate schemas, but\n\t// instead as a starting point for scripts or UIs.\n\t//\n\t// This will return a mega set of key:value pairs with all possible schema\n\t// permutations and default values (when not an object) and everything else.\n\tgenerateAddressses (pObject, pBaseAddress, pSchema)\n\t{\n\t\tlet tmpBaseAddress = (typeof(pBaseAddress) == 'string') ? pBaseAddress : '';\n\t\tlet tmpSchema = (typeof(pSchema) == 'object') ? pSchema : {};\n\n\t\tlet tmpObjectType = typeof(pObject);\n\n\t\tlet tmpSchemaObjectEntry = (\n\t\t\t{\n\t\t\t\tAddress: tmpBaseAddress,\n\t\t\t\tHash: tmpBaseAddress,\n\t\t\t\tName: tmpBaseAddress,\n\t\t\t\t// This is so scripts and UI controls can force a developer to opt-in.\n\t\t\t\tInSchema: false\n\t\t\t}\n\t\t)\n\n\t\tif ((tmpObjectType == 'object') && (pObject == null))\n\t\t{\n\t\t\ttmpObjectType = 'null';\n\t\t}\n\n\t\tswitch(tmpObjectType)\n\t\t{\n\t\t\tcase 'string':\n\t\t\t\ttmpSchemaObjectEntry.DataType = 'String';\n\t\t\t\ttmpSchemaObjectEntry.Default = pObject;\n\t\t\t\ttmpSchema[tmpBaseAddress] = tmpSchemaObjectEntry;\n\t\t\t\tbreak;\n\t\t\tcase 'number':\n\t\t\tcase 'bigint':\n\t\t\t\ttmpSchemaObjectEntry.DataType = 'Number';\n\t\t\t\ttmpSchemaObjectEntry.Default = pObject;\n\t\t\t\ttmpSchema[tmpBaseAddress] = tmpSchemaObjectEntry;\n\t\t\t\tbreak;\n\t\t\tcase 'undefined':\n\t\t\tcase 'null':\n\t\t\t\ttmpSchemaObjectEntry.DataType = 'Any';\n\t\t\t\ttmpSchemaObjectEntry.Default = pObject;\n\t\t\t\ttmpSchema[tmpBaseAddress] = tmpSchemaObjectEntry;\n\t\t\t\tbreak;\n\t\t\tcase 'object':\n\t\t\t\tif (Array.isArray(pObject))\n\t\t\t\t{\n\t\t\t\t\ttmpSchemaObjectEntry.DataType = 'Array';\n\t\t\t\t\tif (tmpBaseAddress != '')\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpSchema[tmpBaseAddress] = tmpSchemaObjectEntry;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (let i = 0; i < pObject.length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.generateAddressses(pObject[i], `${tmpBaseAddress}[${i}]`, tmpSchema);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttmpSchemaObjectEntry.DataType = 'Object';\n\t\t\t\t\tif (tmpBaseAddress != '')\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpSchema[tmpBaseAddress] = tmpSchemaObjectEntry;\n\t\t\t\t\t\ttmpBaseAddress += '.';\n\t\t\t\t\t}\n\n\t\t\t\t\tlet tmpObjectProperties = Object.keys(pObject);\n\n\t\t\t\t\tfor (let i = 0; i < tmpObjectProperties.length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.generateAddressses(pObject[tmpObjectProperties[i]], `${tmpBaseAddress}${tmpObjectProperties[i]}`, tmpSchema);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'symbol':\n\t\t\tcase 'function':\n\t\t\t\t// Symbols and functions neither recurse nor get added to the schema\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn tmpSchema;\n\t}\n};\n\nmodule.exports = ManyfestObjectAddressGeneration;\n},{\"./Manyfest-LogToConsole.js\":36}],42:[function(require,module,exports){\n/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\nlet libSimpleLog = require('./Manyfest-LogToConsole.js');\n\n/**\n* Schema Manipulation Functions\n*\n* @class ManyfestSchemaManipulation\n*/\nclass ManyfestSchemaManipulation\n{\n\tconstructor(pInfoLog, pErrorLog)\n\t{\n\t\t// Wire in logging\n\t\tthis.logInfo = (typeof(pInfoLog) === 'function') ? pInfoLog : libSimpleLog;\n\t\tthis.logError = (typeof(pErrorLog) === 'function') ? pErrorLog : libSimpleLog;\n\t}\n\n    // This translates the default address mappings to something different.\n    //\n    // For instance you can pass in manyfest schema descriptor object:\n    // \t{\n\t//\t  \"Address.Of.a\": { \"Hash\": \"a\", \"Type\": \"Number\" },\n\t//\t  \"Address.Of.b\": { \"Hash\": \"b\", \"Type\": \"Number\" }\n\t//  }\n    //\n    //\n    // And then an address mapping (basically a Hash->Address map)\n    //  {\n    //    \"a\": \"New.Address.Of.a\",\n    //    \"b\": \"New.Address.Of.b\"\n    //  }\n    //\n    // NOTE: This mutates the schema object permanently, altering the base hash.\n    //       If there is a collision with an existing address, it can lead to overwrites.\n    // TODO: Discuss what should happen on collisions.\n\tresolveAddressMappings(pManyfestSchemaDescriptors, pAddressMapping)\n\t{\n\t\tif (typeof(pManyfestSchemaDescriptors) != 'object')\n\t\t{\n\t\t\tthis.logError(`Attempted to resolve address mapping but the descriptor was not an object.`);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (typeof(pAddressMapping) != 'object')\n\t\t{\n\t\t\t// No mappings were passed in\n\t\t\treturn true;\n\t\t}\n\n\t\t// Get the arrays of both the schema definition and the hash mapping\n\t\tlet tmpManyfestAddresses = Object.keys(pManyfestSchemaDescriptors);\n\t\tlet tmpHashMapping = {};\n\t\ttmpManyfestAddresses.forEach(\n\t\t\t(pAddress) =>\n\t\t\t{\n\t\t\t\tif (pManyfestSchemaDescriptors[pAddress].hasOwnProperty('Hash'))\n\t\t\t\t{\n\t\t\t\t\ttmpHashMapping[pManyfestSchemaDescriptors[pAddress].Hash] = pAddress;\n\t\t\t\t}\n\t\t\t});\n\n\t\tlet tmpAddressMappingSet = Object.keys(pAddressMapping);\n\n\t\ttmpAddressMappingSet.forEach(\n\t\t\t(pInputAddress) =>\n\t\t\t{\n\t\t\t\tlet tmpNewDescriptorAddress = pAddressMapping[pInputAddress];\n\t\t\t\tlet tmpOldDescriptorAddress = false;\n\t\t\t\tlet tmpDescriptor = false;\n\n\t\t\t\t// See if there is a matching descriptor either by Address directly or Hash\n\t\t\t\tif (pManyfestSchemaDescriptors.hasOwnProperty(pInputAddress))\n\t\t\t\t{\n\t\t\t\t\ttmpOldDescriptorAddress = pInputAddress;\n\t\t\t\t}\n\t\t\t\telse if (tmpHashMapping.hasOwnProperty(pInputAddress))\n\t\t\t\t{\n\t\t\t\t\ttmpOldDescriptorAddress = tmpHashMapping[pInputAddress];\n\t\t\t\t}\n\n\t\t\t\t// If there was a matching descriptor in the manifest, store it in the temporary descriptor\n\t\t\t\tif (tmpOldDescriptorAddress)\n\t\t\t\t{\n\t\t\t\t\ttmpDescriptor = pManyfestSchemaDescriptors[tmpOldDescriptorAddress];\n\t\t\t\t\tdelete pManyfestSchemaDescriptors[tmpOldDescriptorAddress];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Create a new descriptor!  Map it to the input address.\n\t\t\t\t\ttmpDescriptor = { Hash:pInputAddress };\n\t\t\t\t}\n\n\t\t\t\t// Now re-add the descriptor to the manyfest schema\n\t\t\t\tpManyfestSchemaDescriptors[tmpNewDescriptorAddress] = tmpDescriptor;\n\t\t\t});\n\n\t\treturn true;\n\t}\n\n\tsafeResolveAddressMappings(pManyfestSchemaDescriptors, pAddressMapping)\n\t{\n\t\t// This returns the descriptors as a new object, safely remapping without mutating the original schema Descriptors\n\t\tlet tmpManyfestSchemaDescriptors = JSON.parse(JSON.stringify(pManyfestSchemaDescriptors));\n\t\tthis.resolveAddressMappings(tmpManyfestSchemaDescriptors, pAddressMapping);\n\t\treturn tmpManyfestSchemaDescriptors;\n\t}\n\n\tmergeAddressMappings(pManyfestSchemaDescriptorsDestination, pManyfestSchemaDescriptorsSource)\n\t{\n\t\tif ((typeof(pManyfestSchemaDescriptorsSource) != 'object') || (typeof(pManyfestSchemaDescriptorsDestination) != 'object'))\n\t\t{\n\t\t\tthis.logError(`Attempted to merge two schema descriptors but both were not objects.`);\n\t\t\treturn false;\n\t\t}\n\n\t\tlet tmpSource = JSON.parse(JSON.stringify(pManyfestSchemaDescriptorsSource));\n\t\tlet tmpNewManyfestSchemaDescriptors = JSON.parse(JSON.stringify(pManyfestSchemaDescriptorsDestination));\n\n\t\t// The first passed-in set of descriptors takes precedence.\n\t\tlet tmpDescriptorAddresses = Object.keys(tmpSource);\n\n\t\ttmpDescriptorAddresses.forEach(\n\t\t\t(pDescriptorAddress) =>\n\t\t\t{\n\t\t\t\tif (!tmpNewManyfestSchemaDescriptors.hasOwnProperty(pDescriptorAddress))\n\t\t\t\t{\n\t\t\t\t\ttmpNewManyfestSchemaDescriptors[pDescriptorAddress] = tmpSource[pDescriptorAddress];\n\t\t\t\t}\n\t\t\t});\n\n\t\treturn tmpNewManyfestSchemaDescriptors;\n\t}\n}\n\nmodule.exports = ManyfestSchemaManipulation;\n},{\"./Manyfest-LogToConsole.js\":36}],43:[function(require,module,exports){\n/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\nlet libSimpleLog = require('./Manyfest-LogToConsole.js');\n\nlet libPrecedent = require('precedent');\n\nlet libHashTranslation = require('./Manyfest-HashTranslation.js');\nlet libObjectAddressCheckAddressExists = require('./Manyfest-ObjectAddress-CheckAddressExists.js');\nlet libObjectAddressGetValue = require('./Manyfest-ObjectAddress-GetValue.js');\nlet libObjectAddressSetValue = require('./Manyfest-ObjectAddress-SetValue.js');\nlet libObjectAddressDeleteValue = require('./Manyfest-ObjectAddress-DeleteValue.js');\nlet libObjectAddressGeneration = require('./Manyfest-ObjectAddressGeneration.js');\nlet libSchemaManipulation = require('./Manyfest-SchemaManipulation.js');\n\n\n/**\n* Manyfest object address-based descriptions and manipulations.\n*\n* @class Manyfest\n*/\nclass Manyfest\n{\n\tconstructor(pManifest, pInfoLog, pErrorLog, pOptions)\n\t{\n\t\t// Wire in logging\n\t\tthis.logInfo = (typeof(pInfoLog) === 'function') ? pInfoLog : libSimpleLog;\n\t\tthis.logError = (typeof(pErrorLog) === 'function') ? pErrorLog : libSimpleLog;\n\n\t\t// Create an object address resolver and map in the functions\n\t\tthis.objectAddressCheckAddressExists = new libObjectAddressCheckAddressExists(this.logInfo, this.logError);\n\t\tthis.objectAddressGetValue = new libObjectAddressGetValue(this.logInfo, this.logError);\n\t\tthis.objectAddressSetValue = new libObjectAddressSetValue(this.logInfo, this.logError);\n\t\tthis.objectAddressDeleteValue = new libObjectAddressDeleteValue(this.logInfo, this.logError);\n\n\t\tthis.options = (\n\t\t\t{\n\t\t\t\tstrict: false,\n\t\t\t\tdefaultValues:\n\t\t\t\t\t{\n\t\t\t\t\t\t\"String\": \"\",\n\t\t\t\t\t\t\"Number\": 0,\n\t\t\t\t\t\t\"Float\": 0.0,\n\t\t\t\t\t\t\"Integer\": 0,\n\t\t\t\t\t\t\"Boolean\": false,\n\t\t\t\t\t\t\"Binary\": 0,\n\t\t\t\t\t\t\"DateTime\": 0,\n\t\t\t\t\t\t\"Array\": [],\n\t\t\t\t\t\t\"Object\": {},\n\t\t\t\t\t\t\"Null\": null\n\t\t\t\t\t}\n\t\t\t});\n\n\t\tthis.scope = undefined;\n\t\tthis.elementAddresses = undefined;\n\t\tthis.elementHashes = undefined;\n\t\tthis.elementDescriptors = undefined;\n\t\t// This can cause a circular dependency chain, so it only gets initialized if the schema specifically calls for it.\n\t\tthis.dataSolvers = undefined;\n\t\t// So solvers can use their own state\n\t\tthis.dataSolverState = undefined;\n\n\t\tthis.reset();\n\n\t\tif (typeof(pManifest) === 'object')\n\t\t{\n\t\t\tthis.loadManifest(pManifest);\n\t\t}\n\n\t\tthis.schemaManipulations = new libSchemaManipulation(this.logInfo, this.logError);\n\t\tthis.objectAddressGeneration = new libObjectAddressGeneration(this.logInfo, this.logError);\n\n\t\tthis.hashTranslations = new libHashTranslation(this.logInfo, this.logError);\n\t}\n\n\t/*************************************************************************\n\t * Schema Manifest Loading, Reading, Manipulation and Serialization Functions\n\t */\n\n\t// Reset critical manifest properties\n\treset()\n\t{\n\t\tthis.scope = 'DEFAULT';\n\t\tthis.elementAddresses = [];\n\t\tthis.elementHashes = {};\n\t\tthis.elementDescriptors = {};\n\t\tthis.dataSolvers = undefined;\n\t\tthis.dataSolverState = {};\n\n\t\tthis.libElucidator = undefined;\n\t}\n\n\tsetElucidatorSolvers(pElucidatorSolver, pElucidatorSolverState)\n\t{\n\t\tthis.objectAddressCheckAddressExists.elucidatorSolver = pElucidatorSolver;\n\t\tthis.objectAddressGetValue.elucidatorSolver = pElucidatorSolver;\n\t\tthis.objectAddressSetValue.elucidatorSolver = pElucidatorSolver;\n\t\tthis.objectAddressDeleteValue.elucidatorSolver = pElucidatorSolver;\n\n\t\tthis.objectAddressCheckAddressExists.elucidatorSolverState = pElucidatorSolverState;\n\t\tthis.objectAddressGetValue.elucidatorSolverState = pElucidatorSolverState;\n\t\tthis.objectAddressSetValue.elucidatorSolverState = pElucidatorSolverState;\n\t\tthis.objectAddressDeleteValue.elucidatorSolverState = pElucidatorSolverState;\n\t}\n\n\tclone()\n\t{\n\t\t// Make a copy of the options in-place\n\t\tlet tmpNewOptions = JSON.parse(JSON.stringify(this.options));\n\n\t\tlet tmpNewManyfest = new Manyfest(this.getManifest(), this.logInfo, this.logError, tmpNewOptions);\n\n\t\t// Import the hash translations\n\t\ttmpNewManyfest.hashTranslations.addTranslation(this.hashTranslations.translationTable);\n\n\t\treturn tmpNewManyfest;\n\t}\n\n\t// Deserialize a Manifest from a string\n\tdeserialize(pManifestString)\n\t{\n\t\t// TODO: Add guards for bad manifest string\n\t\treturn this.loadManifest(JSON.parse(pManifestString));\n\t}\n\n\t// Load a manifest from an object\n\tloadManifest(pManifest)\n\t{\n\t\tif (typeof(pManifest) !== 'object')\n\t\t{\n\t\t\tthis.logError(`(${this.scope}) Error loading manifest; expecting an object but parameter was type ${typeof(pManifest)}.`);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (pManifest.hasOwnProperty('Scope'))\n\t\t{\n\t\t\tif (typeof(pManifest.Scope) === 'string')\n\t\t\t{\n\t\t\t\tthis.scope = pManifest.Scope;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.logError(`(${this.scope}) Error loading scope from manifest; expecting a string but property was type ${typeof(pManifest.Scope)}.`, pManifest);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.logError(`(${this.scope}) Error loading scope from manifest object.  Property \"Scope\" does not exist in the root of the object.`, pManifest);\n\t\t}\n\n\t\tif (pManifest.hasOwnProperty('Descriptors'))\n\t\t{\n\t\t\tif (typeof(pManifest.Descriptors) === 'object')\n\t\t\t{\n\t\t\t\tlet tmpDescriptionAddresses = Object.keys(pManifest.Descriptors);\n\t\t\t\tfor (let i = 0; i < tmpDescriptionAddresses.length; i++)\n\t\t\t\t{\n\t\t\t\t\tthis.addDescriptor(tmpDescriptionAddresses[i], pManifest.Descriptors[tmpDescriptionAddresses[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.logError(`(${this.scope}) Error loading description object from manifest object.  Expecting an object in 'Manifest.Descriptors' but the property was type ${typeof(pManifest.Descriptors)}.`, pManifest);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.logError(`(${this.scope}) Error loading object description from manifest object.  Property \"Descriptors\" does not exist in the root of the Manifest object.`, pManifest);\n\t\t}\n\n\t\t// This seems like it would create a circular dependency issue but it only goes as deep as the schema defines Solvers\n\t\tif ((pManifest.hasOwnProperty('Solvers')) && (typeof(pManifest.Solvers) == 'object'))\n\t\t{\n\t\t\t// There are elucidator solvers passed-in, so we will create one to filter data.\n\t\t\tlet libElucidator = require('elucidator');\n\t\t\t// WARNING THESE CAN MUTATE THE DATA\n\t\t\t\t// The pattern for the solver is: {<~~SolverName~~>} anywhere in a property.\n\t\t\t\t//   Yes, this means your Javascript elements can't have my self-styled jellyfish brackets in them.\n\t\t\t\t//   This does, though, mean we can filter at multiple layers safely.\n\t\t\t\t//   Because these can be put at any address\n\t\t\t// The solver themselves:\n\t\t\t\t//   They are passed-in an object, and the current record is in the Record subobject.\n\t\t\t\t//   Basic operations can just write to the root object but...\n\t\t\t\t//   IF YOU PERMUTE THE Record SUBOBJECT YOU CAN AFFECT RECURSION\n\t\t\t// This is mostly meant for if statements to filter.\n\t\t\t\t//   Basically on aggregation, if a filter is set it will set \"keep record\" to true and let the solver decide differently.\n\t\t\tthis.dataSolvers = new libElucidator(pManifest.Solvers, this.logInfo, this.logError);\n\n\t\t\t// Load the solver state in so each instruction can have internal config\n\t\t\t// TODO: Should this just be a part of the lower layer pattern?\n\t\t\tlet tmpSolverKeys = Object.keys(pManifest.Solvers)\n\t\t\tfor (let i = 0; i < tmpSolverKeys.length; i++)\n\t\t\t{\n\t\t\t\tthis.dataSolverState[tmpSolverKeys] = pManifest.Solvers[tmpSolverKeys[i]];\n\t\t\t}\n\n\t\t\tthis.setElucidatorSolvers(this.dataSolvers, this.dataSolverState);\n\t\t}\n\t}\n\n\t// Serialize the Manifest to a string\n\t// TODO: Should this also serialize the translation table?\n\tserialize()\n\t{\n\t\treturn JSON.stringify(this.getManifest());\n\t}\n\n\tgetManifest()\n\t{\n\t\treturn (\n\t\t\t{\n\t\t\t\tScope: this.scope,\n\t\t\t\tDescriptors: JSON.parse(JSON.stringify(this.elementDescriptors))\n\t\t\t});\n\t}\n\n\t// Add a descriptor to the manifest\n\taddDescriptor(pAddress, pDescriptor)\n\t{\n\t\tif (typeof(pDescriptor) === 'object')\n\t\t{\n\t\t\t// Add the Address into the Descriptor if it doesn't exist:\n\t\t\tif (!pDescriptor.hasOwnProperty('Address'))\n\t\t\t{\n\t\t\t\tpDescriptor.Address = pAddress;\n\t\t\t}\n\n\t\t\tif (!this.elementDescriptors.hasOwnProperty(pAddress))\n\t\t\t{\n\t\t\t\tthis.elementAddresses.push(pAddress);\n\t\t\t}\n\n\t\t\t// Add the element descriptor to the schema\n\t\t\tthis.elementDescriptors[pAddress] = pDescriptor;\n\n\t\t\t// Always add the address as a hash\n\t\t\tthis.elementHashes[pAddress] = pAddress;\n\n\t\t\tif (pDescriptor.hasOwnProperty('Hash'))\n\t\t\t{\n\t\t\t\t// TODO: Check if this is a good idea or not..\n\t\t\t\t//       Collisions are bound to happen with both representations of the address/hash in here and developers being able to create their own hashes.\n\t\t\t\tthis.elementHashes[pDescriptor.Hash] = pAddress;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpDescriptor.Hash = pAddress;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.logError(`(${this.scope}) Error loading object descriptor for address '${pAddress}' from manifest object.  Expecting an object but property was type ${typeof(pDescriptor)}.`);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tgetDescriptorByHash(pHash)\n\t{\n\t\treturn this.getDescriptor(this.resolveHashAddress(pHash));\n\t}\n\n\tgetDescriptor(pAddress)\n\t{\n\t\treturn this.elementDescriptors[pAddress];\n\t}\n\n\t// execute an action function for each descriptor\n\teachDescriptor(fAction)\n\t{\n        let tmpDescriptorAddresses = Object.keys(this.elementDescriptors);\n        for (let i = 0; i < tmpDescriptorAddresses.length; i++)\n        {\n            fAction(this.elementDescriptors[tmpDescriptorAddresses[i]]);\n        }\n\n\t}\n\n\t/*************************************************************************\n\t * Beginning of Object Manipulation (read & write) Functions\n\t */\n\t// Check if an element exists by its hash\n\tcheckAddressExistsByHash (pObject, pHash)\n\t{\n\t\treturn this.checkAddressExists(pObject,this.resolveHashAddress(pHash));\n\t}\n\n\t// Check if an element exists at an address\n\tcheckAddressExists (pObject, pAddress)\n\t{\n\t\treturn this.objectAddressCheckAddressExists.checkAddressExists(pObject, pAddress);\n\t}\n\n\t// Turn a hash into an address, factoring in the translation table.\n\tresolveHashAddress(pHash)\n\t{\n\t\tlet tmpAddress = undefined;\n\n\t\tlet tmpInElementHashTable = this.elementHashes.hasOwnProperty(pHash);\n\t\tlet tmpInTranslationTable = this.hashTranslations.translationTable.hasOwnProperty(pHash);\n\n\t\t// The most straightforward: the hash exists, no translations.\n\t\tif (tmpInElementHashTable && !tmpInTranslationTable)\n\t\t{\n\t\t\ttmpAddress = this.elementHashes[pHash];\n\t\t}\n\t\t// There is a translation from one hash to another, and, the elementHashes contains the pointer end\n\t\telse if (tmpInTranslationTable && this.elementHashes.hasOwnProperty(this.hashTranslations.translate(pHash)))\n\t\t{\n\t\t\ttmpAddress = this.elementHashes[this.hashTranslations.translate(pHash)];\n\t\t}\n\t\t// Use the level of indirection only in the Translation Table\n\t\telse if (tmpInTranslationTable)\n\t\t{\n\t\t\ttmpAddress = this.hashTranslations.translate(pHash);\n\t\t}\n\t\t// Just treat the hash as an address.\n\t\t// TODO: Discuss this ... it is magic but controversial\n\t\telse\n\t\t{\n\t\t\ttmpAddress = pHash;\n\t\t}\n\n\t\treturn tmpAddress;\n\t}\n\n\t// Get the value of an element by its hash\n\tgetValueByHash (pObject, pHash)\n\t{\n\t\tlet tmpValue = this.getValueAtAddress(pObject, this.resolveHashAddress(pHash));\n\n\t\tif (typeof(tmpValue) == 'undefined')\n\t\t{\n\t\t\t// Try to get a default if it exists\n\t\t\ttmpValue = this.getDefaultValue(this.getDescriptorByHash(pHash));\n\t\t}\n\n\t\treturn tmpValue;\n\t}\n\n\t// Get the value of an element at an address\n\tgetValueAtAddress (pObject, pAddress)\n\t{\n\t\tlet tmpValue = this.objectAddressGetValue.getValueAtAddress(pObject, pAddress);\n\n\t\tif (typeof(tmpValue) == 'undefined')\n\t\t{\n\t\t\t// Try to get a default if it exists\n\t\t\ttmpValue = this.getDefaultValue(this.getDescriptor(pAddress));\n\t\t}\n\n\t\treturn tmpValue;\n\t}\n\n\t// Set the value of an element by its hash\n\tsetValueByHash(pObject, pHash, pValue)\n\t{\n\t\treturn this.setValueAtAddress(pObject, this.resolveHashAddress(pHash), pValue);\n\t}\n\n\t// Set the value of an element at an address\n\tsetValueAtAddress (pObject, pAddress, pValue)\n\t{\n\t\treturn this.objectAddressSetValue.setValueAtAddress(pObject, pAddress, pValue);\n\t}\n\n\t// Delete the value of an element by its hash\n\tdeleteValueByHash(pObject, pHash, pValue)\n\t{\n\t\treturn this.deleteValueAtAddress(pObject, this.resolveHashAddress(pHash), pValue);\n\t}\n\n\t// Delete the value of an element at an address\n\tdeleteValueAtAddress (pObject, pAddress, pValue)\n\t{\n\t\treturn this.objectAddressDeleteValue.deleteValueAtAddress(pObject, pAddress, pValue);\n\t}\n\n\t// Validate the consistency of an object against the schema\n\tvalidate(pObject)\n\t{\n\t\tlet tmpValidationData =\n\t\t{\n\t\t\tError: null,\n\t\t\tErrors: [],\n\t\t\tMissingElements:[]\n\t\t};\n\n\t\tif (typeof(pObject) !== 'object')\n\t\t{\n\t\t\ttmpValidationData.Error = true;\n\t\t\ttmpValidationData.Errors.push(`Expected passed in object to be type object but was passed in ${typeof(pObject)}`);\n\t\t}\n\n\t\tlet addValidationError = (pAddress, pErrorMessage) =>\n\t\t{\n\t\t\ttmpValidationData.Error = true;\n\t\t\ttmpValidationData.Errors.push(`Element at address \"${pAddress}\" ${pErrorMessage}.`);\n\t\t};\n\n\t\t// Now enumerate through the values and check for anomalies based on the schema\n\t\tfor (let i = 0; i < this.elementAddresses.length; i++)\n\t\t{\n\t\t\tlet tmpDescriptor = this.getDescriptor(this.elementAddresses[i]);\n\t\t\tlet tmpValueExists = this.checkAddressExists(pObject, tmpDescriptor.Address);\n\t\t\tlet tmpValue = this.getValueAtAddress(pObject, tmpDescriptor.Address);\n\n\t\t\tif ((typeof(tmpValue) == 'undefined') || !tmpValueExists)\n\t\t\t{\n\t\t\t\t// This will technically mean that `Object.Some.Value = undefined` will end up showing as \"missing\"\n\t\t\t\t// TODO: Do we want to do a different message based on if the property exists but is undefined?\n\t\t\t\ttmpValidationData.MissingElements.push(tmpDescriptor.Address);\n\t\t\t\tif (tmpDescriptor.Required || this.options.strict)\n\t\t\t\t{\n\t\t\t\t\taddValidationError(tmpDescriptor.Address, 'is flagged REQUIRED but is not set in the object');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Now see if there is a data type specified for this element\n\t\t\tif (tmpDescriptor.DataType)\n\t\t\t{\n\t\t\t\tlet tmpElementType = typeof(tmpValue);\n\t\t\t\tswitch(tmpDescriptor.DataType.toString().trim().toLowerCase())\n\t\t\t\t{\n\t\t\t\t\tcase 'string':\n\t\t\t\t\t\tif (tmpElementType != 'string')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but is of the type ${tmpElementType}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'number':\n\t\t\t\t\t\tif (tmpElementType != 'number')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but is of the type ${tmpElementType}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'integer':\n\t\t\t\t\t\tif (tmpElementType != 'number')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but is of the type ${tmpElementType}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlet tmpValueString = tmpValue.toString();\n\t\t\t\t\t\t\tif (tmpValueString.indexOf('.') > -1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// TODO: Is this an error?\n\t\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but has a decimal point in the number.`);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'float':\n\t\t\t\t\t\tif (tmpElementType != 'number')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but is of the type ${tmpElementType}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'DateTime':\n\t\t\t\t\t\tlet tmpValueDate = new Date(tmpValue);\n\t\t\t\t\t\tif (tmpValueDate.toString() == 'Invalid Date')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but is not parsable as a Date by Javascript`);\n\t\t\t\t\t\t}\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t// Check if this is a string, in the default case\n\t\t\t\t\t\t// Note this is only when a DataType is specified and it is an unrecognized data type.\n\t\t\t\t\t\tif (tmpElementType != 'string')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} (which auto-converted to String because it was unrecognized) but is of the type ${tmpElementType}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn tmpValidationData;\n\t}\n\n\t// Returns a default value, or, the default value for the data type (which is overridable with configuration)\n\tgetDefaultValue(pDescriptor)\n\t{\n\t\tif (typeof(pDescriptor) != 'object')\n\t\t{\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (pDescriptor.hasOwnProperty('Default'))\n\t\t{\n\t\t\treturn pDescriptor.Default;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Default to a null if it doesn't have a type specified.\n\t\t\t// This will ensure a placeholder is created but isn't misinterpreted.\n\t\t\tlet tmpDataType = (pDescriptor.hasOwnProperty('DataType')) ? pDescriptor.DataType : 'String';\n\t\t\tif (this.options.defaultValues.hasOwnProperty(tmpDataType))\n\t\t\t{\n\t\t\t\treturn this.options.defaultValues[tmpDataType];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// give up and return null\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Enumerate through the schema and populate default values if they don't exist.\n\tpopulateDefaults(pObject, pOverwriteProperties)\n\t{\n\t\treturn this.populateObject(pObject, pOverwriteProperties,\n\t\t\t// This just sets up a simple filter to see if there is a default set.\n\t\t\t(pDescriptor) =>\n\t\t\t{\n\t\t\t\treturn pDescriptor.hasOwnProperty('Default');\n\t\t\t});\n\t}\n\n\t// Forcefully populate all values even if they don't have defaults.\n\t// Based on type, this can do unexpected things.\n\tpopulateObject(pObject, pOverwriteProperties, fFilter)\n\t{\n\t\t// Automatically create an object if one isn't passed in.\n\t\tlet tmpObject = (typeof(pObject) === 'object') ? pObject : {};\n\t\t// Default to *NOT OVERWRITING* properties\n\t\tlet tmpOverwriteProperties = (typeof(pOverwriteProperties) == 'undefined') ? false : pOverwriteProperties;\n\t\t// This is a filter function, which is passed the schema and allows complex filtering of population\n\t\t// The default filter function just returns true, populating everything.\n\t\tlet tmpFilterFunction = (typeof(fFilter) == 'function') ? fFilter : (pDescriptor) => { return true; };\n\n\t\tthis.elementAddresses.forEach(\n\t\t\t(pAddress) =>\n\t\t\t{\n\t\t\t\tlet tmpDescriptor = this.getDescriptor(pAddress);\n\t\t\t\t// Check the filter function to see if this is an address we want to set the value for.\n\t\t\t\tif (tmpFilterFunction(tmpDescriptor))\n\t\t\t\t{\n\t\t\t\t\t// If we are overwriting properties OR the property does not exist\n\t\t\t\t\tif (tmpOverwriteProperties || !this.checkAddressExists(tmpObject, pAddress))\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.setValueAtAddress(tmpObject, pAddress, this.getDefaultValue(tmpDescriptor));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\treturn tmpObject;\n\t}\n};\n\nmodule.exports = Manyfest;\n},{\"./Manyfest-HashTranslation.js\":35,\"./Manyfest-LogToConsole.js\":36,\"./Manyfest-ObjectAddress-CheckAddressExists.js\":37,\"./Manyfest-ObjectAddress-DeleteValue.js\":38,\"./Manyfest-ObjectAddress-GetValue.js\":39,\"./Manyfest-ObjectAddress-SetValue.js\":40,\"./Manyfest-ObjectAddressGeneration.js\":41,\"./Manyfest-SchemaManipulation.js\":42,\"elucidator\":4,\"precedent\":44}],44:[function(require,module,exports){\n/**\n* Precedent Meta-Templating\n*\n* @license     MIT\n*\n* @author      Steven Velozo <steven@velozo.com>\n*\n* @description Process text streams, parsing out meta-template expressions.\n*/\nvar libWordTree = require(`./WordTree.js`);\nvar libStringParser = require(`./StringParser.js`);\n\nclass Precedent\n{\n\t/**\n\t * Precedent Constructor\n\t */\n\tconstructor()\n\t{\n\t\tthis.WordTree = new libWordTree();\n\t\t\n\t\tthis.StringParser = new libStringParser();\n\n\t\tthis.ParseTree = this.WordTree.ParseTree;\n\t}\n\t\n\t/**\n\t * Add a Pattern to the Parse Tree\n\t * @method addPattern\n\t * @param {Object} pTree - A node on the parse tree to push the characters into\n\t * @param {string} pPattern - The string to add to the tree\n\t * @param {number} pIndex - callback function\n\t * @return {bool} True if adding the pattern was successful\n\t */\n\taddPattern(pPatternStart, pPatternEnd, pParser)\n\t{\n\t\treturn this.WordTree.addPattern(pPatternStart, pPatternEnd, pParser);\n\t}\n\t\n\t/**\n\t * Parse a string with the existing parse tree\n\t * @method parseString\n\t * @param {string} pString - The string to parse\n\t * @return {string} The result from the parser\n\t */\n\tparseString(pString)\n\t{\n\t\treturn this.StringParser.parseString(pString, this.ParseTree);\n\t}\n}\n\nmodule.exports = Precedent;\n\n},{\"./StringParser.js\":45,\"./WordTree.js\":46}],45:[function(require,module,exports){\n/**\n* String Parser\n*\n* @license     MIT\n*\n* @author      Steven Velozo <steven@velozo.com>\n*\n* @description Parse a string, properly processing each matched token in the word tree.\n*/\n\nclass StringParser\n{\n\t/**\n\t * StringParser Constructor\n\t */\n\tconstructor()\n\t{\n\t}\n\t\n\t/**\n\t * Create a fresh parsing state object to work with.\n\t * @method newParserState\n\t * @param {Object} pParseTree - A node on the parse tree to begin parsing from (usually root)\n\t * @return {Object} A new parser state object for running a character parser on\n\t * @private\n\t */\n\tnewParserState (pParseTree)\n\t{\n\t\treturn (\n\t\t{\n\t\t\tParseTree: pParseTree,\n\n\t\t\tOutput: '',\n\t\t\tOutputBuffer: '',\n\n\t\t\tPattern: false,\n\n\t\t\tPatternMatch: false,\n\t\t\tPatternMatchOutputBuffer: ''\n\t\t});\n\t}\n\t\t\n\t/**\n\t * Assign a node of the parser tree to be the next potential match.\n\t * If the node has a PatternEnd property, it is a valid match and supercedes the last valid match (or becomes the initial match).\n\t * @method assignNode\n\t * @param {Object} pNode - A node on the parse tree to assign\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tassignNode (pNode, pParserState)\n\t{\n\t\tpParserState.PatternMatch = pNode;\n\n\t\t// If the pattern has a END we can assume it has a parse function...\n\t\tif (pParserState.PatternMatch.hasOwnProperty('PatternEnd'))\n\t\t{\n\t\t\t// ... this is the legitimate start of a pattern.\n\t\t\tpParserState.Pattern = pParserState.PatternMatch;\n\t\t}\n\t}\n\t\n\t/**\n\t * Append a character to the output buffer in the parser state.\n\t * This output buffer is used when a potential match is being explored, or a match is being explored.\n\t * @method appendOutputBuffer\n\t * @param {string} pCharacter - The character to append\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tappendOutputBuffer (pCharacter, pParserState)\n\t{\n\t\tpParserState.OutputBuffer += pCharacter;\n\t}\n\t\n\t/**\n\t * Flush the output buffer to the output and clear it.\n\t * @method flushOutputBuffer\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tflushOutputBuffer (pParserState)\n\t{\n\t\tpParserState.Output += pParserState.OutputBuffer;\n\t\tpParserState.OutputBuffer = '';\n\t}\n\n\t\n\t/**\n\t * Check if the pattern has ended.  If it has, properly flush the buffer and start looking for new patterns.\n\t * @method checkPatternEnd\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tcheckPatternEnd (pParserState)\n\t{\n\t\tif ((pParserState.OutputBuffer.length >= pParserState.Pattern.PatternEnd.length+pParserState.Pattern.PatternStart.length) && \n\t\t\t(pParserState.OutputBuffer.substr(-pParserState.Pattern.PatternEnd.length) === pParserState.Pattern.PatternEnd))\n\t\t{\n\t\t\t// ... this is the end of a pattern, cut off the end tag and parse it.\n\t\t\t// Trim the start and end tags off the output buffer now\n\t\t\tpParserState.OutputBuffer = pParserState.Pattern.Parse(pParserState.OutputBuffer.substr(pParserState.Pattern.PatternStart.length, pParserState.OutputBuffer.length - (pParserState.Pattern.PatternStart.length+pParserState.Pattern.PatternEnd.length)));\n\t\t\t// Flush the output buffer.\n\t\t\tthis.flushOutputBuffer(pParserState);\n\t\t\t// End pattern mode\n\t\t\tpParserState.Pattern = false;\n\t\t\tpParserState.PatternMatch = false;\n\t\t}\n\t}\n\t\n\t/**\n\t * Parse a character in the buffer.\n\t * @method parseCharacter\n\t * @param {string} pCharacter - The character to append\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tparseCharacter (pCharacter, pParserState)\n\t{\n\t\t// (1) If we aren't in a pattern match, and we aren't potentially matching, and this may be the start of a new pattern....\n\t\tif (!pParserState.PatternMatch && pParserState.ParseTree.hasOwnProperty(pCharacter))\n\t\t{\n\t\t\t// ... assign the node as the matched node.\n\t\t\tthis.assignNode(pParserState.ParseTree[pCharacter], pParserState);\n\t\t\tthis.appendOutputBuffer(pCharacter, pParserState);\n\t\t}\n\t\t// (2) If we are in a pattern match (actively seeing if this is part of a new pattern token)\n\t\telse if (pParserState.PatternMatch)\n\t\t{\n\t\t\t// If the pattern has a subpattern with this key\n\t\t\tif (pParserState.PatternMatch.hasOwnProperty(pCharacter))\n\t\t\t{\n\t\t\t\t// Continue matching patterns.\n\t\t\t\tthis.assignNode(pParserState.PatternMatch[pCharacter], pParserState);\n\t\t\t}\n\t\t\tthis.appendOutputBuffer(pCharacter, pParserState);\n\t\t\tif (pParserState.Pattern)\n\t\t\t{\n\t\t\t\t// ... Check if this is the end of the pattern (if we are matching a valid pattern)...\n\t\t\t\tthis.checkPatternEnd(pParserState);\n\t\t\t}\n\t\t}\n\t\t// (3) If we aren't in a pattern match or pattern, and this isn't the start of a new pattern (RAW mode)....\n\t\telse\n\t\t{\n\t\t\tpParserState.Output += pCharacter;\n\t\t}\n\t}\n\t\n\t/**\n\t * Parse a string for matches, and process any template segments that occur.\n\t * @method parseString\n\t * @param {string} pString - The string to parse.\n\t * @param {Object} pParseTree - The parse tree to begin parsing from (usually root)\n\t */\n\tparseString (pString, pParseTree)\n\t{\n\t\tlet tmpParserState = this.newParserState(pParseTree);\n\n\t\tfor (var i = 0; i < pString.length; i++)\n\t\t{\n\t\t\t// TODO: This is not fast.\n\t\t\tthis.parseCharacter(pString[i], tmpParserState);\n\t\t}\n\t\t\n\t\tthis.flushOutputBuffer(tmpParserState);\n\t\t\n\t\treturn tmpParserState.Output;\n\t}\n}\n\nmodule.exports = StringParser;\n\n},{}],46:[function(require,module,exports){\n/**\n* Word Tree\n*\n* @license     MIT\n*\n* @author      Steven Velozo <steven@velozo.com>\n*\n* @description Create a tree (directed graph) of Javascript objects, one character per object.\n*/\n\nclass WordTree\n{\n\t/**\n\t * WordTree Constructor\n\t */\n\tconstructor()\n\t{\n\t\tthis.ParseTree = {};\n\t}\n\t\n\t/** \n\t * Add a child character to a Parse Tree node\n\t * @method addChild\n\t * @param {Object} pTree - A parse tree to push the characters into\n\t * @param {string} pPattern - The string to add to the tree\n\t * @param {number} pIndex - The index of the character in the pattern\n\t * @returns {Object} The resulting leaf node that was added (or found)\n\t * @private\n\t */\n\taddChild (pTree, pPattern, pIndex)\n\t{\n\t\tif (!pTree.hasOwnProperty(pPattern[pIndex]))\n\t\t\tpTree[pPattern[pIndex]] = {};\n\t\t\n\t\treturn pTree[pPattern[pIndex]];\n\t}\n\t\n\t/** Add a Pattern to the Parse Tree\n\t * @method addPattern\n\t * @param {Object} pPatternStart - The starting string for the pattern (e.g. \"${\")\n\t * @param {string} pPatternEnd - The ending string for the pattern (e.g. \"}\")\n\t * @param {number} pParser - The function to parse if this is the matched pattern, once the Pattern End is met.  If this is a string, a simple replacement occurs.\n\t * @return {bool} True if adding the pattern was successful\n\t */\n\taddPattern (pPatternStart, pPatternEnd, pParser)\n\t{\n\t\tif (pPatternStart.length < 1)\n\t\t\treturn false;\n\n\t\tif ((typeof(pPatternEnd) === 'string') && (pPatternEnd.length < 1))\n\t\t\treturn false;\n\n\t\tlet tmpLeaf = this.ParseTree;\n\n\t\t// Add the tree of leaves iteratively\n\t\tfor (var i = 0; i < pPatternStart.length; i++)\n\t\t\ttmpLeaf = this.addChild(tmpLeaf, pPatternStart, i);\n\n\t\ttmpLeaf.PatternStart = pPatternStart;\n\t\ttmpLeaf.PatternEnd = ((typeof(pPatternEnd) === 'string') && (pPatternEnd.length > 0)) ? pPatternEnd : pPatternStart;\n\t\ttmpLeaf.Parse = (typeof(pParser) === 'function') ? pParser : \n\t\t\t\t\t\t(typeof(pParser) === 'string') ? () => { return pParser; } :\n\t\t\t\t\t\t(pData) => { return pData; };\n\n\t\treturn true;\n\t}\n}\n\nmodule.exports = WordTree;\n\n},{}],47:[function(require,module,exports){\n/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\n\n/**\n* Elucidator browser shim loader\n*/\n\n// Load the manyfest module into the browser global automatically.\nvar libElucidator = require('./Elucidator.js');\n\nif (typeof(window) === 'object') window.Elucidator = libElucidator;\n\nmodule.exports = libElucidator;\n},{\"./Elucidator.js\":50}],48:[function(require,module,exports){\narguments[4][2][0].apply(exports,arguments)\n},{\"dup\":2}],49:[function(require,module,exports){\narguments[4][3][0].apply(exports,arguments)\n},{\"dup\":3}],50:[function(require,module,exports){\narguments[4][4][0].apply(exports,arguments)\n},{\"./Elucidator-InstructionSet.js\":48,\"./Elucidator-LogToConsole.js\":49,\"./InstructionSets/Geometry.js\":51,\"./InstructionSets/Logic.js\":52,\"./InstructionSets/Math-Javascript.js\":53,\"./InstructionSets/PreciseMath-Decimal.js\":77,\"./InstructionSets/Set.js\":78,\"./InstructionSets/String.js\":79,\"dup\":4,\"manyfest\":43,\"precedent\":44}],51:[function(require,module,exports){\narguments[4][5][0].apply(exports,arguments)\n},{\"../Elucidator-InstructionSet.js\":48,\"./Operations/Geometry-RectangleArea.json\":54,\"dup\":5}],52:[function(require,module,exports){\narguments[4][6][0].apply(exports,arguments)\n},{\"../Elucidator-InstructionSet.js\":48,\"./Operations/Logic-Execute.json\":55,\"./Operations/Logic-If.json\":56,\"dup\":6}],53:[function(require,module,exports){\narguments[4][7][0].apply(exports,arguments)\n},{\"../Elucidator-InstructionSet.js\":48,\"./Operations/Math-Add.json\":57,\"./Operations/Math-Aggregate.json\":58,\"./Operations/Math-Divide.json\":59,\"./Operations/Math-Multiply.json\":60,\"./Operations/Math-Subtract.json\":61,\"dup\":7}],54:[function(require,module,exports){\narguments[4][8][0].apply(exports,arguments)\n},{\"dup\":8}],55:[function(require,module,exports){\narguments[4][9][0].apply(exports,arguments)\n},{\"dup\":9}],56:[function(require,module,exports){\narguments[4][10][0].apply(exports,arguments)\n},{\"dup\":10}],57:[function(require,module,exports){\narguments[4][11][0].apply(exports,arguments)\n},{\"dup\":11}],58:[function(require,module,exports){\narguments[4][12][0].apply(exports,arguments)\n},{\"dup\":12}],59:[function(require,module,exports){\narguments[4][13][0].apply(exports,arguments)\n},{\"dup\":13}],60:[function(require,module,exports){\narguments[4][14][0].apply(exports,arguments)\n},{\"dup\":14}],61:[function(require,module,exports){\narguments[4][15][0].apply(exports,arguments)\n},{\"dup\":15}],62:[function(require,module,exports){\narguments[4][16][0].apply(exports,arguments)\n},{\"dup\":16}],63:[function(require,module,exports){\nmodule.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"PreciseMath\",\n\t\t\"Operation\": \"Aggregate\",\n\t\t\"Synopsis\": \"Precisely aggregate a set of numbers (from array or object address):  x = a + b + ... + z\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"a\": { \"Hash\": \"a\", \"Type\": \"Set\" },\n\t\t\"ValueNames\": { \"Hash\": \"ValueNames\", \"Type\": \"Set\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"x\": { \"Hash\": \"x\", \"Type\": \"Number\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Aggregate all numeric values in {{Name:a}}, storing the resultant in {{Name:x}}.\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:x}} = {{OutputValue:x}}\"\t\t\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"PreciseMath\",\n\t\t\t\"Instruction\": \"aggregate\"\n\t\t}\n\t]\n}\n},{}],64:[function(require,module,exports){\narguments[4][18][0].apply(exports,arguments)\n},{\"dup\":18}],65:[function(require,module,exports){\narguments[4][19][0].apply(exports,arguments)\n},{\"dup\":19}],66:[function(require,module,exports){\narguments[4][20][0].apply(exports,arguments)\n},{\"dup\":20}],67:[function(require,module,exports){\narguments[4][21][0].apply(exports,arguments)\n},{\"dup\":21}],68:[function(require,module,exports){\narguments[4][22][0].apply(exports,arguments)\n},{\"dup\":22}],69:[function(require,module,exports){\narguments[4][23][0].apply(exports,arguments)\n},{\"dup\":23}],70:[function(require,module,exports){\narguments[4][24][0].apply(exports,arguments)\n},{\"dup\":24}],71:[function(require,module,exports){\narguments[4][25][0].apply(exports,arguments)\n},{\"dup\":25}],72:[function(require,module,exports){\narguments[4][26][0].apply(exports,arguments)\n},{\"dup\":26}],73:[function(require,module,exports){\narguments[4][27][0].apply(exports,arguments)\n},{\"dup\":27}],74:[function(require,module,exports){\narguments[4][28][0].apply(exports,arguments)\n},{\"dup\":28}],75:[function(require,module,exports){\narguments[4][29][0].apply(exports,arguments)\n},{\"dup\":29}],76:[function(require,module,exports){\narguments[4][30][0].apply(exports,arguments)\n},{\"dup\":30}],77:[function(require,module,exports){\narguments[4][31][0].apply(exports,arguments)\n},{\"../Elucidator-InstructionSet.js\":48,\"./Operations/PreciseMath-Add.json\":62,\"./Operations/PreciseMath-Aggregate.json\":63,\"./Operations/PreciseMath-Divide.json\":64,\"./Operations/PreciseMath-GroupValuesAndAggregate.json\":65,\"./Operations/PreciseMath-Multiply.json\":66,\"./Operations/PreciseMath-Round.json\":67,\"./Operations/PreciseMath-SetPrecision.json\":68,\"./Operations/PreciseMath-SetRoundingMode.json\":69,\"./Operations/PreciseMath-Subtract.json\":70,\"./Operations/PreciseMath-ToDecimalPlaces.json\":71,\"./Operations/PreciseMath-ToSignificantDigits.json\":72,\"decimal.js\":1,\"dup\":31}],78:[function(require,module,exports){\narguments[4][32][0].apply(exports,arguments)\n},{\"../Elucidator-InstructionSet.js\":48,\"./Operations/Set-GroupValuesBy.json\":73,\"dup\":32}],79:[function(require,module,exports){\narguments[4][33][0].apply(exports,arguments)\n},{\"../Elucidator-InstructionSet.js\":48,\"./Operations/String-Replace.json\":74,\"./Operations/String-Substring.json\":75,\"./Operations/String-Trim.json\":76,\"dup\":33}]},{},[47])(47)\n});\n\n","/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\n\n/**\n* Instruction Set Bace Class.\n*\n* @class ElucidatorInstructionSet\n*/\nclass ElucidatorInstructionSet\n{\n    constructor(pElucidator)\n    {\n        this.elucidator = pElucidator;\n\n        this.namespace = 'default';\n    }\n\n    // Create an empty namespace for instructions and operations if either one doesn't exist\n    initializeNamespace(pNamespace)\n    {\n        if (typeof(pNamespace) == 'string')\n        {\n            this.namespace = pNamespace;\n        }\n        if (!this.elucidator.instructionSets.hasOwnProperty(this.namespace))\n        {\n            this.elucidator.instructionSets[this.namespace.toLowerCase()] = {};\n        }\n        if (!this.elucidator.operationSets.hasOwnProperty(this.namespace))\n        {\n            this.elucidator.operationSets[this.namespace.toLowerCase()] = {};\n        }\n    }\n\n    // Add an instruction to the set\n    addInstruction(pInstructionHash, fInstructionFunction)\n    {\n        if (typeof(pInstructionHash) != 'string')\n        {\n            this.elucidator.logError(`Attempted to add an instruction with an invalid hash; expected a string but the instruction hash type was ${typeof(pInstructionHash)}`);\n            return false;\n        }\n        if (typeof(fInstructionFunction) != 'function')\n        {\n            this.elucidator.logError(`Attempted to add an instruction with an invalid function; expected a function but type was ${typeof(fInstructionFunction)}`);\n            return false;\n        }\n\n        this.elucidator.instructionSets[this.namespace.toLowerCase()][pInstructionHash] = fInstructionFunction;\n        return true;\n    }\n\n    initializeInstructions()\n    {\n        // This is where we map in the instructions.\n        // If the extending class calls super it will inject a harmless noop into the scope.\n        // It isn't recommended to do these inline as lambdas, but this code is generally not expected to be called.\n        // Unless the developer wants a noop in their instruction set...........\n        this.addInstruction('noop', \n            (pOperation) =>\n            {\n                pOperation.logInfo('Executing a no-operation operation.');\n                return true;\n            });\n\n        return true;\n    }\n\n    // Add an operation to the set\n    addOperation(pOperationHash, pOperation)\n    {\n        if (typeof(pOperationHash) != 'string')\n        {\n            this.elucidator.logError(`Attempted to add an operation with an invalid hash; expected a string but the operation hash type was ${typeof(pOperationHash)}`, pOperation);\n            return false;\n        }\n        if (typeof(pOperation) != 'object')\n        {\n            this.elucidator.logError(`Attempted to add an invalid operation; expected an object data type but the type was ${typeof(pOperation)}`, pOperation);\n            return false;\n        }\n        // Validate the Description subobject, which is key to functioning.\n        if (!pOperation.hasOwnProperty(\"Description\"))\n        {\n            this.elucidator.logError(`Attempted to add an operation with an invalid description; no Description subobject set.`, pOperation);\n            return false;\n        }\n        if (typeof(pOperation.Description) != 'object')\n        {\n            this.elucidator.logError(`Attempted to add an operation with an invalid description; Description subobject was not an object.  The type was ${typeof(pOperation.Description)}.`, pOperation);\n            return false;\n        }\n        if (typeof(pOperation.Description.Hash) != 'string')\n        {\n            if (typeof(pOperation.Description.Operation) == 'string')\n            {\n                // Use the \"Operation\" as the \"Hash\"\n                pOperation.Description.Hash = pOperation.Description.Operation;\n            }\n            else\n            {\n                this.elucidator.logError(`Attempted to add an operation with an invalid description; Description subobject did not contain a valid Hash which is required to call the operation.`, pOperation);\n                return false;\n            }\n        }\n\n        // Now auto create data if it is missing or wrong in the Description\n        if ((typeof(pOperation.Description.Namespace) != 'string') || (pOperation.Description.Namespace != this.namespace))\n        {\n            pOperation.Description.Namespace = this.namespace;\n        }\n        if (typeof(pOperation.Description.Summary) != 'string')\n        {\n            pOperation.Description.Summary = `[${pOperation.Description.Namespace}] [${pOperation.Description.Hash}] operation.`;\n        }\n\n        // If there are no inputs, or outputs, or steps, add them.\n        if (!pOperation.hasOwnProperty('Inputs'))\n        {\n            pOperation.Inputs = {};\n        }\n        if (!pOperation.hasOwnProperty('Outputs'))\n        {\n            pOperation.Outputs = {};\n        }\n        if (!pOperation.hasOwnProperty('Steps'))\n        {\n            pOperation.Steps = [];\n        }\n\n        // If there are no inputs, or outputs, or steps, add them.\n        // TODO: Add a step where we try to load this into Manyfest and see that it's valid.\n        if (typeof(pOperation.Inputs) !== 'object')\n        {\n            this.elucidator.logError(`Attempted to add an operation with an invalid Inputs object.`, pOperation);\n            return false;\n        }\n        // If there are no inputs, or outputs, or steps, add them.\n        // TODO: Add a step where we try to load this into Manyfest and see that it's valid.\n        if (typeof(pOperation.Outputs) !== 'object')\n        {\n            this.elucidator.logError(`Attempted to add an operation with an invalid Outputs object.`, pOperation);\n            return false;\n        }\n        if (!Array.isArray(pOperation.Steps))\n        {\n            this.elucidator.logError(`Attempted to add an operation with an invalid Steps array.`, pOperation);\n            return false;\n        }\n\n\n        this.elucidator.operationSets[this.namespace.toLowerCase()][pOperationHash.toLowerCase()] = pOperation;\n        return true;\n    }\n\n    initializeOperations()\n    {\n        this.addOperation('noop', \n            {\n                \"Description\":\n                {\n                    \"Operation\": \"noop\",\n                    \"Description\": \"No operation - no affect on any data.\"\n                }\n            });\n\n        return true;\n    }\n};\n\nmodule.exports = ElucidatorInstructionSet;","/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\n\n/**\n* Elucidator simple logging shim (for browser and dependency-free running)\n*/\n\nconst logToConsole = (pLogLine, pLogObject, pLogLevel) =>\n{\n    let tmpLogLine = (typeof(pLogLine) === 'string') ? pLogLine : '';\n    let tmpLogLevel = (typeof(pLogLevel) === 'string') ? pLogLevel : 'INFO';\n\n    console.log(`[Elucidator:${tmpLogLevel}] ${tmpLogLine}`);\n\n    if (pLogObject) console.log(JSON.stringify(pLogObject,null,4)+\"\\n\");\n};\n\nconst logInfo = (pLogLine, pLogObject) =>\n{\n    logToConsole(pLogLine, pLogObject, 'Info');\n};\n\n\nconst logWarning = (pLogLine, pLogObject) =>\n{\n    logToConsole(pLogLine, pLogObject, 'Warning');\n};\n\n\nconst logError = (pLogLine, pLogObject) =>\n{\n    logToConsole(pLogLine, pLogObject, 'Error');\n};\n\nmodule.exports = (\n{\n    logToConsole: logToConsole,\n    info: logInfo,\n    warning: logWarning,\n    error: logError\n});","/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\nconst libSimpleLog = require('./Elucidator-LogToConsole.js');\nconst libManyfest = require('manyfest');\nconst libPrecedent = require('precedent');\n\nconst libElucidatorInstructionSet = require('./Elucidator-InstructionSet.js');\n\n/**\n* Elucidator object address-based descriptions and manipulations.\n*\n* @class Elucidator\n*/\nclass Elucidator\n{\n    constructor(pOperations, fInfoLog, fErrorLog)\n    {\n        // Wire in logging\n        this.logInfo = (typeof(fInfoLog) === 'function') ? fInfoLog : libSimpleLog.info;\n        this.logWarning = (typeof(fWarningLog) === 'function') ? fWarningLog : libSimpleLog.warning;\n        this.logError = (typeof(fErrorLog) === 'function') ? fErrorLog : libSimpleLog.error;\n\n\t\t// Instructions are the basic building blocks for operations\n\t\tthis.instructionSets = {};\n\n\t\t// Operations are the solvers that can be called (instructions can't be called directly)\n\t\t// These can be added at run-time as well\n\t\tthis.operationSets = {};\n\n\t\t// Decide later how to make this truly unique.\n\t\tthis.UUID = 0;\n\n\t\tthis.loadDefaultInstructionSets();\n\n\t\tif (pOperations)\n\t\t{\n\t\t\tlet tmpSolverHashes = Object.keys(pOperations);\n\t\t\tfor (let i = 0; i < tmpSolverHashes.length; i++)\n\t\t\t{\n\t\t\t\tthis.addOperation('Custom',tmpSolverHashes[i], pOperations[tmpSolverHashes[i]]);\n\t\t\t}\n\t\t}\n    }\n\n\t// Load an instruction set\n\tloadInstructionSet(cInstructionSet)\n\t{\n\t\tlet tmpInstructionSet = new cInstructionSet(this);\n\t\t// Setup the namespace\n\t\ttmpInstructionSet.initializeNamespace();\n\t\ttmpInstructionSet.initializeInstructions();\n\t\ttmpInstructionSet.initializeOperations();\n\t}\n\n\tloadDefaultInstructionSets()\n\t{\n\t\t// The javascript math instructions and operations\n\t\t// These provide the \"Math\" namespace\n\t\tthis.loadInstructionSet(require(`./InstructionSets/Math-Javascript.js`));\n\n\t\t// A precision javascript math library that is consistent across browsers, stable and without mantissa issues\n\t\t// Uses Decimal.js\n\t\t// These provide the \"PreciseMath\" namespace\n\t\tthis.loadInstructionSet(require(`./InstructionSets/PreciseMath-Decimal.js`));\n\n\t\t// The abstract geometry instructions and operations (rectangle area, circle area, etc.)\n\t\t// These provide the \"Geometry\" namespace\n\t\tthis.loadInstructionSet(require(`./InstructionSets/Geometry.js`));\n\n\t\t// The logic operations (if, execution of instructions, etc.)\n\t\t// These provide the \"Logic\" namespace\n\t\tthis.loadInstructionSet(require(`./InstructionSets/Logic.js`));\n\n\t\t// Basic string manipulation instructions and operations\n\t\t// These provide the \"String\" namespace\n\t\tthis.loadInstructionSet(require(`./InstructionSets/String.js`));\n\n\t\t// Basic set manipulation instructions and operations\n\t\t// These provide the \"Set\" namespace\n\t\tthis.loadInstructionSet(require(`./InstructionSets/Set.js`));\n\t}\n\n\toperationExists(pNamespace, pOperationHash)\n\t{\n\t\tif ((typeof(pNamespace) != 'string') || (typeof(pOperationHash) != 'string'))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\tlet tmpNamespace = pNamespace.toLowerCase();\n\t\treturn (this.operationSets.hasOwnProperty(tmpNamespace) && this.operationSets[tmpNamespace].hasOwnProperty(pOperationHash.toLowerCase()));\n\t}\n\n\taddOperation(pNamespace, pOperationHash, pOperation)\n\t{\n        if (typeof(pNamespace) != 'string')\n        {\n            this.logError(`Attempted to add an operation at runtime via Elucidator.addOperation with an invalid namespace; expected a string but the type was ${typeof(pNamespace)}`, pOperation);\n            return false;\n        }\n\n\t\tlet tmpOperationInjector = new libElucidatorInstructionSet(this);\n\t\ttmpOperationInjector.initializeNamespace(pNamespace);\n\n\t\treturn tmpOperationInjector.addOperation(pOperationHash, pOperation);\n\t}\n\n\tsolveInternalOperation(pNamespace, pOperationHash, pInputObject, pOutputObject, pDescriptionManyfest, pInputAddressMapping, pOutputAddressMapping, pSolutionContext)\n\t{\n\t\tif (!this.operationExists(pNamespace, pOperationHash))\n\t\t{\n\t\t\tthis.logError(`Attempted to solveInternalOperation for namespace ${pNamespace} operationHash ${pOperationHash} but the operation was not found.`);\n\t\t\t// TODO: Should this return something with an error log populated?\n\t\t\treturn false;\n\t\t}\n\t\tlet tmpOperation = this.operationSets[pNamespace.toLowerCase()][pOperationHash.toLowerCase()];\n\t\treturn this.solveOperation(tmpOperation, pInputObject, pOutputObject, pDescriptionManyfest, pInputAddressMapping, pOutputAddressMapping, pSolutionContext);\n\t}\n\n\tsolveOperation(pOperationObject, pInputObject, pOutputObject, pDescriptionManyfest, pInputAddressMapping, pOutputAddressMapping, pSolutionContext)\n\t{\n\t\tlet tmpOperation = JSON.parse(JSON.stringify(pOperationObject));\n\n\t\tif (typeof(pInputObject) != 'object')\n\t\t{\n            this.logError(`Attempted to run a solve but the passed in Input was not an object.  The type was ${typeof(pInputObject)}.`);\n\t\t\treturn false;\n\t\t}\n\t\tlet tmpInputObject = pInputObject;\n\n\t\t// Default to reusing the input object as the output object.\n\t\tlet tmpOutputObject = tmpInputObject;\n\n\t\t// This is how recursive solutions bind their context together.\n\t\tlet tmpSolutionContext = pSolutionContext;\n\t\tif (typeof(tmpSolutionContext) === 'undefined')\n\t\t{\n\t\t\ttmpSolutionContext = (\n\t\t\t\t{\n\t\t\t\t\t\"SolutionGUID\": `Solution-${this.UUID++}`, \n\t\t\t\t\t\"SolutionBaseNamespace\": pOperationObject.Description.Namespace,\n\t\t\t\t\t\"SolutionBaseOperation\": pOperationObject.Description.Operation,\n\t\t\t\t\t\"SolutionLog\": []\n\t\t\t\t});\n\t\t\t\n\t\t\t// This is the root operation, see if there are Inputs and Outputs created ... if not, create them.\n\t\t\tif (!tmpOperation.hasOwnProperty('Inputs'))\n\t\t\t{\n\t\t\t\ttmpOperation.Inputs = {};\n\t\t\t}\n\t\t\tif (!tmpOperation.hasOwnProperty('Outputs'))\n\t\t\t{\n\t\t\t\ttmpOperation.Outputs = {};\n\t\t\t}\n\n\t\t\t// This is the root Operation, see if there is a hash translation available for either side (input or output)\n\t\t\tif (tmpOperation.hasOwnProperty('InputHashTranslationTable'))\n\t\t\t{\n\t\t\t\ttmpSolutionContext.InputHashMapping = JSON.parse(JSON.stringify(tmpOperation.InputHashTranslationTable));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttmpSolutionContext.InputHashMapping = {};\n\t\t\t}\n\n\t\t\tif (tmpOperation.hasOwnProperty('OutputHashTranslationTable'))\n\t\t\t{\n\t\t\t\ttmpSolutionContext.OutputHashMapping = JSON.parse(JSON.stringify(tmpOperation.OutputHashTranslationTable));\n\t\t\t}\n\n\t\t\tif ((typeof(pOutputObject) != 'object')\n\t\t\t\t&& (typeof(tmpOutputHashMapping) == 'undefined') \n\t\t\t\t&& (typeof(tmpInputHashMapping) != 'undefined'))\n\t\t\t{\n\t\t\t\t// Reuse the input hash mapping if:\n\t\t\t\t//   1) we auto-mapped the input hash mapping to the output because only an input object was supplied\n\t\t\t\t//   2) there *was not* an output hash mapping supplied\n\t\t\t\t//   3) there *was* an input hash mapping supplied\n\t\t\t\t//\n\t\t\t\t// This seems simple at first but exposes some really interesting behaviors in terms of\n\t\t\t\t// reusing the same object and schema for input and output, but having different hash\n\t\t\t\t// mappings for each of them.\n\t\t\t\ttmpSolutionContext.OutputHashMapping = tmpSolutionContext.InputHashMapping;\n\t\t\t}\n\t\t}\n\n\t\tif (typeof(pOutputObject) == 'object')\n\t\t{\n\t\t\t// If the call defined an explicit, different output object from the input object use that instead.\n\t\t\ttmpOutputObject = pOutputObject;\n\t\t}\n\n\t\tlet tmpDescriptionManyfest = false;\n\t\tif (typeof(pDescriptionManyfest) === 'undefined')\n\t\t{\n\t\t\t// We are going to use this for some clever schema manipulations, then recreate the object\n\t\t\ttmpDescriptionManyfest = new libManyfest();\n\t\t\t// Synthesize a manyfest from the Input and Output properties\n\t\t\tlet tmpManyfestSchema = (\n\t\t\t\t{\n\t\t\t\t\tScope: 'Solver Data Part Descriptions',\n\t\t\t\t\tDescriptors: tmpDescriptionManyfest.schemaManipulations.mergeAddressMappings(tmpOperation.Inputs, tmpOperation.Outputs)\n\t\t\t\t});\n\t\t\t}\n\t\telse\n\t\t{\n\t\t\t// Clone the passed-in manyfest, so mutations do not alter the upstream version\n\t\t\ttmpDescriptionManyfest = pDescriptionManyfest.clone();\n\t\t}\n\t\t// Now that the operation object has been created uniquely, apply any passed-in address-hash and hash-hash remappings\n\t\tif (pInputAddressMapping)\n\t\t{\n\t\t\ttmpDescriptionManyfest.schemaManipulations.resolveAddressMappings(tmpOperation.Inputs, pInputAddressMapping);\n\t\t}\n\t\tif (pOutputAddressMapping)\n\t\t{\n\t\t\ttmpDescriptionManyfest.schemaManipulations.resolveAddressMappings(tmpOperation.Inputs, pOutputAddressMapping);\n\t\t}\n\t\tif (tmpSolutionContext.InputHashMapping)\n\t\t{\n\t\t\ttmpDescriptionManyfest.hashTranslations.addTranslation(tmpSolutionContext.InputHashMapping);\n\t\t}\n\t\tif (tmpSolutionContext.OutputHashMapping)\n\t\t{\n\t\t\ttmpDescriptionManyfest.hashTranslations.addTranslation(tmpSolutionContext.OutputHashMapping);\t\t\t\n\t\t}\n\n\n\t\t// Set some kind of unique identifier for the operation\n\t\ttmpOperation.UUID = this.UUID++;\n\t\ttmpOperation.SolutionContext = tmpSolutionContext;\n\n\t\tif (tmpOperation.Description.Synopsys)\n\t\t{\n\t\t\ttmpSolutionContext.SolutionLog.push(`[${tmpOperation.UUID}]: Solver running operation ${tmpOperation.Description.Synopsys}`);\n\t\t}\n\n\t\tlet tmpPrecedent = new libPrecedent();\n\t\ttmpPrecedent.addPattern('{{Name:', '}}',\n\t\t\t(pHash)=>\n\t\t\t{\n\t\t\t\tlet tmpHash = pHash.trim();\n\t\t\t\tlet tmpDescriptor = tmpDescriptionManyfest.getDescriptorByHash(tmpHash)\n\n\t\t\t\t// Return a human readable value\n\t\t\t\tif ((typeof(tmpDescriptor) == 'object')  && tmpDescriptor.hasOwnProperty('Name'))\n\t\t\t\t{\n\t\t\t\t\treturn tmpDescriptor.Name;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treturn tmpHash;\n\t\t\t\t}\n\t\t\t});\n\t\ttmpPrecedent.addPattern('{{InputValue:', '}}',\n\t\t\t(pHash)=>\n\t\t\t{\n\t\t\t\tlet tmpHash = pHash.trim();\n\t\t\t\treturn tmpDescriptionManyfest.getValueByHash(tmpInputObject,tmpHash);\n\t\t\t});\n\t\ttmpPrecedent.addPattern('{{OutputValue:', '}}',\n\t\t\t(pHash)=>\n\t\t\t{\n\t\t\t\tlet tmpHash = pHash.trim();\n\t\t\t\treturn tmpDescriptionManyfest.getValueByHash(tmpOutputObject,tmpHash);\n\t\t\t});\n\n\t\tif (tmpOperation.hasOwnProperty('Log') && tmpOperation.Log.hasOwnProperty('PreOperation'))\n\t\t{\n\t\t\tif (typeof(tmpOperation.Log.PreOperation) == 'string')\n\t\t\t{\n\t\t\t\ttmpOperation.SolutionContext.SolutionLog.push(tmpPrecedent.parseString(tmpOperation.Log.PreOperation));\n\t\t\t}\n\t\t\telse if (Array.isArray(tmpOperation.Log.PreOperation))\n\t\t\t{\n\t\t\t\tfor (let i = 0; i < tmpOperation.Log.PreOperation.length; i++)\n\t\t\t\t{\n\t\t\t\t\tif ((typeof(tmpOperation.Log.PreOperation[i]) == 'string'))\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpOperation.SolutionContext.SolutionLog.push(tmpPrecedent.parseString(tmpOperation.Log.PreOperation[i]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Now step through each operation and solve\n\t\tfor (let i = 0; i < tmpOperation.Steps.length; i++)\n\t\t{\n\t\t\tlet tmpStep = tmpOperation.Steps[i];\n\n\t\t\t// Instructions are always endpoints -- they *do not* recurse.\n\t\t\tif (tmpStep.hasOwnProperty('Instruction'))\n\t\t\t{\n\t\t\t\tlet tmpInputSchema = (\n\t\t\t\t\t{\n\t\t\t\t\t\t\"Scope\": \"InputObject\",\n\t\t\t\t\t\t\"Descriptors\": JSON.parse(JSON.stringify(tmpOperation.Inputs))\n\t\t\t\t\t});\n\t\t\t\t// Perform step-specific address mappings.\n\t\t\t\ttmpDescriptionManyfest.schemaManipulations.resolveAddressMappings(tmpInputSchema.Descriptors, tmpStep.InputHashAddressMap);\n\t\t\t\tlet tmpInputManyfest = new libManyfest(tmpInputSchema);\n\t\t\t\tif (tmpSolutionContext.InputHashMapping)\n\t\t\t\t{\n\t\t\t\t\ttmpInputManyfest.hashTranslations.addTranslation(tmpSolutionContext.InputHashMapping);\n\t\t\t\t}\n\n\t\t\t\tlet tmpOutputSchema = (\n\t\t\t\t\t{\n\t\t\t\t\t\t\"Scope\": \"OutputObject\",\n\t\t\t\t\t\t\"Descriptors\": JSON.parse(JSON.stringify(tmpOperation.Outputs))\n\t\t\t\t\t});\n\t\t\t\t\ttmpDescriptionManyfest.schemaManipulations.resolveAddressMappings(tmpOutputSchema.Descriptors, tmpStep.OutputHashAddressMap);\n\t\t\t\tlet tmpOutputManyfest = new libManyfest(tmpOutputSchema);\n\t\t\t\tif (tmpSolutionContext.OutputHashMapping)\n\t\t\t\t{\n\t\t\t\t\ttmpOutputManyfest.hashTranslations.addTranslation(tmpSolutionContext.OutputHashMapping);\n\t\t\t\t}\n\t\n\t\t\t\t// Construct the instruction state object\n\t\t\t\tlet tmpInstructionState = (\n\t\t\t\t{\n\t\t\t\t\tElucidator: this,\n\n\t\t\t\t\tNamespace: tmpStep.Namespace.toLowerCase(),\n\t\t\t\t\tInstruction: tmpStep.Instruction.toLowerCase(),\n\n\t\t\t\t\tOperation: tmpOperation,\n\n\t\t\t\t\tSolutionContext: tmpSolutionContext,\n\n\t\t\t\t\tDescriptionManyfest: tmpDescriptionManyfest,\n\n\t\t\t\t\tInputObject: tmpInputObject,\n\t\t\t\t\tInputManyfest: tmpInputManyfest,\n\n\t\t\t\t\tOutputObject: tmpOutputObject,\n\t\t\t\t\tOutputManyfest: tmpOutputManyfest\n\t\t\t\t});\n\n\t\t\t\ttmpInstructionState.logError = \n\t\t\t\t\t(pMessage) => \n\t\t\t\t\t{\n\t\t\t\t\t\ttmpSolutionContext.SolutionLog.push(`[ERROR][Operation ${tmpInstructionState.Operation.Description.Namespace}:${tmpInstructionState.Operation.Description.Hash} - Step #${i}:${tmpStep.Namespace}:${tmpStep.Instruction}] ${pMessage}`)\n\t\t\t\t\t};\n\n\t\t\t\ttmpInstructionState.logInfo = \n\t\t\t\t\t(pMessage) => \n\t\t\t\t\t{\n\t\t\t\t\t\ttmpSolutionContext.SolutionLog.push(`[INFO][Operation ${tmpInstructionState.Operation.Description.Namespace}:${tmpInstructionState.Operation.Description.Hash} - Step #${i}:${tmpStep.Namespace}:${tmpStep.Instruction}] ${pMessage}`)\n\t\t\t\t\t};\n\n\t\t\t\tif (this.instructionSets[tmpInstructionState.Namespace].hasOwnProperty(tmpInstructionState.Instruction))\n\t\t\t\t{\n\t\t\t\t\tlet fInstruction = this.instructionSets[tmpInstructionState.Namespace][tmpInstructionState.Instruction];\n\t\t\t\t\tfInstruction(tmpInstructionState);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Operations recurse.\n\t\t\tif (tmpStep.hasOwnProperty('Operation'))\n\t\t\t{\n\t\t\t\tif (typeof(tmpStep.Operation) == 'string')\n\t\t\t\t{\n\t\t\t\t\tthis.solveInternalOperation(tmpStep.Namespace, tmpStep.Operation, tmpInputObject, tmpOutputObject, tmpDescriptionManyfest, tmpStep.InputHashAddressMap, tmpStep.OutputHashAddressMap, tmpSolutionContext);\n\t\t\t\t}\n\t\t\t\telse if (typeof(tmpStep.Operation) == 'object')\n\t\t\t\t{\n\t\t\t\t\t// You can even define an inline object operation!  This gets crazy fast\n\t\t\t\t\tthis.solveOperation(tmpStep.Operation, tmpInputObject, tmpOutputObject, tmpDescriptionManyfest, tmpStep.InputHashAddressMap, tmpStep.OutputHashAddressMap, tmpSolutionContext);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (tmpOperation.hasOwnProperty('Log') && tmpOperation.Log.hasOwnProperty('PostOperation'))\n\t\t{\n\t\t\tif (typeof(tmpOperation.Log.PostOperation) == 'string')\n\t\t\t{\n\t\t\t\ttmpOperation.SolutionContext.SolutionLog.push(tmpPrecedent.parseString(tmpOperation.Log.PostOperation));\n\t\t\t}\n\t\t\telse if (Array.isArray(tmpOperation.Log.PreOperation))\n\t\t\t{\n\t\t\t\tfor (let i = 0; i < tmpOperation.Log.PostOperation.length; i++)\n\t\t\t\t{\n\t\t\t\t\tif ((typeof(tmpOperation.Log.PostOperation[i]) == 'string'))\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpOperation.SolutionContext.SolutionLog.push(tmpPrecedent.parseString(tmpOperation.Log.PostOperation[i]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn tmpSolutionContext;\n\t}\n};\n\nmodule.exports = Elucidator;","// Solution providers are meant to be stateless, and not classes.\n// These solution providers are akin to drivers, connecting code libraries or \n// other types of behavior to mapping operations.\n\nlet libElucidatorInstructionSet = require('../Elucidator-InstructionSet.js');\n\nclass Geometry extends libElucidatorInstructionSet\n{\n    constructor(pElucidator)\n    {\n        super(pElucidator);\n        this.namespace = 'Geometry';\n    }\n\n    // Geometry provides no instructions\n    initializeInstructions()\n    {\n        return true;\n    }\n\n    initializeOperations()\n    {\n        this.addOperation('rectanglearea', require(`./Operations/Geometry-RectangleArea.json`));\n\n        return true;\n    }\n}\n\nmodule.exports = Geometry;","// Solution providers are meant to be stateless, and not classes.\n// These solution providers are akin to drivers, connecting code libraries or \n// other types of behavior to mapping operations.\n\nlet libElucidatorInstructionSet = require('../Elucidator-InstructionSet.js');\n\nconst ifInstruction = (pOperation) =>\n{\n    let tmpLeftValue = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'leftValue');\n    let tmpRightValue = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'rightValue');\n    let tmpComparator = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'comparator').toString().toLowerCase();\n\n    let tmpComparisonOperator = 'equal';\n\n    // This may eventually come from configuration; for now just leave it here.\n    let tmpComparisonOperatorMapping = (\n        {\n            '==':'equal',\n            'eq':'equal',\n            'equal':'equal',\n\n            '!=':'notequal',\n            'noteq':'notequal',\n            'notequal':'notequal',\n\n            '===':'identity',\n            'id':'identity',\n            'identity':'identity',\n\n            '>':'greaterthan',\n            'gt':'greaterthan',\n            'greaterthan':'greaterthan',\n\n            '>=':'greaterthanorequal',\n            'gte':'greaterthanorequal',\n            'greaterthanorequal':'greaterthanorequal',\n\n            '<':'lessthan',\n            'lt':'lessthan',\n            'lessthan':'lessthan',\n\n            '<=':'lessthanorequal',\n            'lte':'lessthanorequal',\n            'lessthanorequal':'lessthanorequal'\n        });\n\n    if (tmpComparisonOperatorMapping.hasOwnProperty(tmpComparator))\n    {\n        tmpComparisonOperator = tmpComparisonOperatorMapping[tmpComparator];\n    }\n\n    let tmpTrueNamespace = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'trueNamespace');\n    let tmpTrueOperation = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'trueOperation');\n\n    let tmpFalseNamespace = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'falseNamespace');\n    let tmpFalseOperation = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'falseOperation');\n\n    let tmpTruthiness = null;\n\n    switch(tmpComparisonOperator)\n    {\n        case 'equal':\n            tmpTruthiness = (tmpLeftValue == tmpRightValue);\n            break;\n        case 'identity':\n            tmpTruthiness = (tmpLeftValue === tmpRightValue);\n            break;\n        case 'notequal':\n            tmpTruthiness = (tmpLeftValue != tmpRightValue);\n            break;\n        case 'greaterthan':\n            tmpTruthiness = (tmpLeftValue > tmpRightValue);\n            break;\n        case 'greaterthanorequal':\n            tmpTruthiness = (tmpLeftValue >= tmpRightValue);\n            break;\n        case 'lessthan':\n            tmpTruthiness = (tmpLeftValue < tmpRightValue);\n            break;\n        case 'lessthanorequal':\n            tmpTruthiness = (tmpLeftValue <= tmpRightValue);\n            break;\n    }\n\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'truthinessResult', tmpTruthiness);\n\n    // Now execute the operations (unless it is a noop or a bunk operation)\n    // This is, frankly, kindof a mind-blowing amount of recursion possibility.\n    // Both of these are falling back on the base solution hash mapping.\n    // --> Not certain if this is the correct approach and the only way to tell will be through exercise of this\n    if (tmpTruthiness && (typeof(tmpTrueNamespace) == 'string') && (typeof(tmpTrueOperation) == 'string') && (tmpTrueOperation != 'noop'))\n    {\n        pOperation.Elucidator.solveInternalOperation(tmpTrueNamespace, tmpTrueOperation, pOperation.InputObject, pOperation.OutputObject, pOperation.DescriptionManyfest, pOperation.SolutionContext.InputHashMapping, pOperation.SolutionContext.OutputHashMapping, pOperation.SolutionContext);\n    }\n    else if ((typeof(tmpFalseNamespace) == 'string') &&  (typeof(tmpFalseOperation) == 'string') && (tmpFalseOperation != 'noop'))\n    {\n        pOperation.Elucidator.solveInternalOperation(tmpFalseNamespace, tmpFalseOperation, pOperation.InputObject, pOperation.OutputObject, pOperation.DescriptionManyfest, pOperation.SolutionContext.InputHashMapping, pOperation.SolutionContext.OutputHashMapping, pOperation.SolutionContext);\n    }\n\n    return true;\n};\n\nconst executeOperation = (pOperation) =>\n{\n    let tmpNamespace = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'namespace');\n    let tmpOperation = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'operation');\n\n    pOperation.Elucidator.solveInternalOperation(tmpNamespace, tmpOperation, pOperation.InputObject, pOperation.OutputObject, pOperation.DescriptionManyfest, pOperation.SolutionContext.InputHashMapping, pOperation.SolutionContext.OutputHashMapping, pOperation.SolutionContext);\n\n    return true;\n}\n\nclass Logic extends libElucidatorInstructionSet\n{\n    constructor(pElucidator)\n    {\n        super(pElucidator);\n        this.namespace = 'Logic';\n    }\n\n    initializeInstructions()\n    {\n        // Logic actually wants a noop instruction!\n        super.initializeInstructions();\n\n        this.addInstruction('if', ifInstruction);\n        this.addInstruction('execute', executeOperation);\n\n        return true;\n    }\n\n    initializeOperations()\n    {\n        this.addOperation('if', require(`./Operations/Logic-If.json`));\n        this.addOperation('execute', require(`./Operations/Logic-Execute.json`));\n\n        return true;\n    }\n}\n\nmodule.exports = Logic;","// Solution providers are meant to be stateless, and not classes.\n// These solution providers are akin to drivers, connecting code libraries or \n// other types of behavior to mapping operations.\n\nlet libElucidatorInstructionSet = require('../Elucidator-InstructionSet.js');\n\nlet add = (pOperation) =>\n{\n    // This could be done in one line, but, would be more difficult to comprehend.\n    let tmpA = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'a');\n    let tmpB = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'b');\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'x', tmpA + tmpB);\n    return true;\n};\n\nlet subtract = (pOperation) =>\n{\n    // This could be done in one line, but, would be more difficult to comprehend.\n    let tmpA = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'a');\n    let tmpB = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'b');\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'x', tmpA - tmpB);\n    return true;\n};\n\nlet multiply = (pOperation) =>\n{\n    // This could be done in one line, but, would be more difficult to comprehend.\n    let tmpA = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'a');\n    let tmpB = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'b');\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'x', tmpA * tmpB);\n    return true;\n};\n\nlet divide = (pOperation) =>\n{\n    // This could be done in one line, but, would be more difficult to comprehend.\n    let tmpA = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'a');\n    let tmpB = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'b');\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'x', tmpA / tmpB);\n    return true;\n};\n\nlet aggregate = (pOperation) =>\n{\n    let tmpA = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'a');\n\n    let tmpObjectType = typeof(tmpA);\n\n    let tmpAggregationValue = 0;\n\n    if (tmpObjectType == 'object')\n    {\n        if (Array.isArray(tmpA))\n        {\n            for (let i = 0; i < tmpA.length; i++)\n            {\n                // If this is an array, enumerate it and try to aggregate each number\n                let tmpValue = parseInt(tmpA[i]);\n\n                if (isNaN(tmpValue))\n                {\n                    pOperation.logError(`Array element index [${i}] could not be parsed as a number; skipping.  (${tmpA[i]})`);\n                }\n                else\n                {\n                    tmpAggregationValue += tmpValue;\n                    pOperation.logInfo(`Adding element [${i}] value ${tmpValue} totaling: ${tmpAggregationValue}`)\n                }\n            }\n        }\n        else\n        {\n            let tmpObjectKeys = Object.keys(tmpA);\n            for (let i = 0; i < tmpObjectKeys.length; i++)\n            {\n                let tmpValue = parseInt(tmpA[tmpObjectKeys[i]]);\n\n                if (isNaN(tmpValue))\n                {\n                    pOperation.logError(`Object property [${tmpObjectKeys[i]}] could not be parsed as a number; skipping.  (${tmpA[tmpObjectKeys[i]]})`);\n                }\n                else\n                {\n                    tmpAggregationValue += tmpValue;\n                    pOperation.logInfo(`Adding object property [${tmpObjectKeys[i]}] value ${tmpValue} totaling: ${tmpAggregationValue}`)\n                }\n            }\n        }\n    }\n    else\n    {\n        let tmpValue = parseInt(tmpA);\n\n        if (isNaN(tmpValue))\n        {\n            pOperation.logError(`Direct value could not be parsed as a number; skipping.  (${tmpA})`);\n        }\n        else\n        {\n            tmpAggregationValue += tmpValue;\n        }\n    }\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'x', tmpAggregationValue);\n    return true;\n};\n\nclass MathJavascript extends libElucidatorInstructionSet\n{\n    constructor(pElucidator)\n    {\n        super(pElucidator);\n        this.namespace = 'Math';\n    }\n\n    initializeInstructions()\n    {\n        this.addInstruction('add', add);\n\n        this.addInstruction('subtract', subtract);\n        this.addInstruction('sub', subtract);\n\n        this.addInstruction('multiply', multiply);\n        this.addInstruction('mul', multiply);\n\n        this.addInstruction('divide', divide);\n        this.addInstruction('div', divide);\n\n        this.addInstruction('aggregate', aggregate);\n\n        return true;\n    }\n\n    initializeOperations()\n    {\n        this.addOperation('add', require(`./Operations/Math-Add.json`));\n        this.addOperation('subtract', require(`./Operations/Math-Subtract.json`));\n        this.addOperation('multiply', require(`./Operations/Math-Multiply.json`));\n        this.addOperation('divide', require(`./Operations/Math-Divide.json`));\n\n        this.addOperation('aggregate', require(`./Operations/Math-Aggregate.json`));\n\n        return true;\n    }\n}\n\nmodule.exports = MathJavascript;","module.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"Geometry\",\n\t\t\"Operation\": \"RectangleArea\",\n\t\t\"Synopsis\": \"Solve for the area of a rectangle:  Area = Width * Height\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"Width\": { \"Hash\":\"Width\", \"Type\":\"Number\" },\n\t\t\"Height\": { \"Hash\":\"Height\", \"Type\":\"Number\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"Area\": { \"Hash\":\"Area\", \"Name\": \"Area of the Rectangle\"},\n\t\t\"Ratio\": { \"Hash\":\"Ratio\", \"Name\": \"The Ratio between the Width and the Height\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Solve for [ {{Name:Area}} ] based on [ {{Name:Width}} ] and [ {{Name:Height}} ].\",\n\t\t\"PostOperation\": \"Operation complete; [ {{Name:Area}} ] = {{InputValue:Width}} * {{InputValue:Height}} = {{OutputValue:Area}}\"\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"PreciseMath\",\n\t\t\t\"Instruction\": \"multiply\",\n\t\t\t\"InputHashAddressMap\": \n\t\t\t\t{\n\t\t\t\t\t\"a\": \"Width\",\n\t\t\t\t\t\"b\": \"Height\"\n\t\t\t\t},\n\t\t\t\"OutputHashAddressMap\":\n\t\t\t\t{\n\t\t\t\t\t\"x\": \"Area\"\n\t\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"Namespace\": \"PreciseMath\",\n\t\t\t\"Instruction\": \"divide\",\n\t\t\t\"InputHashAddressMap\": \n\t\t\t\t{\n\t\t\t\t\t\"a\": \"Width\",\n\t\t\t\t\t\"b\": \"Height\"\n\t\t\t\t},\n\t\t\t\"OutputHashAddressMap\":\n\t\t\t\t{\n\t\t\t\t\t\"x\": \"Ratio\"\n\t\t\t\t}\n\t\t}\n\t]\n}","module.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"Logic\",\n\t\t\"Operation\": \"Execute\",\n\t\t\"Synopsis\": \"Execute an operation based on namespace and operation.\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"namespace\": { \"Hash\": \"namespace\", \"Type\": \"string\", \"Default\":\"logic\" },\n\t\t\"operation\": { \"Hash\": \"operation\", \"Type\": \"string\", \"Default\":\"noop\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Execute the {{InputValue:operation}} operation in namespace {{InputValue:namespace}}.\",\n\t\t\"PostOperation\": \"Operation [{{InputValue:namespace}}:{{InputValue:operation}}] execution complete.\"\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"Logic\",\n\t\t\t\"Instruction\": \"execute\"\n\t\t}\n\t]\n}","module.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"Logic\",\n\t\t\"Operation\": \"If\",\n\t\t\"Synopsis\": \"Comparison-based if of leftValue and RightValue based on comparator.  Executes trueNamespace:trueOperation or falseNamespace:falseOperation based on truthiness of result.  Also outputs a true or false to truthinessResult.\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"leftValue\": { \"Hash\":\"leftValue\", \"Type\":\"Any\" },\n\t\t\"rightValue\": { \"Hash\":\"rightValue\", \"Type\":\"Any\", \"Default\": true },\n\t\t\"comparator\": { \"Hash\":\"comparator\", \"Type\":\"String\", \"Default\":\"==\" },\n\n\t\t\"trueNamespace\": {\"Hash\":\"trueNamespace\", \"Type\":\"String\", \"Default\":\"logic\" },\n\t\t\"trueOperation\": {\"Hash\":\"trueOperation\", \"Type\":\"String\", \"Default\":\"noop\" },\n\n\t\t\"falseNamespace\": {\"Hash\":\"falseNamespace\", \"Type\":\"String\", \"Default\":\"logic\" },\n\t\t\"falseOperation\": {\"Hash\":\"falseOperation\", \"Type\":\"String\", \"Default\":\"noop\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"truthinessResult\": { \"Hash\": \"truthinessResult\", \"Type\": \"Boolean\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Compare {{Name:leftValue}} and {{Name:rightValue}} with the {{InputValue:comparator}} operator, storing the truthiness in {{Name:truthinessResult}}.\",\n\t\t\"PostOperation\": \"Operation complete: {{InputValue:leftValue}} {{InputValue:comparator}} {{InputValue:rightValue}} evaluated to {{OutputValue:truthinessResult}}\"\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"Logic\",\n\t\t\t\"Instruction\": \"If\"\n\t\t}\n\t]\n}","module.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"Math\",\n\t\t\"Operation\": \"Add\",\n\t\t\"Synopsis\": \"Add two numbers:  x = a + b\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"a\": { \"Hash\": \"a\", \"Type\": \"Number\" },\n\t\t\"b\": { \"Hash\": \"b\", \"Type\": \"Number\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"x\": { \"Hash\": \"x\", \"Type\": \"Number\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Add {{Name:a}} and {{Name:b}}, storing the value in {{Name:x}}.\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:x}} = {{InputValue:a}} + {{InputValue:b}} = {{OutputValue:x}}\"\t\t\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"Math\",\n\t\t\t\"Instruction\": \"add\"\n\t\t}\n\t]\n}","module.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"Math\",\n\t\t\"Operation\": \"Aggregate\",\n\t\t\"Synopsis\": \"Aggregate a set of numbers (from array or object address):  x = a + b + ... + z\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"a\": { \"Hash\": \"a\", \"Type\": \"Set\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"x\": { \"Hash\": \"x\", \"Type\": \"Number\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Aggregate all numeric values in {{Name:a}}, storing the resultant in {{Name:x}}.\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:x}} = {{OutputValue:x}}\"\t\t\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"Math\",\n\t\t\t\"Instruction\": \"aggregate\"\n\t\t}\n\t]\n}","module.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"Math\",\n\t\t\"Operation\": \"Divide\",\n\t\t\"Synopsis\": \"Divide two numbers:  x = a / b\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"a\": { \"Hash\": \"a\", \"Type\": \"Number\" },\n\t\t\"b\": { \"Hash\": \"b\", \"Type\": \"Number\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"x\": { \"Hash\": \"x\", \"Type\": \"Number\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Divide {{Name:a}} over {{Name:b}}, storing the value in {{Name:x}}.\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:x}} = {{InputValue:a}} / {{InputValue:b}} = {{OutputValue:x}}\"\t\t\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"Math\",\n\t\t\t\"Instruction\": \"divide\"\n\t\t}\n\t]\n}","module.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"Math\",\n\t\t\"Operation\": \"Multiply\",\n\t\t\"Synopsis\": \"Multiply two numbers:  x = a * b\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"a\": { \"Hash\": \"a\", \"Type\": \"Number\" },\n\t\t\"b\": { \"Hash\": \"b\", \"Type\": \"Number\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"x\": { \"Hash\": \"x\", \"Type\": \"Number\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Multiply {{Name:a}} and {{Name:b}}, storing the value in {{Name:x}}.\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:x}} = {{InputValue:a}} * {{InputValue:b}} = {{OutputValue:x}}\"\t\t\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"Math\",\n\t\t\t\"Instruction\": \"multiply\"\n\t\t}\n\t]\n}","module.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"Math\",\n\t\t\"Operation\": \"Subtract\",\n\t\t\"Synopsis\": \"Subtract two numbers:  x = a - b\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"a\": { \"Hash\": \"a\", \"Type\": \"Number\" },\n\t\t\"b\": { \"Hash\": \"b\", \"Type\": \"Number\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"x\": { \"Hash\": \"x\", \"Type\": \"Number\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Subtract {{Name:a}} and {{Name:b}}, storing the value in {{Name:x}}.\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:x}} = {{InputValue:a}} - {{InputValue:b}} = {{OutputValue:x}}\"\t\t\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"Math\",\n\t\t\t\"Instruction\": \"subtract\"\n\t\t}\n\t]\n}","module.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"PreciseMath\",\n\t\t\"Operation\": \"Add\",\n\t\t\"Synopsis\": \"Precisely add two numbers:  x = a + b\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"a\": { \"Hash\": \"a\", \"Type\": \"Number\" },\n\t\t\"b\": { \"Hash\": \"b\", \"Type\": \"Number\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"x\": { \"Hash\": \"x\", \"Type\": \"Number\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Add {{Name:a}} and {{Name:b}}, storing the value in {{Name:x}}.\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:x}} = {{InputValue:a}} + {{InputValue:b}} = {{OutputValue:x}}\"\t\t\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"PreciseMath\",\n\t\t\t\"Instruction\": \"add\"\n\t\t}\n\t]\n}","module.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"PreciseMath\",\n\t\t\"Operation\": \"Aggregate\",\n\t\t\"Synopsis\": \"Precisely aggregate a set of numbers (from array or object address):  x = a + b + ... + z\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"a\": { \"Hash\": \"a\", \"Type\": \"Set\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"x\": { \"Hash\": \"x\", \"Type\": \"Number\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Aggregate all numeric values in {{Name:a}}, storing the resultant in {{Name:x}}.\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:x}} = {{OutputValue:x}}\"\t\t\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"PreciseMath\",\n\t\t\t\"Instruction\": \"aggregate\"\n\t\t}\n\t]\n}","module.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"PreciseMath\",\n\t\t\"Operation\": \"Divide\",\n\t\t\"Synopsis\": \"Precisely divide two numbers:  x = a / b\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"a\": { \"Hash\": \"a\", \"Type\": \"Number\" },\n\t\t\"b\": { \"Hash\": \"b\", \"Type\": \"Number\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"x\": { \"Hash\": \"x\", \"Type\": \"Number\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Divide {{Name:a}} over {{Name:b}}, storing the value in {{Name:x}}.\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:x}} = {{InputValue:a}} / {{InputValue:b}} = {{OutputValue:x}}\"\t\t\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"PreciseMath\",\n\t\t\t\"Instruction\": \"divide\"\n\t\t}\n\t]\n}","module.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"PreciseMath\",\n\t\t\"Operation\": \"GroupValuesAndAggregate\",\n\t\t\"Synopsis\": \"Group values in a set and aggregate the set of numbers (from array or object addresses)\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"inputDataSet\": { \"Hash\":\"inputDataSet\", \"Type\":\"Set\" },\n\t\t\"groupByProperty\": { \"Hash\":\"groupByProperty\", \"Type\":\"Any\"},\n\t\t\"groupValueProperty\": { \"Hash\":\"groupValueProperty\", \"Type\":\"Any\"},\n\t\t\"recordIndicatorProperty\": { \"Hash\":\"recordIndicatorProperty\", \"Type\":\"String\", \"Default\":false}\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"outputDataSet\": { \"Hash\": \"outputDataSet\", \"Type\": \"Set\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Group {{Name:inputDataSet}} by {{Name:groupByProperty}} and create a map, storing the resultant in {{Name:outputDataSet}}.\",\n\t\t\"PostOperation\": \"Operation complete: Grouping {{Name:inputDataSet}} by {{Name:groupByProperty}} into aggregated values in {{Name:outputDataSet}}\"\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"PreciseMath\",\n\t\t\t\"Instruction\": \"groupvaluesandaggregate\"\n\t\t}\n\t]\n}","module.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"PreciseMath\",\n\t\t\"Operation\": \"Multiply\",\n\t\t\"Synopsis\": \"Precisely multiply two numbers:  x = a * b\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"a\": { \"Hash\": \"a\", \"Type\": \"Number\" },\n\t\t\"b\": { \"Hash\": \"b\", \"Type\": \"Number\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"x\": { \"Hash\": \"x\", \"Type\": \"Number\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Multiply {{Name:a}} and {{Name:b}}, storing the value in {{Name:x}}.\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:x}} = {{InputValue:a}} * {{InputValue:b}} = {{OutputValue:x}}\"\t\t\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"PreciseMath\",\n\t\t\t\"Instruction\": \"multiply\"\n\t\t}\n\t]\n}","module.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"PreciseMath\",\n\t\t\"Operation\": \"Round\",\n\t\t\"Synopsis\": \"Precisely round a number.\"\n\t},\n\n\t\"Inputs\":\n\t{\n\t\t\"a\": { \"Hash\": \"a\", \"Type\": \"Number\" },\n\t\t\"precision\": { \"Hash\": \"precision\", \"Type\": \"Number\" },\n\t\t\"roundingmode\": { \"Hash\": \"roundingmode\", \"Type\":\"String\" }\n\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"x\": { \"Hash\": \"x\", \"Type\": \"Number\" }\n\t},\n\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Round {{Name:a}}, storing the value in {{Name:x}}.\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:x}} = Round({{InputValue:a}}) = {{OutputValue:x}}\"\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"PreciseMath\",\n\t\t\t\"Instruction\": \"round\"\n\t\t}\n\t]\n}","module.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"PreciseMath\",\n\t\t\"Operation\": \"SetPrecision\",\n\t\t\"Synopsis\": \"Set the precision.\"\n\t},\n\n\t\"Inputs\":\n\t{\n\t\t\"precision\": { \"Hash\": \"precision\", \"Type\":\"Number\", \"Default\":2}\n\n\t},\n\n\t\"Outputs\":\n\t{\n\t},\n\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Set precision to {{InputValue:precision}}.\",\n\t\t\"PostOperation\": \"Operation complete: Default precision set to {{InputValue:precision}}.\"\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"PreciseMath\",\n\t\t\t\"Instruction\": \"setprecision\"\n\t\t}\n\t]\n}","module.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"PreciseMath\",\n\t\t\"Operation\": \"SetRoundingMode\",\n\t\t\"Synopsis\": \"Set the rounding mode.\"\n\t},\n\n\t\"Inputs\":\n\t{\n\t\t\"roundingmode\": { \"Hash\": \"roundingmode\", \"Type\":\"String\", \"Default\":\"ROUND_HALF_UP\"}\n\n\t},\n\n\t\"Outputs\":\n\t{\n\t},\n\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Set rounding mode to {{InputValue:roundingmode}}.\",\n\t\t\"PostOperation\": \"Operation complete: Default rounding mode set to {{InputValue:roundingmode}}.\"\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"PreciseMath\",\n\t\t\t\"Instruction\": \"setroundingmode\"\n\t\t}\n\t]\n}","module.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"PreciseMath\",\n\t\t\"Operation\": \"Subtract\",\n\t\t\"Synopsis\": \"Precisely subtract two numbers:  x = a - b\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"a\": { \"Hash\": \"a\", \"Type\": \"Number\" },\n\t\t\"b\": { \"Hash\": \"b\", \"Type\": \"Number\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"x\": { \"Hash\": \"x\", \"Type\": \"Number\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Subtract {{Name:a}} and {{Name:b}}, storing the value in {{Name:x}}.\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:x}} = {{InputValue:a}} - {{InputValue:b}} = {{OutputValue:x}}\"\t\t\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"PreciseMath\",\n\t\t\t\"Instruction\": \"subtract\"\n\t\t}\n\t]\n}","module.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"PreciseMath\",\n\t\t\"Operation\": \"ToDecimalPlaces\",\n\t\t\"Synopsis\": \"Precisely round a number to a certain number of decimal places.\"\n\t},\n\n\t\"Inputs\":\n\t{\n\t\t\"a\": { \"Hash\": \"a\", \"Type\": \"Number\" },\n\t\t\"decimalplaces\": { \"Hash\": \"decimalplaces\", \"Type\": \"Number\", \"Default\":2 },\n\t\t\"roundingmode\": { \"Hash\": \"roundingmode\", \"Type\":\"String\" }\n\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"x\": { \"Hash\": \"x\", \"Type\": \"Number\" }\n\t},\n\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Round {{Name:a}} to {{Value:decimalplaces}} decimal places, storing the value in {{Name:x}}.\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:x}} = Round({{InputValue:a}} TO {{Value:decimalplaces}} decimal places) = {{OutputValue:x}}\"\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"PreciseMath\",\n\t\t\t\"Instruction\": \"todecimalplaces\"\n\t\t}\n\t]\n}","module.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"PreciseMath\",\n\t\t\"Operation\": \"ToSignificantDigits\",\n\t\t\"Synopsis\": \"Precisely round a number to a specific number of significant digits.\"\n\t},\n\n\t\"Inputs\":\n\t{\n\t\t\"a\": { \"Hash\": \"a\", \"Type\": \"Number\" },\n\t\t\"digits\": { \"Hash\": \"digits\", \"Type\": \"Number\", \"Default\":12 },\n\t\t\"roundingmode\": { \"Hash\": \"roundingmode\", \"Type\":\"String\" }\n\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"x\": { \"Hash\": \"x\", \"Type\": \"Number\" }\n\t},\n\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Round {{Name:a}} to {{InputValue:digits}}, storing the value in {{Name:x}}.\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:x}} = Round({{InputValue:a}} TO {{InputValue:digits}}) = {{OutputValue:x}}\"\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"PreciseMath\",\n\t\t\t\"Instruction\": \"tosignificantdigits\"\n\t\t}\n\t]\n}","module.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"Set\",\n\t\t\"Operation\": \"GroupValuesBy\",\n\t\t\"Synopsis\": \"Group set of Sub object values by another property in the objects.\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"inputDataSet\": { \"Hash\":\"inputDataSet\", \"Type\":\"Set\" },\n\t\t\"groupByProperty\": { \"Hash\":\"groupByProperty\", \"Type\":\"Any\"},\n\t\t\"groupValueProperty\": { \"Hash\":\"groupValueProperty\", \"Type\":\"Any\"}\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"outputDataSet\": { \"Hash\": \"outputDataSet\", \"Type\": \"Set\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Group {{Name:inputDataSet}} by {{Name:groupByProperty}} and create a mapped result set into {{Name:outputDataSet}}.\",\n\t\t\"PostOperation\": \"Operation complete: Grouping {{Name:inputDataSet}} by {{Name:groupByProperty}} into {{Name:outputDataSet}}\"\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"Set\",\n\t\t\t\"Instruction\": \"GroupValuesBy\"\n\t\t}\n\t]\n}","module.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"String\",\n\t\t\"Operation\": \"Replace\",\n\t\t\"Synopsis\": \"Replace all instances of searchFor with replaceWith in inputString\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"inputString\": { \"Hash\": \"inputString\", \"Type\": \"String\" },\n\t\t\"searchFor\": { \"Hash\": \"searchFor\", \"Type\": \"String\" },\n\t\t\"replaceWith\": { \"Hash\": \"replaceWith\", \"Type\": \"String\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"outputString\": { \"Hash\": \"outputString\", \"Type\": \"String\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Search for [{{InputValue:searchFor}}] and replace it with [{{InputValue:replaceWith}}] in [{{InputValue:inputString}}].\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:outputString}} = [{{OutputValue:outputString}}] from [{{InputValue:inputString}}] replacing [{{InputValue:searchFor}}] with [{{InputValue:replaceWith}}].\"\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"String\",\n\t\t\t\"Instruction\": \"replace\"\n\t\t}\n\t]\n}","module.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"String\",\n\t\t\"Operation\": \"Substring\",\n\t\t\"Synopsis\": \"Get all characters between indexStart and indexEnd (optional) for a given inputString.\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"inputString\": { \"Hash\": \"inputString\", \"Type\": \"String\" },\n\t\t\"indexStart\": { \"Hash\": \"indexStart\", \"Type\": \"Number\", \"Default\":0 },\n\t\t\"indexEnd\": { \"Hash\": \"indexEnd\", \"Type\": \"String\", \"Default\":null }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"outputString\": { \"Hash\": \"outputString\", \"Type\": \"String\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Get all characters between {{InputValue:indexStart}} and {{InputValue:indexEnd}} in [{{InputValue:inputString}}].\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:outputString}} = [{{OutputValue:outputString}}] from [{{InputValue:inputString}}] between {{InputValue:indexStart}} and {{InputValue:indexEnd}}.\"\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"String\",\n\t\t\t\"Instruction\": \"substring\"\n\t\t}\n\t]\n}","module.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"String\",\n\t\t\"Operation\": \"Trim\",\n\t\t\"Synopsis\": \"Trim whitespace off the end of string in inputString, putting the result in outputString\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"inputString\": { \"Hash\": \"inputString\", \"Type\": \"String\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"outputString\": { \"Hash\": \"outputString\", \"Type\": \"String\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Trim the whitespace from value [{{InputValue:inputString}}].\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:outputString}} = [{{OutputValue:outputString}}] from [{{InputValue:inputString}}]\"\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"String\",\n\t\t\t\"Instruction\": \"trim\"\n\t\t}\n\t]\n}","let libElucidatorInstructionSet = require('../Elucidator-InstructionSet.js');\n\nconst libDecimal = require('decimal.js');\n\nlet add = (pOperation) =>\n{\n    // This could be done in one line, but, would be more difficult to comprehend.\n    let tmpA = new libDecimal(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'a'));\n    let tmpB = new libDecimal(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'b'));\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'x', tmpA.plus(tmpB).toString());\n    return true;\n};\n\nlet subtract = (pOperation) =>\n{\n    // This could be done in one line, but, would be more difficult to comprehend.\n    let tmpA = new libDecimal(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'a'));\n    let tmpB = new libDecimal(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'b'));\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'x', tmpA.sub(tmpB).toString());\n    return true;\n};\n\nlet multiply = (pOperation) =>\n{\n    // This could be done in one line, but, would be more difficult to comprehend.\n    let tmpA = new libDecimal(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'a'));\n    let tmpB = new libDecimal(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'b'));\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'x', tmpA.mul(tmpB).toString());\n    return true;\n};\n\nlet divide = (pOperation) =>\n{\n    // This could be done in one line, but, would be more difficult to comprehend.\n    let tmpA = new libDecimal(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'a'));\n    let tmpB = new libDecimal(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'b'));\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'x', tmpA.div(tmpB).toString());\n    return true;\n};\n\nlet round = (pOperation) =>\n{\n    let tmpA = new libDecimal(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'a'));\n\n    let tmpPrecision = parseInt(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'precision'));\n    let tmpRoundingMode = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'roundingmode')\n\n    // Eventually don't set this every time...\n    if (tmpRoundingMode)\n    {\n        switch (tmpRoundingMode.toString().toLowerCase())\n        {\n            case 'round_up':\n                libDecimal.set({ rounding: libDecimal.ROUND_UP });\n                break;\n            case 'round_down':\n                libDecimal.set({ rounding: libDecimal.ROUND_DOWN });\n                break;\n            case 'round_ceil':\n                libDecimal.set({ rounding: libDecimal.ROUND_CEIL });\n                break;\n            case 'round_floor':\n                libDecimal.set({ rounding: libDecimal.ROUND_FLOOR });\n                break;\n            default:\n            case 'round_half_up':\n                libDecimal.set({ rounding: libDecimal.ROUND_HALF_UP });\n                break;\n            case 'round_half_down':\n                libDecimal.set({ rounding: libDecimal.ROUND_HALF_DOWN });\n                break;\n            case 'round_half_even':\n                libDecimal.set({ rounding: libDecimal.ROUND_HALF_EVEN });\n                break;\n            case 'round_half_ceil':\n                libDecimal.set({ rounding: libDecimal.ROUND_HALF_CEIL });\n                break;\n            case 'round_half_floor':\n                libDecimal.set({ rounding: libDecimal.ROUND_HALF_FLOOR });\n                break;\n            case 'euclid':\n                libDecimal.set({ rounding: libDecimal.EUCLID });\n                break;\n        }\n    }\n    \n    if (!isNaN(tmpPrecision))\n    {\n        libDecimal.set({ precision: tmpPrecision });\n    }\n\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'x', libDecimal.round(tmpA).toString());\n};\n\n\nlet tosignificantdigits = (pOperation) =>\n{\n    let tmpA = new libDecimal(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'a'));\n\n    let tmpDigits = parseInt(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'digits'));\n    let tmpRoundingMode = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'roundingmode')\n\n    // Eventually don't set this every time...\n    if (tmpRoundingMode)\n    {\n        switch (tmpRoundingMode.toString().toLowerCase())\n        {\n            case 'round_up':\n                libDecimal.set({ rounding: libDecimal.ROUND_UP });\n                break;\n            case 'round_down':\n                libDecimal.set({ rounding: libDecimal.ROUND_DOWN });\n                break;\n            case 'round_ceil':\n                libDecimal.set({ rounding: libDecimal.ROUND_CEIL });\n                break;\n            case 'round_floor':\n                libDecimal.set({ rounding: libDecimal.ROUND_FLOOR });\n                break;\n            default:\n            case 'round_half_up':\n                libDecimal.set({ rounding: libDecimal.ROUND_HALF_UP });\n                break;\n            case 'round_half_down':\n                libDecimal.set({ rounding: libDecimal.ROUND_HALF_DOWN });\n                break;\n            case 'round_half_even':\n                libDecimal.set({ rounding: libDecimal.ROUND_HALF_EVEN });\n                break;\n            case 'round_half_ceil':\n                libDecimal.set({ rounding: libDecimal.ROUND_HALF_CEIL });\n                break;\n            case 'round_half_floor':\n                libDecimal.set({ rounding: libDecimal.ROUND_HALF_FLOOR });\n                break;\n            case 'euclid':\n                libDecimal.set({ rounding: libDecimal.EUCLID });\n                break;\n        }\n    }\n    \n    if (isNaN(tmpDigits))\n    {\n        tmpDigits = 12;\n    }\n\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'x', tmpA.toSignificantDigits(tmpDigits).toString());\n};\n\nlet todecimalplaces = (pOperation) =>\n{\n    let tmpA = new libDecimal(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'a'));\n\n    let tmpDecimalPlaces = parseInt(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'decimalplaces'));\n    let tmpRoundingMode = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'roundingmode')\n\n    // Eventually don't set this every time...\n    if (tmpRoundingMode)\n    {\n        switch (tmpRoundingMode.toString().toLowerCase())\n        {\n            case 'round_up':\n                libDecimal.set({ rounding: libDecimal.ROUND_UP });\n                break;\n            case 'round_down':\n                libDecimal.set({ rounding: libDecimal.ROUND_DOWN });\n                break;\n            case 'round_ceil':\n                libDecimal.set({ rounding: libDecimal.ROUND_CEIL });\n                break;\n            case 'round_floor':\n                libDecimal.set({ rounding: libDecimal.ROUND_FLOOR });\n                break;\n            default:\n            case 'round_half_up':\n                libDecimal.set({ rounding: libDecimal.ROUND_HALF_UP });\n                break;\n            case 'round_half_down':\n                libDecimal.set({ rounding: libDecimal.ROUND_HALF_DOWN });\n                break;\n            case 'round_half_even':\n                libDecimal.set({ rounding: libDecimal.ROUND_HALF_EVEN });\n                break;\n            case 'round_half_ceil':\n                libDecimal.set({ rounding: libDecimal.ROUND_HALF_CEIL });\n                break;\n            case 'round_half_floor':\n                libDecimal.set({ rounding: libDecimal.ROUND_HALF_FLOOR });\n                break;\n            case 'euclid':\n                libDecimal.set({ rounding: libDecimal.EUCLID });\n                break;\n        }\n    }\n    \n    if (isNaN(tmpDecimalPlaces))\n    {\n        tmpDecimalPlaces = 2;\n    }\n\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'x', tmpA.toDecimalPlaces(tmpDecimalPlaces).toString());\n};\n\nlet setprecision = (pOperation) =>\n{\n    let tmpPrecision = parseInt(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'precision'));\n    \n    console.log(tmpPrecision)\n    if (!isNaN(tmpPrecision))\n    {\n        libDecimal.set({ precision: tmpPrecision });\n    }\n};\n\nlet setroundingmode = (pOperation) =>\n{\n    let tmpRoundingMode = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'roundingmode')\n\n    // Eventually don't set this every time...\n    if (tmpRoundingMode)\n    {\n        switch (tmpRoundingMode.toString().toLowerCase())\n        {\n            case 'round_up':\n                libDecimal.set({ rounding: libDecimal.ROUND_UP });\n                break;\n            case 'round_down':\n                libDecimal.set({ rounding: libDecimal.ROUND_DOWN });\n                break;\n            case 'round_ceil':\n                libDecimal.set({ rounding: libDecimal.ROUND_CEIL });\n                break;\n            case 'round_floor':\n                libDecimal.set({ rounding: libDecimal.ROUND_FLOOR });\n                break;\n            default:\n            case 'round_half_up':\n                libDecimal.set({ rounding: libDecimal.ROUND_HALF_UP });\n                break;\n            case 'round_half_down':\n                libDecimal.set({ rounding: libDecimal.ROUND_HALF_DOWN });\n                break;\n            case 'round_half_even':\n                libDecimal.set({ rounding: libDecimal.ROUND_HALF_EVEN });\n                break;\n            case 'round_half_ceil':\n                libDecimal.set({ rounding: libDecimal.ROUND_HALF_CEIL });\n                break;\n            case 'round_half_floor':\n                libDecimal.set({ rounding: libDecimal.ROUND_HALF_FLOOR });\n                break;\n            case 'euclid':\n                libDecimal.set({ rounding: libDecimal.EUCLID });\n                break;\n        }\n    }\n};\n\nlet aggregate = (pOperation) =>\n{\n    let tmpA = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'a');\n\n    let tmpObjectType = typeof(tmpA);\n\n    let tmpAggregationValue = new libDecimal(0);\n\n    if (tmpObjectType == 'object')\n    {\n        if (Array.isArray(tmpA))\n        {\n            for (let i = 0; i < tmpA.length; i++)\n            {\n                // If this is an array, enumerate it and try to aggregate each number\n                let tmpValue = new libDecimal(tmpA[i]);\n\n                if (isNaN(tmpValue))\n                {\n                    pOperation.logError(`Array element index [${i}] could not be parsed as a number by Decimal.js; skipping.  (${tmpA[i]})`);\n                }\n                else\n                {\n                    tmpAggregationValue = tmpAggregationValue.plus(tmpValue);\n                    pOperation.logInfo(`Adding element [${i}] value ${tmpValue} totaling: ${tmpAggregationValue}`)\n                }\n            }\n        }\n        else\n        {\n            let tmpObjectKeys = Object.keys(tmpA);\n            for (let i = 0; i < tmpObjectKeys.length; i++)\n            {\n                let tmpValue = new libDecimal(tmpA[tmpObjectKeys[i]]);\n\n                if (isNaN(tmpValue))\n                {\n                    pOperation.logError(`Object property [${tmpObjectKeys[i]}] could not be parsed as a number; skipping.  (${tmpA[tmpObjectKeys[i]]})`);\n                }\n                else\n                {\n                    tmpAggregationValue = tmpAggregationValue.plus(tmpValue);\n                    pOperation.logInfo(`Adding object property [${tmpObjectKeys[i]}] value ${tmpValue} totaling: ${tmpAggregationValue}`)\n                }\n            }\n        }\n    }\n    else\n    {\n        let tmpValue = new libDecimal(tmpA);\n\n        if (isNaN(tmpValue))\n        {\n            pOperation.logError(`Direct value could not be parsed as a number; skipping.  (${tmpA})`);\n        }\n        else\n        {\n            tmpAggregationValue = tmpValue;\n        }\n    }\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'x', tmpAggregationValue.toString());\n    return true;\n};\n\nconst groupValuesAndAggregate = (pOperation) =>\n{\n    let tmpInputDataSet = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'inputDataSet');\n    let tmpGroupByProperty = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'groupByProperty');\n    let tmpGroupValueProperty = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'groupValueProperty');\n\n    let tmpOutputDataSet = {};\n    let tmpProcessedOutputDataSet = {};\n \n    let tmpObjectType = typeof(tmpInputDataSet);\n\n    if (tmpObjectType == 'object')\n    {\n        if (Array.isArray(tmpInputDataSet))\n        {\n            for (let i = 0; i < tmpInputDataSet.length; i++)\n            {\n                if (typeof(tmpInputDataSet[i]) !== 'object')\n                {\n                    pOperation.logInfo(`Element [${i}] was not an object; skipping group operation.`);\n                }\n                else\n                {\n                    let tmpValue = tmpInputDataSet[i];\n                    let tmpGroupByValue = tmpValue[tmpGroupByProperty];\n                    if (!tmpValue.hasOwnProperty(tmpGroupByProperty))\n                    {\n                        pOperation.logInfo(`Element [${i}] doesn't have the group by property [${tmpGroupByProperty}]; setting group to [__NO_GROUP].`);\n                        tmpGroupByValue = '__NO_GROUP';\n                    }\n\n                    if (!tmpValue.hasOwnProperty(tmpGroupValueProperty))\n                    {\n                        pOperation.logInfo(`Element [${i}] doesn't have the group value property [${tmpGroupValueProperty}]; skipping group operation.`);\n                    }\n                    else\n                    {\n                        let tmpDecimalValue = new libDecimal(tmpValue[tmpGroupValueProperty]);\n\n                        if (isNaN(tmpDecimalValue))\n                        {\n                            pOperation.logError(`Object property [${i}] could not be parsed as a number; skipping.  (${tmpValue[tmpGroupValueProperty]})`);\n                        }\n                        else\n                        {\n                            if (!tmpOutputDataSet.hasOwnProperty(tmpGroupByValue))\n                            {\n                                tmpOutputDataSet[tmpGroupByValue] = tmpDecimalValue;\n                            }\n                            else\n                            {\n                                tmpOutputDataSet[tmpGroupByValue] = tmpOutputDataSet[tmpGroupByValue].plus(tmpDecimalValue);\n                            }\n                            pOperation.logInfo(`Adding object property [${i}] value ${tmpDecimalValue} totaling: ${tmpOutputDataSet[tmpGroupByValue]}`)\n                        }\n                    }\n                }\n            }\n        }\n        else\n        {\n            let tmpObjectKeys = Object.keys(tmpInputDataSet);\n            for (let i = 0; i < tmpObjectKeys.length; i++)\n            {\n                if (typeof(tmpInputDataSet[tmpObjectKeys[i]]) !== 'object')\n                {\n                    pOperation.logInfo(`Element [${i}] was not an object; skipping group operation.`);\n                }\n                else\n                {\n                    let tmpValue = tmpInputDataSet[tmpObjectKeys[i]];\n                    let tmpGroupByValue = tmpValue[tmpGroupByProperty];\n                    if (!tmpValue.hasOwnProperty(tmpGroupByProperty))\n                    {\n                        pOperation.logInfo(`Element [${tmpObjectKeys[i]}][${i}] doesn't have the group by property [${tmpGroupByProperty}]; setting group to [__NO_GROUP].`);\n                        tmpGroupByValue = '__NO_GROUP';\n                    }\n\n                    if (!tmpValue.hasOwnProperty(tmpGroupValueProperty))\n                    {\n                        pOperation.logInfo(`Element [${tmpObjectKeys[i]}][${i}] doesn't have the group value property [${tmpGroupValueProperty}]; skipping group operation.`);\n                    }\n                    else\n                    {\n                        let tmpDecimalValue = new libDecimal(tmpValue[tmpGroupValueProperty]);\n\n                        if (isNaN(tmpDecimalValue))\n                        {\n                            pOperation.logError(`Object property [${tmpObjectKeys[i]}][${i}] to group ${tmpGroupByValue} could not be parsed as a number; skipping.  (${tmpValue[tmpGroupValueProperty]})`);\n                        }\n                        else\n                        {\n                            if (!tmpOutputDataSet.hasOwnProperty(tmpGroupByValue))\n                            {\n                                tmpOutputDataSet[tmpGroupByValue] = tmpDecimalValue;\n                            }\n                            else\n                            {\n                                tmpOutputDataSet[tmpGroupByValue] = tmpOutputDataSet[tmpGroupByValue].plus(tmpDecimalValue);\n                            }\n                            pOperation.logInfo(`Adding object property [${tmpObjectKeys[i]}][${i}] to group ${tmpGroupByValue} value ${tmpDecimalValue} totaling: ${tmpOutputDataSet[tmpGroupByValue]}`)\n                        }\n                    }\n                }\n            }\n        }\n\n        // Now marshal the aggregated values\n        let tmpOutputGroups = Object.keys(tmpOutputDataSet);\n        for (let j = 0; j < tmpOutputGroups.length; j++)\n        {\n            tmpProcessedOutputDataSet[tmpOutputGroups[j]] = tmpOutputDataSet[tmpOutputGroups[j]].toString();\n        }\n    }\n    else\n    {\n        pOperation.logError(`Input set is neither an Array nor an Object`);\n    }\n\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'outputDataSet', tmpProcessedOutputDataSet);\n\n    return true;\n}\n\nlet toFraction = (pOperation) =>\n{\n    // This could be done in one line, but, would be more difficult to comprehend.\n    let tmpA = new libDecimal(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'a'));\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'x', tmpA.toFraction().toString());\n    return true;\n};\n\n\nclass PreciseMath extends libElucidatorInstructionSet\n{\n    constructor(pElucidator)\n    {\n        super(pElucidator);\n        this.namespace = 'PreciseMath';\n    }\n\n    initializeInstructions()\n    {\n        this.addInstruction('add', add);\n\n        this.addInstruction('subtract', subtract);\n        this.addInstruction('sub', subtract);\n\n        this.addInstruction('multiply', multiply);\n        this.addInstruction('mul', multiply);\n\n        this.addInstruction('divide', divide);\n        this.addInstruction('div', divide);\n\n        this.addInstruction('aggregate', aggregate);\n        this.addInstruction('groupvaluesandaggregate', groupValuesAndAggregate);\n\n        this.addInstruction('setprecision', setprecision);\n        this.addInstruction('setroundingmode', setroundingmode);\n\n        this.addInstruction('todecimalplaces', todecimalplaces);\n        this.addInstruction('tosignificantdigits', tosignificantdigits);\n        this.addInstruction('round', round);\n        this.addInstruction('tofraction', toFraction);\n\n\n        return true;\n    }\n\n    initializeOperations()\n    {\n        this.addOperation('add', require(`./Operations/PreciseMath-Add.json`));\n        this.addOperation('subtract', require(`./Operations/PreciseMath-Subtract.json`));\n        this.addOperation('multiply', require(`./Operations/PreciseMath-Multiply.json`));\n        this.addOperation('divide', require(`./Operations/PreciseMath-Divide.json`));\n\n        this.addOperation('aggregate', require('./Operations/PreciseMath-Aggregate.json'));\n        this.addOperation('groupvaluesandaggregate', require('./Operations/PreciseMath-GroupValuesAndAggregate.json'));\n\n        this.addOperation('setprecision', require('./Operations/PreciseMath-SetPrecision.json'));\n        this.addOperation('setroundingmode', require('./Operations/PreciseMath-SetRoundingMode.json'));\n\n        this.addOperation('tosignificantdigits', require('./Operations/PreciseMath-ToSignificantDigits.json'));\n        this.addOperation('todecimalplaces', require('./Operations/PreciseMath-ToDecimalPlaces.json'));\n        this.addOperation('round', require('./Operations/PreciseMath-Round.json'));\n\n        return true;\n    }\n}\n\nmodule.exports = PreciseMath;","// Solution providers are meant to be stateless, and not classes.\n// These solution providers are akin to drivers, connecting code libraries or \n// other types of behavior to mapping operations.\n\nlet libElucidatorInstructionSet = require('../Elucidator-InstructionSet.js');\n\nconst groupValuesBy = (pOperation) =>\n{\n    let tmpInputDataSet = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'inputDataSet');\n    let tmpGroupByProperty = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'groupByProperty');\n    let tmpGroupValueProperty = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'groupValueProperty');\n\n    let tmpOutputDataSet = {};\n \n    let tmpObjectType = typeof(tmpInputDataSet);\n\n    if (tmpObjectType == 'object')\n    {\n        if (Array.isArray(tmpInputDataSet))\n        {\n            for (let i = 0; i < tmpInputDataSet.length; i++)\n            {\n                if (typeof(tmpInputDataSet[i]) !== 'object')\n                {\n                    pOperation.logInfo(`Element [${i}] was not an object; skipping group operation.`);\n                }\n                else\n                {\n                    let tmpValue = tmpInputDataSet[i];\n                    let tmpGroupByValue = tmpValue[tmpGroupByProperty];\n                    if (!tmpValue.hasOwnProperty(tmpGroupByProperty))\n                    {\n                        pOperation.logInfo(`Element [${i}] doesn't have the group by property [${tmpGroupByProperty}]; setting group to [__NO_GROUP].`);\n                        tmpGroupByValue = '__NO_GROUP';\n                    }\n\n                    if (!tmpValue.hasOwnProperty(tmpGroupValueProperty))\n                    {\n                        pOperation.logInfo(`Element [${i}] doesn't have the group value property [${tmpGroupValueProperty}]; skipping group operation.`);\n                    }\n                    else\n                    {\n                        if (!tmpOutputDataSet.hasOwnProperty(tmpGroupByValue))\n                        {\n                            // Create a new grouped value\n                            pOperation.logInfo(`Creating a new group [${tmpGroupByValue}] for element [${i}].`);\n                            tmpOutputDataSet[tmpGroupByValue] = [];\n                        }\n\n                        tmpOutputDataSet[tmpGroupByValue].push(tmpValue[tmpGroupValueProperty]);\n                    }\n                }\n            }\n        }\n        else\n        {\n            let tmpObjectKeys = Object.keys(tmpInputDataSet);\n            for (let i = 0; i < tmpObjectKeys.length; i++)\n            {\n                if (typeof(tmpInputDataSet[tmpObjectKeys[i]]) !== 'object')\n                {\n                    pOperation.logInfo(`Element [${i}] was not an object; skipping group operation.`);\n                }\n                else\n                {\n                    let tmpValue = tmpInputDataSet[tmpObjectKeys[i]];\n                    let tmpGroupByValue = tmpValue[tmpGroupByProperty];\n                    if (!tmpValue.hasOwnProperty(tmpGroupByProperty))\n                    {\n                        pOperation.logInfo(`Element [${tmpObjectKeys[i]}][${i}] doesn't have the group by property [${tmpGroupByProperty}]; setting group to [__NO_GROUP].`);\n                        tmpGroupByValue = '__NO_GROUP';\n                    }\n\n                    if (!tmpValue.hasOwnProperty(tmpGroupValueProperty))\n                    {\n                        pOperation.logInfo(`Element [${tmpObjectKeys[i]}][${i}] doesn't have the group value property [${tmpGroupValueProperty}]; skipping group operation.`);\n                    }\n                    else\n                    {\n                        if (!tmpOutputDataSet.hasOwnProperty(tmpGroupByValue))\n                        {\n                            // Create a new grouped value\n                            pOperation.logInfo(`Creating a new group [${tmpGroupByValue}] for element [${tmpObjectKeys[i]}][${i}].`);\n                            tmpOutputDataSet[tmpGroupByValue] = [];\n                        }\n\n                        tmpOutputDataSet[tmpGroupByValue].push(tmpValue[tmpGroupValueProperty]);\n                    }\n                }\n            }\n        }\n    }\n    else\n    {\n        pOperation.logError(`Input set is neither an Array nor an Object`);\n    }\n\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'outputDataSet', tmpOutputDataSet);\n\n    return true;\n}\n\nclass Set extends libElucidatorInstructionSet\n{\n    constructor(pElucidator)\n    {\n        super(pElucidator);\n        this.namespace = 'Set';\n    }\n\n    initializeInstructions()\n    {\n        // Logic actually wants a noop instruction!\n        super.initializeInstructions();\n\n        this.addInstruction('groupvaluesby', groupValuesBy);\n\n        return true;\n    }\n\n    initializeOperations()\n    {\n        this.addOperation('groupvaluesby', require(`./Operations/Set-GroupValuesBy.json`));\n\n        return true;\n    }\n}\n\nmodule.exports = Set;","// Solution providers are meant to be stateless, and not classes.\n// These solution providers are akin to drivers, connecting code libraries or \n// other types of behavior to mapping operations.\n\nlet libElucidatorInstructionSet = require('../Elucidator-InstructionSet.js');\n\nlet trim = (pOperation) =>\n{\n    let tmpInputString = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'inputString');\n\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'outputString', tmpInputString.trim());\n\n    return true;\n};\n\nlet replace = (pOperation) =>\n{\n    let tmpInputString = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'inputString');\n    let tmpSearchFor = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'searchFor');\n    let tmpReplaceWith = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'replaceWith');\n\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'outputString', tmpInputString.replace(tmpSearchFor, tmpReplaceWith));\n\n    return true;\n};\n\nlet substring = (pOperation) =>\n{\n    let tmpInputString = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'inputString');\n    let indexStart = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'indexStart');\n    let indexEnd = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'indexEnd');\n\n    if (indexEnd != null)\n    {\n        pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'outputString', tmpInputString.substring(indexStart, indexEnd));\n    }\n    else\n    {\n        pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'outputString', tmpInputString.substring(indexStart));\n    }\n\n    return true;\n};\n\nclass StringOperations extends libElucidatorInstructionSet\n{\n    constructor(pElucidator)\n    {\n        super(pElucidator);\n        this.namespace = 'String';\n    }\n\n    initializeInstructions()\n    {\n        this.addInstruction('trim', trim);\n        this.addInstruction('replace', replace);\n        this.addInstruction('substring', substring);\n\n        return true;\n    }\n\n    initializeOperations()\n    {\n        this.addOperation('trim', require(`./Operations/String-Trim.json`));\n        this.addOperation('replace', require(`./Operations/String-Replace.json`));\n        this.addOperation('substring', require(`./Operations/String-Substring.json`));\n\n        return true;\n    }\n}\n\nmodule.exports = StringOperations;","// When a boxed property is passed in, it should have quotes of some\n// kind around it.\n//\n// For instance:\n// \t\tMyValues['Name']\n// \t\tMyValues[\"Age\"]\n// \t\tMyValues[`Cost`]\n//\n// This function removes the wrapping quotes.\n//\n// Please note it *DOES NOT PARSE* template literals, so backticks just\n// end up doing the same thing as other quote types.\n//\n// TODO: Should template literals be processed?  If so what state do they have access to?  That should happen here if so.\n// TODO: Make a simple class include library with these\nlet cleanWrapCharacters = (pCharacter, pString) =>\n{\n\tif (pString.startsWith(pCharacter) && pString.endsWith(pCharacter))\n\t{\n\t\treturn pString.substring(1, pString.length - 1);\n\t}\n\telse\n\t{\n\t\treturn pString;\n\t}\n};\n\nmodule.exports = cleanWrapCharacters;","/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\nlet libSimpleLog = require('./Manyfest-LogToConsole.js');\n\n/**\n* Hash Translation\n*\n* This is a very simple translation table for hashes, which allows the same schema to resolve\n* differently based on a loaded translation table.\n*\n* This is to prevent the requirement for mutating schemas over and over again when we want to\n* reuse the structure but look up data elements by different addresses.\n*\n* One side-effect of this is that a translation table can \"override\" the built-in hashes, since\n* this is always used to resolve hashes before any of the functionCallByHash(pHash, ...) perform\n* their lookups by hash.\n*\n* @class ManyfestHashTranslation\n*/\nclass ManyfestHashTranslation\n{\n\tconstructor(pInfoLog, pErrorLog)\n\t{\n\t\t// Wire in logging\n\t\tthis.logInfo = (typeof(pInfoLog) === 'function') ? pInfoLog : libSimpleLog;\n\t\tthis.logError = (typeof(pErrorLog) === 'function') ? pErrorLog : libSimpleLog;\n\n        this.translationTable = {};\n\t}\n\n    translationCount()\n    {\n        return Object.keys(this.translationTable).length;\n    }\n\n    addTranslation(pTranslation)\n    {\n        // This adds a translation in the form of:\n        // { \"SourceHash\": \"DestinationHash\", \"SecondSourceHash\":\"SecondDestinationHash\" }\n        if (typeof(pTranslation) != 'object')\n        {\n            this.logError(`Hash translation addTranslation expected a translation be type object but was passed in ${typeof(pTranslation)}`);\n            return false;\n        }\n\n        let tmpTranslationSources = Object.keys(pTranslation)\n\n        tmpTranslationSources.forEach(\n            (pTranslationSource) =>\n            {\n                if (typeof(pTranslation[pTranslationSource]) != 'string')\n                {\n                    this.logError(`Hash translation addTranslation expected a translation destination hash for [${pTranslationSource}] to be a string but the referrant was a ${typeof(pTranslation[pTranslationSource])}`);\n                }\n                else\n                {\n                    this.translationTable[pTranslationSource] = pTranslation[pTranslationSource];\n                }\n            });\n    }\n\n    removeTranslationHash(pTranslationHash)\n    {\n        if (this.translationTable.hasOwnProperty(pTranslationHash))\n        {\n            delete this.translationTable[pTranslationHash];\n        }\n    }\n\n    // This removes translations.\n    // If passed a string, just removes the single one.\n    // If passed an object, it does all the source keys.\n    removeTranslation(pTranslation)\n    {\n        if (typeof(pTranslation) == 'string')\n        {\n            this.removeTranslationHash(pTranslation);\n            return true;\n        }\n        else if (typeof(pTranslation) == 'object')\n        {\n            let tmpTranslationSources = Object.keys(pTranslation)\n\n            tmpTranslationSources.forEach(\n                (pTranslationSource) =>\n                {\n                    this.removeTranslation(pTranslationSource);\n                });\n            return true;\n        }\n        else\n        {\n            this.logError(`Hash translation removeTranslation expected either a string or an object but the passed-in translation was type ${typeof(pTranslation)}`);\n            return false;\n        }\n    }\n\n    clearTranslations()\n    {\n        this.translationTable = {};\n    }\n\n    translate(pTranslation)\n    {\n        if (this.translationTable.hasOwnProperty(pTranslation))\n        {\n            return this.translationTable[pTranslation];\n        }\n        else\n        {\n            return pTranslation;\n        }\n    }\n}\n\nmodule.exports = ManyfestHashTranslation;","/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\n\n/**\n* Manyfest simple logging shim (for browser and dependency-free running)\n*/\n\nconst logToConsole = (pLogLine, pLogObject) =>\n{\n    let tmpLogLine = (typeof(pLogLine) === 'string') ? pLogLine : '';\n\n    console.log(`[Manyfest] ${tmpLogLine}`);\n\n    if (pLogObject) console.log(JSON.stringify(pLogObject));\n};\n\nmodule.exports = logToConsole;","/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\nlet libSimpleLog = require('./Manyfest-LogToConsole.js');\n\n/**\n* Object Address Resolver\n*\n* IMPORTANT NOTE: This code is intentionally more verbose than necessary, to\n*                 be extremely clear what is going on in the recursion for\n*                 each of the three address resolution functions.\n*\n*                 Although there is some opportunity to repeat ourselves a\n*                 bit less in this codebase (e.g. with detection of arrays\n*                 versus objects versus direct properties), it can make\n*                 debugging.. challenging.  The minified version of the code\n*                 optimizes out almost anything repeated in here.  So please\n*                 be kind and rewind... meaning please keep the codebase less\n*                 terse and more verbose so humans can comprehend it.\n*\n*\n* @class ManyfestObjectAddressResolverCheckAddressExists\n*/\nclass ManyfestObjectAddressResolverCheckAddressExists\n{\n\tconstructor(pInfoLog, pErrorLog)\n\t{\n\t\t// Wire in logging\n\t\tthis.logInfo = (typeof(pInfoLog) == 'function') ? pInfoLog : libSimpleLog;\n\t\tthis.logError = (typeof(pErrorLog) == 'function') ? pErrorLog : libSimpleLog;\n\n\t\tthis.elucidatorSolver = false;\n\t\tthis.elucidatorSolverState = {};\n\t}\n\n\t// Check if an address exists.\n\t//\n\t// This is necessary because the getValueAtAddress function is ambiguous on\n\t// whether the element/property is actually there or not (it returns\n\t// undefined whether the property exists or not).  This function checks for\n\t// existance and returns true or false dependent.\n\tcheckAddressExists (pObject, pAddress)\n\t{\n\t\t// TODO: Should these throw an error?\n\t\t// Make sure pObject is an object\n\t\tif (typeof(pObject) != 'object') return false;\n\t\t// Make sure pAddress is a string\n\t\tif (typeof(pAddress) != 'string') return false;\n\n\t\t// TODO: Make this work for things like SomeRootObject.Metadata[\"Some.People.Use.Bad.Object.Property.Names\"]\n\t\tlet tmpSeparatorIndex = pAddress.indexOf('.');\n\n\t\t// This is the terminal address string (no more dots so the RECUSION ENDS IN HERE somehow)\n\t\tif (tmpSeparatorIndex == -1)\n\t\t{\n\t\t\t// Check if the address refers to a boxed property\n\t\t\tlet tmpBracketStartIndex = pAddress.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = pAddress.indexOf(']');\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[10]\n\t\t\t// \t\tMyValues['Name']\n\t\t\t// \t\tMyValues[\"Age\"]\n\t\t\t// \t\tMyValues[`Cost`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpBracketStartIndex > 0)\n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex)\n\t\t\t//    3) There is data\n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 1))\n\t\t\t{\n\t\t\t\t// The \"Name\" of the Object contained too the left of the bracket\n\t\t\t\tlet tmpBoxedPropertyName = pAddress.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\t// If the subproperty doesn't test as a proper Object, none of the rest of this is possible.\n\t\t\t\t// This is a rare case where Arrays testing as Objects is useful\n\t\t\t\tif (typeof(pObject[tmpBoxedPropertyName]) !== 'object')\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// The \"Reference\" to the property within it, either an array element or object property\n\t\t\t\tlet tmpBoxedPropertyReference = pAddress.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\t\t\t\t// Attempt to parse the reference as a number, which will be used as an array element\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to treat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynamic object property.\n\t\t\t\t\t// We would expect the property to be wrapped in some kind of quotes so strip them\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\t// Check if the property exists.\n\t\t\t\t\treturn pObject[tmpBoxedPropertyName].hasOwnProperty(tmpBoxedPropertyReference);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Use the new in operator to see if the element is in the array\n\t\t\t\t\treturn (tmpBoxedPropertyNumber in pObject[tmpBoxedPropertyName]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Check if the property exists\n\t\t\t\treturn pObject.hasOwnProperty(pAddress);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlet tmpSubObjectName = pAddress.substring(0, tmpSeparatorIndex);\n\t\t\tlet tmpNewAddress = pAddress.substring(tmpSeparatorIndex+1);\n\n\t\t\t// Test if the tmpNewAddress is an array or object\n\t\t\t// Check if it's a boxed property\n\t\t\tlet tmpBracketStartIndex = tmpSubObjectName.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = tmpSubObjectName.indexOf(']');\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[42]\n\t\t\t// \t\tMyValues['Color']\n\t\t\t// \t\tMyValues[\"Weight\"]\n\t\t\t// \t\tMyValues[`Diameter`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpBracketStartIndex > 0)\n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex)\n\t\t\t//    3) There is data\n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 1))\n\t\t\t{\n\t\t\t\tlet tmpBoxedPropertyName = tmpSubObjectName.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyReference = tmpSubObjectName.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[1].Tardy\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an object, so the [1].Tardy is not possible to access\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[\"JaneDoe\"].Grade\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an array, so the [\"JaneDoe\"].Grade is not possible to access\n\t\t\t\t// TODO: Should this be an error or something?  Should we keep a log of failures like this?\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// Because this is an impossible address, the property doesn't exist\n\t\t\t\t\t// TODO: Should we throw an error in this condition?\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t//This is a bracketed value\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to reat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynanmic object property.\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\t// Recurse directly into the subobject\n\t\t\t\t\treturn this.checkAddressExists(pObject[tmpBoxedPropertyName][tmpBoxedPropertyReference], tmpNewAddress);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// We parsed a valid number out of the boxed property name, so recurse into the array\n\t\t\t\t\treturn this.checkAddressExists(pObject[tmpBoxedPropertyName][tmpBoxedPropertyNumber], tmpNewAddress);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If there is an object property already named for the sub object, but it isn't an object\n\t\t\t// then the system can't set the value in there.  Error and abort!\n\t\t\tif (pObject.hasOwnProperty(tmpSubObjectName) && typeof(pObject[tmpSubObjectName]) !== 'object')\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse if (pObject.hasOwnProperty(tmpSubObjectName))\n\t\t\t{\n\t\t\t\t// If there is already a subobject pass that to the recursive thingy\n\t\t\t\treturn this.checkAddressExists(pObject[tmpSubObjectName], tmpNewAddress);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Create a subobject and then pass that\n\t\t\t\tpObject[tmpSubObjectName] = {};\n\t\t\t\treturn this.checkAddressExists(pObject[tmpSubObjectName], tmpNewAddress);\n\t\t\t}\n\t\t}\n\t}\n};\n\nmodule.exports = ManyfestObjectAddressResolverCheckAddressExists;","/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\nlet libSimpleLog = require('./Manyfest-LogToConsole.js');\nlet libPrecedent = require('precedent');\nlet fCleanWrapCharacters = require('./Manyfest-CleanWrapCharacters.js');\n\n/**\n* Object Address Resolver - DeleteValue\n*\n* IMPORTANT NOTE: This code is intentionally more verbose than necessary, to\n*                 be extremely clear what is going on in the recursion for\n*                 each of the three address resolution functions.\n*\n*                 Although there is some opportunity to repeat ourselves a\n*                 bit less in this codebase (e.g. with detection of arrays\n*                 versus objects versus direct properties), it can make\n*                 debugging.. challenging.  The minified version of the code\n*                 optimizes out almost anything repeated in here.  So please\n*                 be kind and rewind... meaning please keep the codebase less\n*                 terse and more verbose so humans can comprehend it.\n*\n* TODO: Once we validate this pattern is good to go, break these out into\n*       three separate modules.\n*\n* @class ManyfestObjectAddressResolverDeleteValue\n*/\nclass ManyfestObjectAddressResolverDeleteValue\n{\n\tconstructor(pInfoLog, pErrorLog)\n\t{\n\t\t// Wire in logging\n\t\tthis.logInfo = (typeof(pInfoLog) == 'function') ? pInfoLog : libSimpleLog;\n\t\tthis.logError = (typeof(pErrorLog) == 'function') ? pErrorLog : libSimpleLog;\n\n\t\tthis.elucidatorSolver = false;\n\t\tthis.elucidatorSolverState = {};\n\n\t\tthis.cleanWrapCharacters = fCleanWrapCharacters;\n\t}\n\n\tcheckFilters(pAddress, pRecord)\n\t{\n\t\tlet tmpPrecedent = new libPrecedent();\n\t\t// If we don't copy the string, precedent takes it out for good.\n\t\t// TODO: Consider adding a \"don't replace\" option for precedent\n\t\tlet tmpAddress = pAddress;\n\n\t\tif (!this.elucidatorSolver)\n\t\t{\n\t\t\t// Again, manage against circular dependencies\n\t\t\tlet libElucidator = require('elucidator');\n\t\t\tthis.elucidatorSolver = new libElucidator({}, this.logInfo, this.logError);\n\t\t}\n\n\t\tif (this.elucidatorSolver)\n\t\t{\n\t\t\t// This allows the magic filtration with elucidator configuration\n\t\t\t// TODO: We could pass more state in (e.g. parent address, object, etc.)\n\t\t\t// TODO: Discuss this metaprogramming AT LENGTH\n\t\t\tlet tmpFilterState = (\n\t\t\t\t{\n\t\t\t\t\tRecord: pRecord,\n\t\t\t\t\tkeepRecord: true\n\t\t\t\t});\n\n\t\t\t// This is about as complex as it gets.\n\t\t\t// TODO: Optimize this so it is only initialized once.\n\t\t\t// TODO: That means figuring out a healthy pattern for passing in state to this\n\t\t\ttmpPrecedent.addPattern('<<~~', '~~>>',\n\t\t\t\t(pInstructionHash) =>\n\t\t\t\t{\n\t\t\t\t\t// This is for internal config on the solution steps.  Right now config is not shared across steps.\n\t\t\t\t\tif (this.elucidatorSolverState.hasOwnProperty(pInstructionHash))\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpFilterState.SolutionState = this.elucidatorSolverState[pInstructionHash];\n\t\t\t\t\t}\n\t\t\t\t\tthis.elucidatorSolver.solveInternalOperation('Custom', pInstructionHash, tmpFilterState);\n\t\t\t\t});\n\t\t\ttmpPrecedent.addPattern('<<~?', '?~>>',\n\t\t\t\t(pMagicSearchExpression) =>\n\t\t\t\t{\n\t\t\t\t\tif (typeof(pMagicSearchExpression) !== 'string')\n\t\t\t\t\t{\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\t// This expects a comma separated expression:\n\t\t\t\t\t//     Some.Address.In.The.Object,==,Search Term to Match\n\t\t\t\t\tlet tmpMagicComparisonPatternSet = pMagicSearchExpression.split(',');\n\n\t\t\t\t\tlet tmpSearchAddress = tmpMagicComparisonPatternSet[0];\n\t\t\t\t\tlet tmpSearchComparator = tmpMagicComparisonPatternSet[1];\n\t\t\t\t\tlet tmpSearchValue = tmpMagicComparisonPatternSet[2];\n\n\t\t\t\t\ttmpFilterState.ComparisonState = (\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tSearchAddress: tmpSearchAddress,\n\t\t\t\t\t\t\tComparator: tmpSearchComparator,\n\t\t\t\t\t\t\tSearchTerm: tmpSearchValue\n\t\t\t\t\t\t});\n\n\t\t\t\t\tthis.elucidatorSolver.solveOperation(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"Description\":\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"Operation\": \"Simple_If\",\n\t\t\t\t\t\t\t\t\"Synopsis\": \"Test for \"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"Steps\":\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\"Namespace\": \"Logic\",\n\t\t\t\t\t\t\t\t\t\"Instruction\": \"if\",\n\n\t\t\t\t\t\t\t\t\t\"InputHashAddressMap\":\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t// This is ... dynamically assigning the address in the instruction\n\t\t\t\t\t\t\t\t\t\t\t// The complexity is astounding.\n\t\t\t\t\t\t\t\t\t\t\t\"leftValue\": `Record.${tmpSearchAddress}`,\n\t\t\t\t\t\t\t\t\t\t\t\"rightValue\": \"ComparisonState.SearchTerm\",\n\t\t\t\t\t\t\t\t\t\t\t\"comparator\": \"ComparisonState.Comparator\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\"OutputHashAddressMap\": { \"truthinessResult\":\"keepRecord\" }\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t}, tmpFilterState);\n\t\t\t\t});\n\t\t\ttmpPrecedent.parseString(tmpAddress);\n\n\t\t\t// It is expected that the operation will mutate this to some truthy value\n\t\t\treturn tmpFilterState.keepRecord;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t// Delete the value of an element at an address\n\tdeleteValueAtAddress (pObject, pAddress, pParentAddress)\n\t{\n\t\t// Make sure pObject (the object we are meant to be recursing) is an object (which could be an array or object)\n\t\tif (typeof(pObject) != 'object') return undefined;\n\t\t// Make sure pAddress (the address we are resolving) is a string\n\t\tif (typeof(pAddress) != 'string') return undefined;\n\t\t// Stash the parent address for later resolution\n\t\tlet tmpParentAddress = \"\";\n\t\tif (typeof(pParentAddress) == 'string')\n\t\t{\n\t\t\ttmpParentAddress = pParentAddress;\n\t\t}\n\n\t\t// TODO: Make this work for things like SomeRootObject.Metadata[\"Some.People.Use.Bad.Object.Property.Names\"]\n\t\tlet tmpSeparatorIndex = pAddress.indexOf('.');\n\n\t\t// This is the terminal address string (no more dots so the RECUSION ENDS IN HERE somehow)\n\t\tif (tmpSeparatorIndex == -1)\n\t\t{\n\t\t\t// Check if the address refers to a boxed property\n\t\t\tlet tmpBracketStartIndex = pAddress.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = pAddress.indexOf(']');\n\n\t\t\t// Check for the Object Set Type marker.\n\t\t\t// Note this will not work with a bracket in the same address box set\n\t\t\tlet tmpObjectTypeMarkerIndex = pAddress.indexOf('{}');\n\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[10]\n\t\t\t// \t\tMyValues['Name']\n\t\t\t// \t\tMyValues[\"Age\"]\n\t\t\t// \t\tMyValues[`Cost`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpBracketStartIndex > 0)\n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex)\n\t\t\t//    3) There is data\n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 1))\n\t\t\t{\n\t\t\t\t// The \"Name\" of the Object contained too the left of the bracket\n\t\t\t\tlet tmpBoxedPropertyName = pAddress.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\t// If the subproperty doesn't test as a proper Object, none of the rest of this is possible.\n\t\t\t\t// This is a rare case where Arrays testing as Objects is useful\n\t\t\t\tif (typeof(pObject[tmpBoxedPropertyName]) !== 'object')\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// The \"Reference\" to the property within it, either an array element or object property\n\t\t\t\tlet tmpBoxedPropertyReference = pAddress.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\t\t\t\t// Attempt to parse the reference as a number, which will be used as an array element\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to treat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynamic object property.\n\t\t\t\t\t// We would expect the property to be wrapped in some kind of quotes so strip them\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\t// Return the value in the property\n\t\t\t\t\tdelete pObject[tmpBoxedPropertyName][tmpBoxedPropertyReference];\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdelete pObject[tmpBoxedPropertyName][tmpBoxedPropertyNumber];\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// The requirements to detect a boxed set element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\telse if ((tmpBracketStartIndex > 0)\n\t\t\t//    2) The end bracket is after the start bracket\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex)\n\t\t\t//    3) There is nothing in the brackets\n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex == 1))\n\t\t\t{\n\t\t\t\tlet tmpBoxedPropertyName = pAddress.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\tif (!Array.isArray(pObject[tmpBoxedPropertyName]))\n\t\t\t\t{\n\t\t\t\t\t// We asked for a set from an array but it isnt' an array.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tlet tmpInputArray = pObject[tmpBoxedPropertyName];\n\t\t\t\t// Count from the end to the beginning so splice doesn't %&%#$ up the array\n\t\t\t\tfor (let i = tmpInputArray.length - 1; i >= 0; i--)\n\t\t\t\t{\n\t\t\t\t\t// The filtering is complex but allows config-based metaprogramming directly from schema\n\t\t\t\t\tlet tmpKeepRecord = this.checkFilters(pAddress, tmpInputArray[i]);\n\t\t\t\t\tif (tmpKeepRecord)\n\t\t\t\t\t{\n\t\t\t\t\t\t// Delete elements end to beginning\n\t\t\t\t\t\ttmpInputArray.splice(i, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t// The object has been flagged as an object set, so treat it as such\n\t\t\telse if (tmpObjectTypeMarkerIndex > 0)\n\t\t\t{\n\t\t\t\tlet tmpObjectPropertyName = pAddress.substring(0, tmpObjectTypeMarkerIndex).trim();\n\n\t\t\t\tif (typeof(pObject[tmpObjectPropertyName]) != 'object')\n\t\t\t\t{\n\t\t\t\t\t// We asked for a set from an array but it isnt' an array.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tdelete pObject[tmpObjectPropertyName];\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Now is the point in recursion to return the value in the address\n\t\t\t\tdelete pObject[pAddress];\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlet tmpSubObjectName = pAddress.substring(0, tmpSeparatorIndex);\n\t\t\tlet tmpNewAddress = pAddress.substring(tmpSeparatorIndex+1);\n\n\t\t\t// BOXED ELEMENTS\n\t\t\t// Test if the tmpNewAddress is an array or object\n\t\t\t// Check if it's a boxed property\n\t\t\tlet tmpBracketStartIndex = tmpSubObjectName.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = tmpSubObjectName.indexOf(']');\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[42]\n\t\t\t// \t\tMyValues['Color']\n\t\t\t// \t\tMyValues[\"Weight\"]\n\t\t\t// \t\tMyValues[`Diameter`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpBracketStartIndex > 0)\n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex)\n\t\t\t//    3) There is data\n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 1))\n\t\t\t{\n\t\t\t\tlet tmpBoxedPropertyName = tmpSubObjectName.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyReference = tmpSubObjectName.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[1].Tardy\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an object, so the [1].Tardy is not possible to access\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[\"JaneDoe\"].Grade\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an array, so the [\"JaneDoe\"].Grade is not possible to access\n\t\t\t\t// TODO: Should this be an error or something?  Should we keep a log of failures like this?\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t// Check if the boxed property is an object.\n\t\t\t\tif (typeof(pObject[tmpBoxedPropertyName]) != 'object')\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\n\t\t\t\t//This is a bracketed value\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to reat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynanmic object property.\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\t// Continue to manage the parent address for recursion\n\t\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpSubObjectName}`;\n\t\t\t\t\t// Recurse directly into the subobject\n\t\t\t\t\treturn this.deleteValueAtAddress(pObject[tmpBoxedPropertyName][tmpBoxedPropertyReference], tmpNewAddress, tmpParentAddress);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Continue to manage the parent address for recursion\n\t\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpSubObjectName}`;\n\t\t\t\t\t// We parsed a valid number out of the boxed property name, so recurse into the array\n\t\t\t\t\treturn this.deleteValueAtAddress(pObject[tmpBoxedPropertyName][tmpBoxedPropertyNumber], tmpNewAddress, tmpParentAddress);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// The requirements to detect a boxed set element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\telse if ((tmpBracketStartIndex > 0)\n\t\t\t//    2) The end bracket is after the start bracket\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex)\n\t\t\t//    3) There is nothing in the brackets\n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex == 1))\n\t\t\t{\n\t\t\t\tlet tmpBoxedPropertyName = pAddress.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\tif (!Array.isArray(pObject[tmpBoxedPropertyName]))\n\t\t\t\t{\n\t\t\t\t\t// We asked for a set from an array but it isnt' an array.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// We need to enumerate the array and grab the addresses from there.\n\t\t\t\tlet tmpArrayProperty = pObject[tmpBoxedPropertyName];\n\t\t\t\t// Managing the parent address is a bit more complex here -- the box will be added for each element.\n\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpBoxedPropertyName}`;\n\t\t\t\t// The container object is where we have the \"Address\":SOMEVALUE pairs\n\t\t\t\tlet tmpContainerObject = {};\n\t\t\t\tfor (let i = 0; i < tmpArrayProperty.length; i++)\n\t\t\t\t{\n\t\t\t\t\tlet tmpPropertyParentAddress = `${tmpParentAddress}[${i}]`;\n\t\t\t\t\tlet tmpValue = this.deleteValueAtAddress(pObject[tmpBoxedPropertyName][i], tmpNewAddress, tmpPropertyParentAddress);\n\n\t\t\t\t\ttmpContainerObject[`${tmpPropertyParentAddress}.${tmpNewAddress}`] = tmpValue;\n\t\t\t\t}\n\n\t\t\t\treturn tmpContainerObject;\n\t\t\t}\n\n\t\t\t// OBJECT SET\n\t\t\t// Note this will not work with a bracket in the same address box set\n\t\t\tlet tmpObjectTypeMarkerIndex = pAddress.indexOf('{}');\n\t\t\tif (tmpObjectTypeMarkerIndex > 0)\n\t\t\t{\n\t\t\t\tlet tmpObjectPropertyName = pAddress.substring(0, tmpObjectTypeMarkerIndex).trim();\n\n\t\t\t\tif (typeof(pObject[tmpObjectPropertyName]) != 'object')\n\t\t\t\t{\n\t\t\t\t\t// We asked for a set from an array but it isnt' an array.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// We need to enumerate the Object and grab the addresses from there.\n\t\t\t\tlet tmpObjectProperty = pObject[tmpObjectPropertyName];\n\t\t\t\tlet tmpObjectPropertyKeys = Object.keys(tmpObjectProperty);\n\t\t\t\t// Managing the parent address is a bit more complex here -- the box will be added for each element.\n\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpObjectPropertyName}`;\n\t\t\t\t// The container object is where we have the \"Address\":SOMEVALUE pairs\n\t\t\t\tlet tmpContainerObject = {};\n\t\t\t\tfor (let i = 0; i < tmpObjectPropertyKeys.length; i++)\n\t\t\t\t{\n\t\t\t\t\tlet tmpPropertyParentAddress = `${tmpParentAddress}.${tmpObjectPropertyKeys[i]}`;\n\t\t\t\t\tlet tmpValue = this.deleteValueAtAddress(pObject[tmpObjectPropertyName][tmpObjectPropertyKeys[i]], tmpNewAddress, tmpPropertyParentAddress);\n\n\t\t\t\t\t// The filtering is complex but allows config-based metaprogramming directly from schema\n\t\t\t\t\tlet tmpKeepRecord = this.checkFilters(pAddress, tmpValue);\n\t\t\t\t\tif (tmpKeepRecord)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpContainerObject[`${tmpPropertyParentAddress}.${tmpNewAddress}`] = tmpValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn tmpContainerObject;\n\t\t\t}\n\n\t\t\t// If there is an object property already named for the sub object, but it isn't an object\n\t\t\t// then the system can't set the value in there.  Error and abort!\n\t\t\tif (pObject.hasOwnProperty(tmpSubObjectName) && typeof(pObject[tmpSubObjectName]) !== 'object')\n\t\t\t{\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\telse if (pObject.hasOwnProperty(tmpSubObjectName))\n\t\t\t{\n\t\t\t\t// If there is already a subobject pass that to the recursive thingy\n\t\t\t\t// Continue to manage the parent address for recursion\n\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpSubObjectName}`;\n\t\t\t\treturn this.deleteValueAtAddress(pObject[tmpSubObjectName], tmpNewAddress, tmpParentAddress);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Create a subobject and then pass that\n\t\t\t\t// Continue to manage the parent address for recursion\n\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpSubObjectName}`;\n\t\t\t\tpObject[tmpSubObjectName] = {};\n\t\t\t\treturn this.deleteValueAtAddress(pObject[tmpSubObjectName], tmpNewAddress, tmpParentAddress);\n\t\t\t}\n\t\t}\n\t}\n};\n\nmodule.exports = ManyfestObjectAddressResolverDeleteValue;","/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\nlet libSimpleLog = require('./Manyfest-LogToConsole.js');\nlet libPrecedent = require('precedent');\nlet fCleanWrapCharacters = require('./Manyfest-CleanWrapCharacters.js');\n\n/**\n* Object Address Resolver - GetValue\n*\n* IMPORTANT NOTE: This code is intentionally more verbose than necessary, to\n*                 be extremely clear what is going on in the recursion for\n*                 each of the three address resolution functions.\n*\n*                 Although there is some opportunity to repeat ourselves a\n*                 bit less in this codebase (e.g. with detection of arrays\n*                 versus objects versus direct properties), it can make\n*                 debugging.. challenging.  The minified version of the code\n*                 optimizes out almost anything repeated in here.  So please\n*                 be kind and rewind... meaning please keep the codebase less\n*                 terse and more verbose so humans can comprehend it.\n*\n* TODO: Once we validate this pattern is good to go, break these out into\n*       three separate modules.\n*\n* @class ManyfestObjectAddressResolverGetValue\n*/\nclass ManyfestObjectAddressResolverGetValue\n{\n\tconstructor(pInfoLog, pErrorLog)\n\t{\n\t\t// Wire in logging\n\t\tthis.logInfo = (typeof(pInfoLog) == 'function') ? pInfoLog : libSimpleLog;\n\t\tthis.logError = (typeof(pErrorLog) == 'function') ? pErrorLog : libSimpleLog;\n\n\t\tthis.elucidatorSolver = false;\n\t\tthis.elucidatorSolverState = {};\n\n\t\tthis.cleanWrapCharacters = fCleanWrapCharacters;\n\t}\n\n\tcheckFilters(pAddress, pRecord)\n\t{\n\t\tlet tmpPrecedent = new libPrecedent();\n\t\t// If we don't copy the string, precedent takes it out for good.\n\t\t// TODO: Consider adding a \"don't replace\" option for precedent\n\t\tlet tmpAddress = pAddress;\n\n\t\tif (!this.elucidatorSolver)\n\t\t{\n\t\t\t// Again, manage against circular dependencies\n\t\t\tlet libElucidator = require('elucidator');\n\t\t\tthis.elucidatorSolver = new libElucidator({}, this.logInfo, this.logError);\n\t\t}\n\n\t\tif (this.elucidatorSolver)\n\t\t{\n\t\t\t// This allows the magic filtration with elucidator configuration\n\t\t\t// TODO: We could pass more state in (e.g. parent address, object, etc.)\n\t\t\t// TODO: Discuss this metaprogramming AT LENGTH\n\t\t\tlet tmpFilterState = (\n\t\t\t\t{\n\t\t\t\t\tRecord: pRecord,\n\t\t\t\t\tkeepRecord: true\n\t\t\t\t});\n\n\t\t\t// This is about as complex as it gets.\n\t\t\t// TODO: Optimize this so it is only initialized once.\n\t\t\t// TODO: That means figuring out a healthy pattern for passing in state to this\n\t\t\ttmpPrecedent.addPattern('<<~~', '~~>>',\n\t\t\t\t(pInstructionHash) =>\n\t\t\t\t{\n\t\t\t\t\t// This is for internal config on the solution steps.  Right now config is not shared across steps.\n\t\t\t\t\tif (this.elucidatorSolverState.hasOwnProperty(pInstructionHash))\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpFilterState.SolutionState = this.elucidatorSolverState[pInstructionHash];\n\t\t\t\t\t}\n\t\t\t\t\tthis.elucidatorSolver.solveInternalOperation('Custom', pInstructionHash, tmpFilterState);\n\t\t\t\t});\n\t\t\ttmpPrecedent.addPattern('<<~?', '?~>>',\n\t\t\t\t(pMagicSearchExpression) =>\n\t\t\t\t{\n\t\t\t\t\tif (typeof(pMagicSearchExpression) !== 'string')\n\t\t\t\t\t{\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\t// This expects a comma separated expression:\n\t\t\t\t\t//     Some.Address.In.The.Object,==,Search Term to Match\n\t\t\t\t\tlet tmpMagicComparisonPatternSet = pMagicSearchExpression.split(',');\n\n\t\t\t\t\tlet tmpSearchAddress = tmpMagicComparisonPatternSet[0];\n\t\t\t\t\tlet tmpSearchComparator = tmpMagicComparisonPatternSet[1];\n\t\t\t\t\tlet tmpSearchValue = tmpMagicComparisonPatternSet[2];\n\n\t\t\t\t\ttmpFilterState.ComparisonState = (\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tSearchAddress: tmpSearchAddress,\n\t\t\t\t\t\t\tComparator: tmpSearchComparator,\n\t\t\t\t\t\t\tSearchTerm: tmpSearchValue\n\t\t\t\t\t\t});\n\n\t\t\t\t\tthis.elucidatorSolver.solveOperation(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"Description\":\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\"Operation\": \"Simple_If\",\n\t\t\t\t\t\t\t\t\"Synopsis\": \"Test for \"\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\"Steps\":\n\t\t\t\t\t\t\t[\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\"Namespace\": \"Logic\",\n\t\t\t\t\t\t\t\t\t\"Instruction\": \"if\",\n\n\t\t\t\t\t\t\t\t\t\"InputHashAddressMap\":\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t// This is ... dynamically assigning the address in the instruction\n\t\t\t\t\t\t\t\t\t\t\t// The complexity is astounding.\n\t\t\t\t\t\t\t\t\t\t\t\"leftValue\": `Record.${tmpSearchAddress}`,\n\t\t\t\t\t\t\t\t\t\t\t\"rightValue\": \"ComparisonState.SearchTerm\",\n\t\t\t\t\t\t\t\t\t\t\t\"comparator\": \"ComparisonState.Comparator\"\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\"OutputHashAddressMap\": { \"truthinessResult\":\"keepRecord\" }\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t}, tmpFilterState);\n\t\t\t\t});\n\t\t\ttmpPrecedent.parseString(tmpAddress);\n\n\t\t\t// It is expected that the operation will mutate this to some truthy value\n\t\t\treturn tmpFilterState.keepRecord;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t// Get the value of an element at an address\n\tgetValueAtAddress (pObject, pAddress, pParentAddress)\n\t{\n\t\t// Make sure pObject (the object we are meant to be recursing) is an object (which could be an array or object)\n\t\tif (typeof(pObject) != 'object') return undefined;\n\t\t// Make sure pAddress (the address we are resolving) is a string\n\t\tif (typeof(pAddress) != 'string') return undefined;\n\t\t// Stash the parent address for later resolution\n\t\tlet tmpParentAddress = \"\";\n\t\tif (typeof(pParentAddress) == 'string')\n\t\t{\n\t\t\ttmpParentAddress = pParentAddress;\n\t\t}\n\n\t\t// TODO: Make this work for things like SomeRootObject.Metadata[\"Some.People.Use.Bad.Object.Property.Names\"]\n\t\tlet tmpSeparatorIndex = pAddress.indexOf('.');\n\n\t\t// This is the terminal address string (no more dots so the RECUSION ENDS IN HERE somehow)\n\t\tif (tmpSeparatorIndex == -1)\n\t\t{\n\t\t\t// Check if the address refers to a boxed property\n\t\t\tlet tmpBracketStartIndex = pAddress.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = pAddress.indexOf(']');\n\n\t\t\t// Check for the Object Set Type marker.\n\t\t\t// Note this will not work with a bracket in the same address box set\n\t\t\tlet tmpObjectTypeMarkerIndex = pAddress.indexOf('{}');\n\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[10]\n\t\t\t// \t\tMyValues['Name']\n\t\t\t// \t\tMyValues[\"Age\"]\n\t\t\t// \t\tMyValues[`Cost`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpBracketStartIndex > 0)\n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex)\n\t\t\t//    3) There is data\n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 1))\n\t\t\t{\n\t\t\t\t// The \"Name\" of the Object contained too the left of the bracket\n\t\t\t\tlet tmpBoxedPropertyName = pAddress.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\t// If the subproperty doesn't test as a proper Object, none of the rest of this is possible.\n\t\t\t\t// This is a rare case where Arrays testing as Objects is useful\n\t\t\t\tif (typeof(pObject[tmpBoxedPropertyName]) !== 'object')\n\t\t\t\t{\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\t// The \"Reference\" to the property within it, either an array element or object property\n\t\t\t\tlet tmpBoxedPropertyReference = pAddress.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\t\t\t\t// Attempt to parse the reference as a number, which will be used as an array element\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to treat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynamic object property.\n\t\t\t\t\t// We would expect the property to be wrapped in some kind of quotes so strip them\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\t// Return the value in the property\n\t\t\t\t\treturn pObject[tmpBoxedPropertyName][tmpBoxedPropertyReference];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treturn pObject[tmpBoxedPropertyName][tmpBoxedPropertyNumber];\n\t\t\t\t}\n\t\t\t}\n\t\t\t// The requirements to detect a boxed set element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\telse if ((tmpBracketStartIndex > 0)\n\t\t\t//    2) The end bracket is after the start bracket\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex)\n\t\t\t//    3) There is nothing in the brackets\n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex == 1))\n\t\t\t{\n\t\t\t\tlet tmpBoxedPropertyName = pAddress.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\tif (!Array.isArray(pObject[tmpBoxedPropertyName]))\n\t\t\t\t{\n\t\t\t\t\t// We asked for a set from an array but it isnt' an array.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tlet tmpInputArray = pObject[tmpBoxedPropertyName];\n\t\t\t\tlet tmpOutputArray = [];\n\t\t\t\tfor (let i = 0; i < tmpInputArray.length; i++)\n\t\t\t\t{\n\t\t\t\t\t// The filtering is complex but allows config-based metaprogramming directly from schema\n\t\t\t\t\tlet tmpKeepRecord = this.checkFilters(pAddress, tmpInputArray[i]);\n\t\t\t\t\tif (tmpKeepRecord)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpOutputArray.push(tmpInputArray[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn tmpOutputArray;\n\t\t\t}\n\t\t\t// The object has been flagged as an object set, so treat it as such\n\t\t\telse if (tmpObjectTypeMarkerIndex > 0)\n\t\t\t{\n\t\t\t\tlet tmpObjectPropertyName = pAddress.substring(0, tmpObjectTypeMarkerIndex).trim();\n\n\t\t\t\tif (typeof(pObject[tmpObjectPropertyName]) != 'object')\n\t\t\t\t{\n\t\t\t\t\t// We asked for a set from an array but it isnt' an array.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\treturn pObject[tmpObjectPropertyName];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Now is the point in recursion to return the value in the address\n\t\t\t\treturn pObject[pAddress];\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlet tmpSubObjectName = pAddress.substring(0, tmpSeparatorIndex);\n\t\t\tlet tmpNewAddress = pAddress.substring(tmpSeparatorIndex+1);\n\n\t\t\t// BOXED ELEMENTS\n\t\t\t// Test if the tmpNewAddress is an array or object\n\t\t\t// Check if it's a boxed property\n\t\t\tlet tmpBracketStartIndex = tmpSubObjectName.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = tmpSubObjectName.indexOf(']');\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[42]\n\t\t\t// \t\tMyValues['Color']\n\t\t\t// \t\tMyValues[\"Weight\"]\n\t\t\t// \t\tMyValues[`Diameter`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpBracketStartIndex > 0)\n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex)\n\t\t\t//    3) There is data\n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 1))\n\t\t\t{\n\t\t\t\tlet tmpBoxedPropertyName = tmpSubObjectName.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyReference = tmpSubObjectName.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[1].Tardy\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an object, so the [1].Tardy is not possible to access\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[\"JaneDoe\"].Grade\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an array, so the [\"JaneDoe\"].Grade is not possible to access\n\t\t\t\t// TODO: Should this be an error or something?  Should we keep a log of failures like this?\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t\t// Check if the boxed property is an object.\n\t\t\t\tif (typeof(pObject[tmpBoxedPropertyName]) != 'object')\n\t\t\t\t{\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\n\t\t\t\t//This is a bracketed value\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to reat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynanmic object property.\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\t// Continue to manage the parent address for recursion\n\t\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpSubObjectName}`;\n\t\t\t\t\t// Recurse directly into the subobject\n\t\t\t\t\treturn this.getValueAtAddress(pObject[tmpBoxedPropertyName][tmpBoxedPropertyReference], tmpNewAddress, tmpParentAddress);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Continue to manage the parent address for recursion\n\t\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpSubObjectName}`;\n\t\t\t\t\t// We parsed a valid number out of the boxed property name, so recurse into the array\n\t\t\t\t\treturn this.getValueAtAddress(pObject[tmpBoxedPropertyName][tmpBoxedPropertyNumber], tmpNewAddress, tmpParentAddress);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// The requirements to detect a boxed set element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\telse if ((tmpBracketStartIndex > 0)\n\t\t\t//    2) The end bracket is after the start bracket\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex)\n\t\t\t//    3) There is nothing in the brackets\n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex == 1))\n\t\t\t{\n\t\t\t\tlet tmpBoxedPropertyName = pAddress.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\tif (!Array.isArray(pObject[tmpBoxedPropertyName]))\n\t\t\t\t{\n\t\t\t\t\t// We asked for a set from an array but it isnt' an array.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// We need to enumerate the array and grab the addresses from there.\n\t\t\t\tlet tmpArrayProperty = pObject[tmpBoxedPropertyName];\n\t\t\t\t// Managing the parent address is a bit more complex here -- the box will be added for each element.\n\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpBoxedPropertyName}`;\n\t\t\t\t// The container object is where we have the \"Address\":SOMEVALUE pairs\n\t\t\t\tlet tmpContainerObject = {};\n\t\t\t\tfor (let i = 0; i < tmpArrayProperty.length; i++)\n\t\t\t\t{\n\t\t\t\t\tlet tmpPropertyParentAddress = `${tmpParentAddress}[${i}]`;\n\t\t\t\t\tlet tmpValue = this.getValueAtAddress(pObject[tmpBoxedPropertyName][i], tmpNewAddress, tmpPropertyParentAddress);\n\n\t\t\t\t\ttmpContainerObject[`${tmpPropertyParentAddress}.${tmpNewAddress}`] = tmpValue;\n\t\t\t\t}\n\n\t\t\t\treturn tmpContainerObject;\n\t\t\t}\n\n\t\t\t// OBJECT SET\n\t\t\t// Note this will not work with a bracket in the same address box set\n\t\t\tlet tmpObjectTypeMarkerIndex = pAddress.indexOf('{}');\n\t\t\tif (tmpObjectTypeMarkerIndex > 0)\n\t\t\t{\n\t\t\t\tlet tmpObjectPropertyName = pAddress.substring(0, tmpObjectTypeMarkerIndex).trim();\n\n\t\t\t\tif (typeof(pObject[tmpObjectPropertyName]) != 'object')\n\t\t\t\t{\n\t\t\t\t\t// We asked for a set from an array but it isnt' an array.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// We need to enumerate the Object and grab the addresses from there.\n\t\t\t\tlet tmpObjectProperty = pObject[tmpObjectPropertyName];\n\t\t\t\tlet tmpObjectPropertyKeys = Object.keys(tmpObjectProperty);\n\t\t\t\t// Managing the parent address is a bit more complex here -- the box will be added for each element.\n\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpObjectPropertyName}`;\n\t\t\t\t// The container object is where we have the \"Address\":SOMEVALUE pairs\n\t\t\t\tlet tmpContainerObject = {};\n\t\t\t\tfor (let i = 0; i < tmpObjectPropertyKeys.length; i++)\n\t\t\t\t{\n\t\t\t\t\tlet tmpPropertyParentAddress = `${tmpParentAddress}.${tmpObjectPropertyKeys[i]}`;\n\t\t\t\t\tlet tmpValue = this.getValueAtAddress(pObject[tmpObjectPropertyName][tmpObjectPropertyKeys[i]], tmpNewAddress, tmpPropertyParentAddress);\n\n\t\t\t\t\t// The filtering is complex but allows config-based metaprogramming directly from schema\n\t\t\t\t\tlet tmpKeepRecord = this.checkFilters(pAddress, tmpValue);\n\t\t\t\t\tif (tmpKeepRecord)\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpContainerObject[`${tmpPropertyParentAddress}.${tmpNewAddress}`] = tmpValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn tmpContainerObject;\n\t\t\t}\n\n\t\t\t// If there is an object property already named for the sub object, but it isn't an object\n\t\t\t// then the system can't set the value in there.  Error and abort!\n\t\t\tif (pObject.hasOwnProperty(tmpSubObjectName) && typeof(pObject[tmpSubObjectName]) !== 'object')\n\t\t\t{\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\telse if (pObject.hasOwnProperty(tmpSubObjectName))\n\t\t\t{\n\t\t\t\t// If there is already a subobject pass that to the recursive thingy\n\t\t\t\t// Continue to manage the parent address for recursion\n\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpSubObjectName}`;\n\t\t\t\treturn this.getValueAtAddress(pObject[tmpSubObjectName], tmpNewAddress, tmpParentAddress);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Create a subobject and then pass that\n\t\t\t\t// Continue to manage the parent address for recursion\n\t\t\t\ttmpParentAddress = `${tmpParentAddress}${(tmpParentAddress.length > 0) ? '.' : ''}${tmpSubObjectName}`;\n\t\t\t\tpObject[tmpSubObjectName] = {};\n\t\t\t\treturn this.getValueAtAddress(pObject[tmpSubObjectName], tmpNewAddress, tmpParentAddress);\n\t\t\t}\n\t\t}\n\t}\n};\n\nmodule.exports = ManyfestObjectAddressResolverGetValue;","/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\nlet libSimpleLog = require('./Manyfest-LogToConsole.js');\nlet libPrecedent = require('precedent');\nlet fCleanWrapCharacters = require('./Manyfest-CleanWrapCharacters.js');\n\n/**\n* Object Address Resolver - SetValue\n*\n* IMPORTANT NOTE: This code is intentionally more verbose than necessary, to\n*                 be extremely clear what is going on in the recursion for\n*                 each of the three address resolution functions.\n*\n*                 Although there is some opportunity to repeat ourselves a\n*                 bit less in this codebase (e.g. with detection of arrays\n*                 versus objects versus direct properties), it can make\n*                 debugging.. challenging.  The minified version of the code\n*                 optimizes out almost anything repeated in here.  So please\n*                 be kind and rewind... meaning please keep the codebase less\n*                 terse and more verbose so humans can comprehend it.\n*\n*\n* @class ManyfestObjectAddressSetValue\n*/\nclass ManyfestObjectAddressSetValue\n{\n\tconstructor(pInfoLog, pErrorLog)\n\t{\n\t\t// Wire in logging\n\t\tthis.logInfo = (typeof(pInfoLog) == 'function') ? pInfoLog : libSimpleLog;\n\t\tthis.logError = (typeof(pErrorLog) == 'function') ? pErrorLog : libSimpleLog;\n\n\t\tthis.elucidatorSolver = false;\n\t\tthis.elucidatorSolverState = {};\n\n\t\tthis.cleanWrapCharacters = fCleanWrapCharacters;\n\t}\n\n\t// Set the value of an element at an address\n\tsetValueAtAddress (pObject, pAddress, pValue)\n\t{\n\t\t// Make sure pObject is an object\n\t\tif (typeof(pObject) != 'object') return false;\n\t\t// Make sure pAddress is a string\n\t\tif (typeof(pAddress) != 'string') return false;\n\n\t\tlet tmpSeparatorIndex = pAddress.indexOf('.');\n\n\t\tif (tmpSeparatorIndex == -1)\n\t\t{\n\t\t\t// Check if it's a boxed property\n\t\t\tlet tmpBracketStartIndex = pAddress.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = pAddress.indexOf(']');\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[10]\n\t\t\t// \t\tMyValues['Name']\n\t\t\t// \t\tMyValues[\"Age\"]\n\t\t\t// \t\tMyValues[`Cost`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpBracketStartIndex > 0)\n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex)\n\t\t\t//    3) There is data\n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 1))\n\t\t\t{\n\t\t\t\t// The \"Name\" of the Object contained too the left of the bracket\n\t\t\t\tlet tmpBoxedPropertyName = pAddress.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\t// If the subproperty doesn't test as a proper Object, none of the rest of this is possible.\n\t\t\t\t// This is a rare case where Arrays testing as Objects is useful\n\t\t\t\tif (typeof(pObject[tmpBoxedPropertyName]) !== 'object')\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// The \"Reference\" to the property within it, either an array element or object property\n\t\t\t\tlet tmpBoxedPropertyReference = pAddress.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\t\t\t\t// Attempt to parse the reference as a number, which will be used as an array element\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to treat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynamic object property.\n\t\t\t\t\t// We would expect the property to be wrapped in some kind of quotes so strip them\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\t// Return the value in the property\n\t\t\t\t\tpObject[tmpBoxedPropertyName][tmpBoxedPropertyReference] = pValue;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tpObject[tmpBoxedPropertyName][tmpBoxedPropertyNumber] = pValue;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Now is the time in recursion to set the value in the object\n\t\t\t\tpObject[pAddress] = pValue;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlet tmpSubObjectName = pAddress.substring(0, tmpSeparatorIndex);\n\t\t\tlet tmpNewAddress = pAddress.substring(tmpSeparatorIndex+1);\n\n\t\t\t// Test if the tmpNewAddress is an array or object\n\t\t\t// Check if it's a boxed property\n\t\t\tlet tmpBracketStartIndex = tmpSubObjectName.indexOf('[');\n\t\t\tlet tmpBracketStopIndex = tmpSubObjectName.indexOf(']');\n\t\t\t// Boxed elements look like this:\n\t\t\t// \t\tMyValues[42]\n\t\t\t// \t\tMyValues['Color']\n\t\t\t// \t\tMyValues[\"Weight\"]\n\t\t\t// \t\tMyValues[`Diameter`]\n\t\t\t//\n\t\t\t// When we are passed SomeObject[\"Name\"] this code below recurses as if it were SomeObject.Name\n\t\t\t// The requirements to detect a boxed element are:\n\t\t\t//    1) The start bracket is after character 0\n\t\t\tif ((tmpBracketStartIndex > 0)\n\t\t\t//    2) The end bracket has something between them\n\t\t\t\t&& (tmpBracketStopIndex > tmpBracketStartIndex)\n\t\t\t//    3) There is data\n\t\t\t\t&& (tmpBracketStopIndex - tmpBracketStartIndex > 1))\n\t\t\t{\n\t\t\t\tlet tmpBoxedPropertyName = tmpSubObjectName.substring(0, tmpBracketStartIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyReference = tmpSubObjectName.substring(tmpBracketStartIndex+1, tmpBracketStopIndex).trim();\n\n\t\t\t\tlet tmpBoxedPropertyNumber = parseInt(tmpBoxedPropertyReference, 10);\n\n\t\t\t\t// Guard: If the referrant is a number and the boxed property is not an array, or vice versa, return undefined.\n\t\t\t\t//        This seems confusing to me at first read, so explaination:\n\t\t\t\t//        Is the Boxed Object an Array?  TRUE\n\t\t\t\t//        And is the Reference inside the boxed Object not a number? TRUE\n\t\t\t\t//        -->  So when these are in agreement, it's an impossible access state\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[1].Tardy\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an object, so the [1].Tardy is not possible to access\n\t\t\t\t// This could be a failure in the recursion chain because they passed something like this in:\n\t\t\t\t//    StudentData.Sections.Algebra.Students[\"JaneDoe\"].Grade\n\t\t\t\t//       BUT\n\t\t\t\t//         StudentData.Sections.Algebra.Students is an array, so the [\"JaneDoe\"].Grade is not possible to access\n\t\t\t\t// TODO: Should this be an error or something?  Should we keep a log of failures like this?\n\t\t\t\tif (Array.isArray(pObject[tmpBoxedPropertyName]) == isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t//This is a bracketed value\n\t\t\t\t//    4) If the middle part is *only* a number (no single, double or backtick quotes) it is an array element,\n\t\t\t\t//       otherwise we will try to reat it as a dynamic object property.\n\t\t\t\tif (isNaN(tmpBoxedPropertyNumber))\n\t\t\t\t{\n\t\t\t\t\t// This isn't a number ... let's treat it as a dynanmic object property.\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('\"', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters('`', tmpBoxedPropertyReference);\n\t\t\t\t\ttmpBoxedPropertyReference = this.cleanWrapCharacters(\"'\", tmpBoxedPropertyReference);\n\n\t\t\t\t\t// Recurse directly into the subobject\n\t\t\t\t\treturn this.setValueAtAddress(pObject[tmpBoxedPropertyName][tmpBoxedPropertyReference], tmpNewAddress, pValue);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// We parsed a valid number out of the boxed property name, so recurse into the array\n\t\t\t\t\treturn this.setValueAtAddress(pObject[tmpBoxedPropertyName][tmpBoxedPropertyNumber], tmpNewAddress, pValue);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If there is an object property already named for the sub object, but it isn't an object\n\t\t\t// then the system can't set the value in there.  Error and abort!\n\t\t\tif (pObject.hasOwnProperty(tmpSubObjectName) && typeof(pObject[tmpSubObjectName]) !== 'object')\n\t\t\t{\n\t\t\t\tif (!pObject.hasOwnProperty('__ERROR'))\n\t\t\t\t\tpObject['__ERROR'] = {};\n\t\t\t\t// Put it in an error object so data isn't lost\n\t\t\t\tpObject['__ERROR'][pAddress] = pValue;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse if (pObject.hasOwnProperty(tmpSubObjectName))\n\t\t\t{\n\t\t\t\t// If there is already a subobject pass that to the recursive thingy\n\t\t\t\treturn this.setValueAtAddress(pObject[tmpSubObjectName], tmpNewAddress, pValue);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Create a subobject and then pass that\n\t\t\t\tpObject[tmpSubObjectName] = {};\n\t\t\t\treturn this.setValueAtAddress(pObject[tmpSubObjectName], tmpNewAddress, pValue);\n\t\t\t}\n\t\t}\n\t}\n};\n\nmodule.exports = ManyfestObjectAddressSetValue;","/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\nlet libSimpleLog = require('./Manyfest-LogToConsole.js');\n\n/**\n* Object Address Generation\n*\n* Automagically generate addresses and properties based on a passed-in object,\n* to be used for easy creation of schemas.  Meant to simplify the lives of\n* developers wanting to create schemas without typing a bunch of stuff.\n*\n* IMPORTANT NOTE: This code is intentionally more verbose than necessary, to\n*                 be extremely clear what is going on in the recursion for\n*                 each of the three address resolution functions.\n*\n*                 Although there is some opportunity to repeat ourselves a\n*                 bit less in this codebase (e.g. with detection of arrays\n*                 versus objects versus direct properties), it can make\n*                 debugging.. challenging.  The minified version of the code\n*                 optimizes out almost anything repeated in here.  So please\n*                 be kind and rewind... meaning please keep the codebase less\n*                 terse and more verbose so humans can comprehend it.\n*\n*\n* @class ManyfestObjectAddressGeneration\n*/\nclass ManyfestObjectAddressGeneration\n{\n\tconstructor(pInfoLog, pErrorLog)\n\t{\n\t\t// Wire in logging\n\t\tthis.logInfo = (typeof(pInfoLog) == 'function') ? pInfoLog : libSimpleLog;\n\t\tthis.logError = (typeof(pErrorLog) == 'function') ? pErrorLog : libSimpleLog;\n\t}\n\n\t// generateAddressses\n\t//\n\t// This flattens an object into a set of key:value pairs for *EVERY SINGLE\n\t// POSSIBLE ADDRESS* in the object.  It can get ... really insane really\n\t// quickly.  This is not meant to be used directly to generate schemas, but\n\t// instead as a starting point for scripts or UIs.\n\t//\n\t// This will return a mega set of key:value pairs with all possible schema\n\t// permutations and default values (when not an object) and everything else.\n\tgenerateAddressses (pObject, pBaseAddress, pSchema)\n\t{\n\t\tlet tmpBaseAddress = (typeof(pBaseAddress) == 'string') ? pBaseAddress : '';\n\t\tlet tmpSchema = (typeof(pSchema) == 'object') ? pSchema : {};\n\n\t\tlet tmpObjectType = typeof(pObject);\n\n\t\tlet tmpSchemaObjectEntry = (\n\t\t\t{\n\t\t\t\tAddress: tmpBaseAddress,\n\t\t\t\tHash: tmpBaseAddress,\n\t\t\t\tName: tmpBaseAddress,\n\t\t\t\t// This is so scripts and UI controls can force a developer to opt-in.\n\t\t\t\tInSchema: false\n\t\t\t}\n\t\t)\n\n\t\tif ((tmpObjectType == 'object') && (pObject == null))\n\t\t{\n\t\t\ttmpObjectType = 'null';\n\t\t}\n\n\t\tswitch(tmpObjectType)\n\t\t{\n\t\t\tcase 'string':\n\t\t\t\ttmpSchemaObjectEntry.DataType = 'String';\n\t\t\t\ttmpSchemaObjectEntry.Default = pObject;\n\t\t\t\ttmpSchema[tmpBaseAddress] = tmpSchemaObjectEntry;\n\t\t\t\tbreak;\n\t\t\tcase 'number':\n\t\t\tcase 'bigint':\n\t\t\t\ttmpSchemaObjectEntry.DataType = 'Number';\n\t\t\t\ttmpSchemaObjectEntry.Default = pObject;\n\t\t\t\ttmpSchema[tmpBaseAddress] = tmpSchemaObjectEntry;\n\t\t\t\tbreak;\n\t\t\tcase 'undefined':\n\t\t\tcase 'null':\n\t\t\t\ttmpSchemaObjectEntry.DataType = 'Any';\n\t\t\t\ttmpSchemaObjectEntry.Default = pObject;\n\t\t\t\ttmpSchema[tmpBaseAddress] = tmpSchemaObjectEntry;\n\t\t\t\tbreak;\n\t\t\tcase 'object':\n\t\t\t\tif (Array.isArray(pObject))\n\t\t\t\t{\n\t\t\t\t\ttmpSchemaObjectEntry.DataType = 'Array';\n\t\t\t\t\tif (tmpBaseAddress != '')\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpSchema[tmpBaseAddress] = tmpSchemaObjectEntry;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (let i = 0; i < pObject.length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.generateAddressses(pObject[i], `${tmpBaseAddress}[${i}]`, tmpSchema);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttmpSchemaObjectEntry.DataType = 'Object';\n\t\t\t\t\tif (tmpBaseAddress != '')\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpSchema[tmpBaseAddress] = tmpSchemaObjectEntry;\n\t\t\t\t\t\ttmpBaseAddress += '.';\n\t\t\t\t\t}\n\n\t\t\t\t\tlet tmpObjectProperties = Object.keys(pObject);\n\n\t\t\t\t\tfor (let i = 0; i < tmpObjectProperties.length; i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.generateAddressses(pObject[tmpObjectProperties[i]], `${tmpBaseAddress}${tmpObjectProperties[i]}`, tmpSchema);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'symbol':\n\t\t\tcase 'function':\n\t\t\t\t// Symbols and functions neither recurse nor get added to the schema\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn tmpSchema;\n\t}\n};\n\nmodule.exports = ManyfestObjectAddressGeneration;","/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\nlet libSimpleLog = require('./Manyfest-LogToConsole.js');\n\n/**\n* Schema Manipulation Functions\n*\n* @class ManyfestSchemaManipulation\n*/\nclass ManyfestSchemaManipulation\n{\n\tconstructor(pInfoLog, pErrorLog)\n\t{\n\t\t// Wire in logging\n\t\tthis.logInfo = (typeof(pInfoLog) === 'function') ? pInfoLog : libSimpleLog;\n\t\tthis.logError = (typeof(pErrorLog) === 'function') ? pErrorLog : libSimpleLog;\n\t}\n\n    // This translates the default address mappings to something different.\n    //\n    // For instance you can pass in manyfest schema descriptor object:\n    // \t{\n\t//\t  \"Address.Of.a\": { \"Hash\": \"a\", \"Type\": \"Number\" },\n\t//\t  \"Address.Of.b\": { \"Hash\": \"b\", \"Type\": \"Number\" }\n\t//  }\n    //\n    //\n    // And then an address mapping (basically a Hash->Address map)\n    //  {\n    //    \"a\": \"New.Address.Of.a\",\n    //    \"b\": \"New.Address.Of.b\"\n    //  }\n    //\n    // NOTE: This mutates the schema object permanently, altering the base hash.\n    //       If there is a collision with an existing address, it can lead to overwrites.\n    // TODO: Discuss what should happen on collisions.\n\tresolveAddressMappings(pManyfestSchemaDescriptors, pAddressMapping)\n\t{\n\t\tif (typeof(pManyfestSchemaDescriptors) != 'object')\n\t\t{\n\t\t\tthis.logError(`Attempted to resolve address mapping but the descriptor was not an object.`);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (typeof(pAddressMapping) != 'object')\n\t\t{\n\t\t\t// No mappings were passed in\n\t\t\treturn true;\n\t\t}\n\n\t\t// Get the arrays of both the schema definition and the hash mapping\n\t\tlet tmpManyfestAddresses = Object.keys(pManyfestSchemaDescriptors);\n\t\tlet tmpHashMapping = {};\n\t\ttmpManyfestAddresses.forEach(\n\t\t\t(pAddress) =>\n\t\t\t{\n\t\t\t\tif (pManyfestSchemaDescriptors[pAddress].hasOwnProperty('Hash'))\n\t\t\t\t{\n\t\t\t\t\ttmpHashMapping[pManyfestSchemaDescriptors[pAddress].Hash] = pAddress;\n\t\t\t\t}\n\t\t\t});\n\n\t\tlet tmpAddressMappingSet = Object.keys(pAddressMapping);\n\n\t\ttmpAddressMappingSet.forEach(\n\t\t\t(pInputAddress) =>\n\t\t\t{\n\t\t\t\tlet tmpNewDescriptorAddress = pAddressMapping[pInputAddress];\n\t\t\t\tlet tmpOldDescriptorAddress = false;\n\t\t\t\tlet tmpDescriptor = false;\n\n\t\t\t\t// See if there is a matching descriptor either by Address directly or Hash\n\t\t\t\tif (pManyfestSchemaDescriptors.hasOwnProperty(pInputAddress))\n\t\t\t\t{\n\t\t\t\t\ttmpOldDescriptorAddress = pInputAddress;\n\t\t\t\t}\n\t\t\t\telse if (tmpHashMapping.hasOwnProperty(pInputAddress))\n\t\t\t\t{\n\t\t\t\t\ttmpOldDescriptorAddress = tmpHashMapping[pInputAddress];\n\t\t\t\t}\n\n\t\t\t\t// If there was a matching descriptor in the manifest, store it in the temporary descriptor\n\t\t\t\tif (tmpOldDescriptorAddress)\n\t\t\t\t{\n\t\t\t\t\ttmpDescriptor = pManyfestSchemaDescriptors[tmpOldDescriptorAddress];\n\t\t\t\t\tdelete pManyfestSchemaDescriptors[tmpOldDescriptorAddress];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Create a new descriptor!  Map it to the input address.\n\t\t\t\t\ttmpDescriptor = { Hash:pInputAddress };\n\t\t\t\t}\n\n\t\t\t\t// Now re-add the descriptor to the manyfest schema\n\t\t\t\tpManyfestSchemaDescriptors[tmpNewDescriptorAddress] = tmpDescriptor;\n\t\t\t});\n\n\t\treturn true;\n\t}\n\n\tsafeResolveAddressMappings(pManyfestSchemaDescriptors, pAddressMapping)\n\t{\n\t\t// This returns the descriptors as a new object, safely remapping without mutating the original schema Descriptors\n\t\tlet tmpManyfestSchemaDescriptors = JSON.parse(JSON.stringify(pManyfestSchemaDescriptors));\n\t\tthis.resolveAddressMappings(tmpManyfestSchemaDescriptors, pAddressMapping);\n\t\treturn tmpManyfestSchemaDescriptors;\n\t}\n\n\tmergeAddressMappings(pManyfestSchemaDescriptorsDestination, pManyfestSchemaDescriptorsSource)\n\t{\n\t\tif ((typeof(pManyfestSchemaDescriptorsSource) != 'object') || (typeof(pManyfestSchemaDescriptorsDestination) != 'object'))\n\t\t{\n\t\t\tthis.logError(`Attempted to merge two schema descriptors but both were not objects.`);\n\t\t\treturn false;\n\t\t}\n\n\t\tlet tmpSource = JSON.parse(JSON.stringify(pManyfestSchemaDescriptorsSource));\n\t\tlet tmpNewManyfestSchemaDescriptors = JSON.parse(JSON.stringify(pManyfestSchemaDescriptorsDestination));\n\n\t\t// The first passed-in set of descriptors takes precedence.\n\t\tlet tmpDescriptorAddresses = Object.keys(tmpSource);\n\n\t\ttmpDescriptorAddresses.forEach(\n\t\t\t(pDescriptorAddress) =>\n\t\t\t{\n\t\t\t\tif (!tmpNewManyfestSchemaDescriptors.hasOwnProperty(pDescriptorAddress))\n\t\t\t\t{\n\t\t\t\t\ttmpNewManyfestSchemaDescriptors[pDescriptorAddress] = tmpSource[pDescriptorAddress];\n\t\t\t\t}\n\t\t\t});\n\n\t\treturn tmpNewManyfestSchemaDescriptors;\n\t}\n}\n\nmodule.exports = ManyfestSchemaManipulation;","/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\nlet libSimpleLog = require('./Manyfest-LogToConsole.js');\n\nlet libPrecedent = require('precedent');\n\nlet libHashTranslation = require('./Manyfest-HashTranslation.js');\nlet libObjectAddressCheckAddressExists = require('./Manyfest-ObjectAddress-CheckAddressExists.js');\nlet libObjectAddressGetValue = require('./Manyfest-ObjectAddress-GetValue.js');\nlet libObjectAddressSetValue = require('./Manyfest-ObjectAddress-SetValue.js');\nlet libObjectAddressDeleteValue = require('./Manyfest-ObjectAddress-DeleteValue.js');\nlet libObjectAddressGeneration = require('./Manyfest-ObjectAddressGeneration.js');\nlet libSchemaManipulation = require('./Manyfest-SchemaManipulation.js');\n\n\n/**\n* Manyfest object address-based descriptions and manipulations.\n*\n* @class Manyfest\n*/\nclass Manyfest\n{\n\tconstructor(pManifest, pInfoLog, pErrorLog, pOptions)\n\t{\n\t\t// Wire in logging\n\t\tthis.logInfo = (typeof(pInfoLog) === 'function') ? pInfoLog : libSimpleLog;\n\t\tthis.logError = (typeof(pErrorLog) === 'function') ? pErrorLog : libSimpleLog;\n\n\t\t// Create an object address resolver and map in the functions\n\t\tthis.objectAddressCheckAddressExists = new libObjectAddressCheckAddressExists(this.logInfo, this.logError);\n\t\tthis.objectAddressGetValue = new libObjectAddressGetValue(this.logInfo, this.logError);\n\t\tthis.objectAddressSetValue = new libObjectAddressSetValue(this.logInfo, this.logError);\n\t\tthis.objectAddressDeleteValue = new libObjectAddressDeleteValue(this.logInfo, this.logError);\n\n\t\tthis.options = (\n\t\t\t{\n\t\t\t\tstrict: false,\n\t\t\t\tdefaultValues:\n\t\t\t\t\t{\n\t\t\t\t\t\t\"String\": \"\",\n\t\t\t\t\t\t\"Number\": 0,\n\t\t\t\t\t\t\"Float\": 0.0,\n\t\t\t\t\t\t\"Integer\": 0,\n\t\t\t\t\t\t\"Boolean\": false,\n\t\t\t\t\t\t\"Binary\": 0,\n\t\t\t\t\t\t\"DateTime\": 0,\n\t\t\t\t\t\t\"Array\": [],\n\t\t\t\t\t\t\"Object\": {},\n\t\t\t\t\t\t\"Null\": null\n\t\t\t\t\t}\n\t\t\t});\n\n\t\tthis.scope = undefined;\n\t\tthis.elementAddresses = undefined;\n\t\tthis.elementHashes = undefined;\n\t\tthis.elementDescriptors = undefined;\n\t\t// This can cause a circular dependency chain, so it only gets initialized if the schema specifically calls for it.\n\t\tthis.dataSolvers = undefined;\n\t\t// So solvers can use their own state\n\t\tthis.dataSolverState = undefined;\n\n\t\tthis.reset();\n\n\t\tif (typeof(pManifest) === 'object')\n\t\t{\n\t\t\tthis.loadManifest(pManifest);\n\t\t}\n\n\t\tthis.schemaManipulations = new libSchemaManipulation(this.logInfo, this.logError);\n\t\tthis.objectAddressGeneration = new libObjectAddressGeneration(this.logInfo, this.logError);\n\n\t\tthis.hashTranslations = new libHashTranslation(this.logInfo, this.logError);\n\t}\n\n\t/*************************************************************************\n\t * Schema Manifest Loading, Reading, Manipulation and Serialization Functions\n\t */\n\n\t// Reset critical manifest properties\n\treset()\n\t{\n\t\tthis.scope = 'DEFAULT';\n\t\tthis.elementAddresses = [];\n\t\tthis.elementHashes = {};\n\t\tthis.elementDescriptors = {};\n\t\tthis.dataSolvers = undefined;\n\t\tthis.dataSolverState = {};\n\n\t\tthis.libElucidator = undefined;\n\t}\n\n\tsetElucidatorSolvers(pElucidatorSolver, pElucidatorSolverState)\n\t{\n\t\tthis.objectAddressCheckAddressExists.elucidatorSolver = pElucidatorSolver;\n\t\tthis.objectAddressGetValue.elucidatorSolver = pElucidatorSolver;\n\t\tthis.objectAddressSetValue.elucidatorSolver = pElucidatorSolver;\n\t\tthis.objectAddressDeleteValue.elucidatorSolver = pElucidatorSolver;\n\n\t\tthis.objectAddressCheckAddressExists.elucidatorSolverState = pElucidatorSolverState;\n\t\tthis.objectAddressGetValue.elucidatorSolverState = pElucidatorSolverState;\n\t\tthis.objectAddressSetValue.elucidatorSolverState = pElucidatorSolverState;\n\t\tthis.objectAddressDeleteValue.elucidatorSolverState = pElucidatorSolverState;\n\t}\n\n\tclone()\n\t{\n\t\t// Make a copy of the options in-place\n\t\tlet tmpNewOptions = JSON.parse(JSON.stringify(this.options));\n\n\t\tlet tmpNewManyfest = new Manyfest(this.getManifest(), this.logInfo, this.logError, tmpNewOptions);\n\n\t\t// Import the hash translations\n\t\ttmpNewManyfest.hashTranslations.addTranslation(this.hashTranslations.translationTable);\n\n\t\treturn tmpNewManyfest;\n\t}\n\n\t// Deserialize a Manifest from a string\n\tdeserialize(pManifestString)\n\t{\n\t\t// TODO: Add guards for bad manifest string\n\t\treturn this.loadManifest(JSON.parse(pManifestString));\n\t}\n\n\t// Load a manifest from an object\n\tloadManifest(pManifest)\n\t{\n\t\tif (typeof(pManifest) !== 'object')\n\t\t{\n\t\t\tthis.logError(`(${this.scope}) Error loading manifest; expecting an object but parameter was type ${typeof(pManifest)}.`);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (pManifest.hasOwnProperty('Scope'))\n\t\t{\n\t\t\tif (typeof(pManifest.Scope) === 'string')\n\t\t\t{\n\t\t\t\tthis.scope = pManifest.Scope;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.logError(`(${this.scope}) Error loading scope from manifest; expecting a string but property was type ${typeof(pManifest.Scope)}.`, pManifest);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.logError(`(${this.scope}) Error loading scope from manifest object.  Property \"Scope\" does not exist in the root of the object.`, pManifest);\n\t\t}\n\n\t\tif (pManifest.hasOwnProperty('Descriptors'))\n\t\t{\n\t\t\tif (typeof(pManifest.Descriptors) === 'object')\n\t\t\t{\n\t\t\t\tlet tmpDescriptionAddresses = Object.keys(pManifest.Descriptors);\n\t\t\t\tfor (let i = 0; i < tmpDescriptionAddresses.length; i++)\n\t\t\t\t{\n\t\t\t\t\tthis.addDescriptor(tmpDescriptionAddresses[i], pManifest.Descriptors[tmpDescriptionAddresses[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.logError(`(${this.scope}) Error loading description object from manifest object.  Expecting an object in 'Manifest.Descriptors' but the property was type ${typeof(pManifest.Descriptors)}.`, pManifest);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.logError(`(${this.scope}) Error loading object description from manifest object.  Property \"Descriptors\" does not exist in the root of the Manifest object.`, pManifest);\n\t\t}\n\n\t\t// This seems like it would create a circular dependency issue but it only goes as deep as the schema defines Solvers\n\t\tif ((pManifest.hasOwnProperty('Solvers')) && (typeof(pManifest.Solvers) == 'object'))\n\t\t{\n\t\t\t// There are elucidator solvers passed-in, so we will create one to filter data.\n\t\t\tlet libElucidator = require('elucidator');\n\t\t\t// WARNING THESE CAN MUTATE THE DATA\n\t\t\t\t// The pattern for the solver is: {<~~SolverName~~>} anywhere in a property.\n\t\t\t\t//   Yes, this means your Javascript elements can't have my self-styled jellyfish brackets in them.\n\t\t\t\t//   This does, though, mean we can filter at multiple layers safely.\n\t\t\t\t//   Because these can be put at any address\n\t\t\t// The solver themselves:\n\t\t\t\t//   They are passed-in an object, and the current record is in the Record subobject.\n\t\t\t\t//   Basic operations can just write to the root object but...\n\t\t\t\t//   IF YOU PERMUTE THE Record SUBOBJECT YOU CAN AFFECT RECURSION\n\t\t\t// This is mostly meant for if statements to filter.\n\t\t\t\t//   Basically on aggregation, if a filter is set it will set \"keep record\" to true and let the solver decide differently.\n\t\t\tthis.dataSolvers = new libElucidator(pManifest.Solvers, this.logInfo, this.logError);\n\n\t\t\t// Load the solver state in so each instruction can have internal config\n\t\t\t// TODO: Should this just be a part of the lower layer pattern?\n\t\t\tlet tmpSolverKeys = Object.keys(pManifest.Solvers)\n\t\t\tfor (let i = 0; i < tmpSolverKeys.length; i++)\n\t\t\t{\n\t\t\t\tthis.dataSolverState[tmpSolverKeys] = pManifest.Solvers[tmpSolverKeys[i]];\n\t\t\t}\n\n\t\t\tthis.setElucidatorSolvers(this.dataSolvers, this.dataSolverState);\n\t\t}\n\t}\n\n\t// Serialize the Manifest to a string\n\t// TODO: Should this also serialize the translation table?\n\tserialize()\n\t{\n\t\treturn JSON.stringify(this.getManifest());\n\t}\n\n\tgetManifest()\n\t{\n\t\treturn (\n\t\t\t{\n\t\t\t\tScope: this.scope,\n\t\t\t\tDescriptors: JSON.parse(JSON.stringify(this.elementDescriptors))\n\t\t\t});\n\t}\n\n\t// Add a descriptor to the manifest\n\taddDescriptor(pAddress, pDescriptor)\n\t{\n\t\tif (typeof(pDescriptor) === 'object')\n\t\t{\n\t\t\t// Add the Address into the Descriptor if it doesn't exist:\n\t\t\tif (!pDescriptor.hasOwnProperty('Address'))\n\t\t\t{\n\t\t\t\tpDescriptor.Address = pAddress;\n\t\t\t}\n\n\t\t\tif (!this.elementDescriptors.hasOwnProperty(pAddress))\n\t\t\t{\n\t\t\t\tthis.elementAddresses.push(pAddress);\n\t\t\t}\n\n\t\t\t// Add the element descriptor to the schema\n\t\t\tthis.elementDescriptors[pAddress] = pDescriptor;\n\n\t\t\t// Always add the address as a hash\n\t\t\tthis.elementHashes[pAddress] = pAddress;\n\n\t\t\tif (pDescriptor.hasOwnProperty('Hash'))\n\t\t\t{\n\t\t\t\t// TODO: Check if this is a good idea or not..\n\t\t\t\t//       Collisions are bound to happen with both representations of the address/hash in here and developers being able to create their own hashes.\n\t\t\t\tthis.elementHashes[pDescriptor.Hash] = pAddress;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpDescriptor.Hash = pAddress;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.logError(`(${this.scope}) Error loading object descriptor for address '${pAddress}' from manifest object.  Expecting an object but property was type ${typeof(pDescriptor)}.`);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tgetDescriptorByHash(pHash)\n\t{\n\t\treturn this.getDescriptor(this.resolveHashAddress(pHash));\n\t}\n\n\tgetDescriptor(pAddress)\n\t{\n\t\treturn this.elementDescriptors[pAddress];\n\t}\n\n\t// execute an action function for each descriptor\n\teachDescriptor(fAction)\n\t{\n        let tmpDescriptorAddresses = Object.keys(this.elementDescriptors);\n        for (let i = 0; i < tmpDescriptorAddresses.length; i++)\n        {\n            fAction(this.elementDescriptors[tmpDescriptorAddresses[i]]);\n        }\n\n\t}\n\n\t/*************************************************************************\n\t * Beginning of Object Manipulation (read & write) Functions\n\t */\n\t// Check if an element exists by its hash\n\tcheckAddressExistsByHash (pObject, pHash)\n\t{\n\t\treturn this.checkAddressExists(pObject,this.resolveHashAddress(pHash));\n\t}\n\n\t// Check if an element exists at an address\n\tcheckAddressExists (pObject, pAddress)\n\t{\n\t\treturn this.objectAddressCheckAddressExists.checkAddressExists(pObject, pAddress);\n\t}\n\n\t// Turn a hash into an address, factoring in the translation table.\n\tresolveHashAddress(pHash)\n\t{\n\t\tlet tmpAddress = undefined;\n\n\t\tlet tmpInElementHashTable = this.elementHashes.hasOwnProperty(pHash);\n\t\tlet tmpInTranslationTable = this.hashTranslations.translationTable.hasOwnProperty(pHash);\n\n\t\t// The most straightforward: the hash exists, no translations.\n\t\tif (tmpInElementHashTable && !tmpInTranslationTable)\n\t\t{\n\t\t\ttmpAddress = this.elementHashes[pHash];\n\t\t}\n\t\t// There is a translation from one hash to another, and, the elementHashes contains the pointer end\n\t\telse if (tmpInTranslationTable && this.elementHashes.hasOwnProperty(this.hashTranslations.translate(pHash)))\n\t\t{\n\t\t\ttmpAddress = this.elementHashes[this.hashTranslations.translate(pHash)];\n\t\t}\n\t\t// Use the level of indirection only in the Translation Table\n\t\telse if (tmpInTranslationTable)\n\t\t{\n\t\t\ttmpAddress = this.hashTranslations.translate(pHash);\n\t\t}\n\t\t// Just treat the hash as an address.\n\t\t// TODO: Discuss this ... it is magic but controversial\n\t\telse\n\t\t{\n\t\t\ttmpAddress = pHash;\n\t\t}\n\n\t\treturn tmpAddress;\n\t}\n\n\t// Get the value of an element by its hash\n\tgetValueByHash (pObject, pHash)\n\t{\n\t\tlet tmpValue = this.getValueAtAddress(pObject, this.resolveHashAddress(pHash));\n\n\t\tif (typeof(tmpValue) == 'undefined')\n\t\t{\n\t\t\t// Try to get a default if it exists\n\t\t\ttmpValue = this.getDefaultValue(this.getDescriptorByHash(pHash));\n\t\t}\n\n\t\treturn tmpValue;\n\t}\n\n\t// Get the value of an element at an address\n\tgetValueAtAddress (pObject, pAddress)\n\t{\n\t\tlet tmpValue = this.objectAddressGetValue.getValueAtAddress(pObject, pAddress);\n\n\t\tif (typeof(tmpValue) == 'undefined')\n\t\t{\n\t\t\t// Try to get a default if it exists\n\t\t\ttmpValue = this.getDefaultValue(this.getDescriptor(pAddress));\n\t\t}\n\n\t\treturn tmpValue;\n\t}\n\n\t// Set the value of an element by its hash\n\tsetValueByHash(pObject, pHash, pValue)\n\t{\n\t\treturn this.setValueAtAddress(pObject, this.resolveHashAddress(pHash), pValue);\n\t}\n\n\t// Set the value of an element at an address\n\tsetValueAtAddress (pObject, pAddress, pValue)\n\t{\n\t\treturn this.objectAddressSetValue.setValueAtAddress(pObject, pAddress, pValue);\n\t}\n\n\t// Delete the value of an element by its hash\n\tdeleteValueByHash(pObject, pHash, pValue)\n\t{\n\t\treturn this.deleteValueAtAddress(pObject, this.resolveHashAddress(pHash), pValue);\n\t}\n\n\t// Delete the value of an element at an address\n\tdeleteValueAtAddress (pObject, pAddress, pValue)\n\t{\n\t\treturn this.objectAddressDeleteValue.deleteValueAtAddress(pObject, pAddress, pValue);\n\t}\n\n\t// Validate the consistency of an object against the schema\n\tvalidate(pObject)\n\t{\n\t\tlet tmpValidationData =\n\t\t{\n\t\t\tError: null,\n\t\t\tErrors: [],\n\t\t\tMissingElements:[]\n\t\t};\n\n\t\tif (typeof(pObject) !== 'object')\n\t\t{\n\t\t\ttmpValidationData.Error = true;\n\t\t\ttmpValidationData.Errors.push(`Expected passed in object to be type object but was passed in ${typeof(pObject)}`);\n\t\t}\n\n\t\tlet addValidationError = (pAddress, pErrorMessage) =>\n\t\t{\n\t\t\ttmpValidationData.Error = true;\n\t\t\ttmpValidationData.Errors.push(`Element at address \"${pAddress}\" ${pErrorMessage}.`);\n\t\t};\n\n\t\t// Now enumerate through the values and check for anomalies based on the schema\n\t\tfor (let i = 0; i < this.elementAddresses.length; i++)\n\t\t{\n\t\t\tlet tmpDescriptor = this.getDescriptor(this.elementAddresses[i]);\n\t\t\tlet tmpValueExists = this.checkAddressExists(pObject, tmpDescriptor.Address);\n\t\t\tlet tmpValue = this.getValueAtAddress(pObject, tmpDescriptor.Address);\n\n\t\t\tif ((typeof(tmpValue) == 'undefined') || !tmpValueExists)\n\t\t\t{\n\t\t\t\t// This will technically mean that `Object.Some.Value = undefined` will end up showing as \"missing\"\n\t\t\t\t// TODO: Do we want to do a different message based on if the property exists but is undefined?\n\t\t\t\ttmpValidationData.MissingElements.push(tmpDescriptor.Address);\n\t\t\t\tif (tmpDescriptor.Required || this.options.strict)\n\t\t\t\t{\n\t\t\t\t\taddValidationError(tmpDescriptor.Address, 'is flagged REQUIRED but is not set in the object');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Now see if there is a data type specified for this element\n\t\t\tif (tmpDescriptor.DataType)\n\t\t\t{\n\t\t\t\tlet tmpElementType = typeof(tmpValue);\n\t\t\t\tswitch(tmpDescriptor.DataType.toString().trim().toLowerCase())\n\t\t\t\t{\n\t\t\t\t\tcase 'string':\n\t\t\t\t\t\tif (tmpElementType != 'string')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but is of the type ${tmpElementType}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'number':\n\t\t\t\t\t\tif (tmpElementType != 'number')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but is of the type ${tmpElementType}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'integer':\n\t\t\t\t\t\tif (tmpElementType != 'number')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but is of the type ${tmpElementType}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlet tmpValueString = tmpValue.toString();\n\t\t\t\t\t\t\tif (tmpValueString.indexOf('.') > -1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// TODO: Is this an error?\n\t\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but has a decimal point in the number.`);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'float':\n\t\t\t\t\t\tif (tmpElementType != 'number')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but is of the type ${tmpElementType}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'DateTime':\n\t\t\t\t\t\tlet tmpValueDate = new Date(tmpValue);\n\t\t\t\t\t\tif (tmpValueDate.toString() == 'Invalid Date')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} but is not parsable as a Date by Javascript`);\n\t\t\t\t\t\t}\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t// Check if this is a string, in the default case\n\t\t\t\t\t\t// Note this is only when a DataType is specified and it is an unrecognized data type.\n\t\t\t\t\t\tif (tmpElementType != 'string')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\taddValidationError(tmpDescriptor.Address, `has a DataType ${tmpDescriptor.DataType} (which auto-converted to String because it was unrecognized) but is of the type ${tmpElementType}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn tmpValidationData;\n\t}\n\n\t// Returns a default value, or, the default value for the data type (which is overridable with configuration)\n\tgetDefaultValue(pDescriptor)\n\t{\n\t\tif (typeof(pDescriptor) != 'object')\n\t\t{\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (pDescriptor.hasOwnProperty('Default'))\n\t\t{\n\t\t\treturn pDescriptor.Default;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Default to a null if it doesn't have a type specified.\n\t\t\t// This will ensure a placeholder is created but isn't misinterpreted.\n\t\t\tlet tmpDataType = (pDescriptor.hasOwnProperty('DataType')) ? pDescriptor.DataType : 'String';\n\t\t\tif (this.options.defaultValues.hasOwnProperty(tmpDataType))\n\t\t\t{\n\t\t\t\treturn this.options.defaultValues[tmpDataType];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// give up and return null\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Enumerate through the schema and populate default values if they don't exist.\n\tpopulateDefaults(pObject, pOverwriteProperties)\n\t{\n\t\treturn this.populateObject(pObject, pOverwriteProperties,\n\t\t\t// This just sets up a simple filter to see if there is a default set.\n\t\t\t(pDescriptor) =>\n\t\t\t{\n\t\t\t\treturn pDescriptor.hasOwnProperty('Default');\n\t\t\t});\n\t}\n\n\t// Forcefully populate all values even if they don't have defaults.\n\t// Based on type, this can do unexpected things.\n\tpopulateObject(pObject, pOverwriteProperties, fFilter)\n\t{\n\t\t// Automatically create an object if one isn't passed in.\n\t\tlet tmpObject = (typeof(pObject) === 'object') ? pObject : {};\n\t\t// Default to *NOT OVERWRITING* properties\n\t\tlet tmpOverwriteProperties = (typeof(pOverwriteProperties) == 'undefined') ? false : pOverwriteProperties;\n\t\t// This is a filter function, which is passed the schema and allows complex filtering of population\n\t\t// The default filter function just returns true, populating everything.\n\t\tlet tmpFilterFunction = (typeof(fFilter) == 'function') ? fFilter : (pDescriptor) => { return true; };\n\n\t\tthis.elementAddresses.forEach(\n\t\t\t(pAddress) =>\n\t\t\t{\n\t\t\t\tlet tmpDescriptor = this.getDescriptor(pAddress);\n\t\t\t\t// Check the filter function to see if this is an address we want to set the value for.\n\t\t\t\tif (tmpFilterFunction(tmpDescriptor))\n\t\t\t\t{\n\t\t\t\t\t// If we are overwriting properties OR the property does not exist\n\t\t\t\t\tif (tmpOverwriteProperties || !this.checkAddressExists(tmpObject, pAddress))\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.setValueAtAddress(tmpObject, pAddress, this.getDefaultValue(tmpDescriptor));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\treturn tmpObject;\n\t}\n};\n\nmodule.exports = Manyfest;","/**\n* Precedent Meta-Templating\n*\n* @license     MIT\n*\n* @author      Steven Velozo <steven@velozo.com>\n*\n* @description Process text streams, parsing out meta-template expressions.\n*/\nvar libWordTree = require(`./WordTree.js`);\nvar libStringParser = require(`./StringParser.js`);\n\nclass Precedent\n{\n\t/**\n\t * Precedent Constructor\n\t */\n\tconstructor()\n\t{\n\t\tthis.WordTree = new libWordTree();\n\t\t\n\t\tthis.StringParser = new libStringParser();\n\n\t\tthis.ParseTree = this.WordTree.ParseTree;\n\t}\n\t\n\t/**\n\t * Add a Pattern to the Parse Tree\n\t * @method addPattern\n\t * @param {Object} pTree - A node on the parse tree to push the characters into\n\t * @param {string} pPattern - The string to add to the tree\n\t * @param {number} pIndex - callback function\n\t * @return {bool} True if adding the pattern was successful\n\t */\n\taddPattern(pPatternStart, pPatternEnd, pParser)\n\t{\n\t\treturn this.WordTree.addPattern(pPatternStart, pPatternEnd, pParser);\n\t}\n\t\n\t/**\n\t * Parse a string with the existing parse tree\n\t * @method parseString\n\t * @param {string} pString - The string to parse\n\t * @return {string} The result from the parser\n\t */\n\tparseString(pString)\n\t{\n\t\treturn this.StringParser.parseString(pString, this.ParseTree);\n\t}\n}\n\nmodule.exports = Precedent;\n","/**\n* String Parser\n*\n* @license     MIT\n*\n* @author      Steven Velozo <steven@velozo.com>\n*\n* @description Parse a string, properly processing each matched token in the word tree.\n*/\n\nclass StringParser\n{\n\t/**\n\t * StringParser Constructor\n\t */\n\tconstructor()\n\t{\n\t}\n\t\n\t/**\n\t * Create a fresh parsing state object to work with.\n\t * @method newParserState\n\t * @param {Object} pParseTree - A node on the parse tree to begin parsing from (usually root)\n\t * @return {Object} A new parser state object for running a character parser on\n\t * @private\n\t */\n\tnewParserState (pParseTree)\n\t{\n\t\treturn (\n\t\t{\n\t\t\tParseTree: pParseTree,\n\n\t\t\tOutput: '',\n\t\t\tOutputBuffer: '',\n\n\t\t\tPattern: false,\n\n\t\t\tPatternMatch: false,\n\t\t\tPatternMatchOutputBuffer: ''\n\t\t});\n\t}\n\t\t\n\t/**\n\t * Assign a node of the parser tree to be the next potential match.\n\t * If the node has a PatternEnd property, it is a valid match and supercedes the last valid match (or becomes the initial match).\n\t * @method assignNode\n\t * @param {Object} pNode - A node on the parse tree to assign\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tassignNode (pNode, pParserState)\n\t{\n\t\tpParserState.PatternMatch = pNode;\n\n\t\t// If the pattern has a END we can assume it has a parse function...\n\t\tif (pParserState.PatternMatch.hasOwnProperty('PatternEnd'))\n\t\t{\n\t\t\t// ... this is the legitimate start of a pattern.\n\t\t\tpParserState.Pattern = pParserState.PatternMatch;\n\t\t}\n\t}\n\t\n\t/**\n\t * Append a character to the output buffer in the parser state.\n\t * This output buffer is used when a potential match is being explored, or a match is being explored.\n\t * @method appendOutputBuffer\n\t * @param {string} pCharacter - The character to append\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tappendOutputBuffer (pCharacter, pParserState)\n\t{\n\t\tpParserState.OutputBuffer += pCharacter;\n\t}\n\t\n\t/**\n\t * Flush the output buffer to the output and clear it.\n\t * @method flushOutputBuffer\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tflushOutputBuffer (pParserState)\n\t{\n\t\tpParserState.Output += pParserState.OutputBuffer;\n\t\tpParserState.OutputBuffer = '';\n\t}\n\n\t\n\t/**\n\t * Check if the pattern has ended.  If it has, properly flush the buffer and start looking for new patterns.\n\t * @method checkPatternEnd\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tcheckPatternEnd (pParserState)\n\t{\n\t\tif ((pParserState.OutputBuffer.length >= pParserState.Pattern.PatternEnd.length+pParserState.Pattern.PatternStart.length) && \n\t\t\t(pParserState.OutputBuffer.substr(-pParserState.Pattern.PatternEnd.length) === pParserState.Pattern.PatternEnd))\n\t\t{\n\t\t\t// ... this is the end of a pattern, cut off the end tag and parse it.\n\t\t\t// Trim the start and end tags off the output buffer now\n\t\t\tpParserState.OutputBuffer = pParserState.Pattern.Parse(pParserState.OutputBuffer.substr(pParserState.Pattern.PatternStart.length, pParserState.OutputBuffer.length - (pParserState.Pattern.PatternStart.length+pParserState.Pattern.PatternEnd.length)));\n\t\t\t// Flush the output buffer.\n\t\t\tthis.flushOutputBuffer(pParserState);\n\t\t\t// End pattern mode\n\t\t\tpParserState.Pattern = false;\n\t\t\tpParserState.PatternMatch = false;\n\t\t}\n\t}\n\t\n\t/**\n\t * Parse a character in the buffer.\n\t * @method parseCharacter\n\t * @param {string} pCharacter - The character to append\n\t * @param {Object} pParserState - The state object for the current parsing task\n\t * @private\n\t */\n\tparseCharacter (pCharacter, pParserState)\n\t{\n\t\t// (1) If we aren't in a pattern match, and we aren't potentially matching, and this may be the start of a new pattern....\n\t\tif (!pParserState.PatternMatch && pParserState.ParseTree.hasOwnProperty(pCharacter))\n\t\t{\n\t\t\t// ... assign the node as the matched node.\n\t\t\tthis.assignNode(pParserState.ParseTree[pCharacter], pParserState);\n\t\t\tthis.appendOutputBuffer(pCharacter, pParserState);\n\t\t}\n\t\t// (2) If we are in a pattern match (actively seeing if this is part of a new pattern token)\n\t\telse if (pParserState.PatternMatch)\n\t\t{\n\t\t\t// If the pattern has a subpattern with this key\n\t\t\tif (pParserState.PatternMatch.hasOwnProperty(pCharacter))\n\t\t\t{\n\t\t\t\t// Continue matching patterns.\n\t\t\t\tthis.assignNode(pParserState.PatternMatch[pCharacter], pParserState);\n\t\t\t}\n\t\t\tthis.appendOutputBuffer(pCharacter, pParserState);\n\t\t\tif (pParserState.Pattern)\n\t\t\t{\n\t\t\t\t// ... Check if this is the end of the pattern (if we are matching a valid pattern)...\n\t\t\t\tthis.checkPatternEnd(pParserState);\n\t\t\t}\n\t\t}\n\t\t// (3) If we aren't in a pattern match or pattern, and this isn't the start of a new pattern (RAW mode)....\n\t\telse\n\t\t{\n\t\t\tpParserState.Output += pCharacter;\n\t\t}\n\t}\n\t\n\t/**\n\t * Parse a string for matches, and process any template segments that occur.\n\t * @method parseString\n\t * @param {string} pString - The string to parse.\n\t * @param {Object} pParseTree - The parse tree to begin parsing from (usually root)\n\t */\n\tparseString (pString, pParseTree)\n\t{\n\t\tlet tmpParserState = this.newParserState(pParseTree);\n\n\t\tfor (var i = 0; i < pString.length; i++)\n\t\t{\n\t\t\t// TODO: This is not fast.\n\t\t\tthis.parseCharacter(pString[i], tmpParserState);\n\t\t}\n\t\t\n\t\tthis.flushOutputBuffer(tmpParserState);\n\t\t\n\t\treturn tmpParserState.Output;\n\t}\n}\n\nmodule.exports = StringParser;\n","/**\n* Word Tree\n*\n* @license     MIT\n*\n* @author      Steven Velozo <steven@velozo.com>\n*\n* @description Create a tree (directed graph) of Javascript objects, one character per object.\n*/\n\nclass WordTree\n{\n\t/**\n\t * WordTree Constructor\n\t */\n\tconstructor()\n\t{\n\t\tthis.ParseTree = {};\n\t}\n\t\n\t/** \n\t * Add a child character to a Parse Tree node\n\t * @method addChild\n\t * @param {Object} pTree - A parse tree to push the characters into\n\t * @param {string} pPattern - The string to add to the tree\n\t * @param {number} pIndex - The index of the character in the pattern\n\t * @returns {Object} The resulting leaf node that was added (or found)\n\t * @private\n\t */\n\taddChild (pTree, pPattern, pIndex)\n\t{\n\t\tif (!pTree.hasOwnProperty(pPattern[pIndex]))\n\t\t\tpTree[pPattern[pIndex]] = {};\n\t\t\n\t\treturn pTree[pPattern[pIndex]];\n\t}\n\t\n\t/** Add a Pattern to the Parse Tree\n\t * @method addPattern\n\t * @param {Object} pPatternStart - The starting string for the pattern (e.g. \"${\")\n\t * @param {string} pPatternEnd - The ending string for the pattern (e.g. \"}\")\n\t * @param {number} pParser - The function to parse if this is the matched pattern, once the Pattern End is met.  If this is a string, a simple replacement occurs.\n\t * @return {bool} True if adding the pattern was successful\n\t */\n\taddPattern (pPatternStart, pPatternEnd, pParser)\n\t{\n\t\tif (pPatternStart.length < 1)\n\t\t\treturn false;\n\n\t\tif ((typeof(pPatternEnd) === 'string') && (pPatternEnd.length < 1))\n\t\t\treturn false;\n\n\t\tlet tmpLeaf = this.ParseTree;\n\n\t\t// Add the tree of leaves iteratively\n\t\tfor (var i = 0; i < pPatternStart.length; i++)\n\t\t\ttmpLeaf = this.addChild(tmpLeaf, pPatternStart, i);\n\n\t\ttmpLeaf.PatternStart = pPatternStart;\n\t\ttmpLeaf.PatternEnd = ((typeof(pPatternEnd) === 'string') && (pPatternEnd.length > 0)) ? pPatternEnd : pPatternStart;\n\t\ttmpLeaf.Parse = (typeof(pParser) === 'function') ? pParser : \n\t\t\t\t\t\t(typeof(pParser) === 'string') ? () => { return pParser; } :\n\t\t\t\t\t\t(pData) => { return pData; };\n\n\t\treturn true;\n\t}\n}\n\nmodule.exports = WordTree;\n","/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\n\n/**\n* Elucidator browser shim loader\n*/\n\n// Load the manyfest module into the browser global automatically.\nvar libElucidator = require('./Elucidator.js');\n\nif (typeof(window) === 'object') window.Elucidator = libElucidator;\n\nmodule.exports = libElucidator;","module.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"PreciseMath\",\n\t\t\"Operation\": \"Aggregate\",\n\t\t\"Synopsis\": \"Precisely aggregate a set of numbers (from array or object address):  x = a + b + ... + z\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"a\": { \"Hash\": \"a\", \"Type\": \"Set\" },\n\t\t\"ValueNames\": { \"Hash\": \"ValueNames\", \"Type\": \"Set\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"x\": { \"Hash\": \"x\", \"Type\": \"Number\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Aggregate all numeric values in {{Name:a}}, storing the resultant in {{Name:x}}.\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:x}} = {{OutputValue:x}}\"\t\t\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"PreciseMath\",\n\t\t\t\"Instruction\": \"aggregate\"\n\t\t}\n\t]\n}"]}