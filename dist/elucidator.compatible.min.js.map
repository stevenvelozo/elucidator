{"version":3,"sources":["elucidator.compatible.min.js","node_modules/browser-pack/_prelude.js","node_modules/decimal.js/decimal.js","node_modules/fable-serviceproviderbase/source/Fable-ServiceProviderBase-Preinit.js","node_modules/fable-serviceproviderbase/source/Fable-ServiceProviderBase.js","source/Elucidator-InstructionSet.js","source/Elucidator.js","source/InstructionSets/Geometry.js","source/InstructionSets/Logic.js","source/InstructionSets/Math-Javascript.js","source/InstructionSets/Operations/Geometry-RectangleArea.json","source/InstructionSets/Operations/Logic-Execute.json","source/InstructionSets/Operations/Logic-If.json","source/InstructionSets/Operations/Math-Add.json","source/InstructionSets/Operations/Math-Aggregate.json","source/InstructionSets/Operations/Math-Divide.json","source/InstructionSets/Operations/Math-Multiply.json","source/InstructionSets/Operations/Math-Subtract.json","source/InstructionSets/Operations/PreciseMath-Add.json","source/InstructionSets/Operations/PreciseMath-Aggregate.json","source/InstructionSets/Operations/PreciseMath-Divide.json","source/InstructionSets/Operations/PreciseMath-GroupValuesAndAggregate.json","source/InstructionSets/Operations/PreciseMath-Multiply.json","source/InstructionSets/Operations/PreciseMath-Round.json","source/InstructionSets/Operations/PreciseMath-SetPrecision.json","source/InstructionSets/Operations/PreciseMath-SetRoundingMode.json","source/InstructionSets/Operations/PreciseMath-Subtract.json","source/InstructionSets/Operations/PreciseMath-ToDecimalPlaces.json","source/InstructionSets/Operations/PreciseMath-ToSignificantDigits.json","source/InstructionSets/Operations/Set-GroupValuesBy.json","source/InstructionSets/Operations/String-Replace.json","source/InstructionSets/Operations/String-Substring.json","source/InstructionSets/Operations/String-Trim.json","source/InstructionSets/PreciseMath-Decimal.js","source/InstructionSets/Set.js","source/InstructionSets/String.js"],"names":["_get","Reflect","get","bind","target","property","receiver","base","_superPropBase","desc","Object","getOwnPropertyDescriptor","call","arguments","length","value","apply","this","object","prototype","hasOwnProperty","_getPrototypeOf","_inherits","subClass","superClass","TypeError","create","constructor","writable","configurable","defineProperty","_setPrototypeOf","o","p","setPrototypeOf","__proto__","_createSuper","Derived","hasNativeReflectConstruct","_isNativeReflectConstruct","result","Super","NewTarget","construct","_possibleConstructorReturn","self","_typeof","_assertThisInitialized","ReferenceError","sham","Proxy","Boolean","valueOf","e","getPrototypeOf","_classCallCheck","instance","Constructor","_defineProperties","props","i","descriptor","enumerable","_toPropertyKey","key","_createClass","protoProps","staticProps","_defineProperty","obj","arg","_toPrimitive","String","input","hint","prim","Symbol","toPrimitive","undefined","res","Number","iterator","f","exports","module","define","amd","window","global","Elucidator","r","n","t","c","require","u","a","Error","code","globalScope","Decimal","inexact","noConflict","quadrant","EXP_LIMIT","MAX_DIGITS","NUMERALS","LN10","PI","DEFAULTS","precision","rounding","modulo","toExpNeg","toExpPos","minE","maxE","crypto","external","decimalError","invalidArgument","precisionLimitExceeded","cryptoUnavailable","tag","mathfloor","Math","floor","mathpow","pow","isBinary","isHex","isOctal","isDecimal","BASE","LOG_BASE","LN10_PRECISION","PI_PRECISION","P","toStringTag","digitsToString","d","k","ws","indexOfLastWord","str","w","getZeroString","checkInt32","min","max","checkRoundingDigits","rm","repeating","di","rd","ceil","convertBase","baseIn","baseOut","j","arrL","arr","strL","indexOf","charAt","reverse","absoluteValue","abs","x","s","finalise","clampedTo","clamp","Ctor","NaN","gt","cmp","comparedTo","y","xdL","ydL","xd","yd","xs","ys","cosine","cos","pr","sd","len","isZero","tinyPow","toString","taylorSeries","times","cos2x","minus","plus","toLessThanHalfPi","neg","cubeRoot","cbrt","m","rep","t3","t3plusx","isFinite","toExponential","slice","divide","eq","decimalPlaces","dp","dividedBy","div","dividedToIntegerBy","divToInt","equals","greaterThan","greaterThanOrEqualTo","gte","hyperbolicCosine","cosh","one","cosh2_x","d8","hyperbolicSine","sinh","sqrt","sinh2_x","d5","d16","d20","hyperbolicTangent","tanh","inverseCosine","acos","halfPi","isNeg","getPi","asin","inverseHyperbolicCosine","acosh","lte","ln","inverseHyperbolicSine","asinh","inverseHyperbolicTangent","atanh","wpr","xsd","inverseSine","atan","inverseTangent","px","x2","isInteger","isInt","isNaN","isNegative","isPositive","isPos","lessThan","lt","lessThanOrEqualTo","logarithm","log","isBase10","denominator","inf","num","naturalLogarithm","getLn10","sub","xe","xLTy","push","pop","shift","getBase10Exponent","mod","q","naturalExponential","exp","negated","add","carry","unshift","z","getPrecision","round","sine","sin","sin2_x","squareRoot","tangent","tan","mul","rL","toBinary","toStringBinary","toDecimalPlaces","toDP","finiteToString","toFixed","toFraction","maxD","d0","d1","d2","n0","n1","toHexadecimal","toHex","toNearest","toNumber","toOctal","toPower","yn","intPow","toPrecision","toSignificantDigits","toSD","truncated","trunc","toJSON","multiplyInteger","temp","compare","b","aL","bL","subtract","logBase","more","prod","prodL","qd","rem","remL","rem0","xi","xL","yd0","yL","yz","sign","isTruncated","digits","roundUp","xdi","out","isExp","nonFiniteToString","zs","truncate","isOdd","maxOrMin","args","ltgt","guard","sum","c0","numerator","x1","parseDecimal","replace","search","substring","charCodeAt","parseOther","divisor","isFloat","test","toLowerCase","isHyperbolic","pi","atan2","config","v","useDefaults","defaults","ps","getRandomValues","randomBytes","hypot","isDecimalInstance","log2","log10","random","Uint32Array","copy","clone","ROUND_UP","ROUND_DOWN","ROUND_CEIL","ROUND_FLOOR","ROUND_HALF_UP","ROUND_HALF_DOWN","ROUND_HALF_EVEN","ROUND_HALF_CEIL","ROUND_HALF_FLOOR","EUCLID","set","FableCoreServiceProviderBase","pOptions","pServiceHash","fable","options","serviceType","UUID","concat","Hash","pFable","FableServiceProviderBase","isFable","getUUID","servicesMap","serviceMap","services","CoreServiceProviderBase","ElucidatorInstructionSet","pElucidator","elucidator","namespace","pNamespace","instructionSets","operationSets","pInstructionHash","fInstructionFunction","error","addInstruction","pOperation","info","pOperationHash","Description","Operation","Namespace","Summary","Inputs","Outputs","Steps","Array","isArray","addOperation","libFableServiceProviderBase","libElucidatorInstructionSet","_libFableServiceProvi","_super","_this","loadDefaultInstructionSets","OperationSet","tmpSolverHashes","keys","cInstructionSet","tmpInstructionSet","initializeNamespace","initializeInstructions","initializeOperations","loadInstructionSet","tmpNamespace","tmpOperationInjector","pInputObject","pOutputObject","pDescriptionManyfest","pInputAddressMapping","pOutputAddressMapping","pSolutionContext","operationExists","tmpOperation","solveOperation","pOperationObject","_this2","JSON","parse","stringify","tmpInputObject","tmpOutputObject","tmpSolutionContext","SolutionGUID","SolutionBaseNamespace","SolutionBaseOperation","SolutionLog","InputHashMapping","InputHashTranslationTable","OutputHashMapping","OutputHashTranslationTable","tmpOutputHashMapping","tmpInputHashMapping","tmpDescriptionManyfest","serviceManager","instantiateServiceProviderWithoutRegistration","schemaManipulations","mergeAddressMappings","resolveAddressMappings","hashTranslations","addTranslation","SolutionContext","Synopsys","tmpPrecedent","addPattern","pHash","tmpHash","trim","tmpDescriptor","getDescriptorByHash","Name","getValueByHash","Log","PreOperation","parseString","_loop","_i","tmpStep","tmpInputSchema","Scope","Descriptors","InputHashAddressMap","tmpInputManyfest","tmpOutputSchema","OutputHashAddressMap","tmpOutputManyfest","tmpInstructionState","Instruction","DescriptionManyfest","InputObject","InputManyfest","OutputObject","OutputManyfest","logError","pMessage","tmpErrorMessage","logInfo","tmpInfoMessage","fInstruction","solveInternalOperation","PostOperation","Geometry","_libElucidatorInstruc","_super2","_this3","ifInstruction","tmpLeftValue","tmpRightValue","tmpComparator","tmpComparisonOperator","tmpComparisonOperatorMapping","equal","noteq","notequal","id","identity","greaterthan","greaterthanorequal","lessthan","lessthanorequal","tmpTrueNamespace","tmpTrueOperation","tmpFalseNamespace","tmpFalseOperation","tmpTruthiness","setValueByHash","executeOperation","Logic","_libElucidatorInstruc2","_super3","_this4","tmpA","tmpB","multiply","aggregate","tmpAggregationValue","tmpValue","parseInt","tmpObjectKeys","MathJavascript","_libElucidatorInstruc3","_super4","_this5","Synopsis","Width","Type","Height","Area","Ratio","Default","operation","leftValue","rightValue","comparator","trueNamespace","trueOperation","falseNamespace","falseOperation","truthinessResult","ValueNames","inputDataSet","groupByProperty","groupValueProperty","recordIndicatorProperty","outputDataSet","roundingmode","decimalplaces","inputString","searchFor","replaceWith","outputString","indexStart","indexEnd","libDecimal","tmpPrecision","tmpRoundingMode","tosignificantdigits","tmpDigits","todecimalplaces","tmpDecimalPlaces","setprecision","console","setroundingmode","tmpObjectType","groupValuesAndAggregate","tmpInputDataSet","tmpGroupByProperty","tmpGroupValueProperty","tmpOutputDataSet","tmpProcessedOutputDataSet","tmpGroupByValue","tmpDecimalValue","tmpOutputGroups","PreciseMath","_libElucidatorInstruc4","_super5","_this6","groupValuesBy","Set","_libElucidatorInstruc5","_super6","_this7","tmpInputString","tmpSearchFor","tmpReplaceWith","StringOperations","_libElucidatorInstruc6","_super7","_this8"],"mappings":"AAAA,aAEA,SAASA,OAA2X,OAA7TA,KAA9B,oBAAZC,SAA2BA,QAAQC,IAAcD,QAAQC,IAAIC,OAAwB,SAAcC,EAAQC,EAAUC,GAAY,IAAIC,EAAOC,eAAeJ,EAAQC,GAAW,GAAKE,EAAL,CAAmB,IAAIE,EAAOC,OAAOC,yBAAyBJ,EAAMF,GAAW,OAAII,EAAKP,IAAcO,EAAKP,IAAIU,KAAKC,UAAUC,OAAS,EAAIV,EAASE,GAAoBG,EAAKM,KAA5J,CAAmK,EAAYf,KAAKgB,MAAMC,KAAMJ,UAAY,CACxa,SAASL,eAAeU,EAAQb,GAAY,MAAQK,OAAOS,UAAUC,eAAeR,KAAKM,EAAQb,IAA8D,QAAjDa,EAASG,gBAAgBH,MAAuC,OAAOA,CAAQ,CAC7L,SAASI,UAAUC,EAAUC,GAAc,GAA0B,mBAAfA,GAA4C,OAAfA,EAAuB,MAAM,IAAIC,UAAU,sDAAyDF,EAASJ,UAAYT,OAAOgB,OAAOF,GAAcA,EAAWL,UAAW,CAAEQ,YAAa,CAAEZ,MAAOQ,EAAUK,UAAU,EAAMC,cAAc,KAAWnB,OAAOoB,eAAeP,EAAU,YAAa,CAAEK,UAAU,IAAcJ,GAAYO,gBAAgBR,EAAUC,EAAa,CACnc,SAASO,gBAAgBC,EAAGC,GAA6I,OAAxIF,gBAAkBrB,OAAOwB,eAAiBxB,OAAOwB,eAAe/B,OAAS,SAAyB6B,EAAGC,GAAsB,OAAjBD,EAAEG,UAAYF,EAAUD,CAAG,EAAUD,gBAAgBC,EAAGC,EAAI,CACvM,SAASG,aAAaC,GAAW,IAAIC,EAA4BC,4BAA6B,OAAO,WAAkC,IAAsCC,EAAlCC,EAAQpB,gBAAgBgB,GAAkB,GAAIC,EAA2B,CAAE,IAAII,EAAYrB,gBAAgBJ,MAAMU,YAAaa,EAASvC,QAAQ0C,UAAUF,EAAO5B,UAAW6B,EAAY,MAASF,EAASC,EAAMzB,MAAMC,KAAMJ,WAAc,OAAO+B,2BAA2B3B,KAAMuB,EAAS,CAAG,CACxa,SAASI,2BAA2BC,EAAMjC,GAAQ,GAAIA,IAA2B,WAAlBkC,QAAQlC,IAAsC,mBAATA,GAAwB,OAAOA,EAAa,QAAa,IAATA,EAAmB,MAAM,IAAIa,UAAU,4DAA+D,OAAOsB,uBAAuBF,EAAO,CAC/R,SAASE,uBAAuBF,GAAQ,QAAa,IAATA,EAAmB,MAAM,IAAIG,eAAe,6DAAgE,OAAOH,CAAM,CACrK,SAASN,4BAA8B,GAAuB,oBAAZtC,UAA4BA,QAAQ0C,UAAW,OAAO,EAAO,GAAI1C,QAAQ0C,UAAUM,KAAM,OAAO,EAAO,GAAqB,mBAAVC,MAAsB,OAAO,EAAM,IAAsF,OAAhFC,QAAQhC,UAAUiC,QAAQxC,KAAKX,QAAQ0C,UAAUQ,QAAS,IAAI,WAAa,MAAY,CAAM,CAAE,MAAOE,GAAK,OAAO,CAAO,CAAE,CACxU,SAAShC,gBAAgBW,GAA+J,OAA1JX,gBAAkBX,OAAOwB,eAAiBxB,OAAO4C,eAAenD,OAAS,SAAyB6B,GAAK,OAAOA,EAAEG,WAAazB,OAAO4C,eAAetB,EAAI,EAAUX,gBAAgBW,EAAI,CACnN,SAASuB,gBAAgBC,EAAUC,GAAe,KAAMD,aAAoBC,GAAgB,MAAM,IAAIhC,UAAU,oCAAwC,CACxJ,SAASiC,kBAAkBtD,EAAQuD,GAAS,IAAK,IAAIC,EAAI,EAAGA,EAAID,EAAM7C,OAAQ8C,IAAK,CAAE,IAAIC,EAAaF,EAAMC,GAAIC,EAAWC,WAAaD,EAAWC,aAAc,EAAOD,EAAWhC,cAAe,EAAU,UAAWgC,IAAYA,EAAWjC,UAAW,GAAMlB,OAAOoB,eAAe1B,EAAQ2D,eAAeF,EAAWG,KAAMH,EAAa,CAAE,CAC5U,SAASI,aAAaR,EAAaS,EAAYC,GAAyN,OAAtMD,GAAYR,kBAAkBD,EAAYtC,UAAW+C,GAAiBC,GAAaT,kBAAkBD,EAAaU,GAAczD,OAAOoB,eAAe2B,EAAa,YAAa,CAAE7B,UAAU,IAAiB6B,CAAa,CAC5R,SAASW,gBAAgBC,EAAKL,EAAKjD,GAA4L,OAAnLiD,EAAMD,eAAeC,MAAiBK,EAAO3D,OAAOoB,eAAeuC,EAAKL,EAAK,CAAEjD,MAAOA,EAAO+C,YAAY,EAAMjC,cAAc,EAAMD,UAAU,IAAkByC,EAAIL,GAAOjD,EAAgBsD,CAAK,CAC3O,SAASN,eAAeO,GAAO,IAAIN,EAAMO,aAAaD,EAAK,UAAW,MAAwB,WAAjBxB,QAAQkB,GAAoBA,EAAMQ,OAAOR,EAAM,CAC5H,SAASO,aAAaE,EAAOC,GAAQ,GAAuB,WAAnB5B,QAAQ2B,IAAiC,OAAVA,EAAgB,OAAOA,EAAO,IAAIE,EAAOF,EAAMG,OAAOC,aAAc,QAAaC,IAATH,EAAoB,CAAE,IAAII,EAAMJ,EAAK/D,KAAK6D,EAAOC,GAAQ,WAAY,GAAqB,WAAjB5B,QAAQiC,GAAmB,OAAOA,EAAK,MAAM,IAAItD,UAAU,+CAAiD,CAAE,OAAiB,WAATiD,EAAoBF,OAASQ,QAAQP,EAAQ,CAC5X,SAAS3B,QAAQuB,GAAkC,OAAOvB,QAAU,mBAAqB8B,QAAU,iBAAmBA,OAAOK,SAAW,SAAUZ,GAAO,cAAcA,CAAK,EAAI,SAAUA,GAAO,OAAOA,GAAO,mBAAqBO,QAAUP,EAAI1C,cAAgBiD,QAAUP,IAAQO,OAAOzD,UAAY,gBAAkBkD,CAAK,EAAGvB,QAAQuB,EAAM,ECjB/U,SAAAa,GAAA,GAAA,YAAA,oBAAAC,QAAA,YAAArC,QAAAqC,WAAA,oBAAAC,OAAAA,OAAAD,QAAAD,SAAA,GAAA,mBAAAG,QAAAA,OAAAC,IAAAD,OAAA,GAAAH,OAAA,EAAA,oBAAAK,OAAAA,OAAA,oBAAAC,OAAAA,OAAA,oBAAA3C,KAAAA,KAAA5B,MAAAwE,WAAAP,GAAA,CAAA,CAAA,EAAA,WAAA,OAAA,SAAAQ,EAAArC,EAAAsC,EAAAC,GAAA,SAAA5D,EAAA4B,EAAAsB,GAAA,IAAAS,EAAA/B,GAAA,CAAA,IAAAP,EAAAO,GAAA,CAAA,IAAAiC,EAAA,mBAAAC,SAAAA,QAAA,IAAAZ,GAAAW,EAAA,OAAAA,EAAAjC,GAAA,GAAA,GAAAmC,EAAA,OAAAA,EAAAnC,GAAA,GAAA,IAAAoC,EAAA,IAAAC,MAAA,uBAAArC,EAAA,KAAA,MAAAoC,EAAAE,KAAA,mBAAAF,CAAA,CAAA,IAAA/D,EAAA0D,EAAA/B,GAAA,CAAAuB,QAAA,CAAA,GAAA9B,EAAAO,GAAA,GAAAhD,KAAAqB,EAAAkD,SAAA,SAAAO,GAAA,OAAA1D,EAAAqB,EAAAO,GAAA,GAAA8B,IAAAA,EAAA,GAAAzD,EAAAA,EAAAkD,QAAAO,EAAArC,EAAAsC,EAAAC,EAAA,CAAA,OAAAD,EAAA/B,GAAAuB,OAAA,CAAA,IAAA,IAAAY,EAAA,mBAAAD,SAAAA,QAAAlC,EAAA,EAAAA,EAAAgC,EAAA9E,OAAA8C,IAAA5B,EAAA4D,EAAAhC,IAAA,OAAA5B,CAAA,CAAA,CAAA,CAAA,EAAA,CAAA,SAAA8D,EAAAV,EAAAD,ICAA,SAAAgB;;;;;;;;AAkBA,IAkFAC,EAAAC,EAAAC,EAAAC,EAlFAC,EAAA,KAIAC,EAAA,IAGAC,EAAA,mBAGAC,EAAA,qgCAGAC,EAAA,qgCAIAC,EAAA,CAOAC,UAAA,GAiBAC,SAAA,EAeAC,OAAA,EAIAC,UAAA,EAIAC,SAAA,GAIAC,MAAAX,EAIAY,KAAAZ,EAGAa,QAAA,GAQAC,GAAA,EAEAC,EAAA,kBACAC,EAAAD,EAAA,qBACAE,EAAAF,EAAA,2BACAG,EAAAH,EAAA,qBACAI,EAAA,mBAEAC,EAAAC,KAAAC,MACAC,EAAAF,KAAAG,IAEAC,EAAA,6CACAC,EAAA,yDACAC,EAAA,gDACAC,EAAA,qCAEAC,EAAA,IACAC,EAAA,EAGAC,EAAA5B,EAAA7F,OAAA,EACA0H,EAAA5B,EAAA9F,OAAA,EAGA2H,EAAA,CAAAC,YAAAf,GA01EA,SAAAgB,EAAAC,GACA,IAAAhF,EAAAiF,EAAAC,EACAC,EAAAH,EAAA9H,OAAA,EACAkI,EAAA,GACAC,EAAAL,EAAA,GAEA,GAAAG,EAAA,EAAA,CAEA,IADAC,GAAAC,EACArF,EAAA,EAAAA,EAAAmF,EAAAnF,IACAkF,EAAAF,EAAAhF,GAAA,IACAiF,EAAAP,EAAAQ,EAAAhI,UACAkI,GAAAE,EAAAL,IACAG,GAAAF,EAGAG,EAAAL,EAAAhF,IAEAiF,EAAAP,GADAQ,EAAAG,EAAA,IACAnI,UACAkI,GAAAE,EAAAL,GACA,MAAA,GAAA,IAAAI,EACA,MAAA,IAIA,KAAAA,EAAA,IAAA,GAAAA,GAAA,GAEA,OAAAD,EAAAC,CACA,CAGA,SAAAE,EAAAvF,EAAAwF,EAAAC,GACA,GAAAzF,MAAAA,GAAAA,EAAAwF,GAAAxF,EAAAyF,EACA,MAAApD,MAAAuB,EAAA5D,EAEA,CAQA,SAAA0F,EAAAV,EAAAhF,EAAA2F,EAAAC,GACA,IAAAC,EAAAZ,EAAAnD,EAAAgE,EAGA,IAAAb,EAAAD,EAAA,GAAAC,GAAA,GAAAA,GAAA,KAAAjF,EAwCA,QArCAA,EAAA,GACAA,GAAA0E,EACAmB,EAAA,IAEAA,EAAA5B,KAAA8B,MAAA/F,EAAA,GAAA0E,GACA1E,GAAA0E,GAMAO,EAAAd,EAAA,GAAAO,EAAA1E,GACA8F,EAAAd,EAAAa,GAAAZ,EAAA,EAEA,MAAAW,EACA5F,EAAA,GACA,GAAAA,EAAA8F,EAAAA,EAAA,IAAA,EACA,GAAA9F,IAAA8F,EAAAA,EAAA,GAAA,GACAhE,EAAA6D,EAAA,GAAA,OAAAG,GAAAH,EAAA,GAAA,OAAAG,GAAA,KAAAA,GAAA,GAAAA,GAEAhE,GAAA6D,EAAA,GAAAG,EAAA,GAAAb,GAAAU,EAAA,GAAAG,EAAA,GAAAb,EAAA,KACAD,EAAAa,EAAA,GAAAZ,EAAA,IAAA,IAAAd,EAAA,GAAAnE,EAAA,GAAA,IACA8F,GAAAb,EAAA,GAAA,GAAAa,IAAA,IAAAd,EAAAa,EAAA,GAAAZ,EAAA,IAAA,GAGAjF,EAAA,GACA,GAAAA,EAAA8F,EAAAA,EAAA,IAAA,EACA,GAAA9F,EAAA8F,EAAAA,EAAA,IAAA,EACA,GAAA9F,IAAA8F,EAAAA,EAAA,GAAA,GACAhE,GAAA8D,GAAAD,EAAA,IAAA,MAAAG,IAAAF,GAAAD,EAAA,GAAA,MAAAG,GAEAhE,IAAA8D,GAAAD,EAAA,IAAAG,EAAA,GAAAb,IACAW,GAAAD,EAAA,GAAAG,EAAA,GAAAb,EAAA,KACAD,EAAAa,EAAA,GAAAZ,EAAA,IAAA,IAAAd,EAAA,GAAAnE,EAAA,GAAA,EAIA8B,CACA,CAMA,SAAAkE,EAAAZ,EAAAa,EAAAC,GAOA,IANA,IAAAC,EAEAC,EADAC,EAAA,CAAA,GAEArG,EAAA,EACAsG,EAAAlB,EAAAlI,OAEA8C,EAAAsG,GAAA,CACA,IAAAF,EAAAC,EAAAnJ,OAAAkJ,KAAAC,EAAAD,IAAAH,EAEA,IADAI,EAAA,IAAAvD,EAAAyD,QAAAnB,EAAAoB,OAAAxG,MACAmG,EAAA,EAAAA,EAAAE,EAAAnJ,OAAAiJ,IACAE,EAAAF,GAAAD,EAAA,SACA,IAAAG,EAAAF,EAAA,KAAAE,EAAAF,EAAA,GAAA,GACAE,EAAAF,EAAA,IAAAE,EAAAF,GAAAD,EAAA,EACAG,EAAAF,IAAAD,EAGA,CAEA,OAAAG,EAAAI,SACA,CAj4EA5B,EAAA6B,cAAA7B,EAAA8B,IAAA,WACA,IAAAC,EAAA,IAAAvJ,KAAAU,YAAAV,MAEA,OADAuJ,EAAAC,EAAA,IAAAD,EAAAC,EAAA,GACAC,EAAAF,EACA,EAQA/B,EAAAkB,KAAA,WACA,OAAAe,EAAA,IAAAzJ,KAAAU,YAAAV,MAAAA,KAAAoC,EAAA,EAAA,EACA,EAWAoF,EAAAkC,UAAAlC,EAAAmC,MAAA,SAAAxB,EAAAC,GACA,IACAmB,EAAAvJ,KACA4J,EAAAL,EAAA7I,YAGA,GAFAyH,EAAA,IAAAyB,EAAAzB,GACAC,EAAA,IAAAwB,EAAAxB,IACAD,EAAAqB,IAAApB,EAAAoB,EAAA,OAAA,IAAAI,EAAAC,KACA,GAAA1B,EAAA2B,GAAA1B,GAAA,MAAApD,MAAAuB,EAAA6B,GAEA,OADAmB,EAAAQ,IAAA5B,GACA,EAAAA,EAAAoB,EAAAQ,IAAA3B,GAAA,EAAAA,EAAA,IAAAwB,EAAAL,EACA,EAWA/B,EAAAwC,WAAAxC,EAAAuC,IAAA,SAAAE,GACA,IAAAtH,EAAAmG,EAAAoB,EAAAC,EACAZ,EAAAvJ,KACAoK,EAAAb,EAAA5B,EACA0C,GAAAJ,EAAA,IAAAV,EAAA7I,YAAAuJ,IAAAtC,EACA2C,EAAAf,EAAAC,EACAe,EAAAN,EAAAT,EAGA,IAAAY,IAAAC,EACA,OAAAC,GAAAC,EAAAD,IAAAC,EAAAD,EAAAF,IAAAC,EAAA,GAAAD,EAAAE,EAAA,EAAA,GAAA,EAAAT,IAIA,IAAAO,EAAA,KAAAC,EAAA,GAAA,OAAAD,EAAA,GAAAE,EAAAD,EAAA,IAAAE,EAAA,EAGA,GAAAD,IAAAC,EAAA,OAAAD,EAGA,GAAAf,EAAAnH,IAAA6H,EAAA7H,EAAA,OAAAmH,EAAAnH,EAAA6H,EAAA7H,EAAAkI,EAAA,EAAA,GAAA,EAMA,IAAA3H,EAAA,EAAAmG,GAJAoB,EAAAE,EAAAvK,SACAsK,EAAAE,EAAAxK,QAGAqK,EAAAC,EAAAxH,EAAAmG,IAAAnG,EACA,GAAAyH,EAAAzH,KAAA0H,EAAA1H,GAAA,OAAAyH,EAAAzH,GAAA0H,EAAA1H,GAAA2H,EAAA,EAAA,GAAA,EAIA,OAAAJ,IAAAC,EAAA,EAAAD,EAAAC,EAAAG,EAAA,EAAA,GAAA,CACA,EAgBA9C,EAAAgD,OAAAhD,EAAAiD,IAAA,WACA,IAAAC,EAAApC,EACAiB,EAAAvJ,KACA4J,EAAAL,EAAA7I,YAEA,OAAA6I,EAAA5B,EAGA4B,EAAA5B,EAAA,IAEA+C,EAAAd,EAAA/D,UACAyC,EAAAsB,EAAA9D,SACA8D,EAAA/D,UAAA6E,EAAA9D,KAAAwB,IAAAmB,EAAAnH,EAAAmH,EAAAoB,MAAAtD,EACAuC,EAAA9D,SAAA,EAEAyD,EA4xEA,SAAAK,EAAAL,GACA,IAAA3B,EAAAgD,EAAAX,EAEA,GAAAV,EAAAsB,SAAA,OAAAtB,EAMAqB,EAAArB,EAAA5B,EAAA9H,OACA+K,EAAA,GAEAX,GAAA,EAAAa,EAAA,EADAlD,EAAAhB,KAAA8B,KAAAkC,EAAA,KACAG,YAEAnD,EAAA,GACAqC,EAAA,gCAGAL,EAAA/D,WAAA+B,EAEA2B,EAAAyB,EAAApB,EAAA,EAAAL,EAAA0B,MAAAhB,GAAA,IAAAL,EAAA,IAGA,IAAA,IAAAjH,EAAAiF,EAAAjF,KAAA,CACA,IAAAuI,EAAA3B,EAAA0B,MAAA1B,GACAA,EAAA2B,EAAAD,MAAAC,GAAAC,MAAAD,GAAAD,MAAA,GAAAG,KAAA,EACA,CAIA,OAFAxB,EAAA/D,WAAA+B,EAEA2B,CACA,CA3zEAiB,CAAAZ,EAAAyB,EAAAzB,EAAAL,IAEAK,EAAA/D,UAAA6E,EACAd,EAAA9D,SAAAwC,EAEAmB,EAAA,GAAAnE,GAAA,GAAAA,EAAAiE,EAAA+B,MAAA/B,EAAAmB,EAAApC,GAAA,IAZA,IAAAsB,EAAA,GAHA,IAAAA,EAAAC,IAgBA,EAmBArC,EAAA+D,SAAA/D,EAAAgE,KAAA,WACA,IAAApJ,EAAAqJ,EAAA/G,EAAAD,EAAAiH,EAAAlC,EAAAmB,EAAAhG,EAAAgH,EAAAC,EACArC,EAAAvJ,KACA4J,EAAAL,EAAA7I,YAEA,IAAA6I,EAAAsC,YAAAtC,EAAAsB,SAAA,OAAA,IAAAjB,EAAAL,GAoCA,IAnCAlD,GAAA,GAGAmD,EAAAD,EAAAC,EAAA1C,EAAAyC,EAAAC,EAAAD,EAAA,EAAA,KAIA3C,KAAA0C,IAAAE,IAAA,IAqBA/E,EAAA,IAAAmF,EAAAJ,EAAAuB,aApBArG,EAAAgD,EAAA6B,EAAA5B,IAIA6B,IAHApH,EAAAmH,EAAAnH,GAGAsC,EAAA7E,OAAA,GAAA,KAAA6E,GAAA,GAAA8E,IAAA,GAAAA,EAAA,IAAA,MACAA,EAAA1C,EAAApC,EAAA,EAAA,GAGAtC,EAAAuE,GAAAvE,EAAA,GAAA,IAAAA,EAAA,IAAAA,EAAA,GAAA,EAAA,KASAqC,EAAA,IAAAmF,EANAlF,EADA8E,GAAA,IACA,KAAApH,GAEAsC,EAAA8E,EAAAsC,iBACAC,MAAA,EAAArH,EAAAwE,QAAA,KAAA,GAAA9G,IAIAoH,EAAAD,EAAAC,GAKAmB,GAAAvI,EAAAwH,EAAA/D,WAAA,IAWA,GAJA+F,GADAD,GADAhH,EAAAF,GACAwG,MAAAtG,GAAAsG,MAAAtG,IACAyG,KAAA7B,GACA9E,EAAAuH,EAAAJ,EAAAR,KAAA7B,GAAA0B,MAAAtG,GAAAiH,EAAAR,KAAAO,GAAAhB,EAAA,EAAA,GAGAjD,EAAA/C,EAAAgD,GAAAoE,MAAA,EAAApB,MAAAjG,EAAAgD,EAAAjD,EAAAkD,IAAAoE,MAAA,EAAApB,GAAA,CAKA,GAAA,SAJAjG,EAAAA,EAAAqH,MAAApB,EAAA,EAAAA,EAAA,MAIAe,GAAA,QAAAhH,GAeA,EAIAA,KAAAA,EAAAqH,MAAA,IAAA,KAAArH,EAAAyE,OAAA,MAGAM,EAAAhF,EAAArC,EAAA,EAAA,GACAqJ,GAAAhH,EAAAwG,MAAAxG,GAAAwG,MAAAxG,GAAAwH,GAAA1C,IAGA,KACA,CAvBA,IAAAmC,IACAjC,EAAA9E,EAAAvC,EAAA,EAAA,GAEAuC,EAAAsG,MAAAtG,GAAAsG,MAAAtG,GAAAsH,GAAA1C,IAAA,CACA9E,EAAAE,EACA,KACA,CAGAgG,GAAA,EACAe,EAAA,CAcA,CAKA,OAFArF,GAAA,EAEAoD,EAAAhF,EAAArC,EAAAwH,EAAA9D,SAAA2F,EACA,EAOAjE,EAAA0E,cAAA1E,EAAA2E,GAAA,WACA,IAAAnE,EACAL,EAAA3H,KAAA2H,EACAjD,EAAAmF,IAEA,GAAAlC,EAAA,CAMA,GAJAjD,IADAsD,EAAAL,EAAA9H,OAAA,GACA8G,EAAA3G,KAAAoC,EAAAiF,IAAAA,EAGAW,EAAAL,EAAAK,GACA,KAAAA,EAAA,IAAA,EAAAA,GAAA,GAAAtD,IACAA,EAAA,IAAAA,EAAA,EACA,CAEA,OAAAA,CACA,EAwBA8C,EAAA4E,UAAA5E,EAAA6E,IAAA,SAAApC,GACA,OAAA+B,EAAAhM,KAAA,IAAAA,KAAAU,YAAAuJ,GACA,EAQAzC,EAAA8E,mBAAA9E,EAAA+E,SAAA,SAAAtC,GACA,IACAL,EADA5J,KACAU,YACA,OAAA+I,EAAAuC,EAFAhM,KAEA,IAAA4J,EAAAK,GAAA,EAAA,EAAA,GAAAL,EAAA/D,UAAA+D,EAAA9D,SACA,EAOA0B,EAAAgF,OAAAhF,EAAAyE,GAAA,SAAAhC,GACA,OAAA,IAAAjK,KAAA+J,IAAAE,EACA,EAQAzC,EAAAX,MAAA,WACA,OAAA4C,EAAA,IAAAzJ,KAAAU,YAAAV,MAAAA,KAAAoC,EAAA,EAAA,EACA,EAQAoF,EAAAiF,YAAAjF,EAAAsC,GAAA,SAAAG,GACA,OAAAjK,KAAA+J,IAAAE,GAAA,CACA,EAQAzC,EAAAkF,qBAAAlF,EAAAmF,IAAA,SAAA1C,GACA,IAAArC,EAAA5H,KAAA+J,IAAAE,GACA,OAAA,GAAArC,GAAA,IAAAA,CACA,EA4BAJ,EAAAoF,iBAAApF,EAAAqF,KAAA,WACA,IAAAjF,EAAAlD,EAAAgG,EAAApC,EAAAsC,EACArB,EAAAvJ,KACA4J,EAAAL,EAAA7I,YACAoM,EAAA,IAAAlD,EAAA,GAEA,IAAAL,EAAAsC,WAAA,OAAA,IAAAjC,EAAAL,EAAAC,EAAA,IAAAK,KACA,GAAAN,EAAAsB,SAAA,OAAAiC,EAEApC,EAAAd,EAAA/D,UACAyC,EAAAsB,EAAA9D,SACA8D,EAAA/D,UAAA6E,EAAA9D,KAAAwB,IAAAmB,EAAAnH,EAAAmH,EAAAoB,MAAA,EACAf,EAAA9D,SAAA,GACA8E,EAAArB,EAAA5B,EAAA9H,QAOA,GAEA6E,GAAA,EAAAoG,EAAA,EADAlD,EAAAhB,KAAA8B,KAAAkC,EAAA,KACAG,YAEAnD,EAAA,GACAlD,EAAA,gCAGA6E,EAAAyB,EAAApB,EAAA,EAAAL,EAAA0B,MAAAvG,GAAA,IAAAkF,EAAA,IAAA,GAMA,IAHA,IAAAmD,EACApK,EAAAiF,EACAoF,EAAA,IAAApD,EAAA,GACAjH,KACAoK,EAAAxD,EAAA0B,MAAA1B,GACAA,EAAAuD,EAAA3B,MAAA4B,EAAA9B,MAAA+B,EAAA7B,MAAA4B,EAAA9B,MAAA+B,MAGA,OAAAvD,EAAAF,EAAAK,EAAA/D,UAAA6E,EAAAd,EAAA9D,SAAAwC,GAAA,EACA,EAiCAd,EAAAyF,eAAAzF,EAAA0F,KAAA,WACA,IAAAtF,EAAA8C,EAAApC,EAAAsC,EACArB,EAAAvJ,KACA4J,EAAAL,EAAA7I,YAEA,IAAA6I,EAAAsC,YAAAtC,EAAAsB,SAAA,OAAA,IAAAjB,EAAAL,GAQA,GANAmB,EAAAd,EAAA/D,UACAyC,EAAAsB,EAAA9D,SACA8D,EAAA/D,UAAA6E,EAAA9D,KAAAwB,IAAAmB,EAAAnH,EAAAmH,EAAAoB,MAAA,EACAf,EAAA9D,SAAA,GACA8E,EAAArB,EAAA5B,EAAA9H,QAEA,EACA0J,EAAAyB,EAAApB,EAAA,EAAAL,EAAAA,GAAA,OACA,CAYA3B,GADAA,EAAA,IAAAhB,KAAAuG,KAAAvC,IACA,GAAA,GAAA,EAAAhD,EAGA2B,EAAAyB,EAAApB,EAAA,EADAL,EAAAA,EAAA0B,MAAA,EAAAH,EAAA,EAAAlD,IACA2B,GAAA,GAOA,IAJA,IAAA6D,EACAC,EAAA,IAAAzD,EAAA,GACA0D,EAAA,IAAA1D,EAAA,IACA2D,EAAA,IAAA3D,EAAA,IACAhC,KACAwF,EAAA7D,EAAA0B,MAAA1B,GACAA,EAAAA,EAAA0B,MAAAoC,EAAAjC,KAAAgC,EAAAnC,MAAAqC,EAAArC,MAAAmC,GAAAhC,KAAAmC,KAEA,CAKA,OAHA3D,EAAA/D,UAAA6E,EACAd,EAAA9D,SAAAwC,EAEAmB,EAAAF,EAAAmB,EAAApC,GAAA,EACA,EAmBAd,EAAAgG,kBAAAhG,EAAAiG,KAAA,WACA,IAAA/C,EAAApC,EACAiB,EAAAvJ,KACA4J,EAAAL,EAAA7I,YAEA,OAAA6I,EAAAsC,WACAtC,EAAAsB,SAAA,IAAAjB,EAAAL,IAEAmB,EAAAd,EAAA/D,UACAyC,EAAAsB,EAAA9D,SACA8D,EAAA/D,UAAA6E,EAAA,EACAd,EAAA9D,SAAA,EAEAkG,EAAAzC,EAAA2D,OAAA3D,EAAAsD,OAAAjD,EAAA/D,UAAA6E,EAAAd,EAAA9D,SAAAwC,IARA,IAAAsB,EAAAL,EAAAC,EASA,EAsBAhC,EAAAkG,cAAAlG,EAAAmG,KAAA,WACA,IAAAC,EACArE,EAAAvJ,KACA4J,EAAAL,EAAA7I,YACAkH,EAAA2B,EAAAD,MAAAS,IAAA,GACAW,EAAAd,EAAA/D,UACAyC,EAAAsB,EAAA9D,SAEA,OAAA,IAAA8B,EACA,IAAAA,EAEA2B,EAAAsE,QAAAC,EAAAlE,EAAAc,EAAApC,GAAA,IAAAsB,EAAA,GAEA,IAAAA,EAAAC,KAGAN,EAAAsB,SAAAiD,EAAAlE,EAAAc,EAAA,EAAApC,GAAA2C,MAAA,KAIArB,EAAA/D,UAAA6E,EAAA,EACAd,EAAA9D,SAAA,EAEAyD,EAAAA,EAAAwE,OACAH,EAAAE,EAAAlE,EAAAc,EAAA,EAAApC,GAAA2C,MAAA,IAEArB,EAAA/D,UAAA6E,EACAd,EAAA9D,SAAAwC,EAEAsF,EAAAzC,MAAA5B,GACA,EAsBA/B,EAAAwG,wBAAAxG,EAAAyG,MAAA,WACA,IAAAvD,EAAApC,EACAiB,EAAAvJ,KACA4J,EAAAL,EAAA7I,YAEA,OAAA6I,EAAA2E,IAAA,GAAA,IAAAtE,EAAAL,EAAA0C,GAAA,GAAA,EAAApC,KACAN,EAAAsC,YAEAnB,EAAAd,EAAA/D,UACAyC,EAAAsB,EAAA9D,SACA8D,EAAA/D,UAAA6E,EAAA9D,KAAAwB,IAAAxB,KAAA0C,IAAAC,EAAAnH,GAAAmH,EAAAoB,MAAA,EACAf,EAAA9D,SAAA,EACAO,GAAA,EAEAkD,EAAAA,EAAA0B,MAAA1B,GAAA4B,MAAA,GAAAgC,OAAA/B,KAAA7B,GAEAlD,GAAA,EACAuD,EAAA/D,UAAA6E,EACAd,EAAA9D,SAAAwC,EAEAiB,EAAA4E,MAdA,IAAAvE,EAAAL,EAeA,EAmBA/B,EAAA4G,sBAAA5G,EAAA6G,MAAA,WACA,IAAA3D,EAAApC,EACAiB,EAAAvJ,KACA4J,EAAAL,EAAA7I,YAEA,OAAA6I,EAAAsC,YAAAtC,EAAAsB,SAAA,IAAAjB,EAAAL,IAEAmB,EAAAd,EAAA/D,UACAyC,EAAAsB,EAAA9D,SACA8D,EAAA/D,UAAA6E,EAAA,EAAA9D,KAAAwB,IAAAxB,KAAA0C,IAAAC,EAAAnH,GAAAmH,EAAAoB,MAAA,EACAf,EAAA9D,SAAA,EACAO,GAAA,EAEAkD,EAAAA,EAAA0B,MAAA1B,GAAA6B,KAAA,GAAA+B,OAAA/B,KAAA7B,GAEAlD,GAAA,EACAuD,EAAA/D,UAAA6E,EACAd,EAAA9D,SAAAwC,EAEAiB,EAAA4E,KACA,EAsBA3G,EAAA8G,yBAAA9G,EAAA+G,MAAA,WACA,IAAA7D,EAAApC,EAAAkG,EAAAC,EACAlF,EAAAvJ,KACA4J,EAAAL,EAAA7I,YAEA,OAAA6I,EAAAsC,WACAtC,EAAAnH,GAAA,EAAA,IAAAwH,EAAAL,EAAAD,MAAA2C,GAAA,GAAA1C,EAAAC,EAAA,EAAAD,EAAAsB,SAAAtB,EAAAM,MAEAa,EAAAd,EAAA/D,UACAyC,EAAAsB,EAAA9D,SACA2I,EAAAlF,EAAAoB,KAEA/D,KAAAwB,IAAAqG,EAAA/D,GAAA,GAAAnB,EAAAnH,EAAA,EAAAqH,EAAA,IAAAG,EAAAL,GAAAmB,EAAApC,GAAA,IAEAsB,EAAA/D,UAAA2I,EAAAC,EAAAlF,EAAAnH,EAEAmH,EAAAyC,EAAAzC,EAAA6B,KAAA,GAAA,IAAAxB,EAAA,GAAAuB,MAAA5B,GAAAiF,EAAA9D,EAAA,GAEAd,EAAA/D,UAAA6E,EAAA,EACAd,EAAA9D,SAAA,EAEAyD,EAAAA,EAAA4E,KAEAvE,EAAA/D,UAAA6E,EACAd,EAAA9D,SAAAwC,EAEAiB,EAAA0B,MAAA,MArBA,IAAArB,EAAAC,IAsBA,EAwBArC,EAAAkH,YAAAlH,EAAAuG,KAAA,WACA,IAAAH,EAAAhG,EACA8C,EAAApC,EACAiB,EAAAvJ,KACA4J,EAAAL,EAAA7I,YAEA,OAAA6I,EAAAsB,SAAA,IAAAjB,EAAAL,IAEA3B,EAAA2B,EAAAD,MAAAS,IAAA,GACAW,EAAAd,EAAA/D,UACAyC,EAAAsB,EAAA9D,UAEA,IAAA8B,EAGA,IAAAA,IACAgG,EAAAE,EAAAlE,EAAAc,EAAA,EAAApC,GAAA2C,MAAA,KACAzB,EAAAD,EAAAC,EACAoE,GAIA,IAAAhE,EAAAC,MAKAD,EAAA/D,UAAA6E,EAAA,EACAd,EAAA9D,SAAA,EAEAyD,EAAAA,EAAA8C,IAAA,IAAAzC,EAAA,GAAAuB,MAAA5B,EAAA0B,MAAA1B,IAAA4D,OAAA/B,KAAA,IAAAuD,OAEA/E,EAAA/D,UAAA6E,EACAd,EAAA9D,SAAAwC,EAEAiB,EAAA0B,MAAA,IACA,EAqBAzD,EAAAoH,eAAApH,EAAAmH,KAAA,WACA,IAAAhM,EAAAmG,EAAAlB,EAAAlD,EAAAmK,EAAAlK,EAAAF,EAAA+J,EAAAM,EACAvF,EAAAvJ,KACA4J,EAAAL,EAAA7I,YACAgK,EAAAd,EAAA/D,UACAyC,EAAAsB,EAAA9D,SAEA,GAAAyD,EAAAsC,WAOA,IAAAtC,EAAAsB,SACA,OAAA,IAAAjB,EAAAL,GACA,GAAAA,EAAAD,MAAA2C,GAAA,IAAAvB,EAAA,GAAAnD,EAGA,OAFA9C,EAAAqJ,EAAAlE,EAAAc,EAAA,EAAApC,GAAA2C,MAAA,MACAzB,EAAAD,EAAAC,EACA/E,CACA,KAbA,CACA,IAAA8E,EAAAC,EAAA,OAAA,IAAAI,EAAAC,KACA,GAAAa,EAAA,GAAAnD,EAGA,OAFA9C,EAAAqJ,EAAAlE,EAAAc,EAAA,EAAApC,GAAA2C,MAAA,KACAzB,EAAAD,EAAAC,EACA/E,CAEA,CAmBA,IAXAmF,EAAA/D,UAAA2I,EAAA9D,EAAA,GACAd,EAAA9D,SAAA,EAUAnD,EAFAiF,EAAAhB,KAAAuB,IAAA,GAAAqG,EAAAnH,EAAA,EAAA,GAEA1E,IAAAA,EAAA4G,EAAAA,EAAA8C,IAAA9C,EAAA0B,MAAA1B,GAAA6B,KAAA,GAAA+B,OAAA/B,KAAA,IAWA,IATA/E,GAAA,EAEAyC,EAAAlC,KAAA8B,KAAA8F,EAAAnH,GACA3C,EAAA,EACAoK,EAAAvF,EAAA0B,MAAA1B,GACA9E,EAAA,IAAAmF,EAAAL,GACAsF,EAAAtF,GAGA,IAAA5G,GAOA,GANAkM,EAAAA,EAAA5D,MAAA6D,GACAnK,EAAAF,EAAA0G,MAAA0D,EAAAxC,IAAA3H,GAAA,IAEAmK,EAAAA,EAAA5D,MAAA6D,QAGA,KAFArK,EAAAE,EAAAyG,KAAAyD,EAAAxC,IAAA3H,GAAA,KAEAiD,EAAAmB,GAAA,IAAAnG,EAAAmG,EAAArE,EAAAkD,EAAAhF,KAAAgC,EAAAgD,EAAAhF,IAAAA,MAOA,OAJAiF,IAAAnD,EAAAA,EAAAwG,MAAA,GAAArD,EAAA,IAEAvB,GAAA,EAEAoD,EAAAhF,EAAAmF,EAAA/D,UAAA6E,EAAAd,EAAA9D,SAAAwC,GAAA,EACA,EAOAd,EAAAqE,SAAA,WACA,QAAA7L,KAAA2H,CACA,EAOAH,EAAAuH,UAAAvH,EAAAwH,MAAA,WACA,QAAAhP,KAAA2H,GAAAhB,EAAA3G,KAAAoC,EAAAiF,GAAArH,KAAA2H,EAAA9H,OAAA,CACA,EAOA2H,EAAAyH,MAAA,WACA,OAAAjP,KAAAwJ,CACA,EAOAhC,EAAA0H,WAAA1H,EAAAqG,MAAA,WACA,OAAA7N,KAAAwJ,EAAA,CACA,EAOAhC,EAAA2H,WAAA3H,EAAA4H,MAAA,WACA,OAAApP,KAAAwJ,EAAA,CACA,EAOAhC,EAAAqD,OAAA,WACA,QAAA7K,KAAA2H,GAAA,IAAA3H,KAAA2H,EAAA,EACA,EAOAH,EAAA6H,SAAA7H,EAAA8H,GAAA,SAAArF,GACA,OAAAjK,KAAA+J,IAAAE,GAAA,CACA,EAOAzC,EAAA+H,kBAAA/H,EAAA0G,IAAA,SAAAjE,GACA,OAAAjK,KAAA+J,IAAAE,GAAA,CACA,EAiCAzC,EAAAgI,UAAAhI,EAAAiI,IAAA,SAAAnQ,GACA,IAAAoQ,EAAA/H,EAAAgI,EAAA/H,EAAAgI,EAAAC,EAAAlF,EAAAlG,EACApB,EAAArD,KACA4J,EAAAvG,EAAA3C,YACAgK,EAAAd,EAAA/D,UACAyC,EAAAsB,EAAA9D,SAIA,GAAA,MAAAxG,EACAA,EAAA,IAAAsK,EAAA,IACA8F,GAAA,MACA,CAKA,GAHA/H,GADArI,EAAA,IAAAsK,EAAAtK,IACAqI,EAGArI,EAAAkK,EAAA,IAAA7B,IAAAA,EAAA,IAAArI,EAAA2M,GAAA,GAAA,OAAA,IAAArC,EAAAC,KAEA6F,EAAApQ,EAAA2M,GAAA,GACA,CAKA,GAHAtE,EAAAtE,EAAAsE,EAGAtE,EAAAmG,EAAA,IAAA7B,IAAAA,EAAA,IAAAtE,EAAA4I,GAAA,GACA,OAAA,IAAArC,EAAAjC,IAAAA,EAAA,IAAA,IAAA,GAAAtE,EAAAmG,EAAAK,IAAAlC,EAAA,EAAA,KAKA,GAAA+H,EACA,GAAA/H,EAAA9H,OAAA,EACA+P,GAAA,MACA,CACA,IAAAhI,EAAAD,EAAA,GAAAC,EAAA,IAAA,GAAAA,GAAA,GACAgI,EAAA,IAAAhI,CACA,CAyBA,GAtBAvB,GAAA,EAEAwJ,EAAAC,EAAAzM,EADAsH,EAAAD,EAnCA,GAqCAiF,EAAAD,EAAAK,EAAAnG,EAAAe,EAAA,IAAAmF,EAAAxQ,EAAAqL,GAmBAtC,GAhBA5D,EAAAuH,EAAA6D,EAAAF,EAAAhF,EAAA,IAgBAhD,EAAAC,EAAA8C,EAAApC,GAEA,GAMA,GAJAuH,EAAAC,EAAAzM,EADAsH,GAAA,IAEAgF,EAAAD,EAAAK,EAAAnG,EAAAe,EAAA,IAAAmF,EAAAxQ,EAAAqL,GACAlG,EAAAuH,EAAA6D,EAAAF,EAAAhF,EAAA,IAEAiF,EAAA,EAGAlI,EAAAjD,EAAAkD,GAAAoE,MAAAnE,EAAA,EAAAA,EAAA,IAAA,GAAA,OACAnD,EAAAgF,EAAAhF,EAAAiG,EAAA,EAAA,IAGA,KACA,QACArC,EAAA5D,EAAAkD,EAAAC,GAAA,GAAAU,IAKA,OAFAjC,GAAA,EAEAoD,EAAAhF,EAAAiG,EAAApC,EACA,EAgDAd,EAAA2D,MAAA3D,EAAAwI,IAAA,SAAA/F,GACA,IAAAtC,EAAAvF,EAAAO,EAAAmG,EAAAlB,EAAAgD,EAAAF,EAAApC,EAAA8B,EAAA6F,EAAAC,EAAA7F,EACAd,EAAAvJ,KACA4J,EAAAL,EAAA7I,YAKA,GAHAuJ,EAAA,IAAAL,EAAAK,IAGAV,EAAA5B,IAAAsC,EAAAtC,EAaA,OAVA4B,EAAAC,GAAAS,EAAAT,EAGAD,EAAA5B,EAAAsC,EAAAT,GAAAS,EAAAT,EAKAS,EAAA,IAAAL,EAAAK,EAAAtC,GAAA4B,EAAAC,IAAAS,EAAAT,EAAAD,EAAAM,KARAI,EAAA,IAAAL,EAAAC,KAUAI,EAIA,GAAAV,EAAAC,GAAAS,EAAAT,EAEA,OADAS,EAAAT,GAAAS,EAAAT,EACAD,EAAA6B,KAAAnB,GASA,GANAG,EAAAb,EAAA5B,EACA0C,EAAAJ,EAAAtC,EACA+C,EAAAd,EAAA/D,UACAyC,EAAAsB,EAAA9D,UAGAsE,EAAA,KAAAC,EAAA,GAAA,CAGA,GAAAA,EAAA,GAAAJ,EAAAT,GAAAS,EAAAT,MAGA,KAAAY,EAAA,GAIA,OAAA,IAAAR,EAAA,IAAAtB,GAAA,EAAA,GAJA2B,EAAA,IAAAL,EAAAL,EAIA,CAEA,OAAAlD,EAAAoD,EAAAQ,EAAAS,EAAApC,GAAA2B,CACA,CAYA,GAPA7H,EAAAuE,EAAAsD,EAAA7H,EAAAiF,GACA4I,EAAAtJ,EAAA4C,EAAAnH,EAAAiF,GAEA+C,EAAAA,EAAA2B,QACAnE,EAAAqI,EAAA7N,EAGA,CAyBA,KAxBA8N,EAAAtI,EAAA,IAGAD,EAAAyC,EACAxC,GAAAA,EACAgD,EAAAP,EAAAxK,SAEA8H,EAAA0C,EACAjI,EAAA6N,EACArF,EAAAR,EAAAvK,QAQA+H,GAFAjF,EAAAiE,KAAAwB,IAAAxB,KAAA8B,KAAAgC,EAAArD,GAAAuD,GAAA,KAGAhD,EAAAjF,EACAgF,EAAA9H,OAAA,GAIA8H,EAAAyB,UACAzG,EAAAiF,EAAAjF,KAAAgF,EAAAwI,KAAA,GACAxI,EAAAyB,SAGA,KAAA,CASA,KAHA8G,GAFAvN,EAAAyH,EAAAvK,SACA+K,EAAAP,EAAAxK,WAEA+K,EAAAjI,GAEAA,EAAA,EAAAA,EAAAiI,EAAAjI,IACA,GAAAyH,EAAAzH,IAAA0H,EAAA1H,GAAA,CACAuN,EAAA9F,EAAAzH,GAAA0H,EAAA1H,GACA,KACA,CAGAiF,EAAA,CACA,CAaA,IAXAsI,IACAvI,EAAAyC,EACAA,EAAAC,EACAA,EAAA1C,EACAsC,EAAAT,GAAAS,EAAAT,GAGAoB,EAAAR,EAAAvK,OAIA8C,EAAA0H,EAAAxK,OAAA+K,EAAAjI,EAAA,IAAAA,EAAAyH,EAAAQ,KAAA,EAGA,IAAAjI,EAAA0H,EAAAxK,OAAA8C,EAAAiF,GAAA,CAEA,GAAAwC,IAAAzH,GAAA0H,EAAA1H,GAAA,CACA,IAAAmG,EAAAnG,EAAAmG,GAAA,IAAAsB,IAAAtB,IAAAsB,EAAAtB,GAAA1B,EAAA,IACAgD,EAAAtB,GACAsB,EAAAzH,IAAAyE,CACA,CAEAgD,EAAAzH,IAAA0H,EAAA1H,EACA,CAGA,KAAA,IAAAyH,IAAAQ,IAAAR,EAAAgG,MAGA,KAAA,IAAAhG,EAAA,GAAAA,EAAAiG,UAAAjO,EAGA,OAAAgI,EAAA,IAEAH,EAAAtC,EAAAyC,EACAH,EAAA7H,EAAAkO,EAAAlG,EAAAhI,GAEAiE,EAAAoD,EAAAQ,EAAAS,EAAApC,GAAA2B,GALA,IAAAL,EAAA,IAAAtB,GAAA,EAAA,EAMA,EA2BAd,EAAAzB,OAAAyB,EAAA+I,IAAA,SAAAtG,GACA,IAAAuG,EACAjH,EAAAvJ,KACA4J,EAAAL,EAAA7I,YAKA,OAHAuJ,EAAA,IAAAL,EAAAK,IAGAV,EAAA5B,IAAAsC,EAAAT,GAAAS,EAAAtC,IAAAsC,EAAAtC,EAAA,GAAA,IAAAiC,EAAAC,MAGAI,EAAAtC,GAAA4B,EAAA5B,IAAA4B,EAAA5B,EAAA,GACA8B,EAAA,IAAAG,EAAAL,GAAAK,EAAA/D,UAAA+D,EAAA9D,WAIAO,GAAA,EAEA,GAAAuD,EAAA7D,QAIAyK,EAAAxE,EAAAzC,EAAAU,EAAAX,MAAA,EAAA,EAAA,IACAE,GAAAS,EAAAT,EAEAgH,EAAAxE,EAAAzC,EAAAU,EAAA,EAAAL,EAAA7D,OAAA,GAGAyK,EAAAA,EAAAvF,MAAAhB,GAEA5D,GAAA,EAEAkD,EAAA4B,MAAAqF,GACA,EASAhJ,EAAAiJ,mBAAAjJ,EAAAkJ,IAAA,WACA,OAAAD,EAAAzQ,KACA,EAQAwH,EAAAsI,iBAAAtI,EAAA2G,GAAA,WACA,OAAA2B,EAAA9P,KACA,EAQAwH,EAAAmJ,QAAAnJ,EAAA8D,IAAA,WACA,IAAA/B,EAAA,IAAAvJ,KAAAU,YAAAV,MAEA,OADAuJ,EAAAC,GAAAD,EAAAC,EACAC,EAAAF,EACA,EAwBA/B,EAAA4D,KAAA5D,EAAAoJ,IAAA,SAAA3G,GACA,IAAA4G,EAAAlJ,EAAAvF,EAAAO,EAAAiF,EAAAgD,EAAAF,EAAApC,EAAA8B,EAAAC,EACAd,EAAAvJ,KACA4J,EAAAL,EAAA7I,YAKA,GAHAuJ,EAAA,IAAAL,EAAAK,IAGAV,EAAA5B,IAAAsC,EAAAtC,EAWA,OARA4B,EAAAC,GAAAS,EAAAT,EAMAD,EAAA5B,IAAAsC,EAAA,IAAAL,EAAAK,EAAAtC,GAAA4B,EAAAC,IAAAS,EAAAT,EAAAD,EAAAM,MANAI,EAAA,IAAAL,EAAAC,KAQAI,EAIA,GAAAV,EAAAC,GAAAS,EAAAT,EAEA,OADAS,EAAAT,GAAAS,EAAAT,EACAD,EAAA4B,MAAAlB,GASA,GANAG,EAAAb,EAAA5B,EACA0C,EAAAJ,EAAAtC,EACA+C,EAAAd,EAAA/D,UACAyC,EAAAsB,EAAA9D,UAGAsE,EAAA,KAAAC,EAAA,GAMA,OAFAA,EAAA,KAAAJ,EAAA,IAAAL,EAAAL,IAEAlD,EAAAoD,EAAAQ,EAAAS,EAAApC,GAAA2B,EAaA,GAPArC,EAAAjB,EAAA4C,EAAAnH,EAAAiF,GACAjF,EAAAuE,EAAAsD,EAAA7H,EAAAiF,GAEA+C,EAAAA,EAAA2B,QACApJ,EAAAiF,EAAAxF,EAGA,CAuBA,IArBAO,EAAA,GACAgF,EAAAyC,EACAzH,GAAAA,EACAiI,EAAAP,EAAAxK,SAEA8H,EAAA0C,EACAjI,EAAAwF,EACAgD,EAAAR,EAAAvK,QAOA8C,GAFAiI,GADAhD,EAAAhB,KAAA8B,KAAAgC,EAAArD,IACAuD,EAAAhD,EAAA,EAAAgD,EAAA,KAGAjI,EAAAiI,EACAjD,EAAA9H,OAAA,GAIA8H,EAAAyB,UACAzG,KAAAgF,EAAAwI,KAAA,GACAxI,EAAAyB,SACA,CAcA,KAZAwB,EAAAR,EAAAvK,SACA8C,EAAA0H,EAAAxK,QAGA,IACA8C,EAAAiI,EACAjD,EAAA0C,EACAA,EAAAD,EACAA,EAAAzC,GAIAkJ,EAAA,EAAAlO,GACAkO,GAAAzG,IAAAzH,GAAAyH,EAAAzH,GAAA0H,EAAA1H,GAAAkO,GAAAzJ,EAAA,EACAgD,EAAAzH,IAAAyE,EAUA,IAPAyJ,IACAzG,EAAA0G,QAAAD,KACAzO,GAKAwI,EAAAR,EAAAvK,OAAA,GAAAuK,IAAAQ,IAAAR,EAAAgG,MAKA,OAHAnG,EAAAtC,EAAAyC,EACAH,EAAA7H,EAAAkO,EAAAlG,EAAAhI,GAEAiE,EAAAoD,EAAAQ,EAAAS,EAAApC,GAAA2B,CACA,EASAzC,EAAA3B,UAAA2B,EAAAmD,GAAA,SAAAoG,GACA,IAAAnJ,EACA2B,EAAAvJ,KAEA,QAAA,IAAA+Q,GAAAA,MAAAA,GAAA,IAAAA,GAAA,IAAAA,EAAA,MAAA/L,MAAAuB,EAAAwK,GASA,OAPAxH,EAAA5B,GACAC,EAAAoJ,EAAAzH,EAAA5B,GACAoJ,GAAAxH,EAAAnH,EAAA,EAAAwF,IAAAA,EAAA2B,EAAAnH,EAAA,IAEAwF,EAAAiC,IAGAjC,CACA,EAQAJ,EAAAyJ,MAAA,WACA,IAAA1H,EAAAvJ,KACA4J,EAAAL,EAAA7I,YAEA,OAAA+I,EAAA,IAAAG,EAAAL,GAAAA,EAAAnH,EAAA,EAAAwH,EAAA9D,SACA,EAkBA0B,EAAA0J,KAAA1J,EAAA2J,IAAA,WACA,IAAAzG,EAAApC,EACAiB,EAAAvJ,KACA4J,EAAAL,EAAA7I,YAEA,OAAA6I,EAAAsC,WACAtC,EAAAsB,SAAA,IAAAjB,EAAAL,IAEAmB,EAAAd,EAAA/D,UACAyC,EAAAsB,EAAA9D,SACA8D,EAAA/D,UAAA6E,EAAA9D,KAAAwB,IAAAmB,EAAAnH,EAAAmH,EAAAoB,MAAAtD,EACAuC,EAAA9D,SAAA,EAEAyD,EAs7DA,SAAAK,EAAAL,GACA,IAAA3B,EACAgD,EAAArB,EAAA5B,EAAA9H,OAEA,GAAA+K,EAAA,EACA,OAAArB,EAAAsB,SAAAtB,EAAAyB,EAAApB,EAAA,EAAAL,EAAAA,GASA3B,GADAA,EAAA,IAAAhB,KAAAuG,KAAAvC,IACA,GAAA,GAAA,EAAAhD,EAEA2B,EAAAA,EAAA0B,MAAA,EAAAH,EAAA,EAAAlD,IACA2B,EAAAyB,EAAApB,EAAA,EAAAL,EAAAA,GAOA,IAJA,IAAA6H,EACA/D,EAAA,IAAAzD,EAAA,GACA0D,EAAA,IAAA1D,EAAA,IACA2D,EAAA,IAAA3D,EAAA,IACAhC,KACAwJ,EAAA7H,EAAA0B,MAAA1B,GACAA,EAAAA,EAAA0B,MAAAoC,EAAAjC,KAAAgG,EAAAnG,MAAAqC,EAAArC,MAAAmG,GAAAjG,MAAAoC,MAGA,OAAAhE,CACA,CAp9DA2H,CAAAtH,EAAAyB,EAAAzB,EAAAL,IAEAK,EAAA/D,UAAA6E,EACAd,EAAA9D,SAAAwC,EAEAmB,EAAAnE,EAAA,EAAAiE,EAAA+B,MAAA/B,EAAAmB,EAAApC,GAAA,IAbA,IAAAsB,EAAAC,IAcA,EAeArC,EAAA6J,WAAA7J,EAAA2F,KAAA,WACA,IAAA1B,EAAA/G,EAAAiG,EAAAlG,EAAAiH,EAAA/G,EACA4E,EAAAvJ,KACA2H,EAAA4B,EAAA5B,EACAvF,EAAAmH,EAAAnH,EACAoH,EAAAD,EAAAC,EACAI,EAAAL,EAAA7I,YAGA,GAAA,IAAA8I,IAAA7B,IAAAA,EAAA,GACA,OAAA,IAAAiC,GAAAJ,GAAAA,EAAA,KAAA7B,GAAAA,EAAA,IAAAkC,IAAAlC,EAAA4B,EAAA,KAgCA,IA7BAlD,GAAA,EAOA,IAJAmD,EAAA5C,KAAAuG,MAAA5D,KAIAC,GAAA,OACA9E,EAAAgD,EAAAC,IAEA9H,OAAAuC,GAAA,GAAA,IAAAsC,GAAA,KACA8E,EAAA5C,KAAAuG,KAAAzI,GACAtC,EAAAuE,GAAAvE,EAAA,GAAA,IAAAA,EAAA,GAAAA,EAAA,GASAqC,EAAA,IAAAmF,EANAlF,EADA8E,GAAA,IACA,KAAApH,GAEAsC,EAAA8E,EAAAsC,iBACAC,MAAA,EAAArH,EAAAwE,QAAA,KAAA,GAAA9G,IAKAqC,EAAA,IAAAmF,EAAAJ,EAAAuB,YAGAJ,GAAAvI,EAAAwH,EAAA/D,WAAA,IAQA,GAHApB,GADAE,EAAAF,GACA2G,KAAAY,EAAAzC,EAAA5E,EAAAgG,EAAA,EAAA,IAAAM,MAAA,IAGAvD,EAAA/C,EAAAgD,GAAAoE,MAAA,EAAApB,MAAAjG,EAAAgD,EAAAjD,EAAAkD,IAAAoE,MAAA,EAAApB,GAAA,CAKA,GAAA,SAJAjG,EAAAA,EAAAqH,MAAApB,EAAA,EAAAA,EAAA,MAIAe,GAAA,QAAAhH,GAeA,EAIAA,KAAAA,EAAAqH,MAAA,IAAA,KAAArH,EAAAyE,OAAA,MAGAM,EAAAhF,EAAArC,EAAA,EAAA,GACAqJ,GAAAhH,EAAAwG,MAAAxG,GAAAwH,GAAA1C,IAGA,KACA,CAvBA,IAAAmC,IACAjC,EAAA9E,EAAAvC,EAAA,EAAA,GAEAuC,EAAAsG,MAAAtG,GAAAsH,GAAA1C,IAAA,CACA9E,EAAAE,EACA,KACA,CAGAgG,GAAA,EACAe,EAAA,CAcA,CAKA,OAFArF,GAAA,EAEAoD,EAAAhF,EAAArC,EAAAwH,EAAA9D,SAAA2F,EACA,EAgBAjE,EAAA8J,QAAA9J,EAAA+J,IAAA,WACA,IAAA7G,EAAApC,EACAiB,EAAAvJ,KACA4J,EAAAL,EAAA7I,YAEA,OAAA6I,EAAAsC,WACAtC,EAAAsB,SAAA,IAAAjB,EAAAL,IAEAmB,EAAAd,EAAA/D,UACAyC,EAAAsB,EAAA9D,SACA8D,EAAA/D,UAAA6E,EAAA,GACAd,EAAA9D,SAAA,GAEAyD,EAAAA,EAAA4H,OACA3H,EAAA,EACAD,EAAAyC,EAAAzC,EAAA,IAAAK,EAAA,GAAAuB,MAAA5B,EAAA0B,MAAA1B,IAAA4D,OAAAzC,EAAA,GAAA,GAEAd,EAAA/D,UAAA6E,EACAd,EAAA9D,SAAAwC,EAEAmB,EAAA,GAAAnE,GAAA,GAAAA,EAAAiE,EAAA+B,MAAA/B,EAAAmB,EAAApC,GAAA,IAfA,IAAAsB,EAAAC,IAgBA,EAwBArC,EAAAyD,MAAAzD,EAAAgK,IAAA,SAAAvH,GACA,IAAA4G,EAAAzO,EAAAO,EAAAiF,EAAAnD,EAAAgN,EAAA9M,EAAAuF,EAAAC,EACAZ,EAAAvJ,KACA4J,EAAAL,EAAA7I,YACA0J,EAAAb,EAAA5B,EACA0C,GAAAJ,EAAA,IAAAL,EAAAK,IAAAtC,EAKA,GAHAsC,EAAAT,GAAAD,EAAAC,IAGAY,GAAAA,EAAA,IAAAC,GAAAA,EAAA,IAEA,OAAA,IAAAT,GAAAK,EAAAT,GAAAY,IAAAA,EAAA,KAAAC,GAAAA,IAAAA,EAAA,KAAAD,EAIAP,IAIAO,GAAAC,EAAA,EAAAJ,EAAAT,EAAAS,EAAAT,EAAA,GAoBA,IAjBApH,EAAAuE,EAAA4C,EAAAnH,EAAAiF,GAAAV,EAAAsD,EAAA7H,EAAAiF,IACA6C,EAAAE,EAAAvK,SACAsK,EAAAE,EAAAxK,UAIA4E,EAAA2F,EACAA,EAAAC,EACAA,EAAA5F,EACAgN,EAAAvH,EACAA,EAAAC,EACAA,EAAAsH,GAIAhN,EAAA,GAEA9B,EADA8O,EAAAvH,EAAAC,EACAxH,KAAA8B,EAAA0L,KAAA,GAGA,IAAAxN,EAAAwH,IAAAxH,GAAA,GAAA,CAEA,IADAkO,EAAA,EACAjJ,EAAAsC,EAAAvH,EAAAiF,EAAAjF,GACAgC,EAAAF,EAAAmD,GAAAyC,EAAA1H,GAAAyH,EAAAxC,EAAAjF,EAAA,GAAAkO,EACApM,EAAAmD,KAAAjD,EAAAyC,EAAA,EACAyJ,EAAAlM,EAAAyC,EAAA,EAGA3C,EAAAmD,IAAAnD,EAAAmD,GAAAiJ,GAAAzJ,EAAA,CACA,CAGA,MAAA3C,IAAAgN,IAAAhN,EAAA2L,MAQA,OANAS,IAAAzO,EACAqC,EAAA4L,QAEApG,EAAAtC,EAAAlD,EACAwF,EAAA7H,EAAAkO,EAAA7L,EAAArC,GAEAiE,EAAAoD,EAAAQ,EAAAL,EAAA/D,UAAA+D,EAAA9D,UAAAmE,CACA,EAaAzC,EAAAkK,SAAA,SAAA/G,EAAArC,GACA,OAAAqJ,EAAA3R,KAAA,EAAA2K,EAAArC,EACA,EAaAd,EAAAoK,gBAAApK,EAAAqK,KAAA,SAAA1F,EAAA7D,GACA,IAAAiB,EAAAvJ,KACA4J,EAAAL,EAAA7I,YAGA,OADA6I,EAAA,IAAAK,EAAAL,QACA,IAAA4C,EAAA5C,GAEArB,EAAAiE,EAAA,EAAA3G,QAEA,IAAA8C,EAAAA,EAAAsB,EAAA9D,SACAoC,EAAAI,EAAA,EAAA,GAEAmB,EAAAF,EAAA4C,EAAA5C,EAAAnH,EAAA,EAAAkG,GACA,EAWAd,EAAAsE,cAAA,SAAAK,EAAA7D,GACA,IAAAP,EACAwB,EAAAvJ,KACA4J,EAAAL,EAAA7I,YAcA,YAZA,IAAAyL,EACApE,EAAA+J,EAAAvI,GAAA,IAEArB,EAAAiE,EAAA,EAAA3G,QAEA,IAAA8C,EAAAA,EAAAsB,EAAA9D,SACAoC,EAAAI,EAAA,EAAA,GAGAP,EAAA+J,EADAvI,EAAAE,EAAA,IAAAG,EAAAL,GAAA4C,EAAA,EAAA7D,IACA,EAAA6D,EAAA,IAGA5C,EAAAsE,UAAAtE,EAAAsB,SAAA,IAAA9C,EAAAA,CACA,EAmBAP,EAAAuK,QAAA,SAAA5F,EAAA7D,GACA,IAAAP,EAAAkC,EACAV,EAAAvJ,KACA4J,EAAAL,EAAA7I,YAgBA,YAdA,IAAAyL,EACApE,EAAA+J,EAAAvI,IAEArB,EAAAiE,EAAA,EAAA3G,QAEA,IAAA8C,EAAAA,EAAAsB,EAAA9D,SACAoC,EAAAI,EAAA,EAAA,GAGAP,EAAA+J,EADA7H,EAAAR,EAAA,IAAAG,EAAAL,GAAA4C,EAAA5C,EAAAnH,EAAA,EAAAkG,IACA,EAAA6D,EAAAlC,EAAA7H,EAAA,IAKAmH,EAAAsE,UAAAtE,EAAAsB,SAAA,IAAA9C,EAAAA,CACA,EAcAP,EAAAwK,WAAA,SAAAC,GACA,IAAAtK,EAAAuK,EAAAC,EAAAC,EAAAhQ,EAAAwF,EAAAlD,EAAA2N,EAAAC,EAAA5H,EAAA8F,EAAA/L,EACA8E,EAAAvJ,KACAoK,EAAAb,EAAA5B,EACAiC,EAAAL,EAAA7I,YAEA,IAAA0J,EAAA,OAAA,IAAAR,EAAAL,GAUA,GARA+I,EAAAJ,EAAA,IAAAtI,EAAA,GACAuI,EAAAE,EAAA,IAAAzI,EAAA,GAIAhC,GADAxF,GADAuF,EAAA,IAAAiC,EAAAuI,IACA/P,EAAA4O,EAAA5G,GAAAb,EAAAnH,EAAA,GACAiF,EACAM,EAAAA,EAAA,GAAAb,EAAA,GAAAc,EAAA,EAAAP,EAAAO,EAAAA,GAEA,MAAAqK,EAGAA,EAAA7P,EAAA,EAAAuF,EAAA2K,MACA,CAEA,KADA5N,EAAA,IAAAkF,EAAAqI,IACAjD,SAAAtK,EAAA4K,GAAAgD,GAAA,MAAAtN,MAAAuB,EAAA7B,GACAuN,EAAAvN,EAAAoF,GAAAnC,GAAAvF,EAAA,EAAAuF,EAAA2K,EAAA5N,CACA,CAOA,IALA2B,GAAA,EACA3B,EAAA,IAAAkF,EAAAlC,EAAA0C,IACAM,EAAAd,EAAA/D,UACA+D,EAAA/D,UAAAzD,EAAAgI,EAAAvK,OAAAwH,EAAA,EAGAmJ,EAAAxE,EAAAtH,EAAAiD,EAAA,EAAA,EAAA,GAEA,IADAyK,EAAAF,EAAA9G,KAAAoF,EAAAvF,MAAAkH,KACApI,IAAAkI,IACAC,EAAAC,EACAA,EAAAC,EACAA,EAAAE,EACAA,EAAAD,EAAAjH,KAAAoF,EAAAvF,MAAAmH,IACAC,EAAAD,EACAA,EAAAzK,EACAA,EAAAjD,EAAAyG,MAAAqF,EAAAvF,MAAAmH,IACA1N,EAAA0N,EAeA,OAZAA,EAAApG,EAAAiG,EAAA9G,MAAA+G,GAAAC,EAAA,EAAA,EAAA,GACAE,EAAAA,EAAAjH,KAAAgH,EAAAnH,MAAAqH,IACAJ,EAAAA,EAAA9G,KAAAgH,EAAAnH,MAAAkH,IACAE,EAAA7I,EAAA8I,EAAA9I,EAAAD,EAAAC,EAGA/E,EAAAuH,EAAAsG,EAAAH,EAAA/P,EAAA,GAAA+I,MAAA5B,GAAAD,MAAAS,IAAAiC,EAAAqG,EAAAH,EAAA9P,EAAA,GAAA+I,MAAA5B,GAAAD,OAAA,EACA,CAAAgJ,EAAAH,GAAA,CAAAE,EAAAH,GAEAtI,EAAA/D,UAAA6E,EACArE,GAAA,EAEA5B,CACA,EAaA+C,EAAA+K,cAAA/K,EAAAgL,MAAA,SAAA7H,EAAArC,GACA,OAAAqJ,EAAA3R,KAAA,GAAA2K,EAAArC,EACA,EAmBAd,EAAAiL,UAAA,SAAAxI,EAAA3B,GACA,IAAAiB,EAAAvJ,KACA4J,EAAAL,EAAA7I,YAIA,GAFA6I,EAAA,IAAAK,EAAAL,GAEA,MAAAU,EAAA,CAGA,IAAAV,EAAA5B,EAAA,OAAA4B,EAEAU,EAAA,IAAAL,EAAA,GACAtB,EAAAsB,EAAA9D,QACA,KAAA,CASA,GARAmE,EAAA,IAAAL,EAAAK,QACA,IAAA3B,EACAA,EAAAsB,EAAA9D,SAEAoC,EAAAI,EAAA,EAAA,IAIAiB,EAAA5B,EAAA,OAAAsC,EAAAT,EAAAD,EAAAU,EAGA,IAAAA,EAAAtC,EAEA,OADAsC,EAAAT,IAAAS,EAAAT,EAAAD,EAAAC,GACAS,CAEA,CAeA,OAZAA,EAAAtC,EAAA,IACAtB,GAAA,EACAkD,EAAAyC,EAAAzC,EAAAU,EAAA,EAAA3B,EAAA,GAAA2C,MAAAhB,GACA5D,GAAA,EACAoD,EAAAF,KAIAU,EAAAT,EAAAD,EAAAC,EACAD,EAAAU,GAGAV,CACA,EAQA/B,EAAAkL,SAAA,WACA,OAAA1S,IACA,EAaAwH,EAAAmL,QAAA,SAAAhI,EAAArC,GACA,OAAAqJ,EAAA3R,KAAA,EAAA2K,EAAArC,EACA,EA8CAd,EAAAoL,QAAApL,EAAAT,IAAA,SAAAkD,GACA,IAAA7H,EAAAwF,EAAA8C,EAAAjG,EAAA6D,EAAAkB,EACAD,EAAAvJ,KACA4J,EAAAL,EAAA7I,YACAmS,IAAA5I,EAAA,IAAAL,EAAAK,IAGA,KAAAV,EAAA5B,GAAAsC,EAAAtC,GAAA4B,EAAA5B,EAAA,IAAAsC,EAAAtC,EAAA,IAAA,OAAA,IAAAiC,EAAA9C,GAAAyC,EAAAsJ,IAIA,IAFAtJ,EAAA,IAAAK,EAAAL,IAEA0C,GAAA,GAAA,OAAA1C,EAKA,GAHAmB,EAAAd,EAAA/D,UACAyC,EAAAsB,EAAA9D,SAEAmE,EAAAgC,GAAA,GAAA,OAAAxC,EAAAF,EAAAmB,EAAApC,GAMA,IAHAlG,EAAAuE,EAAAsD,EAAA7H,EAAAiF,KAGA4C,EAAAtC,EAAA9H,OAAA,IAAA+H,EAAAiL,EAAA,GAAAA,EAAAA,IA1nEA,iBA4nEA,OADApO,EAAAqO,EAAAlJ,EAAAL,EAAA3B,EAAA8C,GACAT,EAAAT,EAAA,EAAA,IAAAI,EAAA,GAAAyC,IAAA5H,GAAAgF,EAAAhF,EAAAiG,EAAApC,GAMA,IAHAkB,EAAAD,EAAAC,GAGA,EAAA,CAGA,GAAApH,EAAA6H,EAAAtC,EAAA9H,OAAA,EAAA,OAAA,IAAA+J,EAAAC,KAMA,GAHA,IAAA,EAAAI,EAAAtC,EAAAvF,MAAAoH,EAAA,GAGA,GAAAD,EAAAnH,GAAA,GAAAmH,EAAA5B,EAAA,IAAA,GAAA4B,EAAA5B,EAAA9H,OAEA,OADA0J,EAAAC,EAAAA,EACAD,CAEA,CAcA,OAPAnH,EAAA,IADAwF,EAAAd,GAAAyC,EAAAsJ,KACAhH,SAAAjE,GAEA,IAAAgC,EAAAhC,EAAA,IAAAxF,EADAuE,EAAAkM,GAAAjM,KAAA6I,IAAA,KAAA/H,EAAA6B,EAAA5B,IAAAf,KAAAlB,KAAA6D,EAAAnH,EAAA,KAMAwH,EAAAzD,KAAA,GAAA/D,EAAAwH,EAAA1D,KAAA,EAAA,IAAA0D,EAAAxH,EAAA,EAAAoH,EAAA,EAAA,IAEAnD,GAAA,EACAuD,EAAA9D,SAAAyD,EAAAC,EAAA,EAMA5B,EAAAhB,KAAAuB,IAAA,IAAA/F,EAAA,IAAAvC,SAGA4E,EAAAgM,EAAAxG,EAAAgB,MAAA6E,EAAAvG,EAAAmB,EAAA9C,IAAA8C,IAGA/C,GAOAU,GAJA5D,EAAAgF,EAAAhF,EAAAiG,EAAA,EAAA,IAIA/C,EAAA+C,EAAApC,KACAlG,EAAAsI,EAAA,IAMAhD,GAHAjD,EAAAgF,EAAAgH,EAAAxG,EAAAgB,MAAA6E,EAAAvG,EAAAnH,EAAAwF,IAAAxF,GAAAA,EAAA,EAAA,IAGAuF,GAAAoE,MAAArB,EAAA,EAAAA,EAAA,IAAA,GAAA,OACAjG,EAAAgF,EAAAhF,EAAAiG,EAAA,EAAA,KAKAjG,EAAA+E,EAAAA,EACAnD,GAAA,EACAuD,EAAA9D,SAAAwC,EAEAmB,EAAAhF,EAAAiG,EAAApC,GACA,EAcAd,EAAAuL,YAAA,SAAApI,EAAArC,GACA,IAAAP,EACAwB,EAAAvJ,KACA4J,EAAAL,EAAA7I,YAcA,YAZA,IAAAiK,EACA5C,EAAA+J,EAAAvI,EAAAA,EAAAnH,GAAAwH,EAAA5D,UAAAuD,EAAAnH,GAAAwH,EAAA3D,WAEAiC,EAAAyC,EAAA,EAAAnF,QAEA,IAAA8C,EAAAA,EAAAsB,EAAA9D,SACAoC,EAAAI,EAAA,EAAA,GAGAP,EAAA+J,EADAvI,EAAAE,EAAA,IAAAG,EAAAL,GAAAoB,EAAArC,GACAqC,GAAApB,EAAAnH,GAAAmH,EAAAnH,GAAAwH,EAAA5D,SAAA2E,IAGApB,EAAAsE,UAAAtE,EAAAsB,SAAA,IAAA9C,EAAAA,CACA,EAiBAP,EAAAwL,oBAAAxL,EAAAyL,KAAA,SAAAtI,EAAArC,GACA,IACAsB,EADA5J,KACAU,YAYA,YAVA,IAAAiK,GACAA,EAAAf,EAAA/D,UACAyC,EAAAsB,EAAA9D,WAEAoC,EAAAyC,EAAA,EAAAnF,QAEA,IAAA8C,EAAAA,EAAAsB,EAAA9D,SACAoC,EAAAI,EAAA,EAAA,IAGAmB,EAAA,IAAAG,EAbA5J,MAaA2K,EAAArC,EACA,EAUAd,EAAAuD,SAAA,WACA,IAAAxB,EAAAvJ,KACA4J,EAAAL,EAAA7I,YACAqH,EAAA+J,EAAAvI,EAAAA,EAAAnH,GAAAwH,EAAA5D,UAAAuD,EAAAnH,GAAAwH,EAAA3D,UAEA,OAAAsD,EAAAsE,UAAAtE,EAAAsB,SAAA,IAAA9C,EAAAA,CACA,EAOAP,EAAA0L,UAAA1L,EAAA2L,MAAA,WACA,OAAA1J,EAAA,IAAAzJ,KAAAU,YAAAV,MAAAA,KAAAoC,EAAA,EAAA,EACA,EAQAoF,EAAArF,QAAAqF,EAAA4L,OAAA,WACA,IAAA7J,EAAAvJ,KACA4J,EAAAL,EAAA7I,YACAqH,EAAA+J,EAAAvI,EAAAA,EAAAnH,GAAAwH,EAAA5D,UAAAuD,EAAAnH,GAAAwH,EAAA3D,UAEA,OAAAsD,EAAAsE,QAAA,IAAA9F,EAAAA,CACA,EAkNA,IAAAiE,EAAA,WAGA,SAAAqH,EAAA9J,EAAA3B,EAAAtI,GACA,IAAAgU,EACAzC,EAAA,EACAlO,EAAA4G,EAAA1J,OAEA,IAAA0J,EAAAA,EAAAwC,QAAApJ,KACA2Q,EAAA/J,EAAA5G,GAAAiF,EAAAiJ,EACAtH,EAAA5G,GAAA2Q,EAAAhU,EAAA,EACAuR,EAAAyC,EAAAhU,EAAA,EAKA,OAFAuR,GAAAtH,EAAAuH,QAAAD,GAEAtH,CACA,CAEA,SAAAgK,EAAAxO,EAAAyO,EAAAC,EAAAC,GACA,IAAA/Q,EAAA8B,EAEA,GAAAgP,GAAAC,EACAjP,EAAAgP,EAAAC,EAAA,GAAA,OAEA,IAAA/Q,EAAA8B,EAAA,EAAA9B,EAAA8Q,EAAA9Q,IACA,GAAAoC,EAAApC,IAAA6Q,EAAA7Q,GAAA,CACA8B,EAAAM,EAAApC,GAAA6Q,EAAA7Q,GAAA,GAAA,EACA,KACA,CAIA,OAAA8B,CACA,CAEA,SAAAkP,EAAA5O,EAAAyO,EAAAC,EAAAnU,GAIA,IAHA,IAAAqD,EAAA,EAGA8Q,KACA1O,EAAA0O,IAAA9Q,EACAA,EAAAoC,EAAA0O,GAAAD,EAAAC,GAAA,EAAA,EACA1O,EAAA0O,GAAA9Q,EAAArD,EAAAyF,EAAA0O,GAAAD,EAAAC,GAIA,MAAA1O,EAAA,IAAAA,EAAAlF,OAAA,GAAAkF,EAAAsL,OACA,CAEA,OAAA,SAAA9G,EAAAU,EAAAS,EAAApC,EAAA6D,EAAA7M,GACA,IAAAyK,EAAA3H,EAAAO,EAAAiF,EAAAgM,EAAAC,EAAAC,EAAAC,EAAAvD,EAAAwD,EAAAC,EAAAC,EAAAC,EAAAxJ,EAAAhG,EAAAyP,EAAAC,EAAAC,EACAC,EAAAC,EACA5K,EAAAL,EAAA7I,YACA+T,EAAAlL,EAAAC,GAAAS,EAAAT,EAAA,GAAA,EACAY,EAAAb,EAAA5B,EACA0C,EAAAJ,EAAAtC,EAGA,KAAAyC,GAAAA,EAAA,IAAAC,GAAAA,EAAA,IAEA,OAAA,IAAAT,EACAL,EAAAC,GAAAS,EAAAT,IAAAY,GAAAC,GAAAD,EAAA,IAAAC,EAAA,GAAAA,GAGAD,GAAA,GAAAA,EAAA,KAAAC,EAAA,EAAAoK,EAAAA,EAAA,EAHA5K,KAsBA,IAhBAvK,GACAsU,EAAA,EACAxR,EAAAmH,EAAAnH,EAAA6H,EAAA7H,IAEA9C,EAAA8H,EACAwM,EAAAvM,EACAjF,EAAAuE,EAAA4C,EAAAnH,EAAAwR,GAAAjN,EAAAsD,EAAA7H,EAAAwR,IAGAW,EAAAlK,EAAAxK,OACAwU,EAAAjK,EAAAvK,OAEAmU,GADAxD,EAAA,IAAA5G,EAAA6K,IACA9M,EAAA,GAIAhF,EAAA,EAAA0H,EAAA1H,KAAAyH,EAAAzH,IAAA,GAAAA,KAaA,GAXA0H,EAAA1H,IAAAyH,EAAAzH,IAAA,IAAAP,IAEA,MAAAsI,GACAC,EAAAD,EAAAd,EAAA/D,UACAyC,EAAAsB,EAAA9D,UAEA6E,EADAwB,EACAzB,GAAAnB,EAAAnH,EAAA6H,EAAA7H,GAAA,EAEAsI,EAGAC,EAAA,EACAqJ,EAAA7D,KAAA,GACA0D,GAAA,MACA,CAOA,GAJAlJ,EAAAA,EAAAiJ,EAAA,EAAA,EACAjR,EAAA,EAGA,GAAA4R,EAAA,CAMA,IALA3M,EAAA,EACAyC,EAAAA,EAAA,GACAM,KAGAhI,EAAA0R,GAAAzM,IAAA+C,IAAAhI,IACAgC,EAAAiD,EAAAtI,GAAA8K,EAAAzH,IAAA,GACAqR,EAAArR,GAAAgC,EAAA0F,EAAA,EACAzC,EAAAjD,EAAA0F,EAAA,EAGAwJ,EAAAjM,GAAAjF,EAAA0R,CAGA,KAAA,CAiBA,KAdAzM,EAAAtI,GAAA+K,EAAA,GAAA,GAAA,GAEA,IACAA,EAAAgJ,EAAAhJ,EAAAzC,EAAAtI,GACA8K,EAAAiJ,EAAAjJ,EAAAxC,EAAAtI,GACAiV,EAAAlK,EAAAxK,OACAwU,EAAAjK,EAAAvK,QAGAuU,EAAAG,EAEAL,GADAD,EAAA7J,EAAA2B,MAAA,EAAAwI,IACA1U,OAGAqU,EAAAK,GAAAN,EAAAC,KAAA,GAEAM,EAAAnK,EAAA0B,SACA+E,QAAA,GACAwD,EAAAjK,EAAA,GAEAA,EAAA,IAAA/K,EAAA,KAAAgV,EAEA,GACA1M,EAAA,GAGAmC,EAAAwJ,EAAAlJ,EAAA4J,EAAAM,EAAAL,IAGA,GAGAC,EAAAF,EAAA,GACAM,GAAAL,IAAAC,EAAAA,EAAA7U,GAAA2U,EAAA,IAAA,KAGArM,EAAAuM,EAAAG,EAAA,GAUA,GACA1M,GAAAtI,IAAAsI,EAAAtI,EAAA,GAWA,IAHAyK,EAAAwJ,EALAO,EAAAT,EAAAhJ,EAAAzC,EAAAtI,GAKA2U,EAJAF,EAAAD,EAAAjU,OACAqU,EAAAD,EAAApU,WAOA+H,IAGA+L,EAAAG,EAAAS,EAAAR,EAAAS,EAAAnK,EAAA0J,EAAAzU,MAOA,GAAAsI,IAAAmC,EAAAnC,EAAA,GACAkM,EAAAzJ,EAAA0B,UAGAgI,EAAAD,EAAAjU,QACAqU,GAAAJ,EAAAhD,QAAA,GAGA6C,EAAAM,EAAAH,EAAAI,EAAA5U,IAGA,GAAAyK,IAIAA,EAAAwJ,EAAAlJ,EAAA4J,EAAAM,EAHAL,EAAAD,EAAApU,SAMA,IACA+H,IAGA+L,EAAAM,EAAAM,EAAAL,EAAAM,EAAAnK,EAAA6J,EAAA5U,IAIA4U,EAAAD,EAAApU,QACA,IAAAkK,IACAnC,IACAqM,EAAA,CAAA,IAIAD,EAAArR,KAAAiF,EAGAmC,GAAAkK,EAAA,GACAA,EAAAC,KAAA9J,EAAAgK,IAAA,GAEAH,EAAA,CAAA7J,EAAAgK,IACAF,EAAA,UAGAE,IAAAC,QAAA,IAAAJ,EAAA,KAAAtJ,KAEAkJ,OAAA,IAAAI,EAAA,EACA,CAGAD,EAAA,IAAAA,EAAA3D,OACA,CAGA,GAAA,GAAAuD,EACApD,EAAApO,EAAAA,EACAgD,EAAAyO,MACA,CAGA,IAAAlR,EAAA,EAAAiF,EAAAoM,EAAA,GAAApM,GAAA,GAAAA,GAAA,GAAAjF,IACA6N,EAAApO,EAAAO,EAAAP,EAAAwR,EAAA,EAEAnK,EAAA+G,EAAArE,EAAAzB,EAAA8F,EAAApO,EAAA,EAAAsI,EAAApC,EAAAuL,EACA,CAEA,OAAArD,CACA,CACA,CArQA,GA4QA,SAAA/G,EAAAF,EAAAoB,EAAArC,EAAAoM,GACA,IAAAC,EAAAhS,EAAAmG,EAAAlB,EAAAa,EAAAmM,EAAA5M,EAAAoC,EAAAyK,EACAjL,EAAAL,EAAA7I,YAGAoU,EAAA,GAAA,MAAAnK,EAAA,CAIA,KAHAP,EAAAb,EAAA5B,GAGA,OAAA4B,EAWA,IAAAoL,EAAA,EAAA/M,EAAAwC,EAAA,GAAAxC,GAAA,GAAAA,GAAA,GAAA+M,IAIA,IAHAhS,EAAAgI,EAAAgK,GAGA,EACAhS,GAAA0E,EACAyB,EAAA6B,EAIAlC,GAHAT,EAAAoC,EAAAyK,EAAA,IAGA/N,EAAA,GAAA6N,EAAA7L,EAAA,GAAA,GAAA,OAIA,IAFA+L,EAAAjO,KAAA8B,MAAA/F,EAAA,GAAA0E,MACAO,EAAAwC,EAAAvK,QACA,CACA,IAAA6U,EASA,MAAAI,EANA,KAAAlN,KAAAiN,GAAAzK,EAAA+F,KAAA,GACAnI,EAAAS,EAAA,EACAkM,EAAA,EAEA7L,GADAnG,GAAA0E,GACAA,EAAA,CAIA,KAAA,CAIA,IAHAW,EAAAJ,EAAAwC,EAAAyK,GAGAF,EAAA,EAAA/M,GAAA,GAAAA,GAAA,GAAA+M,IAUAlM,GAHAK,GAJAnG,GAAA0E,GAIAA,EAAAsN,GAGA,EAAA,EAAA3M,EAAAlB,EAAA,GAAA6N,EAAA7L,EAAA,GAAA,GAAA,CACA,CAmBA,GAfA4L,EAAAA,GAAA/J,EAAA,QACA,IAAAP,EAAAyK,EAAA,KAAA/L,EAAA,EAAAd,EAAAA,EAAAlB,EAAA,GAAA6N,EAAA7L,EAAA,IAMA8L,EAAAtM,EAAA,GACAG,GAAAiM,KAAA,GAAApM,GAAAA,IAAAiB,EAAAC,EAAA,EAAA,EAAA,IACAf,EAAA,GAAA,GAAAA,IAAA,GAAAH,GAAAoM,GAAA,GAAApM,IAGA3F,EAAA,EAAAmG,EAAA,EAAAd,EAAAlB,EAAA,GAAA6N,EAAA7L,GAAA,EAAAsB,EAAAyK,EAAA,IAAA,GAAA,GACAvM,IAAAiB,EAAAC,EAAA,EAAA,EAAA,IAEAmB,EAAA,IAAAP,EAAA,GAgBA,OAfAA,EAAAvK,OAAA,EACA+U,GAGAjK,GAAApB,EAAAnH,EAAA,EAGAgI,EAAA,GAAAtD,EAAA,IAAAO,EAAAsD,EAAAtD,GAAAA,GACAkC,EAAAnH,GAAAuI,GAAA,GAIAP,EAAA,GAAAb,EAAAnH,EAAA,EAGAmH,EAiBA,GAbA,GAAA5G,GACAyH,EAAAvK,OAAAgV,EACAjN,EAAA,EACAiN,MAEAzK,EAAAvK,OAAAgV,EAAA,EACAjN,EAAAd,EAAA,GAAAO,EAAA1E,GAIAyH,EAAAyK,GAAA/L,EAAA,GAAAd,EAAAlB,EAAA,GAAA6N,EAAA7L,GAAAhC,EAAA,GAAAgC,GAAA,GAAAlB,EAAA,GAGAgN,EACA,OAAA,CAGA,GAAA,GAAAC,EAAA,CAGA,IAAAlS,EAAA,EAAAmG,EAAAsB,EAAA,GAAAtB,GAAA,GAAAA,GAAA,GAAAnG,IAEA,IADAmG,EAAAsB,EAAA,IAAAxC,EACAA,EAAA,EAAAkB,GAAA,GAAAA,GAAA,GAAAlB,IAGAjF,GAAAiF,IACA2B,EAAAnH,IACAgI,EAAA,IAAAhD,IAAAgD,EAAA,GAAA,IAGA,KACA,CAEA,GADAA,EAAAyK,IAAAjN,EACAwC,EAAAyK,IAAAzN,EAAA,MACAgD,EAAAyK,KAAA,EACAjN,EAAA,CAEA,CAIA,IAAAjF,EAAAyH,EAAAvK,OAAA,IAAAuK,IAAAzH,IAAAyH,EAAAgG,KACA,CAqBA,OAnBA/J,IAGAkD,EAAAnH,EAAAwH,EAAAzD,MAGAoD,EAAA5B,EAAA,KACA4B,EAAAnH,EAAAyH,KAGAN,EAAAnH,EAAAwH,EAAA1D,OAGAqD,EAAAnH,EAAA,EACAmH,EAAA5B,EAAA,CAAA,KAKA4B,CACA,CAGA,SAAAuI,EAAAvI,EAAAwL,EAAApK,GACA,IAAApB,EAAAsC,WAAA,OAAAmJ,EAAAzL,GACA,IAAA3B,EACAxF,EAAAmH,EAAAnH,EACA2F,EAAAL,EAAA6B,EAAA5B,GACAiD,EAAA7C,EAAAlI,OAwBA,OAtBAkV,GACApK,IAAA/C,EAAA+C,EAAAC,GAAA,EACA7C,EAAAA,EAAAoB,OAAA,GAAA,IAAApB,EAAAgE,MAAA,GAAA9D,EAAAL,GACAgD,EAAA,IACA7C,EAAAA,EAAAoB,OAAA,GAAA,IAAApB,EAAAgE,MAAA,IAGAhE,EAAAA,GAAAwB,EAAAnH,EAAA,EAAA,IAAA,MAAAmH,EAAAnH,GACAA,EAAA,GACA2F,EAAA,KAAAE,GAAA7F,EAAA,GAAA2F,EACA4C,IAAA/C,EAAA+C,EAAAC,GAAA,IAAA7C,GAAAE,EAAAL,KACAxF,GAAAwI,GACA7C,GAAAE,EAAA7F,EAAA,EAAAwI,GACAD,IAAA/C,EAAA+C,EAAAvI,EAAA,GAAA,IAAA2F,EAAAA,EAAA,IAAAE,EAAAL,OAEAA,EAAAxF,EAAA,GAAAwI,IAAA7C,EAAAA,EAAAgE,MAAA,EAAAnE,GAAA,IAAAG,EAAAgE,MAAAnE,IACA+C,IAAA/C,EAAA+C,EAAAC,GAAA,IACAxI,EAAA,IAAAwI,IAAA7C,GAAA,KACAA,GAAAE,EAAAL,KAIAG,CACA,CAIA,SAAAuI,EAAAqE,EAAAvS,GACA,IAAA4F,EAAA2M,EAAA,GAGA,IAAAvS,GAAAiF,EAAAW,GAAA,GAAAA,GAAA,GAAA5F,IACA,OAAAA,CACA,CAGA,SAAA2N,EAAAnG,EAAAe,EAAAD,GACA,GAAAC,EAAArD,EAKA,MAFAjB,GAAA,EACAqE,IAAAd,EAAA/D,UAAA6E,GACA1F,MAAAwB,GAEA,OAAAiD,EAAA,IAAAG,EAAAlE,GAAAiF,EAAA,GAAA,EACA,CAGA,SAAAmD,EAAAlE,EAAAe,EAAArC,GACA,GAAAqC,EAAApD,EAAA,MAAAvC,MAAAwB,GACA,OAAAiD,EAAA,IAAAG,EAAAjE,GAAAgF,EAAArC,GAAA,EACA,CAGA,SAAA0I,EAAA2D,GACA,IAAA3M,EAAA2M,EAAA9U,OAAA,EACA+K,EAAA5C,EAAAX,EAAA,EAKA,GAHAW,EAAA2M,EAAA3M,GAGA,CAGA,KAAAA,EAAA,IAAA,EAAAA,GAAA,GAAA4C,IAGA,IAAA5C,EAAA2M,EAAA,GAAA3M,GAAA,GAAAA,GAAA,GAAA4C,GACA,CAEA,OAAAA,CACA,CAGA,SAAA3C,EAAAL,GAEA,IADA,IAAAqN,EAAA,GACArN,KAAAqN,GAAA,IACA,OAAAA,CACA,CAUA,SAAAnC,EAAAlJ,EAAAL,EAAA7E,EAAAgG,GACA,IAAAgK,EACAjQ,EAAA,IAAAmF,EAAA,GAIAhC,EAAAhB,KAAA8B,KAAAgC,EAAArD,EAAA,GAIA,IAFAhB,GAAA,IAEA,CAOA,GANA3B,EAAA,GAEAwQ,GADAzQ,EAAAA,EAAAwG,MAAA1B,IACA5B,EAAAC,KAAA8M,GAAA,GAIA,KADAhQ,EAAAiC,EAAAjC,EAAA,IACA,CAGAA,EAAAD,EAAAkD,EAAA9H,OAAA,EACA6U,GAAA,IAAAjQ,EAAAkD,EAAAjD,MAAAD,EAAAkD,EAAAjD,GACA,KACA,CAGAwQ,GADA3L,EAAAA,EAAA0B,MAAA1B,IACA5B,EAAAC,EACA,CAIA,OAFAvB,GAAA,EAEA5B,CACA,CAGA,SAAA0Q,EAAAzQ,GACA,OAAA,EAAAA,EAAAiD,EAAAjD,EAAAiD,EAAA9H,OAAA,EACA,CAMA,SAAAuV,EAAAxL,EAAAyL,EAAAC,GAKA,IAJA,IAAArL,EACAV,EAAA,IAAAK,EAAAyL,EAAA,IACA1S,EAAA,IAEAA,EAAA0S,EAAAxV,QAAA,CAEA,KADAoK,EAAA,IAAAL,EAAAyL,EAAA1S,KACA6G,EAAA,CACAD,EAAAU,EACA,KACA,CAAAV,EAAA+L,GAAArL,KACAV,EAAAU,EAEA,CAEA,OAAAV,CACA,CAkCA,SAAAkH,EAAAlH,EAAAoB,GACA,IAAAgF,EAAA4F,EAAAzM,EAAA/B,EAAAyO,EAAA7Q,EAAA6J,EACA9C,EAAA,EACA/I,EAAA,EACAiF,EAAA,EACAgC,EAAAL,EAAA7I,YACA4H,EAAAsB,EAAA9D,SACA4E,EAAAd,EAAA/D,UAGA,IAAA0D,EAAA5B,IAAA4B,EAAA5B,EAAA,IAAA4B,EAAAnH,EAAA,GAEA,OAAA,IAAAwH,EAAAL,EAAA5B,EACA4B,EAAA5B,EAAA,GAAA4B,EAAAC,EAAA,EAAA,EAAA,IAAA,EACAD,EAAAC,EAAAD,EAAAC,EAAA,EAAA,EAAAD,EAAA,KAaA,IAVA,MAAAoB,GACAtE,GAAA,EACAmI,EAAA9D,GAEA8D,EAAA7D,EAGAhG,EAAA,IAAAiF,EAAA,QAGAL,EAAAnH,GAAA,GAGAmH,EAAAA,EAAA0B,MAAAtG,GACAiD,GAAA,EAUA,IAJA4G,GADA+G,EAAA3O,KAAA6I,IAAA3I,EAAA,EAAAc,IAAAhB,KAAAlB,KAAA,EAAA,EAAA,EAEAiK,EAAA5I,EAAAyO,EAAA,IAAA5L,EAAA,GACAA,EAAA/D,UAAA2I,IAEA,CAKA,GAJAzH,EAAA0C,EAAA1C,EAAAkE,MAAA1B,GAAAiF,EAAA,GACAmB,EAAAA,EAAA1E,QAAAtI,GAGA+E,GAFA/C,EAAA6Q,EAAApK,KAAAY,EAAAjF,EAAA4I,EAAAnB,EAAA,KAEA7G,GAAAoE,MAAA,EAAAyC,KAAA9G,EAAA8N,EAAA7N,GAAAoE,MAAA,EAAAyC,GAAA,CAEA,IADA1F,EAAAlB,EACAkB,KAAA0M,EAAA/L,EAAA+L,EAAAvK,MAAAuK,GAAAhH,EAAA,GAOA,GAAA,MAAA7D,EAYA,OADAf,EAAA/D,UAAA6E,EACA8K,EAVA,KAAA9J,EAAA,GAAArD,EAAAmN,EAAA7N,EAAA6G,EAAA+G,EAAAjN,EAAAoD,IAMA,OAAAjC,EAAA+L,EAAA5L,EAAA/D,UAAA6E,EAAApC,EAAAjC,GAAA,GALAuD,EAAA/D,UAAA2I,GAAA,GACAmB,EAAA5I,EAAApC,EAAA,IAAAiF,EAAA,GACAjH,EAAA,EACA+I,GAQA,CAEA8J,EAAA7Q,CACA,CACA,CAkBA,SAAAmL,EAAA7F,EAAAU,GACA,IAAA/F,EAAA6Q,EAAA9F,EAAAvN,EAAAsT,EAAAhK,EAAA8J,EAAA7Q,EAAA6J,EAAAmH,EAAA7G,EACApK,EAAA,EAEA6E,EAAAU,EACAG,EAAAb,EAAA5B,EACAiC,EAAAL,EAAA7I,YACA4H,EAAAsB,EAAA9D,SACA4E,EAAAd,EAAA/D,UAGA,GAAA0D,EAAAC,EAAA,IAAAY,IAAAA,EAAA,KAAAb,EAAAnH,GAAA,GAAAgI,EAAA,IAAA,GAAAA,EAAAvK,OACA,OAAA,IAAA+J,EAAAQ,IAAAA,EAAA,IAAA,IAAA,GAAAb,EAAAC,EAAAK,IAAAO,EAAA,EAAAb,GAcA,GAXA,MAAAoB,GACAtE,GAAA,EACAmI,EAAA9D,GAEA8D,EAAA7D,EAGAf,EAAA/D,UAAA2I,GAnBA,GAqBAiH,GADA7Q,EAAA8C,EAAA0C,IACAjB,OAAA,KAEAvC,KAAA0C,IAAAlH,EAAAmH,EAAAnH,GAAA,OAqCA,OAJAuC,EAAAoL,EAAAnG,EAAA4E,EAAA,EAAA9D,GAAAO,MAAA7I,EAAA,IACAmH,EAAAuG,EAAA,IAAAlG,EAAA6L,EAAA,IAAA7Q,EAAAmH,MAAA,IAAAyC,EAzDA,IAyDApD,KAAAzG,GACAiF,EAAA/D,UAAA6E,EAEA,MAAAC,EAAAlB,EAAAF,EAAAmB,EAAApC,EAAAjC,GAAA,GAAAkD,EAxBA,KAAAkM,EAAA,GAAA,GAAAA,GAAA,GAAAA,GAAA7Q,EAAAuE,OAAA,GAAA,GAGAsM,GADA7Q,EAAA8C,GADA6B,EAAAA,EAAA0B,MAAAhB,IACAtC,IACAwB,OAAA,GACAzE,IAiCA,IA9BAtC,EAAAmH,EAAAnH,EAEAqT,EAAA,GACAlM,EAAA,IAAAK,EAAA,KAAAhF,GACAxC,KAEAmH,EAAA,IAAAK,EAAA6L,EAAA,IAAA7Q,EAAAmH,MAAA,IAeA4J,EAAApM,EAKAiM,EAAAE,EAAAnM,EAAAyC,EAAAzC,EAAA4B,MAAA,GAAA5B,EAAA6B,KAAA,GAAAoD,EAAA,GACAM,EAAArF,EAAAF,EAAA0B,MAAA1B,GAAAiF,EAAA,GACAmB,EAAA,IAEA,CAIA,GAHA+F,EAAAjM,EAAAiM,EAAAzK,MAAA6D,GAAAN,EAAA,GAGA9G,GAFA/C,EAAA6Q,EAAApK,KAAAY,EAAA0J,EAAA,IAAA9L,EAAA+F,GAAAnB,EAAA,KAEA7G,GAAAoE,MAAA,EAAAyC,KAAA9G,EAAA8N,EAAA7N,GAAAoE,MAAA,EAAAyC,GAAA,CAcA,GAbAgH,EAAAA,EAAAvK,MAAA,GAIA,IAAA7I,IAAAoT,EAAAA,EAAApK,KAAA2E,EAAAnG,EAAA4E,EAAA,EAAA9D,GAAAO,MAAA7I,EAAA,MACAoT,EAAAxJ,EAAAwJ,EAAA,IAAA5L,EAAAlF,GAAA8J,EAAA,GAQA,MAAA7D,EAWA,OADAf,EAAA/D,UAAA6E,EACA8K,EAVA,IAAAnN,EAAAmN,EAAA7N,EAAA6G,EA5FA,GA4FAlG,EAAAoD,GAMA,OAAAjC,EAAA+L,EAAA5L,EAAA/D,UAAA6E,EAAApC,EAAAjC,GAAA,GALAuD,EAAA/D,UAAA2I,GA7FA,GA8FA7J,EAAA+Q,EAAAnM,EAAAyC,EAAA2J,EAAAxK,MAAA,GAAAwK,EAAAvK,KAAA,GAAAoD,EAAA,GACAM,EAAArF,EAAAF,EAAA0B,MAAA1B,GAAAiF,EAAA,GACAmB,EAAAjE,EAAA,CAQA,CAEA8J,EAAA7Q,EACAgL,GAAA,CACA,CACA,CAIA,SAAAqF,EAAAzL,GAEA,OAAAhG,OAAAgG,EAAAC,EAAAD,EAAAC,EAAA,EACA,CAMA,SAAAoM,EAAArM,EAAAxB,GACA,IAAA3F,EAAAO,EAAAiI,EAmBA,KAhBAxI,EAAA2F,EAAAmB,QAAA,OAAA,IAAAnB,EAAAA,EAAA8N,QAAA,IAAA,MAGAlT,EAAAoF,EAAA+N,OAAA,OAAA,GAGA1T,EAAA,IAAAA,EAAAO,GACAP,IAAA2F,EAAAgE,MAAApJ,EAAA,GACAoF,EAAAA,EAAAgO,UAAA,EAAApT,IACAP,EAAA,IAGAA,EAAA2F,EAAAlI,QAIA8C,EAAA,EAAA,KAAAoF,EAAAiO,WAAArT,GAAAA,KAGA,IAAAiI,EAAA7C,EAAAlI,OAAA,KAAAkI,EAAAiO,WAAApL,EAAA,KAAAA,GAGA,GAFA7C,EAAAA,EAAAgE,MAAApJ,EAAAiI,GAEA,CAYA,GAXAA,GAAAjI,EACA4G,EAAAnH,EAAAA,EAAAA,EAAAO,EAAA,EACA4G,EAAA5B,EAAA,GAMAhF,GAAAP,EAAA,GAAAiF,EACAjF,EAAA,IAAAO,GAAA0E,GAEA1E,EAAAiI,EAAA,CAEA,IADAjI,GAAA4G,EAAA5B,EAAAwI,MAAApI,EAAAgE,MAAA,EAAApJ,IACAiI,GAAAvD,EAAA1E,EAAAiI,GAAArB,EAAA5B,EAAAwI,MAAApI,EAAAgE,MAAApJ,EAAAA,GAAA0E,IACAU,EAAAA,EAAAgE,MAAApJ,GACAA,EAAA0E,EAAAU,EAAAlI,MACA,MACA8C,GAAAiI,EAGA,KAAAjI,KAAAoF,GAAA,IACAwB,EAAA5B,EAAAwI,MAAApI,GAEA1B,IAGAkD,EAAAnH,EAAAmH,EAAA7I,YAAAyF,MAGAoD,EAAA5B,EAAA,KACA4B,EAAAnH,EAAAyH,KAGAN,EAAAnH,EAAAmH,EAAA7I,YAAAwF,OAGAqD,EAAAnH,EAAA,EACAmH,EAAA5B,EAAA,CAAA,IAIA,MAGA4B,EAAAnH,EAAA,EACAmH,EAAA5B,EAAA,CAAA,GAGA,OAAA4B,CACA,CAMA,SAAA0M,EAAA1M,EAAAxB,GACA,IAAAzI,EAAAsK,EAAAsM,EAAAvT,EAAAwT,EAAAvL,EAAA5J,EAAAoJ,EAAA6F,EAEA,GAAAlI,EAAAmB,QAAA,MAAA,GAEA,GADAnB,EAAAA,EAAA8N,QAAA,eAAA,MACA1O,EAAAiP,KAAArO,GAAA,OAAA6N,EAAArM,EAAAxB,QACA,GAAA,aAAAA,GAAA,QAAAA,EAIA,OAHAA,IAAAwB,EAAAC,EAAAK,KACAN,EAAAnH,EAAAyH,IACAN,EAAA5B,EAAA,KACA4B,EAGA,GAAAtC,EAAAmP,KAAArO,GACAzI,EAAA,GACAyI,EAAAA,EAAAsO,mBACA,GAAArP,EAAAoP,KAAArO,GACAzI,EAAA,MACA,KAAA4H,EAAAkP,KAAArO,GAGA,MAAA/C,MAAAuB,EAAAwB,GAFAzI,EAAA,CAGA,CA+BA,KA5BAqD,EAAAoF,EAAA+N,OAAA,OAEA,GACA9U,GAAA+G,EAAAgE,MAAApJ,EAAA,GACAoF,EAAAA,EAAAgO,UAAA,EAAApT,IAEAoF,EAAAA,EAAAgE,MAAA,GAMAoK,GADAxT,EAAAoF,EAAAmB,QAAA,OACA,EACAU,EAAAL,EAAA7I,YAEAyV,IAGAxT,GADAiI,GADA7C,EAAAA,EAAA8N,QAAA,IAAA,KACAhW,QACA8C,EAGAuT,EAAApD,EAAAlJ,EAAA,IAAAA,EAAAtK,GAAAqD,EAAA,EAAAA,IAOAA,EAHAsN,GADA7F,EAAAzB,EAAAZ,EAAAzI,EAAA8H,IACAvH,OAAA,EAGA,IAAAuK,EAAAzH,KAAAA,EAAAyH,EAAAgG,MACA,OAAAzN,EAAA,EAAA,IAAAiH,EAAA,EAAAL,EAAAC,IACAD,EAAAnH,EAAAkO,EAAAlG,EAAA6F,GACA1G,EAAA5B,EAAAyC,EACA/D,GAAA,EAQA8P,IAAA5M,EAAAyC,EAAAzC,EAAA2M,EAAA,EAAAtL,IAGA5J,IAAAuI,EAAAA,EAAA0B,MAAArE,KAAA0C,IAAAtI,GAAA,GAAA8F,EAAA,EAAA9F,GAAAmE,EAAA4B,IAAA,EAAA/F,KACAqF,GAAA,EAEAkD,EACA,CA0CA,SAAAyB,EAAApB,EAAAlF,EAAA6E,EAAAU,EAAAqM,GACA,IAAAxN,EAAAnE,EAAAG,EAAAgK,EAEApE,EAAAd,EAAA/D,UACA+B,EAAAhB,KAAA8B,KAAAgC,EAAArD,GAMA,IAJAhB,GAAA,EACAyI,EAAAvF,EAAA0B,MAAA1B,GACAzE,EAAA,IAAA8E,EAAAK,KAEA,CAMA,GALAtF,EAAAqH,EAAAlH,EAAAmG,MAAA6D,GAAA,IAAAlF,EAAAlF,IAAAA,KAAAgG,EAAA,GACA5F,EAAAwR,EAAArM,EAAAmB,KAAAzG,GAAAsF,EAAAkB,MAAAxG,GACAsF,EAAA+B,EAAArH,EAAAsG,MAAA6D,GAAA,IAAAlF,EAAAlF,IAAAA,KAAAgG,EAAA,QAGA,KAFA/F,EAAAG,EAAAsG,KAAAnB,IAEAtC,EAAAC,GAAA,CACA,IAAAkB,EAAAlB,EAAAjD,EAAAgD,EAAAmB,KAAAhE,EAAA6C,EAAAmB,IAAAA,MACA,IAAA,GAAAA,EAAA,KACA,CAEAA,EAAAhE,EACAA,EAAAmF,EACAA,EAAAtF,EACAA,EAAAmE,CAEA,CAKA,OAHAzC,GAAA,EACA1B,EAAAgD,EAAA9H,OAAA+H,EAAA,EAEAjD,CACA,CAIA,SAAAmG,EAAA0I,EAAApR,GAEA,IADA,IAAAsC,EAAA8O,IACApR,GAAAsC,GAAA8O,EACA,OAAA9O,CACA,CAIA,SAAA2G,EAAAzB,EAAAL,GACA,IAAA5E,EACAkJ,EAAAtE,EAAAC,EAAA,EACA+M,EAAAzI,EAAAlE,EAAAA,EAAA/D,UAAA,GACA+H,EAAA2I,EAAAtL,MAAA,IAIA,IAFA1B,EAAAA,EAAAD,OAEA4E,IAAAN,GAEA,OADAtI,EAAAuI,EAAA,EAAA,EACAtE,EAKA,IAFA5E,EAAA4E,EAAAgD,SAAAgK,IAEA1L,SACAvF,EAAAuI,EAAA,EAAA,MACA,CAIA,IAHAtE,EAAAA,EAAA4B,MAAAxG,EAAAsG,MAAAsL,KAGArI,IAAAN,GAEA,OADAtI,EAAA6P,EAAAxQ,GAAAkJ,EAAA,EAAA,EAAAA,EAAA,EAAA,EACAtE,EAGAjE,EAAA6P,EAAAxQ,GAAAkJ,EAAA,EAAA,EAAAA,EAAA,EAAA,CACA,CAEA,OAAAtE,EAAA4B,MAAAoL,GAAAjN,KACA,CAQA,SAAAqI,EAAApI,EAAAV,EAAA8B,EAAArC,GACA,IAAAhJ,EAAA8C,EAAAO,EAAAiF,EAAAgD,EAAAgK,EAAA7M,EAAAqC,EAAAH,EACAL,EAAAL,EAAA7I,YACAqU,OAAA,IAAApK,EAWA,GATAoK,GACA7M,EAAAyC,EAAA,EAAAnF,QACA,IAAA8C,EAAAA,EAAAsB,EAAA9D,SACAoC,EAAAI,EAAA,EAAA,KAEAqC,EAAAf,EAAA/D,UACAyC,EAAAsB,EAAA9D,UAGAyD,EAAAsC,WAEA,CAoCA,IA3BAkJ,GACAzV,EAAA,EACA,IAAAuJ,EACA8B,EAAA,EAAAA,EAAA,EACA,GAAA9B,IACA8B,EAAA,EAAAA,EAAA,IAGArL,EAAAuJ,GAfAlG,GADAoF,EAAA+J,EAAAvI,IACAL,QAAA,OAsBA,IACAnB,EAAAA,EAAA8N,QAAA,IAAA,KACA5L,EAAA,IAAAL,EAAA,IACAxH,EAAA2F,EAAAlI,OAAA8C,EACAsH,EAAAtC,EAAAgB,EAAAmJ,EAAA7H,GAAA,GAAA3K,GACA2K,EAAA7H,EAAA6H,EAAAtC,EAAA9H,QAIAuC,EAAAwI,GADAR,EAAAzB,EAAAZ,EAAA,GAAAzI,IACAO,OAGA,GAAAuK,IAAAQ,IAAAR,EAAAgG,MAEA,GAAAhG,EAAA,GAEA,CAyBA,GAxBAzH,EAAA,EACAP,MAEAmH,EAAA,IAAAK,EAAAL,IACA5B,EAAAyC,EACAb,EAAAnH,EAAAA,EAEAgI,GADAb,EAAAyC,EAAAzC,EAAAU,EAAAU,EAAArC,EAAA,EAAAhJ,IACAqI,EACAvF,EAAAmH,EAAAnH,EACAwS,EAAAxP,GAIAzC,EAAAyH,EAAAO,GACA/C,EAAAtI,EAAA,EACAsV,EAAAA,QAAA,IAAAxK,EAAAO,EAAA,GAEAiK,EAAAtM,EAAA,QACA,IAAA3F,GAAAiS,KAAA,IAAAtM,GAAAA,KAAAiB,EAAAC,EAAA,EAAA,EAAA,IACA7G,EAAAiF,GAAAjF,IAAAiF,IAAA,IAAAU,GAAAsM,GAAA,IAAAtM,GAAA,EAAA8B,EAAAO,EAAA,IACArC,KAAAiB,EAAAC,EAAA,EAAA,EAAA,IAEAY,EAAAvK,OAAA8K,EAEAiK,EAGA,OAAAxK,IAAAO,GAAArL,EAAA,GACA8K,EAAAO,GAAA,EACAA,MACAvI,EACAgI,EAAA0G,QAAA,IAMA,IAAAlG,EAAAR,EAAAvK,QAAAuK,EAAAQ,EAAA,KAAAA,GAGA,IAAAjI,EAAA,EAAAoF,EAAA,GAAApF,EAAAiI,EAAAjI,IAAAoF,GAAAtC,EAAA0D,OAAAiB,EAAAzH,IAGA,GAAAoS,EAAA,CACA,GAAAnK,EAAA,EACA,GAAA,IAAA/B,GAAA,GAAAA,EAAA,CAEA,IADAlG,EAAA,IAAAkG,EAAA,EAAA,IACA+B,EAAAA,EAAAjI,EAAAiI,IAAA7C,GAAA,IAEA,IAAA6C,GADAR,EAAAzB,EAAAZ,EAAAzI,EAAAuJ,IACAhJ,QAAAuK,EAAAQ,EAAA,KAAAA,GAGA,IAAAjI,EAAA,EAAAoF,EAAA,KAAApF,EAAAiI,EAAAjI,IAAAoF,GAAAtC,EAAA0D,OAAAiB,EAAAzH,GACA,MACAoF,EAAAA,EAAAoB,OAAA,GAAA,IAAApB,EAAAgE,MAAA,GAIAhE,EAAAA,GAAA3F,EAAA,EAAA,IAAA,MAAAA,CACA,MAAA,GAAAA,EAAA,EAAA,CACA,OAAAA,GAAA2F,EAAA,IAAAA,EACAA,EAAA,KAAAA,CACA,MACA,KAAA3F,EAAAwI,EAAA,IAAAxI,GAAAwI,EAAAxI,KAAA2F,GAAA,SACA3F,EAAAwI,IAAA7C,EAAAA,EAAAgE,MAAA,EAAA3J,GAAA,IAAA2F,EAAAgE,MAAA3J,GAEA,MApEA2F,EAAAgN,EAAA,OAAA,IAsEAhN,GAAA,IAAAc,EAAA,KAAA,GAAAA,EAAA,KAAA,GAAAA,EAAA,KAAA,IAAAd,CACA,MA/GAA,EAAAiN,EAAAzL,GAiHA,OAAAA,EAAAC,EAAA,EAAA,IAAAzB,EAAAA,CACA,CAIA,SAAAmN,EAAAlM,EAAA4B,GACA,GAAA5B,EAAAnJ,OAAA+K,EAEA,OADA5B,EAAAnJ,OAAA+K,GACA,CAEA,CAyDA,SAAAtB,GAAAC,GACA,OAAA,IAAAvJ,KAAAuJ,GAAAD,KACA,CASA,SAAAqE,GAAApE,GACA,OAAA,IAAAvJ,KAAAuJ,GAAAoE,MACA,CAUA,SAAAM,GAAA1E,GACA,OAAA,IAAAvJ,KAAAuJ,GAAA0E,OACA,CAWA,SAAA2C,GAAArH,EAAAU,GACA,OAAA,IAAAjK,KAAAuJ,GAAA6B,KAAAnB,EACA,CAUA,SAAA8D,GAAAxE,GACA,OAAA,IAAAvJ,KAAAuJ,GAAAwE,MACA,CAUA,SAAAM,GAAA9E,GACA,OAAA,IAAAvJ,KAAAuJ,GAAA8E,OACA,CAUA,SAAAM,GAAApF,GACA,OAAA,IAAAvJ,KAAAuJ,GAAAoF,MACA,CAUA,SAAAJ,GAAAhF,GACA,OAAA,IAAAvJ,KAAAuJ,GAAAgF,OACA,CA4BA,SAAAiI,GAAAvM,EAAAV,GACAU,EAAA,IAAAjK,KAAAiK,GACAV,EAAA,IAAAvJ,KAAAuJ,GACA,IAAA9E,EACAiG,EAAA1K,KAAA6F,UACAyC,EAAAtI,KAAA8F,SACA0I,EAAA9D,EAAA,EAkCA,OA/BAT,EAAAT,GAAAD,EAAAC,EAIAS,EAAAtC,GAAA4B,EAAA5B,GAKA4B,EAAA5B,GAAAsC,EAAAY,UACApG,EAAA8E,EAAAC,EAAA,EAAAsE,EAAA9N,KAAA0K,EAAApC,GAAA,IAAAtI,KAAA,IACAwJ,EAAAS,EAAAT,GAGAS,EAAAtC,GAAA4B,EAAAsB,UACApG,EAAAqJ,EAAA9N,KAAAwO,EAAA,GAAAvD,MAAA,KACAzB,EAAAS,EAAAT,EAGAD,EAAAC,EAAA,GACAxJ,KAAA6F,UAAA2I,EACAxO,KAAA8F,SAAA,EACArB,EAAAzE,KAAA2O,KAAA3C,EAAA/B,EAAAV,EAAAiF,EAAA,IACAjF,EAAAuE,EAAA9N,KAAAwO,EAAA,GACAxO,KAAA6F,UAAA6E,EACA1K,KAAA8F,SAAAwC,EACA7D,EAAAwF,EAAAT,EAAA,EAAA/E,EAAA0G,MAAA5B,GAAA9E,EAAA2G,KAAA7B,IAEA9E,EAAAzE,KAAA2O,KAAA3C,EAAA/B,EAAAV,EAAAiF,EAAA,KAvBA/J,EAAAqJ,EAAA9N,KAAAwO,EAAA,GAAAvD,MAAA1B,EAAAC,EAAA,EAAA,IAAA,MACAA,EAAAS,EAAAT,EALA/E,EAAA,IAAAzE,KAAA6J,KA8BApF,CACA,CAUA,SAAA+G,GAAAjC,GACA,OAAA,IAAAvJ,KAAAuJ,GAAAiC,MACA,CASA,SAAA9C,GAAAa,GACA,OAAAE,EAAAF,EAAA,IAAAvJ,KAAAuJ,GAAAA,EAAAnH,EAAA,EAAA,EACA,CAWA,SAAAuH,GAAAJ,EAAApB,EAAAC,GACA,OAAA,IAAApI,KAAAuJ,GAAAI,MAAAxB,EAAAC,EACA,CAqBA,SAAAqO,GAAArT,GACA,IAAAA,GAAA,WAAAvB,QAAAuB,GAAA,MAAA4B,MAAAsB,EAAA,mBACA,IAAA3D,EAAA3B,EAAA0V,EACAC,GAAA,IAAAvT,EAAAwT,SACAC,EAAA,CACA,YAAA,EAAArR,EACA,WAAA,EAAA,EACA,YAAAD,EAAA,EACA,WAAA,EAAAA,EACA,OAAA,EAAAA,EACA,QAAAA,EAAA,EACA,SAAA,EAAA,GAGA,IAAA5C,EAAA,EAAAA,EAAAkU,EAAAhX,OAAA8C,GAAA,EAEA,GADA3B,EAAA6V,EAAAlU,GAAAgU,IAAA3W,KAAAgB,GAAA4E,EAAA5E,SACA,KAAA0V,EAAAtT,EAAApC,IAAA,CACA,KAAA2F,EAAA+P,KAAAA,GAAAA,GAAAG,EAAAlU,EAAA,IAAA+T,GAAAG,EAAAlU,EAAA,IACA,MAAAqC,MAAAuB,EAAAvF,EAAA,KAAA0V,GADA1W,KAAAgB,GAAA0V,CAEA,CAIA,GADA1V,EAAA,SAAA2V,IAAA3W,KAAAgB,GAAA4E,EAAA5E,SACA,KAAA0V,EAAAtT,EAAApC,IAAA,CACA,IAAA,IAAA0V,IAAA,IAAAA,GAAA,IAAAA,GAAA,IAAAA,EAYA,MAAA1R,MAAAuB,EAAAvF,EAAA,KAAA0V,GAXA,GAAAA,EAAA,CACA,GAAA,oBAAAtQ,SAAAA,SACAA,OAAA0Q,kBAAA1Q,OAAA2Q,YAGA,MAAA/R,MAAAyB,GAFAzG,KAAAgB,IAAA,CAIA,MACAhB,KAAAgB,IAAA,CAKA,CAEA,OAAAhB,IACA,CAUA,SAAAyK,GAAAlB,GACA,OAAA,IAAAvJ,KAAAuJ,GAAAkB,KACA,CAUA,SAAAoC,GAAAtD,GACA,OAAA,IAAAvJ,KAAAuJ,GAAAsD,MACA,CAwMA,SAAAR,GAAA9C,EAAAU,GACA,OAAA,IAAAjK,KAAAuJ,GAAA8C,IAAApC,EACA,CAUA,SAAAyG,GAAAnH,GACA,OAAA,IAAAvJ,KAAAuJ,GAAAmH,KACA,CASA,SAAA7J,GAAA0C,GACA,OAAAE,EAAAF,EAAA,IAAAvJ,KAAAuJ,GAAAA,EAAAnH,EAAA,EAAA,EACA,CAYA,SAAA4U,KACA,IAAArU,EAAA+B,EACAC,EAAA,IAAA3E,KAAA,GAIA,IAFAqG,GAAA,EAEA1D,EAAA,EAAAA,EAAA/C,UAAAC,QAEA,IADA6E,EAAA,IAAA1E,KAAAJ,UAAA+C,OACAgF,EAMAhD,EAAAgD,IACAhD,EAAAA,EAAAyG,KAAA1G,EAAAuG,MAAAvG,SAPA,CACA,GAAAA,EAAA8E,EAEA,OADAnD,GAAA,EACA,IAAArG,KAAA,KAEA2E,EAAAD,CACA,CAOA,OAFA2B,GAAA,EAEA1B,EAAAwI,MACA,CAQA,SAAA8J,GAAA7T,GACA,OAAAA,aAAA+B,GAAA/B,GAAAA,EAAAqE,cAAAf,IAAA,CACA,CAUA,SAAAyH,GAAA5E,GACA,OAAA,IAAAvJ,KAAAuJ,GAAA4E,IACA,CAaA,SAAAsB,GAAAlG,EAAAU,GACA,OAAA,IAAAjK,KAAAuJ,GAAAkG,IAAAxF,EACA,CAUA,SAAAiN,GAAA3N,GACA,OAAA,IAAAvJ,KAAAuJ,GAAAkG,IAAA,EACA,CAUA,SAAA0H,GAAA5N,GACA,OAAA,IAAAvJ,KAAAuJ,GAAAkG,IAAA,GACA,CASA,SAAArH,KACA,OAAAgN,EAAApV,KAAAJ,UAAA,KACA,CASA,SAAAuI,KACA,OAAAiN,EAAApV,KAAAJ,UAAA,KACA,CAWA,SAAA2Q,GAAAhH,EAAAU,GACA,OAAA,IAAAjK,KAAAuJ,GAAAgH,IAAAtG,EACA,CAWA,SAAAuH,GAAAjI,EAAAU,GACA,OAAA,IAAAjK,KAAAuJ,GAAAiI,IAAAvH,EACA,CAWA,SAAAlD,GAAAwC,EAAAU,GACA,OAAA,IAAAjK,KAAAuJ,GAAAxC,IAAAkD,EACA,CAWA,SAAAmN,GAAAzM,GACA,IAAAhD,EAAAvF,EAAAwF,EAAAlD,EACA/B,EAAA,EACA8B,EAAA,IAAAzE,KAAA,GACAyI,EAAA,GAOA,QALA,IAAAkC,EAAAA,EAAA3K,KAAA6F,UACAqC,EAAAyC,EAAA,EAAAnF,GAEAoC,EAAAhB,KAAA8B,KAAAiC,EAAAtD,GAEArH,KAAAoG,OAIA,GAAAA,OAAA0Q,gBAGA,IAFAnP,EAAAvB,OAAA0Q,gBAAA,IAAAO,YAAAzP,IAEAjF,EAAAiF,IACAlD,EAAAiD,EAAAhF,KAIA,MACAgF,EAAAhF,GAAAyD,OAAA0Q,gBAAA,IAAAO,YAAA,IAAA,GAKA5O,EAAA9F,KAAA+B,EAAA,QAKA,KAAA0B,OAAA2Q,YAwBA,MAAA/R,MAAAyB,GAnBA,IAFAkB,EAAAvB,OAAA2Q,YAAAnP,GAAA,GAEAjF,EAAAiF,IAGAlD,EAAAiD,EAAAhF,IAAAgF,EAAAhF,EAAA,IAAA,IAAAgF,EAAAhF,EAAA,IAAA,MAAA,IAAAgF,EAAAhF,EAAA,KAAA,MAGA,MACAyD,OAAA2Q,YAAA,GAAAO,KAAA3P,EAAAhF,IAKA8F,EAAA0H,KAAAzL,EAAA,KACA/B,GAAA,GAIAA,EAAAiF,EAAA,CAGA,MA/CA,KAAAjF,EAAAiF,GAAAa,EAAA9F,KAAA,IAAAiE,KAAAwQ,SAAA,EA2DA,IAVAxP,EAAAa,IAAA9F,GACAgI,GAAAtD,EAGAO,GAAA+C,IACAjG,EAAAoC,EAAA,GAAAO,EAAAsD,GACAlC,EAAA9F,IAAAiF,EAAAlD,EAAA,GAAAA,GAIA,IAAA+D,EAAA9F,GAAAA,IAAA8F,EAAA2H,MAGA,GAAAzN,EAAA,EACAP,EAAA,EACAqG,EAAA,CAAA,OACA,CAIA,IAHArG,GAAA,EAGA,IAAAqG,EAAA,GAAArG,GAAAiF,EAAAoB,EAAA4H,QAGA,IAAAzI,EAAA,EAAAlD,EAAA+D,EAAA,GAAA/D,GAAA,GAAAA,GAAA,GAAAkD,IAGAA,EAAAP,IAAAjF,GAAAiF,EAAAO,EACA,CAKA,OAHAnD,EAAArC,EAAAA,EACAqC,EAAAkD,EAAAc,EAEAhE,CACA,CAWA,SAAAwM,GAAA1H,GACA,OAAAE,EAAAF,EAAA,IAAAvJ,KAAAuJ,GAAAA,EAAAnH,EAAA,EAAApC,KAAA8F,SACA,CAcA,SAAA2O,GAAAlL,GAEA,OADAA,EAAA,IAAAvJ,KAAAuJ,IACA5B,EAAA4B,EAAA5B,EAAA,GAAA4B,EAAAC,EAAA,EAAAD,EAAAC,EAAAD,EAAAC,GAAAK,GACA,CAUA,SAAAsH,GAAA5H,GACA,OAAA,IAAAvJ,KAAAuJ,GAAA4H,KACA,CAUA,SAAAjE,GAAA3D,GACA,OAAA,IAAAvJ,KAAAuJ,GAAA2D,MACA,CAUA,SAAAC,GAAA5D,GACA,OAAA,IAAAvJ,KAAAuJ,GAAA4D,MACA,CAWA,SAAA6C,GAAAzG,EAAAU,GACA,OAAA,IAAAjK,KAAAuJ,GAAAyG,IAAA/F,EACA,CAYA,SAAAuL,KACA,IAAA7S,EAAA,EACA0S,EAAAzV,UACA2J,EAAA,IAAAvJ,KAAAqV,EAAA1S,IAGA,IADA0D,GAAA,EACAkD,EAAAC,KAAA7G,EAAA0S,EAAAxV,QAAA0J,EAAAA,EAAA6B,KAAAiK,EAAA1S,IAGA,OAFA0D,GAAA,EAEAoD,EAAAF,EAAAvJ,KAAA6F,UAAA7F,KAAA8F,SACA,CAUA,SAAAyL,GAAAhI,GACA,OAAA,IAAAvJ,KAAAuJ,GAAAgI,KACA,CAUA,SAAA9D,GAAAlE,GACA,OAAA,IAAAvJ,KAAAuJ,GAAAkE,MACA,CASA,SAAA0F,GAAA5J,GACA,OAAAE,EAAAF,EAAA,IAAAvJ,KAAAuJ,GAAAA,EAAAnH,EAAA,EAAA,EACA,CAIA+C,EA1mBA,SAAAoS,EAAAnU,GACA,IAAAT,EAAA3B,EAAA6V,EASA,SAAA1R,EAAAuR,GACA,IAAAtU,EAAAO,EAAAgC,EACA4E,EAAAvJ,KAGA,KAAAuJ,aAAApE,GAAA,OAAA,IAAAA,EAAAuR,GAOA,GAHAnN,EAAA7I,YAAAyE,EAGA8R,GAAAP,GAuBA,OAtBAnN,EAAAC,EAAAkN,EAAAlN,OAEAnD,GACAqQ,EAAA/O,GAAA+O,EAAAtU,EAAA+C,EAAAgB,MAGAoD,EAAAnH,EAAAyH,IACAN,EAAA5B,EAAA,MACA+O,EAAAtU,EAAA+C,EAAAe,MAGAqD,EAAAnH,EAAA,EACAmH,EAAA5B,EAAA,CAAA,KAEA4B,EAAAnH,EAAAsU,EAAAtU,EACAmH,EAAA5B,EAAA+O,EAAA/O,EAAAoE,UAGAxC,EAAAnH,EAAAsU,EAAAtU,EACAmH,EAAA5B,EAAA+O,EAAA/O,EAAA+O,EAAA/O,EAAAoE,QAAA2K,EAAA/O,IAQA,GAAA,YAFAhD,EAAA9C,QAAA6U,IAEA,CACA,GAAA,IAAAA,EAIA,OAHAnN,EAAAC,EAAA,EAAAkN,EAAA,GAAA,EAAA,EACAnN,EAAAnH,EAAA,OACAmH,EAAA5B,EAAA,CAAA,IAYA,GARA+O,EAAA,GACAA,GAAAA,EACAnN,EAAAC,GAAA,GAEAD,EAAAC,EAAA,EAIAkN,MAAAA,GAAAA,EAAA,IAAA,CACA,IAAAtU,EAAA,EAAAO,EAAA+T,EAAA/T,GAAA,GAAAA,GAAA,GAAAP,IAkBA,YAhBAiE,EACAjE,EAAA+C,EAAAgB,MACAoD,EAAAnH,EAAAyH,IACAN,EAAA5B,EAAA,MACAvF,EAAA+C,EAAAe,MACAqD,EAAAnH,EAAA,EACAmH,EAAA5B,EAAA,CAAA,KAEA4B,EAAAnH,EAAAA,EACAmH,EAAA5B,EAAA,CAAA+O,KAGAnN,EAAAnH,EAAAA,EACAmH,EAAA5B,EAAA,CAAA+O,IAMA,CAAA,OAAA,EAAAA,GAAA,GACAA,IAAAnN,EAAAC,EAAAK,KACAN,EAAAnH,EAAAyH,SACAN,EAAA5B,EAAA,OAIAiO,EAAArM,EAAAmN,EAAA3L,WAEA,CAAA,GAAA,WAAApG,EACA,MAAAK,MAAAuB,EAAAmQ,GAaA,OATA,MAAA/T,EAAA+T,EAAAV,WAAA,KACAU,EAAAA,EAAA3K,MAAA,GACAxC,EAAAC,GAAA,IAGA,KAAA7G,IAAA+T,EAAAA,EAAA3K,MAAA,IACAxC,EAAAC,EAAA,GAGArC,EAAAiP,KAAAM,GAAAd,EAAArM,EAAAmN,GAAAT,EAAA1M,EAAAmN,EACA,CA2DA,GAzDAvR,EAAAjF,UAAAsH,EAEArC,EAAAqS,SAAA,EACArS,EAAAsS,WAAA,EACAtS,EAAAuS,WAAA,EACAvS,EAAAwS,YAAA,EACAxS,EAAAyS,cAAA,EACAzS,EAAA0S,gBAAA,EACA1S,EAAA2S,gBAAA,EACA3S,EAAA4S,gBAAA,EACA5S,EAAA6S,iBAAA,EACA7S,EAAA8S,OAAA,EAEA9S,EAAAsR,OAAAtR,EAAA+S,IAAAzB,GACAtR,EAAAoS,MAAAA,EACApS,EAAAgC,UAAA8P,GAEA9R,EAAAmE,IAAAA,GACAnE,EAAAwI,KAAAA,GACAxI,EAAA8I,MAAAA,GACA9I,EAAAyL,IAAAA,GACAzL,EAAA4I,KAAAA,GACA5I,EAAAkJ,MAAAA,GACAlJ,EAAAwJ,KAAAA,GACAxJ,EAAAoJ,MAAAA,GACApJ,EAAAqR,MAAAA,GACArR,EAAAqG,KAAAA,GACArG,EAAAuD,KAAAA,GACAvD,EAAAwE,MAAAA,GACAxE,EAAAsF,IAAAA,GACAtF,EAAA0H,KAAAA,GACA1H,EAAAkH,IAAAA,GACAlH,EAAAuL,IAAAA,GACAvL,EAAA0B,MAAAA,GACA1B,EAAA6R,MAAAA,GACA7R,EAAAgJ,GAAAA,GACAhJ,EAAAsK,IAAAA,GACAtK,EAAAgS,MAAAA,GACAhS,EAAA+R,KAAAA,GACA/R,EAAAiD,IAAAA,GACAjD,EAAAgD,IAAAA,GACAhD,EAAAoL,IAAAA,GACApL,EAAAqM,IAAAA,GACArM,EAAA4B,IAAAA,GACA5B,EAAAiS,OAAAA,GACAjS,EAAA8L,MAAAA,GACA9L,EAAAsP,KAAAA,GACAtP,EAAAgM,IAAAA,GACAhM,EAAA+H,KAAAA,GACA/H,EAAAgI,KAAAA,GACAhI,EAAA6K,IAAAA,GACA7K,EAAAqQ,IAAAA,GACArQ,EAAAoM,IAAAA,GACApM,EAAAsI,KAAAA,GACAtI,EAAAgO,MAAAA,QAEA,IAAA/P,IAAAA,EAAA,CAAA,GACAA,IACA,IAAAA,EAAAwT,SAEA,IADAC,EAAA,CAAA,YAAA,WAAA,WAAA,WAAA,OAAA,OAAA,SAAA,UACAlU,EAAA,EAAAA,EAAAkU,EAAAhX,QAAAuD,EAAAjD,eAAAa,EAAA6V,EAAAlU,QAAAS,EAAApC,GAAAhB,KAAAgB,IAMA,OAFAmE,EAAAsR,OAAArT,GAEA+B,CACA,CAqbAoS,CAAA3R,GACAT,EAAAjF,UAAAQ,YAAAyE,EACAA,EAAA,QAAAA,EAAAA,QAAAA,EAGAO,EAAA,IAAAP,EAAAO,GACAC,EAAA,IAAAR,EAAAQ,QAaA,IAAAxB,GAAAA,EAAAD,SACA,mBAAAP,QAAA,UAAA9B,QAAA8B,OAAAK,YACAwD,EAAA7D,OAAA,IAAA,+BAAA6D,EAAAuD,SACAvD,EAAA7D,OAAA8D,aAAA,WAGAtD,EAAAD,QAAAiB,IAIAD,IACAA,EAAA,oBAAAtD,MAAAA,MAAAA,KAAAA,MAAAA,KAAAA,KAAA0C,QAGAe,EAAAH,EAAAC,QACAA,EAAAE,WAAA,WAEA,OADAH,EAAAC,QAAAE,EACAF,CACA,EAEAD,EAAAC,QAAAA,EAEA,CAr0JA,CAq0JAnF,KFGA,EAAE,CAAC,GAAG,EAAE,CAAC,SAAS6E,EAAQV,EAAOD,GGx0JjC,IASAiU,EAAA,WAEA,SAAAA,EAAAC,EAAAC,GACA/V,gBAAAtC,KAAAmY,GACAnY,KAAAsY,OAAA,EAEAtY,KAAAuY,QAAA,WAAA1W,QAAAuW,GAAAA,EAAA,CAAA,EAEApY,KAAAwY,YAAA,UAGAxY,KAAAyY,KAAA,WAAAC,OAAA9R,KAAAC,MAAA,MAAAD,KAAAwQ,SAAA,MAEApX,KAAA2Y,KAAA,iBAAAN,EAAAA,EAAA,GAAAK,OAAA1Y,KAAAyY,KACA,CAWA,OAXAzV,aAAAmV,EAAA,CAAA,CAAApV,IAAA,eAAAjD,MAMA,SAAA8Y,GAIA,OAFA5Y,KAAAsY,MAAAM,GAEA,CACA,KAAAT,CAAA,CAzBA,GAyBAhV,gBAzBAgV,EAAA,kBAiBA,GAWAhU,EAAAD,QAAAiU,CH20JA,EAAE,CAAC,GAAG,EAAE,CAAC,SAAStT,EAAQV,EAAOD,GIh3JjC,IAKA2U,EAAA7V,cAEA,SAAA6V,EAAAD,EAAAR,EAAAC,GACA/V,gBAAAtC,KAAA6Y,GACA7Y,KAAAsY,MAAAM,EAEA5Y,KAAAuY,QAAA,WAAA1W,QAAAuW,GAAAA,EACA,WAAAvW,QAAA+W,IAAAA,EAAAE,QACA,CAAA,EADAF,EAGA5Y,KAAAwY,YAAA,UAEA,mBAAAI,EAAAG,QAEA/Y,KAAAyY,KAAAG,EAAAG,UAIA/Y,KAAAyY,KAAA,cAAAC,OAAA9R,KAAAC,MAAA,MAAAD,KAAAwQ,SAAA,MAGApX,KAAA2Y,KAAA,iBAAAN,EAAAA,EAAA,GAAAK,OAAA1Y,KAAAyY,MAGAzY,KAAAyP,IAAAzP,KAAAsY,MAAA7I,IACAzP,KAAAgZ,YAAAhZ,KAAAsY,MAAAW,WACAjZ,KAAAkZ,SAAAlZ,KAAAsY,MAAAY,QACA,IAAA/V,gBA3BA0V,EAAA,kBA6BA,GAGA1U,EAAAD,QAAA2U,EAEA1U,EAAAD,QAAAiV,wBAAAtU,EAAA,yCJk3JA,EAAE,CAAC,yCAAyC,IAAI,EAAE,CAAC,SAASA,EAAQV,EAAOD;;;;;AKp5J3E,IAKAkV,EAAA,WAEA,SAAAA,EAAAC,GACA/W,gBAAAtC,KAAAoZ,GACApZ,KAAAsZ,WAAAD,EAEArZ,KAAAuZ,UAAA,SACA,CAwJA,OAtJAvW,aAAAoW,EAAA,CAAA,CAAArW,IAAA,sBAAAjD,MACA,SAAA0Z,GAEA,iBAAAA,IAEAxZ,KAAAuZ,UAAAC,GAEAxZ,KAAAsZ,WAAAG,gBAAAtZ,eAAAH,KAAAuZ,aAEAvZ,KAAAsZ,WAAAG,gBAAAzZ,KAAAuZ,UAAAlD,eAAA,CAAA,GAEArW,KAAAsZ,WAAAI,cAAAvZ,eAAAH,KAAAuZ,aAEAvZ,KAAAsZ,WAAAI,cAAA1Z,KAAAuZ,UAAAlD,eAAA,CAAA,EAEA,GAEA,CAAAtT,IAAA,iBAAAjD,MACA,SAAA6Z,EAAAC,GAEA,MAAA,iBAAAD,GAEA3Z,KAAAsZ,WAAA7J,IAAAoK,MAAA,6GAAAnB,OAAA7W,QAAA8X,MACA,GAEA,mBAAAC,GAEA5Z,KAAAsZ,WAAA7J,IAAAoK,MAAA,8FAAAnB,OAAA7W,QAAA+X,MACA,IAGA5Z,KAAAsZ,WAAAG,gBAAAzZ,KAAAuZ,UAAAlD,eAAAsD,GAAAC,GACA,EACA,GAAA,CAAA7W,IAAA,yBAAAjD,MAEA,WAaA,OAPAE,KAAA8Z,eAAA,QACA,SAAAC,GAGA,OADAA,EAAAtK,IAAAuK,KAAA,wCACA,CACA,KAEA,CACA,GAEA,CAAAjX,IAAA,eAAAjD,MACA,SAAAma,EAAAF,GAEA,GAAA,iBAAAE,EAGA,OADAja,KAAAsZ,WAAA7J,IAAAoK,MAAA,yGAAAnB,OAAA7W,QAAAoY,IAAAF,IACA,EAEA,GAAA,UAAAlY,QAAAkY,GAGA,OADA/Z,KAAAsZ,WAAA7J,IAAAoK,MAAA,wFAAAnB,OAAA7W,QAAAkY,IAAAA,IACA,EAGA,IAAAA,EAAA5Z,eAAA,eAGA,OADAH,KAAAsZ,WAAA7J,IAAAoK,MAAA,2FAAAE,IACA,EAEA,GAAA,UAAAlY,QAAAkY,EAAAG,aAGA,OADAla,KAAAsZ,WAAA7J,IAAAoK,MAAA,qHAAAnB,OAAA7W,QAAAkY,EAAAG,aAAA,KAAAH,IACA,EAEA,GAAA,iBAAAA,EAAAG,YAAAvB,KACA,CACA,GAAA,iBAAAoB,EAAAG,YAAAC,UAQA,OADAna,KAAAsZ,WAAA7J,IAAAoK,MAAA,yJAAAE,IACA,EALAA,EAAAG,YAAAvB,KAAAoB,EAAAG,YAAAC,SAOA,CA4BA,MAzBA,iBAAAJ,EAAAG,YAAAE,WAAAL,EAAAG,YAAAE,WAAApa,KAAAuZ,YAEAQ,EAAAG,YAAAE,UAAApa,KAAAuZ,WAEA,iBAAAQ,EAAAG,YAAAG,UAEAN,EAAAG,YAAAG,QAAA,IAAA3B,OAAAqB,EAAAG,YAAAE,UAAA,OAAA1B,OAAAqB,EAAAG,YAAAvB,KAAA,iBAIAoB,EAAA5Z,eAAA,YAEA4Z,EAAAO,OAAA,CAAA,GAEAP,EAAA5Z,eAAA,aAEA4Z,EAAAQ,QAAA,CAAA,GAEAR,EAAA5Z,eAAA,WAEA4Z,EAAAS,MAAA,IAKA,WAAA3Y,QAAAkY,EAAAO,SAEAta,KAAAsZ,WAAA7J,IAAAoK,MAAA,+DAAAE,IACA,GAIA,WAAAlY,QAAAkY,EAAAQ,UAEAva,KAAAsZ,WAAA7J,IAAAoK,MAAA,gEAAAE,IACA,GAEAU,MAAAC,QAAAX,EAAAS,QAOAxa,KAAAsZ,WAAAI,cAAA1Z,KAAAuZ,UAAAlD,eAAA4D,EAAA5D,eAAA0D,GACA,IANA/Z,KAAAsZ,WAAA7J,IAAAoK,MAAA,6DAAAE,IACA,EAMA,GAAA,CAAAhX,IAAA,uBAAAjD,MAEA,WAWA,OATAE,KAAA2a,aAAA,OACA,CACAT,YACA,CACAC,UAAA,OACAD,YAAA,4CAIA,CACA,KAAAd,CAAA,CA/JA,GAkKAjV,EAAAD,QAAAkV,CL25JA,EAAE,CAAC,GAAG,EAAE,CAAC,SAASvU,EAAQV,EAAOD;;;;;AMnkKjC,IAAA0W,EAAA/V,EAAA,6BACAgW,EAAAhW,EAAA,kCAOAL,EAAA,SAAAsW,GAAAza,UAAAmE,EAAAsW,GAAA,IAAAC,EAAA5Z,aAAAqD,GAEA,SAAAA,EAAAoU,EAAAR,EAAAC,GACA,IAAA2C,EAeA,GAfA1Y,gBAAAtC,KAAAwE,IACAwW,EAAAD,EAAApb,KAAAK,KAAA4Y,EAAAR,EAAAC,IAGAoB,gBAAA,CAAA,EAIAuB,EAAAtB,cAAA,CAAA,EAGAsB,EAAAvC,KAAA,EAEAuC,EAAAC,6BAEAD,EAAAzC,QAAA2C,aAGA,IADA,IAAAC,EAAA1b,OAAA2b,KAAAJ,EAAAzC,QAAA2C,cACAvY,EAAA,EAAAA,EAAAwY,EAAAtb,OAAA8C,IAEAqY,EAAAL,aAAA,SAAAQ,EAAAxY,GAAAqY,EAAAzC,QAAA2C,aAAAC,EAAAxY,KAEA,OAAAqY,CACA,CAiWA,OA/VAhY,aAAAwB,EAAA,CAAA,CAAAzB,IAAA,qBAAAjD,MACA,SAAAub,GAEA,IAAAC,EAAA,IAAAD,EAAArb,MAEAsb,EAAAC,sBACAD,EAAAE,yBACAF,EAAAG,sBACA,GAAA,CAAA1Y,IAAA,6BAAAjD,MAEA,WAIAE,KAAA0b,mBAAA7W,EAAA,yCAKA7E,KAAA0b,mBAAA7W,EAAA,6CAIA7E,KAAA0b,mBAAA7W,EAAA,kCAIA7E,KAAA0b,mBAAA7W,EAAA,+BAIA7E,KAAA0b,mBAAA7W,EAAA,gCAIA7E,KAAA0b,mBAAA7W,EAAA,4BACA,GAAA,CAAA9B,IAAA,kBAAAjD,MAEA,SAAA0Z,EAAAS,GAEA,GAAA,iBAAAT,GAAA,iBAAAS,EAEA,OAAA,EAGA,IAAA0B,EAAAnC,EAAAnD,cACA,OAAArW,KAAA0Z,cAAAvZ,eAAAwb,IAAA3b,KAAA0Z,cAAAiC,GAAAxb,eAAA8Z,EAAA5D,cACA,GAAA,CAAAtT,IAAA,eAAAjD,MAEA,SAAA0Z,EAAAS,EAAAF,GAEA,GAAA,iBAAAP,EAGA,OADAxZ,KAAAyP,IAAAoK,MAAA,sIAAAnB,OAAA7W,QAAA2X,IAAAO,IACA,EAGA,IAAA6B,EAAA,IAAAf,EAAA7a,MAGA,OAFA4b,EAAAL,oBAAA/B,GAEAoC,EAAAjB,aAAAV,EAAAF,EACA,GAAA,CAAAhX,IAAA,yBAAAjD,MAEA,SAAA0Z,EAAAS,EAAA4B,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GAEA,IAAAlc,KAAAmc,gBAAA3C,EAAAS,GAIA,OAFAja,KAAAyP,IAAAoK,MAAA,qDAAAnB,OAAAc,EAAA,mBAAAd,OAAAuB,EAAA,uCAEA,EAEA,IAAAmC,EAAApc,KAAA0Z,cAAAF,EAAAnD,eAAA4D,EAAA5D,eACA,OAAArW,KAAAqc,eAAAD,EAAAP,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EACA,GAAA,CAAAnZ,IAAA,iBAAAjD,MAEA,SAAAwc,EAAAT,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GACA,IAAAK,EAAAvc,KACAoc,EAAAI,KAAAC,MAAAD,KAAAE,UAAAJ,IAEA,GAAA,UAAAza,QAAAga,GAGA,OADA7b,KAAAyP,IAAAoK,MAAA,qFAAAnB,OAAA7W,QAAAga,GAAA,OACA,EAEA,IAAAc,EAAAd,EAGAe,EAAAD,EAGAE,EAAAX,OACA,IAAAW,IAEAA,EACA,CACAC,aAAA,YAAApE,OAAA1Y,KAAAyY,QACAsE,sBAAAT,EAAApC,YAAAE,UACA4C,sBAAAV,EAAApC,YAAAC,UACA8C,YAAA,IAIAb,EAAAjc,eAAA,YAEAic,EAAA9B,OAAA,CAAA,GAEA8B,EAAAjc,eAAA,aAEAic,EAAA7B,QAAA,CAAA,GAIA6B,EAAAjc,eAAA,6BAEA0c,EAAAK,iBAAAV,KAAAC,MAAAD,KAAAE,UAAAN,EAAAe,4BAIAN,EAAAK,iBAAA,CAAA,EAGAd,EAAAjc,eAAA,gCAEA0c,EAAAO,kBAAAZ,KAAAC,MAAAD,KAAAE,UAAAN,EAAAiB,8BAGA,UAAAxb,QAAAia,IACA,oBAAAwB,sBACA,oBAAAC,sBAUAV,EAAAO,kBAAAP,EAAAK,mBAIA,UAAArb,QAAAia,KAGAc,EAAAd,GAGA,IAAA0B,GAAA,EACA,QAAA,IAAAzB,GAGAyB,EAAAxd,KAAAsY,MAAAmF,eAAAC,8CAAA,aAKAC,oBAAAC,qBAAAxB,EAAA9B,OAAA8B,EAAA7B,cAMAiD,EAAAzB,EAAAxE,QAGAyE,GAEAwB,EAAAG,oBAAAE,uBAAAzB,EAAA9B,OAAA0B,GAEAC,GAEAuB,EAAAG,oBAAAE,uBAAAzB,EAAA9B,OAAA2B,GAEAY,EAAAK,kBAEAM,EAAAM,iBAAAC,eAAAlB,EAAAK,kBAEAL,EAAAO,mBAEAI,EAAAM,iBAAAC,eAAAlB,EAAAO,mBAKAhB,EAAA3D,KAAAzY,KAAAyY,OACA2D,EAAA4B,gBAAAnB,EAEAT,EAAAlC,YAAA+D,UAEApB,EAAAI,YAAA9M,KAAA,IAAAuI,OAAA0D,EAAA3D,KAAA,gCAAAC,OAAA0D,EAAAlC,YAAA+D,WAGA,IAAAC,EAAAle,KAAAsY,MAAAmF,eAAAC,8CAAA,gBA8BA,GA7BAQ,EAAAC,WAAA,UAAA,MACA,SAAAC,GAEA,IAAAC,EAAAD,EAAAE,OACAC,EAAAf,EAAAgB,oBAAAH,GAGA,MAAA,UAAAxc,QAAA0c,IAAAA,EAAApe,eAAA,QAEAoe,EAAAE,KAIAJ,CAEA,IACAH,EAAAC,WAAA,gBAAA,MACA,SAAAC,GAEA,IAAAC,EAAAD,EAAAE,OACA,OAAAd,EAAAkB,eAAA/B,EAAA0B,EACA,IACAH,EAAAC,WAAA,iBAAA,MACA,SAAAC,GAEA,IAAAC,EAAAD,EAAAE,OACA,OAAAd,EAAAkB,eAAA9B,EAAAyB,EACA,IAEAjC,EAAAjc,eAAA,QAAAic,EAAAuC,IAAAxe,eAAA,gBAEA,GAAA,iBAAAic,EAAAuC,IAAAC,aAEAxC,EAAA4B,gBAAAf,YAAA9M,KAAA+N,EAAAW,YAAAzC,EAAAuC,IAAAC,oBAEA,GAAAnE,MAAAC,QAAA0B,EAAAuC,IAAAC,cAEA,IAAA,IAAAjc,EAAA,EAAAA,EAAAyZ,EAAAuC,IAAAC,aAAA/e,OAAA8C,IAEA,iBAAAyZ,EAAAuC,IAAAC,aAAAjc,IAEAyZ,EAAA4B,gBAAAf,YAAA9M,KAAA+N,EAAAW,YAAAzC,EAAAuC,IAAAC,aAAAjc,KAOA,IADA,IAAAmc,EAAA,SAAAC,GAGA,IAAAC,EAAA5C,EAAA5B,MAAA7X,GAGA,GAAAqc,EAAA7e,eAAA,eACA,CACA,IAAA8e,EACA,CACAC,MAAA,cACAC,YAAA3C,KAAAC,MAAAD,KAAAE,UAAAN,EAAA9B,UAGAkD,EAAAG,oBAAAE,uBAAAoB,EAAAE,YAAAH,EAAAI,qBACA,IAAAC,EAAA9C,EAAAjE,MAAAmF,eAAAC,8CAAA,WAAAuB,GACApC,EAAAK,kBAEAmC,EAAAvB,iBAAAC,eAAAlB,EAAAK,kBAGA,IAAAoC,EACA,CACAJ,MAAA,eACAC,YAAA3C,KAAAC,MAAAD,KAAAE,UAAAN,EAAA7B,WAEAiD,EAAAG,oBAAAE,uBAAAyB,EAAAH,YAAAH,EAAAO,sBACA,IAAAC,EAAAjD,EAAAjE,MAAAmF,eAAAC,8CAAA,WAAA4B,GACAzC,EAAAO,mBAEAoC,EAAA1B,iBAAAC,eAAAlB,EAAAO,mBAIA,IAAAqC,EACA,CACAjb,WAAA+X,EAEAnC,UAAA4E,EAAA5E,UAAA/D,cACAqJ,YAAAV,EAAAU,YAAArJ,cAEA8D,UAAAiC,EAEA4B,gBAAAnB,EAEA8C,oBAAAnC,EAEAoC,YAAAjD,EACAkD,cAAAR,EAEAS,aAAAlD,EACAmD,eAAAP,GAkBA,GAfAC,EAAAO,SACA,SAAAC,GAEA,IAAAC,EAAA,cAAAxH,OAAA+G,EAAAtF,UAAAD,YAAAE,UAAA,KAAA1B,OAAA+G,EAAAtF,UAAAD,YAAAvB,KAAA,aAAAD,OAAA/V,EAAA,KAAA+V,OAAAsG,EAAA5E,UAAA,KAAA1B,OAAAsG,EAAAU,YAAA,MAAAhH,OAAAuH,GACA1D,EAAA9M,IAAAoK,MAAAqG,GACArD,EAAAI,YAAA9M,KAAA,UAAAuI,OAAAwH,GACA,EAEAT,EAAAU,QACA,SAAAF,GAEA,IAAAG,EAAA,cAAA1H,OAAA+G,EAAAtF,UAAAD,YAAAE,UAAA,KAAA1B,OAAA+G,EAAAtF,UAAAD,YAAAvB,KAAA,aAAAD,OAAA/V,EAAA,KAAA+V,OAAAsG,EAAA5E,UAAA,KAAA1B,OAAAsG,EAAAU,YAAA,MAAAhH,OAAAuH,GACApD,EAAAI,YAAA9M,KAAA,SAAAuI,OAAA0H,GACA,EAEA7D,EAAA9C,gBAAAgG,EAAArF,WAAAja,eAAAsf,EAAAC,cAGAW,EADA9D,EAAA9C,gBAAAgG,EAAArF,WAAAqF,EAAAC,cACAD,EAEA,CAGAT,EAAA7e,eAAA,eAEA,iBAAA6e,EAAA7E,UAEAoC,EAAA+D,uBAAAtB,EAAA5E,UAAA4E,EAAA7E,UAAAwC,EAAAC,EAAAY,EAAAwB,EAAAI,oBAAAJ,EAAAO,qBAAA1C,GAEA,UAAAhb,QAAAmd,EAAA7E,YAGAoC,EAAAF,eAAA2C,EAAA7E,UAAAwC,EAAAC,EAAAY,EAAAwB,EAAAI,oBAAAJ,EAAAO,qBAAA1C,GAGA,EAxFAla,EAAA,EAAAA,EAAAyZ,EAAA5B,MAAA3a,OAAA8C,IAAAmc,EAAAC,GA0FA,GAAA3C,EAAAjc,eAAA,QAAAic,EAAAuC,IAAAxe,eAAA,iBAEA,GAAA,iBAAAic,EAAAuC,IAAA4B,cAEAnE,EAAA4B,gBAAAf,YAAA9M,KAAA+N,EAAAW,YAAAzC,EAAAuC,IAAA4B,qBAEA,GAAA9F,MAAAC,QAAA0B,EAAAuC,IAAAC,cAEA,IAAA,IAAAjc,EAAA,EAAAA,EAAAyZ,EAAAuC,IAAA4B,cAAA1gB,OAAA8C,IAEA,iBAAAyZ,EAAAuC,IAAA4B,cAAA5d,IAEAyZ,EAAA4B,gBAAAf,YAAA9M,KAAA+N,EAAAW,YAAAzC,EAAAuC,IAAA4B,cAAA5d,KAMA,OAAAka,CACA,KAAArY,CAAA,CA3XA,CAAAoW,GA8XAzW,EAAAD,QAAAM,CNykKA,EAAE,CAAC,iCAAiC,EAAE,gCAAgC,EAAE,6BAA6B,EAAE,uCAAuC,EAAE,2CAA2C,GAAG,2BAA2B,GAAG,8BAA8B,GAAG,4BAA4B,IAAI,EAAE,CAAC,SAASK,EAAQV,EAAOD,GO/8KxT,IAEAsc,EAAA,SAAAC,GAAApgB,UAAAmgB,EAAAC,GAAA,IAAAC,EAAAvf,aAAAqf,GAEA,SAAAA,EAAAnH,GACA,IAAAsH,EAEA,OAFAre,gBAAAtC,KAAAwgB,IACAG,EAAAD,EAAA/gB,KAAAK,KAAAqZ,IACAE,UAAA,WAAAoH,CACA,CAaA,OAXA3d,aAAAwd,EAAA,CAAA,CAAAzd,IAAA,yBAAAjD,MACA,WAEA,OAAA,CACA,GAAA,CAAAiD,IAAA,uBAAAjD,MAEA,WAIA,OAFAE,KAAA2a,aAAA,gBAAA9V,EAAA,8CAEA,CACA,KAAA2b,CAAA,CAnBA,CAFA3b,EAAA,oCAwBAV,EAAAD,QAAAsc,CPq9KA,EAAE,CAAC,kCAAkC,EAAE,2CAA2C,IAAI,EAAE,CAAC,SAAS3b,EAAQV,EAAOD,GQ7+KjH,IAAA2W,EAAAhW,EAAA,mCAEA+b,EAAA,SAAA7G,GAEA,IAAA8G,EAAA9G,EAAA8F,cAAAnB,eAAA3E,EAAA6F,YAAA,aACAkB,EAAA/G,EAAA8F,cAAAnB,eAAA3E,EAAA6F,YAAA,cACAmB,EAAAhH,EAAA8F,cAAAnB,eAAA3E,EAAA6F,YAAA,cAAA7U,WAAAsL,cAEA2K,EAAA,QAGAC,EACA,CACA,KAAA,QACAhV,GAAA,QACAiV,MAAA,QAEA,KAAA,WACAC,MAAA,WACAC,SAAA,WAEA,MAAA,WACAC,GAAA,WACAC,SAAA,WAEA,IAAA,cACAxX,GAAA,cACAyX,YAAA,cAEA,KAAA,qBACA5U,IAAA,qBACA6U,mBAAA,qBAEA,IAAA,WACAlS,GAAA,WACAmS,SAAA,WAEA,KAAA,kBACAvT,IAAA,kBACAwT,gBAAA,mBAGAT,EAAA9gB,eAAA4gB,KAEAC,EAAAC,EAAAF,IAGA,IAAAY,EAAA5H,EAAA8F,cAAAnB,eAAA3E,EAAA6F,YAAA,iBACAgC,EAAA7H,EAAA8F,cAAAnB,eAAA3E,EAAA6F,YAAA,iBAEAiC,EAAA9H,EAAA8F,cAAAnB,eAAA3E,EAAA6F,YAAA,kBACAkC,EAAA/H,EAAA8F,cAAAnB,eAAA3E,EAAA6F,YAAA,kBAEAmC,EAAA,KAEA,OAAAf,GAEA,IAAA,QACAe,EAAAlB,GAAAC,EACA,MACA,IAAA,WACAiB,EAAAlB,IAAAC,EACA,MACA,IAAA,WACAiB,EAAAlB,GAAAC,EACA,MACA,IAAA,cACAiB,EAAAlB,EAAAC,EACA,MACA,IAAA,qBACAiB,EAAAlB,GAAAC,EACA,MACA,IAAA,WACAiB,EAAAlB,EAAAC,EACA,MACA,IAAA,kBACAiB,EAAAlB,GAAAC,EAmBA,OAfA/G,EAAAgG,eAAAiC,eAAAjI,EAAA+F,aAAA,mBAAAiC,GAMAA,GAAA,iBAAAJ,GAAA,iBAAAC,GAAA,QAAAA,EAEA7H,EAAAvV,WAAA8b,uBAAAqB,EAAAC,EAAA7H,EAAA6F,YAAA7F,EAAA+F,aAAA/F,EAAA4F,oBAAA5F,EAAAiE,gBAAAd,iBAAAnD,EAAAiE,gBAAAZ,kBAAArD,EAAAiE,iBAEA,iBAAA6D,GAAA,iBAAAC,GAAA,QAAAA,GAEA/H,EAAAvV,WAAA8b,uBAAAuB,EAAAC,EAAA/H,EAAA6F,YAAA7F,EAAA+F,aAAA/F,EAAA4F,oBAAA5F,EAAAiE,gBAAAd,iBAAAnD,EAAAiE,gBAAAZ,kBAAArD,EAAAiE,kBAGA,CACA,EAEAiE,EAAA,SAAAlI,GAEA,IAAA4B,EAAA5B,EAAA8F,cAAAnB,eAAA3E,EAAA6F,YAAA,aACAxD,EAAArC,EAAA8F,cAAAnB,eAAA3E,EAAA6F,YAAA,aAIA,OAFA7F,EAAAvV,WAAA8b,uBAAA3E,EAAAS,EAAArC,EAAA6F,YAAA7F,EAAA+F,aAAA/F,EAAA4F,oBAAA5F,EAAAiE,gBAAAd,iBAAAnD,EAAAiE,gBAAAZ,kBAAArD,EAAAiE,kBAEA,CACA,EAEAkE,EAAA,SAAAC,GAAA9hB,UAAA6hB,EAAAC,GAAA,IAAAC,EAAAjhB,aAAA+gB,GAEA,SAAAA,EAAA7I,GACA,IAAAgJ,EAEA,OAFA/f,gBAAAtC,KAAAkiB,IACAG,EAAAD,EAAAziB,KAAAK,KAAAqZ,IACAE,UAAA,QAAA8I,CACA,CAmBA,OAnBArf,aAAAkf,EAAA,CAAA,CAAAnf,IAAA,yBAAAjD,MAEA,WAQA,OALAf,KAAAqB,gBAAA8hB,EAAAhiB,WAAA,yBAAAF,MAAAL,KAAAK,MAEAA,KAAA8Z,eAAA,KAAA8G,GACA5gB,KAAA8Z,eAAA,UAAAmI,IAEA,CACA,GAAA,CAAAlf,IAAA,uBAAAjD,MAEA,WAKA,OAHAE,KAAA2a,aAAA,KAAA9V,EAAA,+BACA7E,KAAA2a,aAAA,UAAA9V,EAAA,qCAEA,CACA,KAAAqd,CAAA,CAzBA,CAAArH,GA4BA1W,EAAAD,QAAAge,CRm/KA,EAAE,CAAC,kCAAkC,EAAE,kCAAkC,GAAG,6BAA6B,KAAK,EAAE,CAAC,SAASrd,EAAQV,EAAOD,GS3nLzI,IAAA2W,EAAAhW,EAAA,mCAEA+L,EAAA,SAAAmJ,GAGA,IAAAuI,EAAAvI,EAAA8F,cAAAnB,eAAA3E,EAAA6F,YAAA,KACA2C,EAAAxI,EAAA8F,cAAAnB,eAAA3E,EAAA6F,YAAA,KAEA,OADA7F,EAAAgG,eAAAiC,eAAAjI,EAAA+F,aAAA,IAAAwC,EAAAC,IACA,CACA,EAEA5O,EAAA,SAAAoG,GAGA,IAAAuI,EAAAvI,EAAA8F,cAAAnB,eAAA3E,EAAA6F,YAAA,KACA2C,EAAAxI,EAAA8F,cAAAnB,eAAA3E,EAAA6F,YAAA,KAEA,OADA7F,EAAAgG,eAAAiC,eAAAjI,EAAA+F,aAAA,IAAAwC,EAAAC,IACA,CACA,EAEAC,EAAA,SAAAzI,GAGA,IAAAuI,EAAAvI,EAAA8F,cAAAnB,eAAA3E,EAAA6F,YAAA,KACA2C,EAAAxI,EAAA8F,cAAAnB,eAAA3E,EAAA6F,YAAA,KAEA,OADA7F,EAAAgG,eAAAiC,eAAAjI,EAAA+F,aAAA,IAAAwC,EAAAC,IACA,CACA,EAEAvW,EAAA,SAAA+N,GAGA,IAAAuI,EAAAvI,EAAA8F,cAAAnB,eAAA3E,EAAA6F,YAAA,KACA2C,EAAAxI,EAAA8F,cAAAnB,eAAA3E,EAAA6F,YAAA,KAEA,OADA7F,EAAAgG,eAAAiC,eAAAjI,EAAA+F,aAAA,IAAAwC,EAAAC,IACA,CACA,EAEAE,EAAA,SAAA1I,GAEA,IAAAuI,EAAAvI,EAAA8F,cAAAnB,eAAA3E,EAAA6F,YAAA,KAIA8C,EAAA,EAEA,GAAA,UAJA7gB,QAAAygB,GAMA,GAAA7H,MAAAC,QAAA4H,GAEA,IAAA,IAAA3f,EAAA,EAAAA,EAAA2f,EAAAziB,OAAA8C,IACA,CAEA,IAAAggB,EAAAC,SAAAN,EAAA3f,IAEAsM,MAAA0T,GAEA5I,EAAAiG,SAAA,wBAAAtH,OAAA/V,EAAA,mDAAA+V,OAAA4J,EAAA3f,GAAA,OAIA+f,GAAAC,EACA5I,EAAAoG,QAAA,mBAAAzH,OAAA/V,EAAA,YAAA+V,OAAAiK,EAAA,eAAAjK,OAAAgK,IAEA,MAKA,IADA,IAAAG,EAAApjB,OAAA2b,KAAAkH,GACA3f,EAAA,EAAAA,EAAAkgB,EAAAhjB,OAAA8C,IACA,CACA,IAAAggB,EAAAC,SAAAN,EAAAO,EAAAlgB,KAEAsM,MAAA0T,GAEA5I,EAAAiG,SAAA,oBAAAtH,OAAAmK,EAAAlgB,GAAA,mDAAA+V,OAAA4J,EAAAO,EAAAlgB,IAAA,OAIA+f,GAAAC,EACA5I,EAAAoG,QAAA,2BAAAzH,OAAAmK,EAAAlgB,GAAA,YAAA+V,OAAAiK,EAAA,eAAAjK,OAAAgK,IAEA,KAIA,CACA,IAAAC,EAAAC,SAAAN,GAEArT,MAAA0T,GAEA5I,EAAAiG,SAAA,6DAAAtH,OAAA4J,EAAA,MAIAI,GAAAC,CAEA,CAEA,OADA5I,EAAAgG,eAAAiC,eAAAjI,EAAA+F,aAAA,IAAA4C,IACA,CACA,EAEAI,EAAA,SAAAC,GAAA1iB,UAAAyiB,EAAAC,GAAA,IAAAC,EAAA7hB,aAAA2hB,GAEA,SAAAA,EAAAzJ,GACA,IAAA4J,EAEA,OAFA3gB,gBAAAtC,KAAA8iB,IACAG,EAAAD,EAAArjB,KAAAK,KAAAqZ,IACAE,UAAA,OAAA0J,CACA,CA8BA,OA9BAjgB,aAAA8f,EAAA,CAAA,CAAA/f,IAAA,yBAAAjD,MAEA,WAeA,OAbAE,KAAA8Z,eAAA,MAAAlJ,GAEA5Q,KAAA8Z,eAAA,WAAAnG,GACA3T,KAAA8Z,eAAA,MAAAnG,GAEA3T,KAAA8Z,eAAA,WAAA0I,GACAxiB,KAAA8Z,eAAA,MAAA0I,GAEAxiB,KAAA8Z,eAAA,SAAA9N,GACAhM,KAAA8Z,eAAA,MAAA9N,GAEAhM,KAAA8Z,eAAA,YAAA2I,IAEA,CACA,GAAA,CAAA1f,IAAA,uBAAAjD,MAEA,WASA,OAPAE,KAAA2a,aAAA,MAAA9V,EAAA,+BACA7E,KAAA2a,aAAA,WAAA9V,EAAA,oCACA7E,KAAA2a,aAAA,WAAA9V,EAAA,oCACA7E,KAAA2a,aAAA,SAAA9V,EAAA,kCAEA7E,KAAA2a,aAAA,YAAA9V,EAAA,sCAEA,CACA,KAAAie,CAAA,CApCA,CAAAjI,GAuCA1W,EAAAD,QAAA4e,CTioLA,EAAE,CAAC,kCAAkC,EAAE,6BAA6B,GAAG,mCAAmC,GAAG,gCAAgC,GAAG,kCAAkC,GAAG,kCAAkC,KAAK,EAAE,CAAC,SAASje,EAAQV,EAAOD,GUlxLvPC,EAAAD,QAAA,CACAgW,YACA,CACAE,UAAA,WACAD,UAAA,gBACA+I,SAAA,6DAGA5I,OACA,CACA6I,MAAA,CAAAxK,KAAA,QAAAyK,KAAA,UACAC,OAAA,CAAA1K,KAAA,SAAAyK,KAAA,WAGA7I,QACA,CACA+I,KAAA,CAAA3K,KAAA,OAAA8F,KAAA,yBACA8E,MAAA,CAAA5K,KAAA,QAAA8F,KAAA,+CAGAE,IACA,CACAC,aAAA,mFACA2B,cAAA,+GAGA/F,MACA,CACA,CACAJ,UAAA,cACAsF,YAAA,WACAN,oBACA,CACAra,EAAA,QACAyO,EAAA,UAEA+L,qBACA,CACAhW,EAAA,SAGA,CACA6Q,UAAA,cACAsF,YAAA,SACAN,oBACA,CACAra,EAAA,QACAyO,EAAA,UAEA+L,qBACA,CACAhW,EAAA,WVwxLA,EAAE,CAAC,GAAG,GAAG,CAAC,SAAS1E,EAAQV,EAAOD,GW30LlCC,EAAAD,QAAA,CACAgW,YACA,CACAE,UAAA,QACAD,UAAA,UACA+I,SAAA,0DAGA5I,OACA,CACAf,UAAA,CAAAZ,KAAA,YAAAyK,KAAA,SAAAI,QAAA,SACAC,UAAA,CAAA9K,KAAA,YAAAyK,KAAA,SAAAI,QAAA,SAGAjJ,QACA,CACA,EAEAoE,IACA,CACAC,aAAA,wFACA2B,cAAA,qFAGA/F,MACA,CACA,CACAJ,UAAA,QACAsF,YAAA,YXg1LA,EAAE,CAAC,GAAG,GAAG,CAAC,SAAS7a,EAAQV,EAAOD,GY52LlCC,EAAAD,QAAA,CACAgW,YACA,CACAE,UAAA,QACAD,UAAA,KACA+I,SAAA,iOAGA5I,OACA,CACAoJ,UAAA,CAAA/K,KAAA,YAAAyK,KAAA,OACAO,WAAA,CAAAhL,KAAA,aAAAyK,KAAA,MAAAI,SAAA,GACAI,WAAA,CAAAjL,KAAA,aAAAyK,KAAA,SAAAI,QAAA,MAEAK,cAAA,CAAAlL,KAAA,gBAAAyK,KAAA,SAAAI,QAAA,SACAM,cAAA,CAAAnL,KAAA,gBAAAyK,KAAA,SAAAI,QAAA,QAEAO,eAAA,CAAApL,KAAA,iBAAAyK,KAAA,SAAAI,QAAA,SACAQ,eAAA,CAAArL,KAAA,iBAAAyK,KAAA,SAAAI,QAAA,SAGAjJ,QACA,CACA0J,iBAAA,CAAAtL,KAAA,mBAAAyK,KAAA,YAGAzE,IACA,CACAC,aAAA,uJACA2B,cAAA,kJAGA/F,MACA,CACA,CACAJ,UAAA,QACAsF,YAAA,OZi3LA,EAAE,CAAC,GAAG,GAAG,CAAC,SAAS7a,EAAQV,EAAOD,Gar5LlCC,EAAAD,QAAA,CACAgW,YACA,CACAE,UAAA,OACAD,UAAA,MACA+I,SAAA,+BAGA5I,OACA,CACAvV,EAAA,CAAA4T,KAAA,IAAAyK,KAAA,UACA5P,EAAA,CAAAmF,KAAA,IAAAyK,KAAA,WAGA7I,QACA,CACAhR,EAAA,CAAAoP,KAAA,IAAAyK,KAAA,WAGAzE,IACA,CACAC,aAAA,kEACA2B,cAAA,4FAGA/F,MACA,CACA,CACAJ,UAAA,OACAsF,YAAA,Qb05LA,EAAE,CAAC,GAAG,GAAG,CAAC,SAAS7a,EAAQV,EAAOD,Gcv7LlCC,EAAAD,QAAA,CACAgW,YACA,CACAE,UAAA,OACAD,UAAA,YACA+I,SAAA,mFAGA5I,OACA,CACAvV,EAAA,CAAA4T,KAAA,IAAAyK,KAAA,QAGA7I,QACA,CACAhR,EAAA,CAAAoP,KAAA,IAAAyK,KAAA,WAGAzE,IACA,CACAC,aAAA,mFACA2B,cAAA,sDAGA/F,MACA,CACA,CACAJ,UAAA,OACAsF,YAAA,cd47LA,EAAE,CAAC,GAAG,GAAG,CAAC,SAAS7a,EAAQV,EAAOD,Gex9LlCC,EAAAD,QAAA,CACAgW,YACA,CACAE,UAAA,OACAD,UAAA,SACA+I,SAAA,kCAGA5I,OACA,CACAvV,EAAA,CAAA4T,KAAA,IAAAyK,KAAA,UACA5P,EAAA,CAAAmF,KAAA,IAAAyK,KAAA,WAGA7I,QACA,CACAhR,EAAA,CAAAoP,KAAA,IAAAyK,KAAA,WAGAzE,IACA,CACAC,aAAA,sEACA2B,cAAA,4FAGA/F,MACA,CACA,CACAJ,UAAA,OACAsF,YAAA,Wf69LA,EAAE,CAAC,GAAG,GAAG,CAAC,SAAS7a,EAAQV,EAAOD,GgB1/LlCC,EAAAD,QAAA,CACAgW,YACA,CACAE,UAAA,OACAD,UAAA,WACA+I,SAAA,oCAGA5I,OACA,CACAvV,EAAA,CAAA4T,KAAA,IAAAyK,KAAA,UACA5P,EAAA,CAAAmF,KAAA,IAAAyK,KAAA,WAGA7I,QACA,CACAhR,EAAA,CAAAoP,KAAA,IAAAyK,KAAA,WAGAzE,IACA,CACAC,aAAA,uEACA2B,cAAA,4FAGA/F,MACA,CACA,CACAJ,UAAA,OACAsF,YAAA,ahB+/LA,EAAE,CAAC,GAAG,GAAG,CAAC,SAAS7a,EAAQV,EAAOD,GiB5hMlCC,EAAAD,QAAA,CACAgW,YACA,CACAE,UAAA,OACAD,UAAA,WACA+I,SAAA,oCAGA5I,OACA,CACAvV,EAAA,CAAA4T,KAAA,IAAAyK,KAAA,UACA5P,EAAA,CAAAmF,KAAA,IAAAyK,KAAA,WAGA7I,QACA,CACAhR,EAAA,CAAAoP,KAAA,IAAAyK,KAAA,WAGAzE,IACA,CACAC,aAAA,uEACA2B,cAAA,4FAGA/F,MACA,CACA,CACAJ,UAAA,OACAsF,YAAA,ajBiiMA,EAAE,CAAC,GAAG,GAAG,CAAC,SAAS7a,EAAQV,EAAOD,GkB9jMlCC,EAAAD,QAAA,CACAgW,YACA,CACAE,UAAA,cACAD,UAAA,MACA+I,SAAA,yCAGA5I,OACA,CACAvV,EAAA,CAAA4T,KAAA,IAAAyK,KAAA,UACA5P,EAAA,CAAAmF,KAAA,IAAAyK,KAAA,WAGA7I,QACA,CACAhR,EAAA,CAAAoP,KAAA,IAAAyK,KAAA,WAGAzE,IACA,CACAC,aAAA,kEACA2B,cAAA,4FAGA/F,MACA,CACA,CACAJ,UAAA,cACAsF,YAAA,QlBmkMA,EAAE,CAAC,GAAG,GAAG,CAAC,SAAS7a,EAAQV,EAAOD,GmBhmMlCC,EAAAD,QAAA,CACAgW,YACA,CACAE,UAAA,cACAD,UAAA,YACA+I,SAAA,6FAGA5I,OACA,CACAvV,EAAA,CAAA4T,KAAA,IAAAyK,KAAA,OACAc,WAAA,CAAAvL,KAAA,aAAAyK,KAAA,QAGA7I,QACA,CACAhR,EAAA,CAAAoP,KAAA,IAAAyK,KAAA,WAGAzE,IACA,CACAC,aAAA,mFACA2B,cAAA,sDAGA/F,MACA,CACA,CACAJ,UAAA,cACAsF,YAAA,cnBqmMA,EAAE,CAAC,GAAG,GAAG,CAAC,SAAS7a,EAAQV,EAAOD,GoBloMlCC,EAAAD,QAAA,CACAgW,YACA,CACAE,UAAA,cACAD,UAAA,SACA+I,SAAA,4CAGA5I,OACA,CACAvV,EAAA,CAAA4T,KAAA,IAAAyK,KAAA,UACA5P,EAAA,CAAAmF,KAAA,IAAAyK,KAAA,WAGA7I,QACA,CACAhR,EAAA,CAAAoP,KAAA,IAAAyK,KAAA,WAGAzE,IACA,CACAC,aAAA,sEACA2B,cAAA,4FAGA/F,MACA,CACA,CACAJ,UAAA,cACAsF,YAAA,WpBuoMA,EAAE,CAAC,GAAG,GAAG,CAAC,SAAS7a,EAAQV,EAAOD,GqBpqMlCC,EAAAD,QAAA,CACAgW,YACA,CACAE,UAAA,cACAD,UAAA,0BACA+I,SAAA,2FAGA5I,OACA,CACA6J,aAAA,CAAAxL,KAAA,eAAAyK,KAAA,OACAgB,gBAAA,CAAAzL,KAAA,kBAAAyK,KAAA,OACAiB,mBAAA,CAAA1L,KAAA,qBAAAyK,KAAA,OACAkB,wBAAA,CAAA3L,KAAA,0BAAAyK,KAAA,SAAAI,SAAA,IAGAjJ,QACA,CACAgK,cAAA,CAAA5L,KAAA,gBAAAyK,KAAA,QAGAzE,IACA,CACAC,aAAA,6HACA2B,cAAA,mIAGA/F,MACA,CACA,CACAJ,UAAA,cACAsF,YAAA,4BrByqMA,EAAE,CAAC,GAAG,GAAG,CAAC,SAAS7a,EAAQV,EAAOD,GsBxsMlCC,EAAAD,QAAA,CACAgW,YACA,CACAE,UAAA,cACAD,UAAA,WACA+I,SAAA,8CAGA5I,OACA,CACAvV,EAAA,CAAA4T,KAAA,IAAAyK,KAAA,UACA5P,EAAA,CAAAmF,KAAA,IAAAyK,KAAA,WAGA7I,QACA,CACAhR,EAAA,CAAAoP,KAAA,IAAAyK,KAAA,WAGAzE,IACA,CACAC,aAAA,uEACA2B,cAAA,4FAGA/F,MACA,CACA,CACAJ,UAAA,cACAsF,YAAA,atB6sMA,EAAE,CAAC,GAAG,GAAG,CAAC,SAAS7a,EAAQV,EAAOD,GuB1uMlCC,EAAAD,QAAA,CACAgW,YACA,CACAE,UAAA,cACAD,UAAA,QACA+I,SAAA,6BAGA5I,OACA,CACAvV,EAAA,CAAA4T,KAAA,IAAAyK,KAAA,UACAvd,UAAA,CAAA8S,KAAA,YAAAyK,KAAA,UACAoB,aAAA,CAAA7L,KAAA,eAAAyK,KAAA,WAIA7I,QACA,CACAhR,EAAA,CAAAoP,KAAA,IAAAyK,KAAA,WAGAzE,IACA,CACAC,aAAA,qDACA2B,cAAA,gFAGA/F,MACA,CACA,CACAJ,UAAA,cACAsF,YAAA,UvB+uMA,EAAE,CAAC,GAAG,GAAG,CAAC,SAAS7a,EAAQV,EAAOD,GwB9wMlCC,EAAAD,QAAA,CACAgW,YACA,CACAE,UAAA,cACAD,UAAA,eACA+I,SAAA,sBAGA5I,OACA,CACAzU,UAAA,CAAA8S,KAAA,YAAAyK,KAAA,SAAAI,QAAA,IAIAjJ,QACA,CACA,EAEAoE,IACA,CACAC,aAAA,6CACA2B,cAAA,0EAGA/F,MACA,CACA,CACAJ,UAAA,cACAsF,YAAA,iBxBmxMA,EAAE,CAAC,GAAG,GAAG,CAAC,SAAS7a,EAAQV,EAAOD,GyB/yMlCC,EAAAD,QAAA,CACAgW,YACA,CACAE,UAAA,cACAD,UAAA,kBACA+I,SAAA,0BAGA5I,OACA,CACAkK,aAAA,CAAA7L,KAAA,eAAAyK,KAAA,SAAAI,QAAA,kBAIAjJ,QACA,CACA,EAEAoE,IACA,CACAC,aAAA,oDACA2B,cAAA,iFAGA/F,MACA,CACA,CACAJ,UAAA,cACAsF,YAAA,oBzBozMA,EAAE,CAAC,GAAG,GAAG,CAAC,SAAS7a,EAAQV,EAAOD,G0Bh1MlCC,EAAAD,QAAA,CACAgW,YACA,CACAE,UAAA,cACAD,UAAA,WACA+I,SAAA,8CAGA5I,OACA,CACAvV,EAAA,CAAA4T,KAAA,IAAAyK,KAAA,UACA5P,EAAA,CAAAmF,KAAA,IAAAyK,KAAA,WAGA7I,QACA,CACAhR,EAAA,CAAAoP,KAAA,IAAAyK,KAAA,WAGAzE,IACA,CACAC,aAAA,uEACA2B,cAAA,4FAGA/F,MACA,CACA,CACAJ,UAAA,cACAsF,YAAA,a1Bq1MA,EAAE,CAAC,GAAG,GAAG,CAAC,SAAS7a,EAAQV,EAAOD,G2Bl3MlCC,EAAAD,QAAA,CACAgW,YACA,CACAE,UAAA,cACAD,UAAA,kBACA+I,SAAA,mEAGA5I,OACA,CACAvV,EAAA,CAAA4T,KAAA,IAAAyK,KAAA,UACAqB,cAAA,CAAA9L,KAAA,gBAAAyK,KAAA,SAAAI,QAAA,GACAgB,aAAA,CAAA7L,KAAA,eAAAyK,KAAA,WAIA7I,QACA,CACAhR,EAAA,CAAAoP,KAAA,IAAAyK,KAAA,WAGAzE,IACA,CACAC,aAAA,+FACA2B,cAAA,0HAGA/F,MACA,CACA,CACAJ,UAAA,cACAsF,YAAA,oB3Bu3MA,EAAE,CAAC,GAAG,GAAG,CAAC,SAAS7a,EAAQV,EAAOD,G4Bt5MlCC,EAAAD,QAAA,CACAgW,YACA,CACAE,UAAA,cACAD,UAAA,sBACA+I,SAAA,wEAGA5I,OACA,CACAvV,EAAA,CAAA4T,KAAA,IAAAyK,KAAA,UACAzO,OAAA,CAAAgE,KAAA,SAAAyK,KAAA,SAAAI,QAAA,IACAgB,aAAA,CAAA7L,KAAA,eAAAyK,KAAA,WAIA7I,QACA,CACAhR,EAAA,CAAAoP,KAAA,IAAAyK,KAAA,WAGAzE,IACA,CACAC,aAAA,8EACA2B,cAAA,yGAGA/F,MACA,CACA,CACAJ,UAAA,cACAsF,YAAA,wB5B25MA,EAAE,CAAC,GAAG,GAAG,CAAC,SAAS7a,EAAQV,EAAOD,G6B17MlCC,EAAAD,QAAA,CACAgW,YACA,CACAE,UAAA,MACAD,UAAA,gBACA+I,SAAA,sEAGA5I,OACA,CACA6J,aAAA,CAAAxL,KAAA,eAAAyK,KAAA,OACAgB,gBAAA,CAAAzL,KAAA,kBAAAyK,KAAA,OACAiB,mBAAA,CAAA1L,KAAA,qBAAAyK,KAAA,QAGA7I,QACA,CACAgK,cAAA,CAAA5L,KAAA,gBAAAyK,KAAA,QAGAzE,IACA,CACAC,aAAA,sHACA2B,cAAA,8GAGA/F,MACA,CACA,CACAJ,UAAA,MACAsF,YAAA,kB7B+7MA,EAAE,CAAC,GAAG,GAAG,CAAC,SAAS7a,EAAQV,EAAOD,G8B79MlCC,EAAAD,QAAA,CACAgW,YACA,CACAE,UAAA,SACAD,UAAA,UACA+I,SAAA,sEAGA5I,OACA,CACAoK,YAAA,CAAA/L,KAAA,cAAAyK,KAAA,UACAuB,UAAA,CAAAhM,KAAA,YAAAyK,KAAA,UACAwB,YAAA,CAAAjM,KAAA,cAAAyK,KAAA,WAGA7I,QACA,CACAsK,aAAA,CAAAlM,KAAA,eAAAyK,KAAA,WAGAzE,IACA,CACAC,aAAA,0HACA2B,cAAA,wLAGA/F,MACA,CACA,CACAJ,UAAA,SACAsF,YAAA,Y9Bk+MA,EAAE,CAAC,GAAG,GAAG,CAAC,SAAS7a,EAAQV,EAAOD,G+BhgNlCC,EAAAD,QAAA,CACAgW,YACA,CACAE,UAAA,SACAD,UAAA,YACA+I,SAAA,0FAGA5I,OACA,CACAoK,YAAA,CAAA/L,KAAA,cAAAyK,KAAA,UACA0B,WAAA,CAAAnM,KAAA,aAAAyK,KAAA,SAAAI,QAAA,GACAuB,SAAA,CAAApM,KAAA,WAAAyK,KAAA,SAAAI,QAAA,OAGAjJ,QACA,CACAsK,aAAA,CAAAlM,KAAA,eAAAyK,KAAA,WAGAzE,IACA,CACAC,aAAA,oHACA2B,cAAA,+KAGA/F,MACA,CACA,CACAJ,UAAA,SACAsF,YAAA,c/BqgNA,EAAE,CAAC,GAAG,GAAG,CAAC,SAAS7a,EAAQV,EAAOD,GgCniNlCC,EAAAD,QAAA,CACAgW,YACA,CACAE,UAAA,SACAD,UAAA,OACA+I,SAAA,4FAGA5I,OACA,CACAoK,YAAA,CAAA/L,KAAA,cAAAyK,KAAA,WAGA7I,QACA,CACAsK,aAAA,CAAAlM,KAAA,eAAAyK,KAAA,WAGAzE,IACA,CACAC,aAAA,+DACA2B,cAAA,gHAGA/F,MACA,CACA,CACAJ,UAAA,SACAsF,YAAA,ShCwiNA,EAAE,CAAC,GAAG,GAAG,CAAC,SAAS7a,EAAQV,EAAOD,GiCpkNlC,IAAA2W,EAAAhW,EAAA,mCAEAmgB,EAAAngB,EAAA,cAEA+L,EAAA,SAAAmJ,GAGA,IAAAuI,EAAA,IAAA0C,EAAAjL,EAAA8F,cAAAnB,eAAA3E,EAAA6F,YAAA,MACA2C,EAAA,IAAAyC,EAAAjL,EAAA8F,cAAAnB,eAAA3E,EAAA6F,YAAA,MAEA,OADA7F,EAAAgG,eAAAiC,eAAAjI,EAAA+F,aAAA,IAAAwC,EAAAlX,KAAAmX,GAAAxX,aACA,CACA,EAEA4I,EAAA,SAAAoG,GAGA,IAAAuI,EAAA,IAAA0C,EAAAjL,EAAA8F,cAAAnB,eAAA3E,EAAA6F,YAAA,MACA2C,EAAA,IAAAyC,EAAAjL,EAAA8F,cAAAnB,eAAA3E,EAAA6F,YAAA,MAEA,OADA7F,EAAAgG,eAAAiC,eAAAjI,EAAA+F,aAAA,IAAAwC,EAAAtS,IAAAuS,GAAAxX,aACA,CACA,EAEAyX,EAAA,SAAAzI,GAGA,IAAAuI,EAAA,IAAA0C,EAAAjL,EAAA8F,cAAAnB,eAAA3E,EAAA6F,YAAA,MACA2C,EAAA,IAAAyC,EAAAjL,EAAA8F,cAAAnB,eAAA3E,EAAA6F,YAAA,MAEA,OADA7F,EAAAgG,eAAAiC,eAAAjI,EAAA+F,aAAA,IAAAwC,EAAA9Q,IAAA+Q,GAAAxX,aACA,CACA,EAEAiB,EAAA,SAAA+N,GAGA,IAAAuI,EAAA,IAAA0C,EAAAjL,EAAA8F,cAAAnB,eAAA3E,EAAA6F,YAAA,MACA2C,EAAA,IAAAyC,EAAAjL,EAAA8F,cAAAnB,eAAA3E,EAAA6F,YAAA,MAEA,OADA7F,EAAAgG,eAAAiC,eAAAjI,EAAA+F,aAAA,IAAAwC,EAAAjW,IAAAkW,GAAAxX,aACA,CACA,EAEAkG,EAAA,SAAA8I,GAEA,IAAAuI,EAAA,IAAA0C,EAAAjL,EAAA8F,cAAAnB,eAAA3E,EAAA6F,YAAA,MAEAqF,EAAArC,SAAA7I,EAAA8F,cAAAnB,eAAA3E,EAAA6F,YAAA,cACAsF,EAAAnL,EAAA8F,cAAAnB,eAAA3E,EAAA6F,YAAA,gBAGA,GAAAsF,EAEA,OAAAA,EAAAna,WAAAsL,eAEA,IAAA,WACA2O,EAAA9M,IAAA,CAAApS,SAAAkf,EAAAxN,WACA,MACA,IAAA,aACAwN,EAAA9M,IAAA,CAAApS,SAAAkf,EAAAvN,aACA,MACA,IAAA,aACAuN,EAAA9M,IAAA,CAAApS,SAAAkf,EAAAtN,aACA,MACA,IAAA,cACAsN,EAAA9M,IAAA,CAAApS,SAAAkf,EAAArN,cACA,MACA,QACA,IAAA,gBACAqN,EAAA9M,IAAA,CAAApS,SAAAkf,EAAApN,gBACA,MACA,IAAA,kBACAoN,EAAA9M,IAAA,CAAApS,SAAAkf,EAAAnN,kBACA,MACA,IAAA,kBACAmN,EAAA9M,IAAA,CAAApS,SAAAkf,EAAAlN,kBACA,MACA,IAAA,kBACAkN,EAAA9M,IAAA,CAAApS,SAAAkf,EAAAjN,kBACA,MACA,IAAA,mBACAiN,EAAA9M,IAAA,CAAApS,SAAAkf,EAAAhN,mBACA,MACA,IAAA,SACAgN,EAAA9M,IAAA,CAAApS,SAAAkf,EAAA/M,SAKAhJ,MAAAgW,IAEAD,EAAA9M,IAAA,CAAArS,UAAAof,IAGAlL,EAAAgG,eAAAiC,eAAAjI,EAAA+F,aAAA,IAAAkF,EAAA/T,MAAAqR,GAAAvX,WACA,EAGAoa,EAAA,SAAApL,GAEA,IAAAuI,EAAA,IAAA0C,EAAAjL,EAAA8F,cAAAnB,eAAA3E,EAAA6F,YAAA,MAEAwF,EAAAxC,SAAA7I,EAAA8F,cAAAnB,eAAA3E,EAAA6F,YAAA,WACAsF,EAAAnL,EAAA8F,cAAAnB,eAAA3E,EAAA6F,YAAA,gBAGA,GAAAsF,EAEA,OAAAA,EAAAna,WAAAsL,eAEA,IAAA,WACA2O,EAAA9M,IAAA,CAAApS,SAAAkf,EAAAxN,WACA,MACA,IAAA,aACAwN,EAAA9M,IAAA,CAAApS,SAAAkf,EAAAvN,aACA,MACA,IAAA,aACAuN,EAAA9M,IAAA,CAAApS,SAAAkf,EAAAtN,aACA,MACA,IAAA,cACAsN,EAAA9M,IAAA,CAAApS,SAAAkf,EAAArN,cACA,MACA,QACA,IAAA,gBACAqN,EAAA9M,IAAA,CAAApS,SAAAkf,EAAApN,gBACA,MACA,IAAA,kBACAoN,EAAA9M,IAAA,CAAApS,SAAAkf,EAAAnN,kBACA,MACA,IAAA,kBACAmN,EAAA9M,IAAA,CAAApS,SAAAkf,EAAAlN,kBACA,MACA,IAAA,kBACAkN,EAAA9M,IAAA,CAAApS,SAAAkf,EAAAjN,kBACA,MACA,IAAA,mBACAiN,EAAA9M,IAAA,CAAApS,SAAAkf,EAAAhN,mBACA,MACA,IAAA,SACAgN,EAAA9M,IAAA,CAAApS,SAAAkf,EAAA/M,SAKAhJ,MAAAmW,KAEAA,EAAA,IAGArL,EAAAgG,eAAAiC,eAAAjI,EAAA+F,aAAA,IAAAwC,EAAAtP,oBAAAoS,GAAAra,WACA,EAEAsa,EAAA,SAAAtL,GAEA,IAAAuI,EAAA,IAAA0C,EAAAjL,EAAA8F,cAAAnB,eAAA3E,EAAA6F,YAAA,MAEA0F,EAAA1C,SAAA7I,EAAA8F,cAAAnB,eAAA3E,EAAA6F,YAAA,kBACAsF,EAAAnL,EAAA8F,cAAAnB,eAAA3E,EAAA6F,YAAA,gBAGA,GAAAsF,EAEA,OAAAA,EAAAna,WAAAsL,eAEA,IAAA,WACA2O,EAAA9M,IAAA,CAAApS,SAAAkf,EAAAxN,WACA,MACA,IAAA,aACAwN,EAAA9M,IAAA,CAAApS,SAAAkf,EAAAvN,aACA,MACA,IAAA,aACAuN,EAAA9M,IAAA,CAAApS,SAAAkf,EAAAtN,aACA,MACA,IAAA,cACAsN,EAAA9M,IAAA,CAAApS,SAAAkf,EAAArN,cACA,MACA,QACA,IAAA,gBACAqN,EAAA9M,IAAA,CAAApS,SAAAkf,EAAApN,gBACA,MACA,IAAA,kBACAoN,EAAA9M,IAAA,CAAApS,SAAAkf,EAAAnN,kBACA,MACA,IAAA,kBACAmN,EAAA9M,IAAA,CAAApS,SAAAkf,EAAAlN,kBACA,MACA,IAAA,kBACAkN,EAAA9M,IAAA,CAAApS,SAAAkf,EAAAjN,kBACA,MACA,IAAA,mBACAiN,EAAA9M,IAAA,CAAApS,SAAAkf,EAAAhN,mBACA,MACA,IAAA,SACAgN,EAAA9M,IAAA,CAAApS,SAAAkf,EAAA/M,SAKAhJ,MAAAqW,KAEAA,EAAA,GAGAvL,EAAAgG,eAAAiC,eAAAjI,EAAA+F,aAAA,IAAAwC,EAAA1Q,gBAAA0T,GAAAva,WACA,EAEAwa,EAAA,SAAAxL,GAEA,IAAAkL,EAAArC,SAAA7I,EAAA8F,cAAAnB,eAAA3E,EAAA6F,YAAA,cAEA4F,QAAA/V,IAAAwV,GACAhW,MAAAgW,IAEAD,EAAA9M,IAAA,CAAArS,UAAAof,GAEA,EAEAQ,EAAA,SAAA1L,GAEA,IAAAmL,EAAAnL,EAAA8F,cAAAnB,eAAA3E,EAAA6F,YAAA,gBAGA,GAAAsF,EAEA,OAAAA,EAAAna,WAAAsL,eAEA,IAAA,WACA2O,EAAA9M,IAAA,CAAApS,SAAAkf,EAAAxN,WACA,MACA,IAAA,aACAwN,EAAA9M,IAAA,CAAApS,SAAAkf,EAAAvN,aACA,MACA,IAAA,aACAuN,EAAA9M,IAAA,CAAApS,SAAAkf,EAAAtN,aACA,MACA,IAAA,cACAsN,EAAA9M,IAAA,CAAApS,SAAAkf,EAAArN,cACA,MACA,QACA,IAAA,gBACAqN,EAAA9M,IAAA,CAAApS,SAAAkf,EAAApN,gBACA,MACA,IAAA,kBACAoN,EAAA9M,IAAA,CAAApS,SAAAkf,EAAAnN,kBACA,MACA,IAAA,kBACAmN,EAAA9M,IAAA,CAAApS,SAAAkf,EAAAlN,kBACA,MACA,IAAA,kBACAkN,EAAA9M,IAAA,CAAApS,SAAAkf,EAAAjN,kBACA,MACA,IAAA,mBACAiN,EAAA9M,IAAA,CAAApS,SAAAkf,EAAAhN,mBACA,MACA,IAAA,SACAgN,EAAA9M,IAAA,CAAApS,SAAAkf,EAAA/M,SAIA,EAEAwK,EAAA,SAAA1I,GAEA,IAAAuI,EAAAvI,EAAA8F,cAAAnB,eAAA3E,EAAA6F,YAAA,KAEA8F,EAAA7jB,QAAAygB,GAEAI,EAAA,IAAAsC,EAAA,GAEA,GAAA,UAAAU,EAEA,GAAAjL,MAAAC,QAAA4H,GAEA,IAAA,IAAA3f,EAAA,EAAAA,EAAA2f,EAAAziB,OAAA8C,IACA,CAEA,IAAAggB,EAAA,IAAAqC,EAAA1C,EAAA3f,IAEAsM,MAAA0T,GAEA5I,EAAAiG,SAAA,wBAAAtH,OAAA/V,EAAA,iEAAA+V,OAAA4J,EAAA3f,GAAA,OAIA+f,EAAAA,EAAAtX,KAAAuX,GACA5I,EAAAoG,QAAA,mBAAAzH,OAAA/V,EAAA,YAAA+V,OAAAiK,EAAA,eAAAjK,OAAAgK,IAEA,MAKA,IADA,IAAAG,EAAApjB,OAAA2b,KAAAkH,GACA3f,EAAA,EAAAA,EAAAkgB,EAAAhjB,OAAA8C,IACA,CACA,IAAAggB,EAAA,IAAAqC,EAAA1C,EAAAO,EAAAlgB,KAEAsM,MAAA0T,GAEA5I,EAAAiG,SAAA,oBAAAtH,OAAAmK,EAAAlgB,GAAA,mDAAA+V,OAAA4J,EAAAO,EAAAlgB,IAAA,OAIA+f,EAAAA,EAAAtX,KAAAuX,GACA5I,EAAAoG,QAAA,2BAAAzH,OAAAmK,EAAAlgB,GAAA,YAAA+V,OAAAiK,EAAA,eAAAjK,OAAAgK,IAEA,KAIA,CACA,IAAAC,EAAA,IAAAqC,EAAA1C,GAEArT,MAAA0T,GAEA5I,EAAAiG,SAAA,6DAAAtH,OAAA4J,EAAA,MAIAI,EAAAC,CAEA,CAEA,OADA5I,EAAAgG,eAAAiC,eAAAjI,EAAA+F,aAAA,IAAA4C,EAAA3X,aACA,CACA,EAEA4a,EAAA,SAAA5L,GAEA,IAAA6L,EAAA7L,EAAA8F,cAAAnB,eAAA3E,EAAA6F,YAAA,gBACAiG,EAAA9L,EAAA8F,cAAAnB,eAAA3E,EAAA6F,YAAA,mBACAkG,EAAA/L,EAAA8F,cAAAnB,eAAA3E,EAAA6F,YAAA,sBAEAmG,EAAA,CAAA,EACAC,EAAA,CAAA,EAIA,GAAA,UAFAnkB,QAAA+jB,GAGA,CACA,GAAAnL,MAAAC,QAAAkL,GAEA,IAAA,IAAAjjB,EAAA,EAAAA,EAAAijB,EAAA/lB,OAAA8C,IAEA,GAAA,WAAAd,QAAA+jB,EAAAjjB,IAEAoX,EAAAoG,QAAA,YAAAzH,OAAA/V,EAAA,uDAGA,CACA,IAAAggB,EAAAiD,EAAAjjB,GACAsjB,EAAAtD,EAAAkD,GAOA,GANAlD,EAAAxiB,eAAA0lB,KAEA9L,EAAAoG,QAAA,YAAAzH,OAAA/V,EAAA,0CAAA+V,OAAAmN,EAAA,sCACAI,EAAA,cAGAtD,EAAAxiB,eAAA2lB,GAKA,CACA,IAAAI,EAAA,IAAAlB,EAAArC,EAAAmD,IAEA7W,MAAAiX,GAEAnM,EAAAiG,SAAA,oBAAAtH,OAAA/V,EAAA,mDAAA+V,OAAAiK,EAAAmD,GAAA,OAIAC,EAAA5lB,eAAA8lB,GAMAF,EAAAE,GAAAF,EAAAE,GAAA7a,KAAA8a,GAJAH,EAAAE,GAAAC,EAMAnM,EAAAoG,QAAA,2BAAAzH,OAAA/V,EAAA,YAAA+V,OAAAwN,EAAA,eAAAxN,OAAAqN,EAAAE,KAEA,MAtBAlM,EAAAoG,QAAA,YAAAzH,OAAA/V,EAAA,6CAAA+V,OAAAoN,EAAA,gCAuBA,MAMA,IADA,IAAAjD,EAAApjB,OAAA2b,KAAAwK,GACAjjB,EAAA,EAAAA,EAAAkgB,EAAAhjB,OAAA8C,IAEA,GAAA,WAAAd,QAAA+jB,EAAA/C,EAAAlgB,KAEAoX,EAAAoG,QAAA,YAAAzH,OAAA/V,EAAA,uDAGA,CACA,IAAAggB,EAAAiD,EAAA/C,EAAAlgB,IACAsjB,EAAAtD,EAAAkD,GAOA,GANAlD,EAAAxiB,eAAA0lB,KAEA9L,EAAAoG,QAAA,YAAAzH,OAAAmK,EAAAlgB,GAAA,MAAA+V,OAAA/V,EAAA,0CAAA+V,OAAAmN,EAAA,sCACAI,EAAA,cAGAtD,EAAAxiB,eAAA2lB,GAKA,CACA,IAAAI,EAAA,IAAAlB,EAAArC,EAAAmD,IAEA7W,MAAAiX,GAEAnM,EAAAiG,SAAA,oBAAAtH,OAAAmK,EAAAlgB,GAAA,MAAA+V,OAAA/V,EAAA,eAAA+V,OAAAuN,EAAA,kDAAAvN,OAAAiK,EAAAmD,GAAA,OAIAC,EAAA5lB,eAAA8lB,GAMAF,EAAAE,GAAAF,EAAAE,GAAA7a,KAAA8a,GAJAH,EAAAE,GAAAC,EAMAnM,EAAAoG,QAAA,2BAAAzH,OAAAmK,EAAAlgB,GAAA,MAAA+V,OAAA/V,EAAA,eAAA+V,OAAAuN,EAAA,WAAAvN,OAAAwN,EAAA,eAAAxN,OAAAqN,EAAAE,KAEA,MAtBAlM,EAAAoG,QAAA,YAAAzH,OAAAmK,EAAAlgB,GAAA,MAAA+V,OAAA/V,EAAA,6CAAA+V,OAAAoN,EAAA,gCAuBA,CAMA,IADA,IAAAK,EAAA1mB,OAAA2b,KAAA2K,GACAjd,EAAA,EAAAA,EAAAqd,EAAAtmB,OAAAiJ,IAEAkd,EAAAG,EAAArd,IAAAid,EAAAI,EAAArd,IAAAiC,UAEA,MAGAgP,EAAAiG,SAAA,+CAKA,OAFAjG,EAAAgG,eAAAiC,eAAAjI,EAAA+F,aAAA,gBAAAkG,IAEA,CACA,EAEAhU,EAAA,SAAA+H,GAGA,IAAAuI,EAAA,IAAA0C,EAAAjL,EAAA8F,cAAAnB,eAAA3E,EAAA6F,YAAA,MAEA,OADA7F,EAAAgG,eAAAiC,eAAAjI,EAAA+F,aAAA,IAAAwC,EAAAtQ,aAAAjH,aACA,CACA,EAGAqb,EAAA,SAAAC,GAAAhmB,UAAA+lB,EAAAC,GAAA,IAAAC,EAAAnlB,aAAAilB,GAEA,SAAAA,EAAA/M,GACA,IAAAkN,EAEA,OAFAjkB,gBAAAtC,KAAAomB,IACAG,EAAAD,EAAA3mB,KAAAK,KAAAqZ,IACAE,UAAA,cAAAgN,CACA,CAgDA,OAhDAvjB,aAAAojB,EAAA,CAAA,CAAArjB,IAAA,yBAAAjD,MAEA,WAyBA,OAvBAE,KAAA8Z,eAAA,MAAAlJ,GAEA5Q,KAAA8Z,eAAA,WAAAnG,GACA3T,KAAA8Z,eAAA,MAAAnG,GAEA3T,KAAA8Z,eAAA,WAAA0I,GACAxiB,KAAA8Z,eAAA,MAAA0I,GAEAxiB,KAAA8Z,eAAA,SAAA9N,GACAhM,KAAA8Z,eAAA,MAAA9N,GAEAhM,KAAA8Z,eAAA,YAAA2I,GACAziB,KAAA8Z,eAAA,0BAAA6L,GAEA3lB,KAAA8Z,eAAA,eAAAyL,GACAvlB,KAAA8Z,eAAA,kBAAA2L,GAEAzlB,KAAA8Z,eAAA,kBAAAuL,GACArlB,KAAA8Z,eAAA,sBAAAqL,GACAnlB,KAAA8Z,eAAA,QAAA7I,GACAjR,KAAA8Z,eAAA,aAAA9H,IAGA,CACA,GAAA,CAAAjP,IAAA,uBAAAjD,MAEA,WAiBA,OAfAE,KAAA2a,aAAA,MAAA9V,EAAA,sCACA7E,KAAA2a,aAAA,WAAA9V,EAAA,2CACA7E,KAAA2a,aAAA,WAAA9V,EAAA,2CACA7E,KAAA2a,aAAA,SAAA9V,EAAA,yCAEA7E,KAAA2a,aAAA,YAAA9V,EAAA,4CACA7E,KAAA2a,aAAA,0BAAA9V,EAAA,0DAEA7E,KAAA2a,aAAA,eAAA9V,EAAA,+CACA7E,KAAA2a,aAAA,kBAAA9V,EAAA,kDAEA7E,KAAA2a,aAAA,sBAAA9V,EAAA,sDACA7E,KAAA2a,aAAA,kBAAA9V,EAAA,kDACA7E,KAAA2a,aAAA,QAAA9V,EAAA,yCAEA,CACA,KAAAuhB,CAAA,CAtDA,CAAAvL,GAyDA1W,EAAAD,QAAAkiB,CjCskNA,EAAE,CAAC,kCAAkC,EAAE,oCAAoC,GAAG,0CAA0C,GAAG,uCAAuC,GAAG,wDAAwD,GAAG,yCAAyC,GAAG,sCAAsC,GAAG,6CAA6C,GAAG,gDAAgD,GAAG,yCAAyC,GAAG,gDAAgD,GAAG,oDAAoD,GAAG,aAAa,IAAI,GAAG,CAAC,SAASvhB,EAAQV,EAAOD,GkClkO3lB,IAAA2W,EAAAhW,EAAA,mCAEA2hB,EAAA,SAAAzM,GAEA,IAAA6L,EAAA7L,EAAA8F,cAAAnB,eAAA3E,EAAA6F,YAAA,gBACAiG,EAAA9L,EAAA8F,cAAAnB,eAAA3E,EAAA6F,YAAA,mBACAkG,EAAA/L,EAAA8F,cAAAnB,eAAA3E,EAAA6F,YAAA,sBAEAmG,EAAA,CAAA,EAIA,GAAA,UAFAlkB,QAAA+jB,GAIA,GAAAnL,MAAAC,QAAAkL,GAEA,IAAA,IAAAjjB,EAAA,EAAAA,EAAAijB,EAAA/lB,OAAA8C,IAEA,GAAA,WAAAd,QAAA+jB,EAAAjjB,IAEAoX,EAAAoG,QAAA,YAAAzH,OAAA/V,EAAA,uDAGA,CACA,IAAAggB,EAAAiD,EAAAjjB,GACAsjB,EAAAtD,EAAAkD,GACAlD,EAAAxiB,eAAA0lB,KAEA9L,EAAAoG,QAAA,YAAAzH,OAAA/V,EAAA,0CAAA+V,OAAAmN,EAAA,sCACAI,EAAA,cAGAtD,EAAAxiB,eAAA2lB,IAMAC,EAAA5lB,eAAA8lB,KAGAlM,EAAAoG,QAAA,yBAAAzH,OAAAuN,EAAA,mBAAAvN,OAAA/V,EAAA,OACAojB,EAAAE,GAAA,IAGAF,EAAAE,GAAA9V,KAAAwS,EAAAmD,KAXA/L,EAAAoG,QAAA,YAAAzH,OAAA/V,EAAA,6CAAA+V,OAAAoN,EAAA,gCAaA,MAMA,IADA,IAAAjD,EAAApjB,OAAA2b,KAAAwK,GACAjjB,EAAA,EAAAA,EAAAkgB,EAAAhjB,OAAA8C,IAEA,GAAA,WAAAd,QAAA+jB,EAAA/C,EAAAlgB,KAEAoX,EAAAoG,QAAA,YAAAzH,OAAA/V,EAAA,uDAGA,CACA,IAAAggB,EAAAiD,EAAA/C,EAAAlgB,IACAsjB,EAAAtD,EAAAkD,GACAlD,EAAAxiB,eAAA0lB,KAEA9L,EAAAoG,QAAA,YAAAzH,OAAAmK,EAAAlgB,GAAA,MAAA+V,OAAA/V,EAAA,0CAAA+V,OAAAmN,EAAA,sCACAI,EAAA,cAGAtD,EAAAxiB,eAAA2lB,IAMAC,EAAA5lB,eAAA8lB,KAGAlM,EAAAoG,QAAA,yBAAAzH,OAAAuN,EAAA,mBAAAvN,OAAAmK,EAAAlgB,GAAA,MAAA+V,OAAA/V,EAAA,OACAojB,EAAAE,GAAA,IAGAF,EAAAE,GAAA9V,KAAAwS,EAAAmD,KAXA/L,EAAAoG,QAAA,YAAAzH,OAAAmK,EAAAlgB,GAAA,MAAA+V,OAAA/V,EAAA,6CAAA+V,OAAAoN,EAAA,gCAaA,MAMA/L,EAAAiG,SAAA,+CAKA,OAFAjG,EAAAgG,eAAAiC,eAAAjI,EAAA+F,aAAA,gBAAAiG,IAEA,CACA,EAEAU,EAAA,SAAAC,GAAArmB,UAAAomB,EAAAC,GAAA,IAAAC,EAAAxlB,aAAAslB,GAEA,SAAAA,EAAApN,GACA,IAAAuN,EAEA,OAFAtkB,gBAAAtC,KAAAymB,IACAG,EAAAD,EAAAhnB,KAAAK,KAAAqZ,IACAE,UAAA,MAAAqN,CACA,CAiBA,OAjBA5jB,aAAAyjB,EAAA,CAAA,CAAA1jB,IAAA,yBAAAjD,MAEA,WAOA,OAJAf,KAAAqB,gBAAAqmB,EAAAvmB,WAAA,yBAAAF,MAAAL,KAAAK,MAEAA,KAAA8Z,eAAA,gBAAA0M,IAEA,CACA,GAAA,CAAAzjB,IAAA,uBAAAjD,MAEA,WAIA,OAFAE,KAAA2a,aAAA,gBAAA9V,EAAA,yCAEA,CACA,KAAA4hB,CAAA,CAvBA,CAAA5L,GA0BA1W,EAAAD,QAAAuiB,ClCwkOA,EAAE,CAAC,kCAAkC,EAAE,sCAAsC,KAAK,GAAG,CAAC,SAAS5hB,EAAQV,EAAOD,GmCpsO9G,IAAA2W,EAAAhW,EAAA,mCAEAyZ,EAAA,SAAAvE,GAEA,IAAA8M,EAAA9M,EAAA8F,cAAAnB,eAAA3E,EAAA6F,YAAA,eAIA,OAFA7F,EAAAgG,eAAAiC,eAAAjI,EAAA+F,aAAA,eAAA+G,EAAAvI,SAEA,CACA,EAEAzI,EAAA,SAAAkE,GAEA,IAAA8M,EAAA9M,EAAA8F,cAAAnB,eAAA3E,EAAA6F,YAAA,eACAkH,EAAA/M,EAAA8F,cAAAnB,eAAA3E,EAAA6F,YAAA,aACAmH,EAAAhN,EAAA8F,cAAAnB,eAAA3E,EAAA6F,YAAA,eAIA,OAFA7F,EAAAgG,eAAAiC,eAAAjI,EAAA+F,aAAA,eAAA+G,EAAAhR,QAAAiR,EAAAC,KAEA,CACA,EAEAhR,EAAA,SAAAgE,GAEA,IAAA8M,EAAA9M,EAAA8F,cAAAnB,eAAA3E,EAAA6F,YAAA,eACAkF,EAAA/K,EAAA8F,cAAAnB,eAAA3E,EAAA6F,YAAA,cACAmF,EAAAhL,EAAA8F,cAAAnB,eAAA3E,EAAA6F,YAAA,YAWA,OATA,MAAAmF,EAEAhL,EAAAgG,eAAAiC,eAAAjI,EAAA+F,aAAA,eAAA+G,EAAA9Q,UAAA+O,EAAAC,IAIAhL,EAAAgG,eAAAiC,eAAAjI,EAAA+F,aAAA,eAAA+G,EAAA9Q,UAAA+O,KAGA,CACA,EAEAkC,EAAA,SAAAC,GAAA5mB,UAAA2mB,EAAAC,GAAA,IAAAC,EAAA/lB,aAAA6lB,GAEA,SAAAA,EAAA3N,GACA,IAAA8N,EAEA,OAFA7kB,gBAAAtC,KAAAgnB,IACAG,EAAAD,EAAAvnB,KAAAK,KAAAqZ,IACAE,UAAA,SAAA4N,CACA,CAkBA,OAlBAnkB,aAAAgkB,EAAA,CAAA,CAAAjkB,IAAA,yBAAAjD,MAEA,WAMA,OAJAE,KAAA8Z,eAAA,OAAAwE,GACAte,KAAA8Z,eAAA,UAAAjE,GACA7V,KAAA8Z,eAAA,YAAA/D,IAEA,CACA,GAAA,CAAAhT,IAAA,uBAAAjD,MAEA,WAMA,OAJAE,KAAA2a,aAAA,OAAA9V,EAAA,kCACA7E,KAAA2a,aAAA,UAAA9V,EAAA,qCACA7E,KAAA2a,aAAA,YAAA9V,EAAA,wCAEA,CACA,KAAAmiB,CAAA,CAxBA,CAAAnM,GA2BA1W,EAAAD,QAAA8iB,CnC0sOA,EAAE,CAAC,kCAAkC,EAAE,mCAAmC,GAAG,qCAAqC,GAAG,gCAAgC,MAAM,CAAC,EAAE,CAAC,GCjxO/J,CDixOmK,EACnK","file":"elucidator.compatible.min.js","sourcesContent":["(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.Elucidator = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\n;(function (globalScope) {\r\n  'use strict';\r\n\r\n\r\n  /*!\r\n   *  decimal.js v10.4.3\r\n   *  An arbitrary-precision Decimal type for JavaScript.\r\n   *  https://github.com/MikeMcl/decimal.js\r\n   *  Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>\r\n   *  MIT Licence\r\n   */\r\n\r\n\r\n  // -----------------------------------  EDITABLE DEFAULTS  ------------------------------------ //\r\n\r\n\r\n    // The maximum exponent magnitude.\r\n    // The limit on the value of `toExpNeg`, `toExpPos`, `minE` and `maxE`.\r\n  var EXP_LIMIT = 9e15,                      // 0 to 9e15\r\n\r\n    // The limit on the value of `precision`, and on the value of the first argument to\r\n    // `toDecimalPlaces`, `toExponential`, `toFixed`, `toPrecision` and `toSignificantDigits`.\r\n    MAX_DIGITS = 1e9,                        // 0 to 1e9\r\n\r\n    // Base conversion alphabet.\r\n    NUMERALS = '0123456789abcdef',\r\n\r\n    // The natural logarithm of 10 (1025 digits).\r\n    LN10 = '2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058',\r\n\r\n    // Pi (1025 digits).\r\n    PI = '3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789',\r\n\r\n\r\n    // The initial configuration properties of the Decimal constructor.\r\n    DEFAULTS = {\r\n\r\n      // These values must be integers within the stated ranges (inclusive).\r\n      // Most of these values can be changed at run-time using the `Decimal.config` method.\r\n\r\n      // The maximum number of significant digits of the result of a calculation or base conversion.\r\n      // E.g. `Decimal.config({ precision: 20 });`\r\n      precision: 20,                         // 1 to MAX_DIGITS\r\n\r\n      // The rounding mode used when rounding to `precision`.\r\n      //\r\n      // ROUND_UP         0 Away from zero.\r\n      // ROUND_DOWN       1 Towards zero.\r\n      // ROUND_CEIL       2 Towards +Infinity.\r\n      // ROUND_FLOOR      3 Towards -Infinity.\r\n      // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.\r\n      // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.\r\n      // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.\r\n      // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.\r\n      // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.\r\n      //\r\n      // E.g.\r\n      // `Decimal.rounding = 4;`\r\n      // `Decimal.rounding = Decimal.ROUND_HALF_UP;`\r\n      rounding: 4,                           // 0 to 8\r\n\r\n      // The modulo mode used when calculating the modulus: a mod n.\r\n      // The quotient (q = a / n) is calculated according to the corresponding rounding mode.\r\n      // The remainder (r) is calculated as: r = a - n * q.\r\n      //\r\n      // UP         0 The remainder is positive if the dividend is negative, else is negative.\r\n      // DOWN       1 The remainder has the same sign as the dividend (JavaScript %).\r\n      // FLOOR      3 The remainder has the same sign as the divisor (Python %).\r\n      // HALF_EVEN  6 The IEEE 754 remainder function.\r\n      // EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.\r\n      //\r\n      // Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian\r\n      // division (9) are commonly used for the modulus operation. The other rounding modes can also\r\n      // be used, but they may not give useful results.\r\n      modulo: 1,                             // 0 to 9\r\n\r\n      // The exponent value at and beneath which `toString` returns exponential notation.\r\n      // JavaScript numbers: -7\r\n      toExpNeg: -7,                          // 0 to -EXP_LIMIT\r\n\r\n      // The exponent value at and above which `toString` returns exponential notation.\r\n      // JavaScript numbers: 21\r\n      toExpPos:  21,                         // 0 to EXP_LIMIT\r\n\r\n      // The minimum exponent value, beneath which underflow to zero occurs.\r\n      // JavaScript numbers: -324  (5e-324)\r\n      minE: -EXP_LIMIT,                      // -1 to -EXP_LIMIT\r\n\r\n      // The maximum exponent value, above which overflow to Infinity occurs.\r\n      // JavaScript numbers: 308  (1.7976931348623157e+308)\r\n      maxE: EXP_LIMIT,                       // 1 to EXP_LIMIT\r\n\r\n      // Whether to use cryptographically-secure random number generation, if available.\r\n      crypto: false                          // true/false\r\n    },\r\n\r\n\r\n  // ----------------------------------- END OF EDITABLE DEFAULTS ------------------------------- //\r\n\r\n\r\n    Decimal, inexact, noConflict, quadrant,\r\n    external = true,\r\n\r\n    decimalError = '[DecimalError] ',\r\n    invalidArgument = decimalError + 'Invalid argument: ',\r\n    precisionLimitExceeded = decimalError + 'Precision limit exceeded',\r\n    cryptoUnavailable = decimalError + 'crypto unavailable',\r\n    tag = '[object Decimal]',\r\n\r\n    mathfloor = Math.floor,\r\n    mathpow = Math.pow,\r\n\r\n    isBinary = /^0b([01]+(\\.[01]*)?|\\.[01]+)(p[+-]?\\d+)?$/i,\r\n    isHex = /^0x([0-9a-f]+(\\.[0-9a-f]*)?|\\.[0-9a-f]+)(p[+-]?\\d+)?$/i,\r\n    isOctal = /^0o([0-7]+(\\.[0-7]*)?|\\.[0-7]+)(p[+-]?\\d+)?$/i,\r\n    isDecimal = /^(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?$/i,\r\n\r\n    BASE = 1e7,\r\n    LOG_BASE = 7,\r\n    MAX_SAFE_INTEGER = 9007199254740991,\r\n\r\n    LN10_PRECISION = LN10.length - 1,\r\n    PI_PRECISION = PI.length - 1,\r\n\r\n    // Decimal.prototype object\r\n    P = { toStringTag: tag };\r\n\r\n\r\n  // Decimal prototype methods\r\n\r\n\r\n  /*\r\n   *  absoluteValue             abs\r\n   *  ceil\r\n   *  clampedTo                 clamp\r\n   *  comparedTo                cmp\r\n   *  cosine                    cos\r\n   *  cubeRoot                  cbrt\r\n   *  decimalPlaces             dp\r\n   *  dividedBy                 div\r\n   *  dividedToIntegerBy        divToInt\r\n   *  equals                    eq\r\n   *  floor\r\n   *  greaterThan               gt\r\n   *  greaterThanOrEqualTo      gte\r\n   *  hyperbolicCosine          cosh\r\n   *  hyperbolicSine            sinh\r\n   *  hyperbolicTangent         tanh\r\n   *  inverseCosine             acos\r\n   *  inverseHyperbolicCosine   acosh\r\n   *  inverseHyperbolicSine     asinh\r\n   *  inverseHyperbolicTangent  atanh\r\n   *  inverseSine               asin\r\n   *  inverseTangent            atan\r\n   *  isFinite\r\n   *  isInteger                 isInt\r\n   *  isNaN\r\n   *  isNegative                isNeg\r\n   *  isPositive                isPos\r\n   *  isZero\r\n   *  lessThan                  lt\r\n   *  lessThanOrEqualTo         lte\r\n   *  logarithm                 log\r\n   *  [maximum]                 [max]\r\n   *  [minimum]                 [min]\r\n   *  minus                     sub\r\n   *  modulo                    mod\r\n   *  naturalExponential        exp\r\n   *  naturalLogarithm          ln\r\n   *  negated                   neg\r\n   *  plus                      add\r\n   *  precision                 sd\r\n   *  round\r\n   *  sine                      sin\r\n   *  squareRoot                sqrt\r\n   *  tangent                   tan\r\n   *  times                     mul\r\n   *  toBinary\r\n   *  toDecimalPlaces           toDP\r\n   *  toExponential\r\n   *  toFixed\r\n   *  toFraction\r\n   *  toHexadecimal             toHex\r\n   *  toNearest\r\n   *  toNumber\r\n   *  toOctal\r\n   *  toPower                   pow\r\n   *  toPrecision\r\n   *  toSignificantDigits       toSD\r\n   *  toString\r\n   *  truncated                 trunc\r\n   *  valueOf                   toJSON\r\n   */\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the absolute value of this Decimal.\r\n   *\r\n   */\r\n  P.absoluteValue = P.abs = function () {\r\n    var x = new this.constructor(this);\r\n    if (x.s < 0) x.s = 1;\r\n    return finalise(x);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal rounded to a whole number in the\r\n   * direction of positive Infinity.\r\n   *\r\n   */\r\n  P.ceil = function () {\r\n    return finalise(new this.constructor(this), this.e + 1, 2);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal clamped to the range\r\n   * delineated by `min` and `max`.\r\n   *\r\n   * min {number|string|Decimal}\r\n   * max {number|string|Decimal}\r\n   *\r\n   */\r\n  P.clampedTo = P.clamp = function (min, max) {\r\n    var k,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n    min = new Ctor(min);\r\n    max = new Ctor(max);\r\n    if (!min.s || !max.s) return new Ctor(NaN);\r\n    if (min.gt(max)) throw Error(invalidArgument + max);\r\n    k = x.cmp(min);\r\n    return k < 0 ? min : x.cmp(max) > 0 ? max : new Ctor(x);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return\r\n   *   1    if the value of this Decimal is greater than the value of `y`,\r\n   *  -1    if the value of this Decimal is less than the value of `y`,\r\n   *   0    if they have the same value,\r\n   *   NaN  if the value of either Decimal is NaN.\r\n   *\r\n   */\r\n  P.comparedTo = P.cmp = function (y) {\r\n    var i, j, xdL, ydL,\r\n      x = this,\r\n      xd = x.d,\r\n      yd = (y = new x.constructor(y)).d,\r\n      xs = x.s,\r\n      ys = y.s;\r\n\r\n    // Either NaN or ±Infinity?\r\n    if (!xd || !yd) {\r\n      return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;\r\n    }\r\n\r\n    // Either zero?\r\n    if (!xd[0] || !yd[0]) return xd[0] ? xs : yd[0] ? -ys : 0;\r\n\r\n    // Signs differ?\r\n    if (xs !== ys) return xs;\r\n\r\n    // Compare exponents.\r\n    if (x.e !== y.e) return x.e > y.e ^ xs < 0 ? 1 : -1;\r\n\r\n    xdL = xd.length;\r\n    ydL = yd.length;\r\n\r\n    // Compare digit by digit.\r\n    for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) {\r\n      if (xd[i] !== yd[i]) return xd[i] > yd[i] ^ xs < 0 ? 1 : -1;\r\n    }\r\n\r\n    // Compare lengths.\r\n    return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the cosine of the value in radians of this Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-1, 1]\r\n   *\r\n   * cos(0)         = 1\r\n   * cos(-0)        = 1\r\n   * cos(Infinity)  = NaN\r\n   * cos(-Infinity) = NaN\r\n   * cos(NaN)       = NaN\r\n   *\r\n   */\r\n  P.cosine = P.cos = function () {\r\n    var pr, rm,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (!x.d) return new Ctor(NaN);\r\n\r\n    // cos(0) = cos(-0) = 1\r\n    if (!x.d[0]) return new Ctor(1);\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n    Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;\r\n    Ctor.rounding = 1;\r\n\r\n    x = cosine(Ctor, toLessThanHalfPi(Ctor, x));\r\n\r\n    Ctor.precision = pr;\r\n    Ctor.rounding = rm;\r\n\r\n    return finalise(quadrant == 2 || quadrant == 3 ? x.neg() : x, pr, rm, true);\r\n  };\r\n\r\n\r\n  /*\r\n   *\r\n   * Return a new Decimal whose value is the cube root of the value of this Decimal, rounded to\r\n   * `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   *  cbrt(0)  =  0\r\n   *  cbrt(-0) = -0\r\n   *  cbrt(1)  =  1\r\n   *  cbrt(-1) = -1\r\n   *  cbrt(N)  =  N\r\n   *  cbrt(-I) = -I\r\n   *  cbrt(I)  =  I\r\n   *\r\n   * Math.cbrt(x) = (x < 0 ? -Math.pow(-x, 1/3) : Math.pow(x, 1/3))\r\n   *\r\n   */\r\n  P.cubeRoot = P.cbrt = function () {\r\n    var e, m, n, r, rep, s, sd, t, t3, t3plusx,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (!x.isFinite() || x.isZero()) return new Ctor(x);\r\n    external = false;\r\n\r\n    // Initial estimate.\r\n    s = x.s * mathpow(x.s * x, 1 / 3);\r\n\r\n     // Math.cbrt underflow/overflow?\r\n     // Pass x to Math.pow as integer, then adjust the exponent of the result.\r\n    if (!s || Math.abs(s) == 1 / 0) {\r\n      n = digitsToString(x.d);\r\n      e = x.e;\r\n\r\n      // Adjust n exponent so it is a multiple of 3 away from x exponent.\r\n      if (s = (e - n.length + 1) % 3) n += (s == 1 || s == -2 ? '0' : '00');\r\n      s = mathpow(n, 1 / 3);\r\n\r\n      // Rarely, e may be one less than the result exponent value.\r\n      e = mathfloor((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2));\r\n\r\n      if (s == 1 / 0) {\r\n        n = '5e' + e;\r\n      } else {\r\n        n = s.toExponential();\r\n        n = n.slice(0, n.indexOf('e') + 1) + e;\r\n      }\r\n\r\n      r = new Ctor(n);\r\n      r.s = x.s;\r\n    } else {\r\n      r = new Ctor(s.toString());\r\n    }\r\n\r\n    sd = (e = Ctor.precision) + 3;\r\n\r\n    // Halley's method.\r\n    // TODO? Compare Newton's method.\r\n    for (;;) {\r\n      t = r;\r\n      t3 = t.times(t).times(t);\r\n      t3plusx = t3.plus(x);\r\n      r = divide(t3plusx.plus(x).times(t), t3plusx.plus(t3), sd + 2, 1);\r\n\r\n      // TODO? Replace with for-loop and checkRoundingDigits.\r\n      if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {\r\n        n = n.slice(sd - 3, sd + 1);\r\n\r\n        // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or 4999\r\n        // , i.e. approaching a rounding boundary, continue the iteration.\r\n        if (n == '9999' || !rep && n == '4999') {\r\n\r\n          // On the first iteration only, check to see if rounding up gives the exact result as the\r\n          // nines may infinitely repeat.\r\n          if (!rep) {\r\n            finalise(t, e + 1, 0);\r\n\r\n            if (t.times(t).times(t).eq(x)) {\r\n              r = t;\r\n              break;\r\n            }\r\n          }\r\n\r\n          sd += 4;\r\n          rep = 1;\r\n        } else {\r\n\r\n          // If the rounding digits are null, 0{0,4} or 50{0,3}, check for an exact result.\r\n          // If not, then there are further digits and m will be truthy.\r\n          if (!+n || !+n.slice(1) && n.charAt(0) == '5') {\r\n\r\n            // Truncate to the first rounding digit.\r\n            finalise(r, e + 1, 1);\r\n            m = !r.times(r).times(r).eq(x);\r\n          }\r\n\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    external = true;\r\n\r\n    return finalise(r, e, Ctor.rounding, m);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return the number of decimal places of the value of this Decimal.\r\n   *\r\n   */\r\n  P.decimalPlaces = P.dp = function () {\r\n    var w,\r\n      d = this.d,\r\n      n = NaN;\r\n\r\n    if (d) {\r\n      w = d.length - 1;\r\n      n = (w - mathfloor(this.e / LOG_BASE)) * LOG_BASE;\r\n\r\n      // Subtract the number of trailing zeros of the last word.\r\n      w = d[w];\r\n      if (w) for (; w % 10 == 0; w /= 10) n--;\r\n      if (n < 0) n = 0;\r\n    }\r\n\r\n    return n;\r\n  };\r\n\r\n\r\n  /*\r\n   *  n / 0 = I\r\n   *  n / N = N\r\n   *  n / I = 0\r\n   *  0 / n = 0\r\n   *  0 / 0 = N\r\n   *  0 / N = N\r\n   *  0 / I = 0\r\n   *  N / n = N\r\n   *  N / 0 = N\r\n   *  N / N = N\r\n   *  N / I = N\r\n   *  I / n = I\r\n   *  I / 0 = I\r\n   *  I / N = N\r\n   *  I / I = N\r\n   *\r\n   * Return a new Decimal whose value is the value of this Decimal divided by `y`, rounded to\r\n   * `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   */\r\n  P.dividedBy = P.div = function (y) {\r\n    return divide(this, new this.constructor(y));\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the integer part of dividing the value of this Decimal\r\n   * by the value of `y`, rounded to `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   */\r\n  P.dividedToIntegerBy = P.divToInt = function (y) {\r\n    var x = this,\r\n      Ctor = x.constructor;\r\n    return finalise(divide(x, new Ctor(y), 0, 1, 1), Ctor.precision, Ctor.rounding);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is equal to the value of `y`, otherwise return false.\r\n   *\r\n   */\r\n  P.equals = P.eq = function (y) {\r\n    return this.cmp(y) === 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal rounded to a whole number in the\r\n   * direction of negative Infinity.\r\n   *\r\n   */\r\n  P.floor = function () {\r\n    return finalise(new this.constructor(this), this.e + 1, 3);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is greater than the value of `y`, otherwise return\r\n   * false.\r\n   *\r\n   */\r\n  P.greaterThan = P.gt = function (y) {\r\n    return this.cmp(y) > 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is greater than or equal to the value of `y`,\r\n   * otherwise return false.\r\n   *\r\n   */\r\n  P.greaterThanOrEqualTo = P.gte = function (y) {\r\n    var k = this.cmp(y);\r\n    return k == 1 || k === 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the hyperbolic cosine of the value in radians of this\r\n   * Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [1, Infinity]\r\n   *\r\n   * cosh(x) = 1 + x^2/2! + x^4/4! + x^6/6! + ...\r\n   *\r\n   * cosh(0)         = 1\r\n   * cosh(-0)        = 1\r\n   * cosh(Infinity)  = Infinity\r\n   * cosh(-Infinity) = Infinity\r\n   * cosh(NaN)       = NaN\r\n   *\r\n   *  x        time taken (ms)   result\r\n   * 1000      9                 9.8503555700852349694e+433\r\n   * 10000     25                4.4034091128314607936e+4342\r\n   * 100000    171               1.4033316802130615897e+43429\r\n   * 1000000   3817              1.5166076984010437725e+434294\r\n   * 10000000  abandoned after 2 minute wait\r\n   *\r\n   * TODO? Compare performance of cosh(x) = 0.5 * (exp(x) + exp(-x))\r\n   *\r\n   */\r\n  P.hyperbolicCosine = P.cosh = function () {\r\n    var k, n, pr, rm, len,\r\n      x = this,\r\n      Ctor = x.constructor,\r\n      one = new Ctor(1);\r\n\r\n    if (!x.isFinite()) return new Ctor(x.s ? 1 / 0 : NaN);\r\n    if (x.isZero()) return one;\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n    Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;\r\n    Ctor.rounding = 1;\r\n    len = x.d.length;\r\n\r\n    // Argument reduction: cos(4x) = 1 - 8cos^2(x) + 8cos^4(x) + 1\r\n    // i.e. cos(x) = 1 - cos^2(x/4)(8 - 8cos^2(x/4))\r\n\r\n    // Estimate the optimum number of times to use the argument reduction.\r\n    // TODO? Estimation reused from cosine() and may not be optimal here.\r\n    if (len < 32) {\r\n      k = Math.ceil(len / 3);\r\n      n = (1 / tinyPow(4, k)).toString();\r\n    } else {\r\n      k = 16;\r\n      n = '2.3283064365386962890625e-10';\r\n    }\r\n\r\n    x = taylorSeries(Ctor, 1, x.times(n), new Ctor(1), true);\r\n\r\n    // Reverse argument reduction\r\n    var cosh2_x,\r\n      i = k,\r\n      d8 = new Ctor(8);\r\n    for (; i--;) {\r\n      cosh2_x = x.times(x);\r\n      x = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));\r\n    }\r\n\r\n    return finalise(x, Ctor.precision = pr, Ctor.rounding = rm, true);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the hyperbolic sine of the value in radians of this\r\n   * Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-Infinity, Infinity]\r\n   *\r\n   * sinh(x) = x + x^3/3! + x^5/5! + x^7/7! + ...\r\n   *\r\n   * sinh(0)         = 0\r\n   * sinh(-0)        = -0\r\n   * sinh(Infinity)  = Infinity\r\n   * sinh(-Infinity) = -Infinity\r\n   * sinh(NaN)       = NaN\r\n   *\r\n   * x        time taken (ms)\r\n   * 10       2 ms\r\n   * 100      5 ms\r\n   * 1000     14 ms\r\n   * 10000    82 ms\r\n   * 100000   886 ms            1.4033316802130615897e+43429\r\n   * 200000   2613 ms\r\n   * 300000   5407 ms\r\n   * 400000   8824 ms\r\n   * 500000   13026 ms          8.7080643612718084129e+217146\r\n   * 1000000  48543 ms\r\n   *\r\n   * TODO? Compare performance of sinh(x) = 0.5 * (exp(x) - exp(-x))\r\n   *\r\n   */\r\n  P.hyperbolicSine = P.sinh = function () {\r\n    var k, pr, rm, len,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (!x.isFinite() || x.isZero()) return new Ctor(x);\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n    Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;\r\n    Ctor.rounding = 1;\r\n    len = x.d.length;\r\n\r\n    if (len < 3) {\r\n      x = taylorSeries(Ctor, 2, x, x, true);\r\n    } else {\r\n\r\n      // Alternative argument reduction: sinh(3x) = sinh(x)(3 + 4sinh^2(x))\r\n      // i.e. sinh(x) = sinh(x/3)(3 + 4sinh^2(x/3))\r\n      // 3 multiplications and 1 addition\r\n\r\n      // Argument reduction: sinh(5x) = sinh(x)(5 + sinh^2(x)(20 + 16sinh^2(x)))\r\n      // i.e. sinh(x) = sinh(x/5)(5 + sinh^2(x/5)(20 + 16sinh^2(x/5)))\r\n      // 4 multiplications and 2 additions\r\n\r\n      // Estimate the optimum number of times to use the argument reduction.\r\n      k = 1.4 * Math.sqrt(len);\r\n      k = k > 16 ? 16 : k | 0;\r\n\r\n      x = x.times(1 / tinyPow(5, k));\r\n      x = taylorSeries(Ctor, 2, x, x, true);\r\n\r\n      // Reverse argument reduction\r\n      var sinh2_x,\r\n        d5 = new Ctor(5),\r\n        d16 = new Ctor(16),\r\n        d20 = new Ctor(20);\r\n      for (; k--;) {\r\n        sinh2_x = x.times(x);\r\n        x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));\r\n      }\r\n    }\r\n\r\n    Ctor.precision = pr;\r\n    Ctor.rounding = rm;\r\n\r\n    return finalise(x, pr, rm, true);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the hyperbolic tangent of the value in radians of this\r\n   * Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-1, 1]\r\n   *\r\n   * tanh(x) = sinh(x) / cosh(x)\r\n   *\r\n   * tanh(0)         = 0\r\n   * tanh(-0)        = -0\r\n   * tanh(Infinity)  = 1\r\n   * tanh(-Infinity) = -1\r\n   * tanh(NaN)       = NaN\r\n   *\r\n   */\r\n  P.hyperbolicTangent = P.tanh = function () {\r\n    var pr, rm,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (!x.isFinite()) return new Ctor(x.s);\r\n    if (x.isZero()) return new Ctor(x);\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n    Ctor.precision = pr + 7;\r\n    Ctor.rounding = 1;\r\n\r\n    return divide(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the arccosine (inverse cosine) in radians of the value of\r\n   * this Decimal.\r\n   *\r\n   * Domain: [-1, 1]\r\n   * Range: [0, pi]\r\n   *\r\n   * acos(x) = pi/2 - asin(x)\r\n   *\r\n   * acos(0)       = pi/2\r\n   * acos(-0)      = pi/2\r\n   * acos(1)       = 0\r\n   * acos(-1)      = pi\r\n   * acos(1/2)     = pi/3\r\n   * acos(-1/2)    = 2*pi/3\r\n   * acos(|x| > 1) = NaN\r\n   * acos(NaN)     = NaN\r\n   *\r\n   */\r\n  P.inverseCosine = P.acos = function () {\r\n    var halfPi,\r\n      x = this,\r\n      Ctor = x.constructor,\r\n      k = x.abs().cmp(1),\r\n      pr = Ctor.precision,\r\n      rm = Ctor.rounding;\r\n\r\n    if (k !== -1) {\r\n      return k === 0\r\n        // |x| is 1\r\n        ? x.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0)\r\n        // |x| > 1 or x is NaN\r\n        : new Ctor(NaN);\r\n    }\r\n\r\n    if (x.isZero()) return getPi(Ctor, pr + 4, rm).times(0.5);\r\n\r\n    // TODO? Special case acos(0.5) = pi/3 and acos(-0.5) = 2*pi/3\r\n\r\n    Ctor.precision = pr + 6;\r\n    Ctor.rounding = 1;\r\n\r\n    x = x.asin();\r\n    halfPi = getPi(Ctor, pr + 4, rm).times(0.5);\r\n\r\n    Ctor.precision = pr;\r\n    Ctor.rounding = rm;\r\n\r\n    return halfPi.minus(x);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the inverse of the hyperbolic cosine in radians of the\r\n   * value of this Decimal.\r\n   *\r\n   * Domain: [1, Infinity]\r\n   * Range: [0, Infinity]\r\n   *\r\n   * acosh(x) = ln(x + sqrt(x^2 - 1))\r\n   *\r\n   * acosh(x < 1)     = NaN\r\n   * acosh(NaN)       = NaN\r\n   * acosh(Infinity)  = Infinity\r\n   * acosh(-Infinity) = NaN\r\n   * acosh(0)         = NaN\r\n   * acosh(-0)        = NaN\r\n   * acosh(1)         = 0\r\n   * acosh(-1)        = NaN\r\n   *\r\n   */\r\n  P.inverseHyperbolicCosine = P.acosh = function () {\r\n    var pr, rm,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (x.lte(1)) return new Ctor(x.eq(1) ? 0 : NaN);\r\n    if (!x.isFinite()) return new Ctor(x);\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n    Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;\r\n    Ctor.rounding = 1;\r\n    external = false;\r\n\r\n    x = x.times(x).minus(1).sqrt().plus(x);\r\n\r\n    external = true;\r\n    Ctor.precision = pr;\r\n    Ctor.rounding = rm;\r\n\r\n    return x.ln();\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the inverse of the hyperbolic sine in radians of the value\r\n   * of this Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-Infinity, Infinity]\r\n   *\r\n   * asinh(x) = ln(x + sqrt(x^2 + 1))\r\n   *\r\n   * asinh(NaN)       = NaN\r\n   * asinh(Infinity)  = Infinity\r\n   * asinh(-Infinity) = -Infinity\r\n   * asinh(0)         = 0\r\n   * asinh(-0)        = -0\r\n   *\r\n   */\r\n  P.inverseHyperbolicSine = P.asinh = function () {\r\n    var pr, rm,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (!x.isFinite() || x.isZero()) return new Ctor(x);\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n    Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6;\r\n    Ctor.rounding = 1;\r\n    external = false;\r\n\r\n    x = x.times(x).plus(1).sqrt().plus(x);\r\n\r\n    external = true;\r\n    Ctor.precision = pr;\r\n    Ctor.rounding = rm;\r\n\r\n    return x.ln();\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the inverse of the hyperbolic tangent in radians of the\r\n   * value of this Decimal.\r\n   *\r\n   * Domain: [-1, 1]\r\n   * Range: [-Infinity, Infinity]\r\n   *\r\n   * atanh(x) = 0.5 * ln((1 + x) / (1 - x))\r\n   *\r\n   * atanh(|x| > 1)   = NaN\r\n   * atanh(NaN)       = NaN\r\n   * atanh(Infinity)  = NaN\r\n   * atanh(-Infinity) = NaN\r\n   * atanh(0)         = 0\r\n   * atanh(-0)        = -0\r\n   * atanh(1)         = Infinity\r\n   * atanh(-1)        = -Infinity\r\n   *\r\n   */\r\n  P.inverseHyperbolicTangent = P.atanh = function () {\r\n    var pr, rm, wpr, xsd,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (!x.isFinite()) return new Ctor(NaN);\r\n    if (x.e >= 0) return new Ctor(x.abs().eq(1) ? x.s / 0 : x.isZero() ? x : NaN);\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n    xsd = x.sd();\r\n\r\n    if (Math.max(xsd, pr) < 2 * -x.e - 1) return finalise(new Ctor(x), pr, rm, true);\r\n\r\n    Ctor.precision = wpr = xsd - x.e;\r\n\r\n    x = divide(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1);\r\n\r\n    Ctor.precision = pr + 4;\r\n    Ctor.rounding = 1;\r\n\r\n    x = x.ln();\r\n\r\n    Ctor.precision = pr;\r\n    Ctor.rounding = rm;\r\n\r\n    return x.times(0.5);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the arcsine (inverse sine) in radians of the value of this\r\n   * Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-pi/2, pi/2]\r\n   *\r\n   * asin(x) = 2*atan(x/(1 + sqrt(1 - x^2)))\r\n   *\r\n   * asin(0)       = 0\r\n   * asin(-0)      = -0\r\n   * asin(1/2)     = pi/6\r\n   * asin(-1/2)    = -pi/6\r\n   * asin(1)       = pi/2\r\n   * asin(-1)      = -pi/2\r\n   * asin(|x| > 1) = NaN\r\n   * asin(NaN)     = NaN\r\n   *\r\n   * TODO? Compare performance of Taylor series.\r\n   *\r\n   */\r\n  P.inverseSine = P.asin = function () {\r\n    var halfPi, k,\r\n      pr, rm,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (x.isZero()) return new Ctor(x);\r\n\r\n    k = x.abs().cmp(1);\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n\r\n    if (k !== -1) {\r\n\r\n      // |x| is 1\r\n      if (k === 0) {\r\n        halfPi = getPi(Ctor, pr + 4, rm).times(0.5);\r\n        halfPi.s = x.s;\r\n        return halfPi;\r\n      }\r\n\r\n      // |x| > 1 or x is NaN\r\n      return new Ctor(NaN);\r\n    }\r\n\r\n    // TODO? Special case asin(1/2) = pi/6 and asin(-1/2) = -pi/6\r\n\r\n    Ctor.precision = pr + 6;\r\n    Ctor.rounding = 1;\r\n\r\n    x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan();\r\n\r\n    Ctor.precision = pr;\r\n    Ctor.rounding = rm;\r\n\r\n    return x.times(2);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the arctangent (inverse tangent) in radians of the value\r\n   * of this Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-pi/2, pi/2]\r\n   *\r\n   * atan(x) = x - x^3/3 + x^5/5 - x^7/7 + ...\r\n   *\r\n   * atan(0)         = 0\r\n   * atan(-0)        = -0\r\n   * atan(1)         = pi/4\r\n   * atan(-1)        = -pi/4\r\n   * atan(Infinity)  = pi/2\r\n   * atan(-Infinity) = -pi/2\r\n   * atan(NaN)       = NaN\r\n   *\r\n   */\r\n  P.inverseTangent = P.atan = function () {\r\n    var i, j, k, n, px, t, r, wpr, x2,\r\n      x = this,\r\n      Ctor = x.constructor,\r\n      pr = Ctor.precision,\r\n      rm = Ctor.rounding;\r\n\r\n    if (!x.isFinite()) {\r\n      if (!x.s) return new Ctor(NaN);\r\n      if (pr + 4 <= PI_PRECISION) {\r\n        r = getPi(Ctor, pr + 4, rm).times(0.5);\r\n        r.s = x.s;\r\n        return r;\r\n      }\r\n    } else if (x.isZero()) {\r\n      return new Ctor(x);\r\n    } else if (x.abs().eq(1) && pr + 4 <= PI_PRECISION) {\r\n      r = getPi(Ctor, pr + 4, rm).times(0.25);\r\n      r.s = x.s;\r\n      return r;\r\n    }\r\n\r\n    Ctor.precision = wpr = pr + 10;\r\n    Ctor.rounding = 1;\r\n\r\n    // TODO? if (x >= 1 && pr <= PI_PRECISION) atan(x) = halfPi * x.s - atan(1 / x);\r\n\r\n    // Argument reduction\r\n    // Ensure |x| < 0.42\r\n    // atan(x) = 2 * atan(x / (1 + sqrt(1 + x^2)))\r\n\r\n    k = Math.min(28, wpr / LOG_BASE + 2 | 0);\r\n\r\n    for (i = k; i; --i) x = x.div(x.times(x).plus(1).sqrt().plus(1));\r\n\r\n    external = false;\r\n\r\n    j = Math.ceil(wpr / LOG_BASE);\r\n    n = 1;\r\n    x2 = x.times(x);\r\n    r = new Ctor(x);\r\n    px = x;\r\n\r\n    // atan(x) = x - x^3/3 + x^5/5 - x^7/7 + ...\r\n    for (; i !== -1;) {\r\n      px = px.times(x2);\r\n      t = r.minus(px.div(n += 2));\r\n\r\n      px = px.times(x2);\r\n      r = t.plus(px.div(n += 2));\r\n\r\n      if (r.d[j] !== void 0) for (i = j; r.d[i] === t.d[i] && i--;);\r\n    }\r\n\r\n    if (k) r = r.times(2 << (k - 1));\r\n\r\n    external = true;\r\n\r\n    return finalise(r, Ctor.precision = pr, Ctor.rounding = rm, true);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is a finite number, otherwise return false.\r\n   *\r\n   */\r\n  P.isFinite = function () {\r\n    return !!this.d;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is an integer, otherwise return false.\r\n   *\r\n   */\r\n  P.isInteger = P.isInt = function () {\r\n    return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is NaN, otherwise return false.\r\n   *\r\n   */\r\n  P.isNaN = function () {\r\n    return !this.s;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is negative, otherwise return false.\r\n   *\r\n   */\r\n  P.isNegative = P.isNeg = function () {\r\n    return this.s < 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is positive, otherwise return false.\r\n   *\r\n   */\r\n  P.isPositive = P.isPos = function () {\r\n    return this.s > 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is 0 or -0, otherwise return false.\r\n   *\r\n   */\r\n  P.isZero = function () {\r\n    return !!this.d && this.d[0] === 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is less than `y`, otherwise return false.\r\n   *\r\n   */\r\n  P.lessThan = P.lt = function (y) {\r\n    return this.cmp(y) < 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is less than or equal to `y`, otherwise return false.\r\n   *\r\n   */\r\n  P.lessThanOrEqualTo = P.lte = function (y) {\r\n    return this.cmp(y) < 1;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return the logarithm of the value of this Decimal to the specified base, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * If no base is specified, return log[10](arg).\r\n   *\r\n   * log[base](arg) = ln(arg) / ln(base)\r\n   *\r\n   * The result will always be correctly rounded if the base of the log is 10, and 'almost always'\r\n   * otherwise:\r\n   *\r\n   * Depending on the rounding mode, the result may be incorrectly rounded if the first fifteen\r\n   * rounding digits are [49]99999999999999 or [50]00000000000000. In that case, the maximum error\r\n   * between the result and the correctly rounded result will be one ulp (unit in the last place).\r\n   *\r\n   * log[-b](a)       = NaN\r\n   * log[0](a)        = NaN\r\n   * log[1](a)        = NaN\r\n   * log[NaN](a)      = NaN\r\n   * log[Infinity](a) = NaN\r\n   * log[b](0)        = -Infinity\r\n   * log[b](-0)       = -Infinity\r\n   * log[b](-a)       = NaN\r\n   * log[b](1)        = 0\r\n   * log[b](Infinity) = Infinity\r\n   * log[b](NaN)      = NaN\r\n   *\r\n   * [base] {number|string|Decimal} The base of the logarithm.\r\n   *\r\n   */\r\n  P.logarithm = P.log = function (base) {\r\n    var isBase10, d, denominator, k, inf, num, sd, r,\r\n      arg = this,\r\n      Ctor = arg.constructor,\r\n      pr = Ctor.precision,\r\n      rm = Ctor.rounding,\r\n      guard = 5;\r\n\r\n    // Default base is 10.\r\n    if (base == null) {\r\n      base = new Ctor(10);\r\n      isBase10 = true;\r\n    } else {\r\n      base = new Ctor(base);\r\n      d = base.d;\r\n\r\n      // Return NaN if base is negative, or non-finite, or is 0 or 1.\r\n      if (base.s < 0 || !d || !d[0] || base.eq(1)) return new Ctor(NaN);\r\n\r\n      isBase10 = base.eq(10);\r\n    }\r\n\r\n    d = arg.d;\r\n\r\n    // Is arg negative, non-finite, 0 or 1?\r\n    if (arg.s < 0 || !d || !d[0] || arg.eq(1)) {\r\n      return new Ctor(d && !d[0] ? -1 / 0 : arg.s != 1 ? NaN : d ? 0 : 1 / 0);\r\n    }\r\n\r\n    // The result will have a non-terminating decimal expansion if base is 10 and arg is not an\r\n    // integer power of 10.\r\n    if (isBase10) {\r\n      if (d.length > 1) {\r\n        inf = true;\r\n      } else {\r\n        for (k = d[0]; k % 10 === 0;) k /= 10;\r\n        inf = k !== 1;\r\n      }\r\n    }\r\n\r\n    external = false;\r\n    sd = pr + guard;\r\n    num = naturalLogarithm(arg, sd);\r\n    denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);\r\n\r\n    // The result will have 5 rounding digits.\r\n    r = divide(num, denominator, sd, 1);\r\n\r\n    // If at a rounding boundary, i.e. the result's rounding digits are [49]9999 or [50]0000,\r\n    // calculate 10 further digits.\r\n    //\r\n    // If the result is known to have an infinite decimal expansion, repeat this until it is clear\r\n    // that the result is above or below the boundary. Otherwise, if after calculating the 10\r\n    // further digits, the last 14 are nines, round up and assume the result is exact.\r\n    // Also assume the result is exact if the last 14 are zero.\r\n    //\r\n    // Example of a result that will be incorrectly rounded:\r\n    // log[1048576](4503599627370502) = 2.60000000000000009610279511444746...\r\n    // The above result correctly rounded using ROUND_CEIL to 1 decimal place should be 2.7, but it\r\n    // will be given as 2.6 as there are 15 zeros immediately after the requested decimal place, so\r\n    // the exact result would be assumed to be 2.6, which rounded using ROUND_CEIL to 1 decimal\r\n    // place is still 2.6.\r\n    if (checkRoundingDigits(r.d, k = pr, rm)) {\r\n\r\n      do {\r\n        sd += 10;\r\n        num = naturalLogarithm(arg, sd);\r\n        denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);\r\n        r = divide(num, denominator, sd, 1);\r\n\r\n        if (!inf) {\r\n\r\n          // Check for 14 nines from the 2nd rounding digit, as the first may be 4.\r\n          if (+digitsToString(r.d).slice(k + 1, k + 15) + 1 == 1e14) {\r\n            r = finalise(r, pr + 1, 0);\r\n          }\r\n\r\n          break;\r\n        }\r\n      } while (checkRoundingDigits(r.d, k += 10, rm));\r\n    }\r\n\r\n    external = true;\r\n\r\n    return finalise(r, pr, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the maximum of the arguments and the value of this Decimal.\r\n   *\r\n   * arguments {number|string|Decimal}\r\n   *\r\n  P.max = function () {\r\n    Array.prototype.push.call(arguments, this);\r\n    return maxOrMin(this.constructor, arguments, 'lt');\r\n  };\r\n   */\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the minimum of the arguments and the value of this Decimal.\r\n   *\r\n   * arguments {number|string|Decimal}\r\n   *\r\n  P.min = function () {\r\n    Array.prototype.push.call(arguments, this);\r\n    return maxOrMin(this.constructor, arguments, 'gt');\r\n  };\r\n   */\r\n\r\n\r\n  /*\r\n   *  n - 0 = n\r\n   *  n - N = N\r\n   *  n - I = -I\r\n   *  0 - n = -n\r\n   *  0 - 0 = 0\r\n   *  0 - N = N\r\n   *  0 - I = -I\r\n   *  N - n = N\r\n   *  N - 0 = N\r\n   *  N - N = N\r\n   *  N - I = N\r\n   *  I - n = I\r\n   *  I - 0 = I\r\n   *  I - N = N\r\n   *  I - I = N\r\n   *\r\n   * Return a new Decimal whose value is the value of this Decimal minus `y`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   */\r\n  P.minus = P.sub = function (y) {\r\n    var d, e, i, j, k, len, pr, rm, xd, xe, xLTy, yd,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    y = new Ctor(y);\r\n\r\n    // If either is not finite...\r\n    if (!x.d || !y.d) {\r\n\r\n      // Return NaN if either is NaN.\r\n      if (!x.s || !y.s) y = new Ctor(NaN);\r\n\r\n      // Return y negated if x is finite and y is ±Infinity.\r\n      else if (x.d) y.s = -y.s;\r\n\r\n      // Return x if y is finite and x is ±Infinity.\r\n      // Return x if both are ±Infinity with different signs.\r\n      // Return NaN if both are ±Infinity with the same sign.\r\n      else y = new Ctor(y.d || x.s !== y.s ? x : NaN);\r\n\r\n      return y;\r\n    }\r\n\r\n    // If signs differ...\r\n    if (x.s != y.s) {\r\n      y.s = -y.s;\r\n      return x.plus(y);\r\n    }\r\n\r\n    xd = x.d;\r\n    yd = y.d;\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n\r\n    // If either is zero...\r\n    if (!xd[0] || !yd[0]) {\r\n\r\n      // Return y negated if x is zero and y is non-zero.\r\n      if (yd[0]) y.s = -y.s;\r\n\r\n      // Return x if y is zero and x is non-zero.\r\n      else if (xd[0]) y = new Ctor(x);\r\n\r\n      // Return zero if both are zero.\r\n      // From IEEE 754 (2008) 6.3: 0 - 0 = -0 - -0 = -0 when rounding to -Infinity.\r\n      else return new Ctor(rm === 3 ? -0 : 0);\r\n\r\n      return external ? finalise(y, pr, rm) : y;\r\n    }\r\n\r\n    // x and y are finite, non-zero numbers with the same sign.\r\n\r\n    // Calculate base 1e7 exponents.\r\n    e = mathfloor(y.e / LOG_BASE);\r\n    xe = mathfloor(x.e / LOG_BASE);\r\n\r\n    xd = xd.slice();\r\n    k = xe - e;\r\n\r\n    // If base 1e7 exponents differ...\r\n    if (k) {\r\n      xLTy = k < 0;\r\n\r\n      if (xLTy) {\r\n        d = xd;\r\n        k = -k;\r\n        len = yd.length;\r\n      } else {\r\n        d = yd;\r\n        e = xe;\r\n        len = xd.length;\r\n      }\r\n\r\n      // Numbers with massively different exponents would result in a very high number of\r\n      // zeros needing to be prepended, but this can be avoided while still ensuring correct\r\n      // rounding by limiting the number of zeros to `Math.ceil(pr / LOG_BASE) + 2`.\r\n      i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;\r\n\r\n      if (k > i) {\r\n        k = i;\r\n        d.length = 1;\r\n      }\r\n\r\n      // Prepend zeros to equalise exponents.\r\n      d.reverse();\r\n      for (i = k; i--;) d.push(0);\r\n      d.reverse();\r\n\r\n    // Base 1e7 exponents equal.\r\n    } else {\r\n\r\n      // Check digits to determine which is the bigger number.\r\n\r\n      i = xd.length;\r\n      len = yd.length;\r\n      xLTy = i < len;\r\n      if (xLTy) len = i;\r\n\r\n      for (i = 0; i < len; i++) {\r\n        if (xd[i] != yd[i]) {\r\n          xLTy = xd[i] < yd[i];\r\n          break;\r\n        }\r\n      }\r\n\r\n      k = 0;\r\n    }\r\n\r\n    if (xLTy) {\r\n      d = xd;\r\n      xd = yd;\r\n      yd = d;\r\n      y.s = -y.s;\r\n    }\r\n\r\n    len = xd.length;\r\n\r\n    // Append zeros to `xd` if shorter.\r\n    // Don't add zeros to `yd` if shorter as subtraction only needs to start at `yd` length.\r\n    for (i = yd.length - len; i > 0; --i) xd[len++] = 0;\r\n\r\n    // Subtract yd from xd.\r\n    for (i = yd.length; i > k;) {\r\n\r\n      if (xd[--i] < yd[i]) {\r\n        for (j = i; j && xd[--j] === 0;) xd[j] = BASE - 1;\r\n        --xd[j];\r\n        xd[i] += BASE;\r\n      }\r\n\r\n      xd[i] -= yd[i];\r\n    }\r\n\r\n    // Remove trailing zeros.\r\n    for (; xd[--len] === 0;) xd.pop();\r\n\r\n    // Remove leading zeros and adjust exponent accordingly.\r\n    for (; xd[0] === 0; xd.shift()) --e;\r\n\r\n    // Zero?\r\n    if (!xd[0]) return new Ctor(rm === 3 ? -0 : 0);\r\n\r\n    y.d = xd;\r\n    y.e = getBase10Exponent(xd, e);\r\n\r\n    return external ? finalise(y, pr, rm) : y;\r\n  };\r\n\r\n\r\n  /*\r\n   *   n % 0 =  N\r\n   *   n % N =  N\r\n   *   n % I =  n\r\n   *   0 % n =  0\r\n   *  -0 % n = -0\r\n   *   0 % 0 =  N\r\n   *   0 % N =  N\r\n   *   0 % I =  0\r\n   *   N % n =  N\r\n   *   N % 0 =  N\r\n   *   N % N =  N\r\n   *   N % I =  N\r\n   *   I % n =  N\r\n   *   I % 0 =  N\r\n   *   I % N =  N\r\n   *   I % I =  N\r\n   *\r\n   * Return a new Decimal whose value is the value of this Decimal modulo `y`, rounded to\r\n   * `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * The result depends on the modulo mode.\r\n   *\r\n   */\r\n  P.modulo = P.mod = function (y) {\r\n    var q,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    y = new Ctor(y);\r\n\r\n    // Return NaN if x is ±Infinity or NaN, or y is NaN or ±0.\r\n    if (!x.d || !y.s || y.d && !y.d[0]) return new Ctor(NaN);\r\n\r\n    // Return x if y is ±Infinity or x is ±0.\r\n    if (!y.d || x.d && !x.d[0]) {\r\n      return finalise(new Ctor(x), Ctor.precision, Ctor.rounding);\r\n    }\r\n\r\n    // Prevent rounding of intermediate calculations.\r\n    external = false;\r\n\r\n    if (Ctor.modulo == 9) {\r\n\r\n      // Euclidian division: q = sign(y) * floor(x / abs(y))\r\n      // result = x - q * y    where  0 <= result < abs(y)\r\n      q = divide(x, y.abs(), 0, 3, 1);\r\n      q.s *= y.s;\r\n    } else {\r\n      q = divide(x, y, 0, Ctor.modulo, 1);\r\n    }\r\n\r\n    q = q.times(y);\r\n\r\n    external = true;\r\n\r\n    return x.minus(q);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the natural exponential of the value of this Decimal,\r\n   * i.e. the base e raised to the power the value of this Decimal, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   */\r\n  P.naturalExponential = P.exp = function () {\r\n    return naturalExponential(this);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the natural logarithm of the value of this Decimal,\r\n   * rounded to `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   */\r\n  P.naturalLogarithm = P.ln = function () {\r\n    return naturalLogarithm(this);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal negated, i.e. as if multiplied by\r\n   * -1.\r\n   *\r\n   */\r\n  P.negated = P.neg = function () {\r\n    var x = new this.constructor(this);\r\n    x.s = -x.s;\r\n    return finalise(x);\r\n  };\r\n\r\n\r\n  /*\r\n   *  n + 0 = n\r\n   *  n + N = N\r\n   *  n + I = I\r\n   *  0 + n = n\r\n   *  0 + 0 = 0\r\n   *  0 + N = N\r\n   *  0 + I = I\r\n   *  N + n = N\r\n   *  N + 0 = N\r\n   *  N + N = N\r\n   *  N + I = N\r\n   *  I + n = I\r\n   *  I + 0 = I\r\n   *  I + N = N\r\n   *  I + I = I\r\n   *\r\n   * Return a new Decimal whose value is the value of this Decimal plus `y`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   */\r\n  P.plus = P.add = function (y) {\r\n    var carry, d, e, i, k, len, pr, rm, xd, yd,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    y = new Ctor(y);\r\n\r\n    // If either is not finite...\r\n    if (!x.d || !y.d) {\r\n\r\n      // Return NaN if either is NaN.\r\n      if (!x.s || !y.s) y = new Ctor(NaN);\r\n\r\n      // Return x if y is finite and x is ±Infinity.\r\n      // Return x if both are ±Infinity with the same sign.\r\n      // Return NaN if both are ±Infinity with different signs.\r\n      // Return y if x is finite and y is ±Infinity.\r\n      else if (!x.d) y = new Ctor(y.d || x.s === y.s ? x : NaN);\r\n\r\n      return y;\r\n    }\r\n\r\n     // If signs differ...\r\n    if (x.s != y.s) {\r\n      y.s = -y.s;\r\n      return x.minus(y);\r\n    }\r\n\r\n    xd = x.d;\r\n    yd = y.d;\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n\r\n    // If either is zero...\r\n    if (!xd[0] || !yd[0]) {\r\n\r\n      // Return x if y is zero.\r\n      // Return y if y is non-zero.\r\n      if (!yd[0]) y = new Ctor(x);\r\n\r\n      return external ? finalise(y, pr, rm) : y;\r\n    }\r\n\r\n    // x and y are finite, non-zero numbers with the same sign.\r\n\r\n    // Calculate base 1e7 exponents.\r\n    k = mathfloor(x.e / LOG_BASE);\r\n    e = mathfloor(y.e / LOG_BASE);\r\n\r\n    xd = xd.slice();\r\n    i = k - e;\r\n\r\n    // If base 1e7 exponents differ...\r\n    if (i) {\r\n\r\n      if (i < 0) {\r\n        d = xd;\r\n        i = -i;\r\n        len = yd.length;\r\n      } else {\r\n        d = yd;\r\n        e = k;\r\n        len = xd.length;\r\n      }\r\n\r\n      // Limit number of zeros prepended to max(ceil(pr / LOG_BASE), len) + 1.\r\n      k = Math.ceil(pr / LOG_BASE);\r\n      len = k > len ? k + 1 : len + 1;\r\n\r\n      if (i > len) {\r\n        i = len;\r\n        d.length = 1;\r\n      }\r\n\r\n      // Prepend zeros to equalise exponents. Note: Faster to use reverse then do unshifts.\r\n      d.reverse();\r\n      for (; i--;) d.push(0);\r\n      d.reverse();\r\n    }\r\n\r\n    len = xd.length;\r\n    i = yd.length;\r\n\r\n    // If yd is longer than xd, swap xd and yd so xd points to the longer array.\r\n    if (len - i < 0) {\r\n      i = len;\r\n      d = yd;\r\n      yd = xd;\r\n      xd = d;\r\n    }\r\n\r\n    // Only start adding at yd.length - 1 as the further digits of xd can be left as they are.\r\n    for (carry = 0; i;) {\r\n      carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;\r\n      xd[i] %= BASE;\r\n    }\r\n\r\n    if (carry) {\r\n      xd.unshift(carry);\r\n      ++e;\r\n    }\r\n\r\n    // Remove trailing zeros.\r\n    // No need to check for zero, as +x + +y != 0 && -x + -y != 0\r\n    for (len = xd.length; xd[--len] == 0;) xd.pop();\r\n\r\n    y.d = xd;\r\n    y.e = getBase10Exponent(xd, e);\r\n\r\n    return external ? finalise(y, pr, rm) : y;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return the number of significant digits of the value of this Decimal.\r\n   *\r\n   * [z] {boolean|number} Whether to count integer-part trailing zeros: true, false, 1 or 0.\r\n   *\r\n   */\r\n  P.precision = P.sd = function (z) {\r\n    var k,\r\n      x = this;\r\n\r\n    if (z !== void 0 && z !== !!z && z !== 1 && z !== 0) throw Error(invalidArgument + z);\r\n\r\n    if (x.d) {\r\n      k = getPrecision(x.d);\r\n      if (z && x.e + 1 > k) k = x.e + 1;\r\n    } else {\r\n      k = NaN;\r\n    }\r\n\r\n    return k;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal rounded to a whole number using\r\n   * rounding mode `rounding`.\r\n   *\r\n   */\r\n  P.round = function () {\r\n    var x = this,\r\n      Ctor = x.constructor;\r\n\r\n    return finalise(new Ctor(x), x.e + 1, Ctor.rounding);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the sine of the value in radians of this Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-1, 1]\r\n   *\r\n   * sin(x) = x - x^3/3! + x^5/5! - ...\r\n   *\r\n   * sin(0)         = 0\r\n   * sin(-0)        = -0\r\n   * sin(Infinity)  = NaN\r\n   * sin(-Infinity) = NaN\r\n   * sin(NaN)       = NaN\r\n   *\r\n   */\r\n  P.sine = P.sin = function () {\r\n    var pr, rm,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (!x.isFinite()) return new Ctor(NaN);\r\n    if (x.isZero()) return new Ctor(x);\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n    Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;\r\n    Ctor.rounding = 1;\r\n\r\n    x = sine(Ctor, toLessThanHalfPi(Ctor, x));\r\n\r\n    Ctor.precision = pr;\r\n    Ctor.rounding = rm;\r\n\r\n    return finalise(quadrant > 2 ? x.neg() : x, pr, rm, true);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the square root of this Decimal, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   *  sqrt(-n) =  N\r\n   *  sqrt(N)  =  N\r\n   *  sqrt(-I) =  N\r\n   *  sqrt(I)  =  I\r\n   *  sqrt(0)  =  0\r\n   *  sqrt(-0) = -0\r\n   *\r\n   */\r\n  P.squareRoot = P.sqrt = function () {\r\n    var m, n, sd, r, rep, t,\r\n      x = this,\r\n      d = x.d,\r\n      e = x.e,\r\n      s = x.s,\r\n      Ctor = x.constructor;\r\n\r\n    // Negative/NaN/Infinity/zero?\r\n    if (s !== 1 || !d || !d[0]) {\r\n      return new Ctor(!s || s < 0 && (!d || d[0]) ? NaN : d ? x : 1 / 0);\r\n    }\r\n\r\n    external = false;\r\n\r\n    // Initial estimate.\r\n    s = Math.sqrt(+x);\r\n\r\n    // Math.sqrt underflow/overflow?\r\n    // Pass x to Math.sqrt as integer, then adjust the exponent of the result.\r\n    if (s == 0 || s == 1 / 0) {\r\n      n = digitsToString(d);\r\n\r\n      if ((n.length + e) % 2 == 0) n += '0';\r\n      s = Math.sqrt(n);\r\n      e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);\r\n\r\n      if (s == 1 / 0) {\r\n        n = '5e' + e;\r\n      } else {\r\n        n = s.toExponential();\r\n        n = n.slice(0, n.indexOf('e') + 1) + e;\r\n      }\r\n\r\n      r = new Ctor(n);\r\n    } else {\r\n      r = new Ctor(s.toString());\r\n    }\r\n\r\n    sd = (e = Ctor.precision) + 3;\r\n\r\n    // Newton-Raphson iteration.\r\n    for (;;) {\r\n      t = r;\r\n      r = t.plus(divide(x, t, sd + 2, 1)).times(0.5);\r\n\r\n      // TODO? Replace with for-loop and checkRoundingDigits.\r\n      if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {\r\n        n = n.slice(sd - 3, sd + 1);\r\n\r\n        // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or\r\n        // 4999, i.e. approaching a rounding boundary, continue the iteration.\r\n        if (n == '9999' || !rep && n == '4999') {\r\n\r\n          // On the first iteration only, check to see if rounding up gives the exact result as the\r\n          // nines may infinitely repeat.\r\n          if (!rep) {\r\n            finalise(t, e + 1, 0);\r\n\r\n            if (t.times(t).eq(x)) {\r\n              r = t;\r\n              break;\r\n            }\r\n          }\r\n\r\n          sd += 4;\r\n          rep = 1;\r\n        } else {\r\n\r\n          // If the rounding digits are null, 0{0,4} or 50{0,3}, check for an exact result.\r\n          // If not, then there are further digits and m will be truthy.\r\n          if (!+n || !+n.slice(1) && n.charAt(0) == '5') {\r\n\r\n            // Truncate to the first rounding digit.\r\n            finalise(r, e + 1, 1);\r\n            m = !r.times(r).eq(x);\r\n          }\r\n\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    external = true;\r\n\r\n    return finalise(r, e, Ctor.rounding, m);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the tangent of the value in radians of this Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-Infinity, Infinity]\r\n   *\r\n   * tan(0)         = 0\r\n   * tan(-0)        = -0\r\n   * tan(Infinity)  = NaN\r\n   * tan(-Infinity) = NaN\r\n   * tan(NaN)       = NaN\r\n   *\r\n   */\r\n  P.tangent = P.tan = function () {\r\n    var pr, rm,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (!x.isFinite()) return new Ctor(NaN);\r\n    if (x.isZero()) return new Ctor(x);\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n    Ctor.precision = pr + 10;\r\n    Ctor.rounding = 1;\r\n\r\n    x = x.sin();\r\n    x.s = 1;\r\n    x = divide(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);\r\n\r\n    Ctor.precision = pr;\r\n    Ctor.rounding = rm;\r\n\r\n    return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);\r\n  };\r\n\r\n\r\n  /*\r\n   *  n * 0 = 0\r\n   *  n * N = N\r\n   *  n * I = I\r\n   *  0 * n = 0\r\n   *  0 * 0 = 0\r\n   *  0 * N = N\r\n   *  0 * I = N\r\n   *  N * n = N\r\n   *  N * 0 = N\r\n   *  N * N = N\r\n   *  N * I = N\r\n   *  I * n = I\r\n   *  I * 0 = N\r\n   *  I * N = N\r\n   *  I * I = I\r\n   *\r\n   * Return a new Decimal whose value is this Decimal times `y`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   */\r\n  P.times = P.mul = function (y) {\r\n    var carry, e, i, k, r, rL, t, xdL, ydL,\r\n      x = this,\r\n      Ctor = x.constructor,\r\n      xd = x.d,\r\n      yd = (y = new Ctor(y)).d;\r\n\r\n    y.s *= x.s;\r\n\r\n     // If either is NaN, ±Infinity or ±0...\r\n    if (!xd || !xd[0] || !yd || !yd[0]) {\r\n\r\n      return new Ctor(!y.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd\r\n\r\n        // Return NaN if either is NaN.\r\n        // Return NaN if x is ±0 and y is ±Infinity, or y is ±0 and x is ±Infinity.\r\n        ? NaN\r\n\r\n        // Return ±Infinity if either is ±Infinity.\r\n        // Return ±0 if either is ±0.\r\n        : !xd || !yd ? y.s / 0 : y.s * 0);\r\n    }\r\n\r\n    e = mathfloor(x.e / LOG_BASE) + mathfloor(y.e / LOG_BASE);\r\n    xdL = xd.length;\r\n    ydL = yd.length;\r\n\r\n    // Ensure xd points to the longer array.\r\n    if (xdL < ydL) {\r\n      r = xd;\r\n      xd = yd;\r\n      yd = r;\r\n      rL = xdL;\r\n      xdL = ydL;\r\n      ydL = rL;\r\n    }\r\n\r\n    // Initialise the result array with zeros.\r\n    r = [];\r\n    rL = xdL + ydL;\r\n    for (i = rL; i--;) r.push(0);\r\n\r\n    // Multiply!\r\n    for (i = ydL; --i >= 0;) {\r\n      carry = 0;\r\n      for (k = xdL + i; k > i;) {\r\n        t = r[k] + yd[i] * xd[k - i - 1] + carry;\r\n        r[k--] = t % BASE | 0;\r\n        carry = t / BASE | 0;\r\n      }\r\n\r\n      r[k] = (r[k] + carry) % BASE | 0;\r\n    }\r\n\r\n    // Remove trailing zeros.\r\n    for (; !r[--rL];) r.pop();\r\n\r\n    if (carry) ++e;\r\n    else r.shift();\r\n\r\n    y.d = r;\r\n    y.e = getBase10Exponent(r, e);\r\n\r\n    return external ? finalise(y, Ctor.precision, Ctor.rounding) : y;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Decimal in base 2, round to `sd` significant\r\n   * digits using rounding mode `rm`.\r\n   *\r\n   * If the optional `sd` argument is present then return binary exponential notation.\r\n   *\r\n   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   */\r\n  P.toBinary = function (sd, rm) {\r\n    return toStringBinary(this, 2, sd, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `dp`\r\n   * decimal places using rounding mode `rm` or `rounding` if `rm` is omitted.\r\n   *\r\n   * If `dp` is omitted, return a new Decimal whose value is the value of this Decimal.\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   */\r\n  P.toDecimalPlaces = P.toDP = function (dp, rm) {\r\n    var x = this,\r\n      Ctor = x.constructor;\r\n\r\n    x = new Ctor(x);\r\n    if (dp === void 0) return x;\r\n\r\n    checkInt32(dp, 0, MAX_DIGITS);\r\n\r\n    if (rm === void 0) rm = Ctor.rounding;\r\n    else checkInt32(rm, 0, 8);\r\n\r\n    return finalise(x, dp + x.e + 1, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Decimal in exponential notation rounded to\r\n   * `dp` fixed decimal places using rounding mode `rounding`.\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   */\r\n  P.toExponential = function (dp, rm) {\r\n    var str,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (dp === void 0) {\r\n      str = finiteToString(x, true);\r\n    } else {\r\n      checkInt32(dp, 0, MAX_DIGITS);\r\n\r\n      if (rm === void 0) rm = Ctor.rounding;\r\n      else checkInt32(rm, 0, 8);\r\n\r\n      x = finalise(new Ctor(x), dp + 1, rm);\r\n      str = finiteToString(x, true, dp + 1);\r\n    }\r\n\r\n    return x.isNeg() && !x.isZero() ? '-' + str : str;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Decimal in normal (fixed-point) notation to\r\n   * `dp` fixed decimal places and rounded using rounding mode `rm` or `rounding` if `rm` is\r\n   * omitted.\r\n   *\r\n   * As with JavaScript numbers, (-0).toFixed(0) is '0', but e.g. (-0.00001).toFixed(0) is '-0'.\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * (-0).toFixed(0) is '0', but (-0.1).toFixed(0) is '-0'.\r\n   * (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.\r\n   * (-0).toFixed(3) is '0.000'.\r\n   * (-0.5).toFixed(0) is '-0'.\r\n   *\r\n   */\r\n  P.toFixed = function (dp, rm) {\r\n    var str, y,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (dp === void 0) {\r\n      str = finiteToString(x);\r\n    } else {\r\n      checkInt32(dp, 0, MAX_DIGITS);\r\n\r\n      if (rm === void 0) rm = Ctor.rounding;\r\n      else checkInt32(rm, 0, 8);\r\n\r\n      y = finalise(new Ctor(x), dp + x.e + 1, rm);\r\n      str = finiteToString(y, false, dp + y.e + 1);\r\n    }\r\n\r\n    // To determine whether to add the minus sign look at the value before it was rounded,\r\n    // i.e. look at `x` rather than `y`.\r\n    return x.isNeg() && !x.isZero() ? '-' + str : str;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return an array representing the value of this Decimal as a simple fraction with an integer\r\n   * numerator and an integer denominator.\r\n   *\r\n   * The denominator will be a positive non-zero value less than or equal to the specified maximum\r\n   * denominator. If a maximum denominator is not specified, the denominator will be the lowest\r\n   * value necessary to represent the number exactly.\r\n   *\r\n   * [maxD] {number|string|Decimal} Maximum denominator. Integer >= 1 and < Infinity.\r\n   *\r\n   */\r\n  P.toFraction = function (maxD) {\r\n    var d, d0, d1, d2, e, k, n, n0, n1, pr, q, r,\r\n      x = this,\r\n      xd = x.d,\r\n      Ctor = x.constructor;\r\n\r\n    if (!xd) return new Ctor(x);\r\n\r\n    n1 = d0 = new Ctor(1);\r\n    d1 = n0 = new Ctor(0);\r\n\r\n    d = new Ctor(d1);\r\n    e = d.e = getPrecision(xd) - x.e - 1;\r\n    k = e % LOG_BASE;\r\n    d.d[0] = mathpow(10, k < 0 ? LOG_BASE + k : k);\r\n\r\n    if (maxD == null) {\r\n\r\n      // d is 10**e, the minimum max-denominator needed.\r\n      maxD = e > 0 ? d : n1;\r\n    } else {\r\n      n = new Ctor(maxD);\r\n      if (!n.isInt() || n.lt(n1)) throw Error(invalidArgument + n);\r\n      maxD = n.gt(d) ? (e > 0 ? d : n1) : n;\r\n    }\r\n\r\n    external = false;\r\n    n = new Ctor(digitsToString(xd));\r\n    pr = Ctor.precision;\r\n    Ctor.precision = e = xd.length * LOG_BASE * 2;\r\n\r\n    for (;;)  {\r\n      q = divide(n, d, 0, 1, 1);\r\n      d2 = d0.plus(q.times(d1));\r\n      if (d2.cmp(maxD) == 1) break;\r\n      d0 = d1;\r\n      d1 = d2;\r\n      d2 = n1;\r\n      n1 = n0.plus(q.times(d2));\r\n      n0 = d2;\r\n      d2 = d;\r\n      d = n.minus(q.times(d2));\r\n      n = d2;\r\n    }\r\n\r\n    d2 = divide(maxD.minus(d0), d1, 0, 1, 1);\r\n    n0 = n0.plus(d2.times(n1));\r\n    d0 = d0.plus(d2.times(d1));\r\n    n0.s = n1.s = x.s;\r\n\r\n    // Determine which fraction is closer to x, n0/d0 or n1/d1?\r\n    r = divide(n1, d1, e, 1).minus(x).abs().cmp(divide(n0, d0, e, 1).minus(x).abs()) < 1\r\n        ? [n1, d1] : [n0, d0];\r\n\r\n    Ctor.precision = pr;\r\n    external = true;\r\n\r\n    return r;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Decimal in base 16, round to `sd` significant\r\n   * digits using rounding mode `rm`.\r\n   *\r\n   * If the optional `sd` argument is present then return binary exponential notation.\r\n   *\r\n   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   */\r\n  P.toHexadecimal = P.toHex = function (sd, rm) {\r\n    return toStringBinary(this, 16, sd, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Returns a new Decimal whose value is the nearest multiple of `y` in the direction of rounding\r\n   * mode `rm`, or `Decimal.rounding` if `rm` is omitted, to the value of this Decimal.\r\n   *\r\n   * The return value will always have the same sign as this Decimal, unless either this Decimal\r\n   * or `y` is NaN, in which case the return value will be also be NaN.\r\n   *\r\n   * The return value is not affected by the value of `precision`.\r\n   *\r\n   * y {number|string|Decimal} The magnitude to round to a multiple of.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * 'toNearest() rounding mode not an integer: {rm}'\r\n   * 'toNearest() rounding mode out of range: {rm}'\r\n   *\r\n   */\r\n  P.toNearest = function (y, rm) {\r\n    var x = this,\r\n      Ctor = x.constructor;\r\n\r\n    x = new Ctor(x);\r\n\r\n    if (y == null) {\r\n\r\n      // If x is not finite, return x.\r\n      if (!x.d) return x;\r\n\r\n      y = new Ctor(1);\r\n      rm = Ctor.rounding;\r\n    } else {\r\n      y = new Ctor(y);\r\n      if (rm === void 0) {\r\n        rm = Ctor.rounding;\r\n      } else {\r\n        checkInt32(rm, 0, 8);\r\n      }\r\n\r\n      // If x is not finite, return x if y is not NaN, else NaN.\r\n      if (!x.d) return y.s ? x : y;\r\n\r\n      // If y is not finite, return Infinity with the sign of x if y is Infinity, else NaN.\r\n      if (!y.d) {\r\n        if (y.s) y.s = x.s;\r\n        return y;\r\n      }\r\n    }\r\n\r\n    // If y is not zero, calculate the nearest multiple of y to x.\r\n    if (y.d[0]) {\r\n      external = false;\r\n      x = divide(x, y, 0, rm, 1).times(y);\r\n      external = true;\r\n      finalise(x);\r\n\r\n    // If y is zero, return zero with the sign of x.\r\n    } else {\r\n      y.s = x.s;\r\n      x = y;\r\n    }\r\n\r\n    return x;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return the value of this Decimal converted to a number primitive.\r\n   * Zero keeps its sign.\r\n   *\r\n   */\r\n  P.toNumber = function () {\r\n    return +this;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Decimal in base 8, round to `sd` significant\r\n   * digits using rounding mode `rm`.\r\n   *\r\n   * If the optional `sd` argument is present then return binary exponential notation.\r\n   *\r\n   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   */\r\n  P.toOctal = function (sd, rm) {\r\n    return toStringBinary(this, 8, sd, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal raised to the power `y`, rounded\r\n   * to `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * ECMAScript compliant.\r\n   *\r\n   *   pow(x, NaN)                           = NaN\r\n   *   pow(x, ±0)                            = 1\r\n\r\n   *   pow(NaN, non-zero)                    = NaN\r\n   *   pow(abs(x) > 1, +Infinity)            = +Infinity\r\n   *   pow(abs(x) > 1, -Infinity)            = +0\r\n   *   pow(abs(x) == 1, ±Infinity)           = NaN\r\n   *   pow(abs(x) < 1, +Infinity)            = +0\r\n   *   pow(abs(x) < 1, -Infinity)            = +Infinity\r\n   *   pow(+Infinity, y > 0)                 = +Infinity\r\n   *   pow(+Infinity, y < 0)                 = +0\r\n   *   pow(-Infinity, odd integer > 0)       = -Infinity\r\n   *   pow(-Infinity, even integer > 0)      = +Infinity\r\n   *   pow(-Infinity, odd integer < 0)       = -0\r\n   *   pow(-Infinity, even integer < 0)      = +0\r\n   *   pow(+0, y > 0)                        = +0\r\n   *   pow(+0, y < 0)                        = +Infinity\r\n   *   pow(-0, odd integer > 0)              = -0\r\n   *   pow(-0, even integer > 0)             = +0\r\n   *   pow(-0, odd integer < 0)              = -Infinity\r\n   *   pow(-0, even integer < 0)             = +Infinity\r\n   *   pow(finite x < 0, finite non-integer) = NaN\r\n   *\r\n   * For non-integer or very large exponents pow(x, y) is calculated using\r\n   *\r\n   *   x^y = exp(y*ln(x))\r\n   *\r\n   * Assuming the first 15 rounding digits are each equally likely to be any digit 0-9, the\r\n   * probability of an incorrectly rounded result\r\n   * P([49]9{14} | [50]0{14}) = 2 * 0.2 * 10^-14 = 4e-15 = 1/2.5e+14\r\n   * i.e. 1 in 250,000,000,000,000\r\n   *\r\n   * If a result is incorrectly rounded the maximum error will be 1 ulp (unit in last place).\r\n   *\r\n   * y {number|string|Decimal} The power to which to raise this Decimal.\r\n   *\r\n   */\r\n  P.toPower = P.pow = function (y) {\r\n    var e, k, pr, r, rm, s,\r\n      x = this,\r\n      Ctor = x.constructor,\r\n      yn = +(y = new Ctor(y));\r\n\r\n    // Either ±Infinity, NaN or ±0?\r\n    if (!x.d || !y.d || !x.d[0] || !y.d[0]) return new Ctor(mathpow(+x, yn));\r\n\r\n    x = new Ctor(x);\r\n\r\n    if (x.eq(1)) return x;\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n\r\n    if (y.eq(1)) return finalise(x, pr, rm);\r\n\r\n    // y exponent\r\n    e = mathfloor(y.e / LOG_BASE);\r\n\r\n    // If y is a small integer use the 'exponentiation by squaring' algorithm.\r\n    if (e >= y.d.length - 1 && (k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {\r\n      r = intPow(Ctor, x, k, pr);\r\n      return y.s < 0 ? new Ctor(1).div(r) : finalise(r, pr, rm);\r\n    }\r\n\r\n    s = x.s;\r\n\r\n    // if x is negative\r\n    if (s < 0) {\r\n\r\n      // if y is not an integer\r\n      if (e < y.d.length - 1) return new Ctor(NaN);\r\n\r\n      // Result is positive if x is negative and the last digit of integer y is even.\r\n      if ((y.d[e] & 1) == 0) s = 1;\r\n\r\n      // if x.eq(-1)\r\n      if (x.e == 0 && x.d[0] == 1 && x.d.length == 1) {\r\n        x.s = s;\r\n        return x;\r\n      }\r\n    }\r\n\r\n    // Estimate result exponent.\r\n    // x^y = 10^e,  where e = y * log10(x)\r\n    // log10(x) = log10(x_significand) + x_exponent\r\n    // log10(x_significand) = ln(x_significand) / ln(10)\r\n    k = mathpow(+x, yn);\r\n    e = k == 0 || !isFinite(k)\r\n      ? mathfloor(yn * (Math.log('0.' + digitsToString(x.d)) / Math.LN10 + x.e + 1))\r\n      : new Ctor(k + '').e;\r\n\r\n    // Exponent estimate may be incorrect e.g. x: 0.999999999999999999, y: 2.29, e: 0, r.e: -1.\r\n\r\n    // Overflow/underflow?\r\n    if (e > Ctor.maxE + 1 || e < Ctor.minE - 1) return new Ctor(e > 0 ? s / 0 : 0);\r\n\r\n    external = false;\r\n    Ctor.rounding = x.s = 1;\r\n\r\n    // Estimate the extra guard digits needed to ensure five correct rounding digits from\r\n    // naturalLogarithm(x). Example of failure without these extra digits (precision: 10):\r\n    // new Decimal(2.32456).pow('2087987436534566.46411')\r\n    // should be 1.162377823e+764914905173815, but is 1.162355823e+764914905173815\r\n    k = Math.min(12, (e + '').length);\r\n\r\n    // r = x^y = exp(y*ln(x))\r\n    r = naturalExponential(y.times(naturalLogarithm(x, pr + k)), pr);\r\n\r\n    // r may be Infinity, e.g. (0.9999999999999999).pow(-1e+40)\r\n    if (r.d) {\r\n\r\n      // Truncate to the required precision plus five rounding digits.\r\n      r = finalise(r, pr + 5, 1);\r\n\r\n      // If the rounding digits are [49]9999 or [50]0000 increase the precision by 10 and recalculate\r\n      // the result.\r\n      if (checkRoundingDigits(r.d, pr, rm)) {\r\n        e = pr + 10;\r\n\r\n        // Truncate to the increased precision plus five rounding digits.\r\n        r = finalise(naturalExponential(y.times(naturalLogarithm(x, e + k)), e), e + 5, 1);\r\n\r\n        // Check for 14 nines from the 2nd rounding digit (the first rounding digit may be 4 or 9).\r\n        if (+digitsToString(r.d).slice(pr + 1, pr + 15) + 1 == 1e14) {\r\n          r = finalise(r, pr + 1, 0);\r\n        }\r\n      }\r\n    }\r\n\r\n    r.s = s;\r\n    external = true;\r\n    Ctor.rounding = rm;\r\n\r\n    return finalise(r, pr, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Decimal rounded to `sd` significant digits\r\n   * using rounding mode `rounding`.\r\n   *\r\n   * Return exponential notation if `sd` is less than the number of digits necessary to represent\r\n   * the integer part of the value in normal notation.\r\n   *\r\n   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   */\r\n  P.toPrecision = function (sd, rm) {\r\n    var str,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (sd === void 0) {\r\n      str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);\r\n    } else {\r\n      checkInt32(sd, 1, MAX_DIGITS);\r\n\r\n      if (rm === void 0) rm = Ctor.rounding;\r\n      else checkInt32(rm, 0, 8);\r\n\r\n      x = finalise(new Ctor(x), sd, rm);\r\n      str = finiteToString(x, sd <= x.e || x.e <= Ctor.toExpNeg, sd);\r\n    }\r\n\r\n    return x.isNeg() && !x.isZero() ? '-' + str : str;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `sd`\r\n   * significant digits using rounding mode `rm`, or to `precision` and `rounding` respectively if\r\n   * omitted.\r\n   *\r\n   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * 'toSD() digits out of range: {sd}'\r\n   * 'toSD() digits not an integer: {sd}'\r\n   * 'toSD() rounding mode not an integer: {rm}'\r\n   * 'toSD() rounding mode out of range: {rm}'\r\n   *\r\n   */\r\n  P.toSignificantDigits = P.toSD = function (sd, rm) {\r\n    var x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (sd === void 0) {\r\n      sd = Ctor.precision;\r\n      rm = Ctor.rounding;\r\n    } else {\r\n      checkInt32(sd, 1, MAX_DIGITS);\r\n\r\n      if (rm === void 0) rm = Ctor.rounding;\r\n      else checkInt32(rm, 0, 8);\r\n    }\r\n\r\n    return finalise(new Ctor(x), sd, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Decimal.\r\n   *\r\n   * Return exponential notation if this Decimal has a positive exponent equal to or greater than\r\n   * `toExpPos`, or a negative exponent equal to or less than `toExpNeg`.\r\n   *\r\n   */\r\n  P.toString = function () {\r\n    var x = this,\r\n      Ctor = x.constructor,\r\n      str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);\r\n\r\n    return x.isNeg() && !x.isZero() ? '-' + str : str;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal truncated to a whole number.\r\n   *\r\n   */\r\n  P.truncated = P.trunc = function () {\r\n    return finalise(new this.constructor(this), this.e + 1, 1);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Decimal.\r\n   * Unlike `toString`, negative zero will include the minus sign.\r\n   *\r\n   */\r\n  P.valueOf = P.toJSON = function () {\r\n    var x = this,\r\n      Ctor = x.constructor,\r\n      str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);\r\n\r\n    return x.isNeg() ? '-' + str : str;\r\n  };\r\n\r\n\r\n  // Helper functions for Decimal.prototype (P) and/or Decimal methods, and their callers.\r\n\r\n\r\n  /*\r\n   *  digitsToString           P.cubeRoot, P.logarithm, P.squareRoot, P.toFraction, P.toPower,\r\n   *                           finiteToString, naturalExponential, naturalLogarithm\r\n   *  checkInt32               P.toDecimalPlaces, P.toExponential, P.toFixed, P.toNearest,\r\n   *                           P.toPrecision, P.toSignificantDigits, toStringBinary, random\r\n   *  checkRoundingDigits      P.logarithm, P.toPower, naturalExponential, naturalLogarithm\r\n   *  convertBase              toStringBinary, parseOther\r\n   *  cos                      P.cos\r\n   *  divide                   P.atanh, P.cubeRoot, P.dividedBy, P.dividedToIntegerBy,\r\n   *                           P.logarithm, P.modulo, P.squareRoot, P.tan, P.tanh, P.toFraction,\r\n   *                           P.toNearest, toStringBinary, naturalExponential, naturalLogarithm,\r\n   *                           taylorSeries, atan2, parseOther\r\n   *  finalise                 P.absoluteValue, P.atan, P.atanh, P.ceil, P.cos, P.cosh,\r\n   *                           P.cubeRoot, P.dividedToIntegerBy, P.floor, P.logarithm, P.minus,\r\n   *                           P.modulo, P.negated, P.plus, P.round, P.sin, P.sinh, P.squareRoot,\r\n   *                           P.tan, P.times, P.toDecimalPlaces, P.toExponential, P.toFixed,\r\n   *                           P.toNearest, P.toPower, P.toPrecision, P.toSignificantDigits,\r\n   *                           P.truncated, divide, getLn10, getPi, naturalExponential,\r\n   *                           naturalLogarithm, ceil, floor, round, trunc\r\n   *  finiteToString           P.toExponential, P.toFixed, P.toPrecision, P.toString, P.valueOf,\r\n   *                           toStringBinary\r\n   *  getBase10Exponent        P.minus, P.plus, P.times, parseOther\r\n   *  getLn10                  P.logarithm, naturalLogarithm\r\n   *  getPi                    P.acos, P.asin, P.atan, toLessThanHalfPi, atan2\r\n   *  getPrecision             P.precision, P.toFraction\r\n   *  getZeroString            digitsToString, finiteToString\r\n   *  intPow                   P.toPower, parseOther\r\n   *  isOdd                    toLessThanHalfPi\r\n   *  maxOrMin                 max, min\r\n   *  naturalExponential       P.naturalExponential, P.toPower\r\n   *  naturalLogarithm         P.acosh, P.asinh, P.atanh, P.logarithm, P.naturalLogarithm,\r\n   *                           P.toPower, naturalExponential\r\n   *  nonFiniteToString        finiteToString, toStringBinary\r\n   *  parseDecimal             Decimal\r\n   *  parseOther               Decimal\r\n   *  sin                      P.sin\r\n   *  taylorSeries             P.cosh, P.sinh, cos, sin\r\n   *  toLessThanHalfPi         P.cos, P.sin\r\n   *  toStringBinary           P.toBinary, P.toHexadecimal, P.toOctal\r\n   *  truncate                 intPow\r\n   *\r\n   *  Throws:                  P.logarithm, P.precision, P.toFraction, checkInt32, getLn10, getPi,\r\n   *                           naturalLogarithm, config, parseOther, random, Decimal\r\n   */\r\n\r\n\r\n  function digitsToString(d) {\r\n    var i, k, ws,\r\n      indexOfLastWord = d.length - 1,\r\n      str = '',\r\n      w = d[0];\r\n\r\n    if (indexOfLastWord > 0) {\r\n      str += w;\r\n      for (i = 1; i < indexOfLastWord; i++) {\r\n        ws = d[i] + '';\r\n        k = LOG_BASE - ws.length;\r\n        if (k) str += getZeroString(k);\r\n        str += ws;\r\n      }\r\n\r\n      w = d[i];\r\n      ws = w + '';\r\n      k = LOG_BASE - ws.length;\r\n      if (k) str += getZeroString(k);\r\n    } else if (w === 0) {\r\n      return '0';\r\n    }\r\n\r\n    // Remove trailing zeros of last w.\r\n    for (; w % 10 === 0;) w /= 10;\r\n\r\n    return str + w;\r\n  }\r\n\r\n\r\n  function checkInt32(i, min, max) {\r\n    if (i !== ~~i || i < min || i > max) {\r\n      throw Error(invalidArgument + i);\r\n    }\r\n  }\r\n\r\n\r\n  /*\r\n   * Check 5 rounding digits if `repeating` is null, 4 otherwise.\r\n   * `repeating == null` if caller is `log` or `pow`,\r\n   * `repeating != null` if caller is `naturalLogarithm` or `naturalExponential`.\r\n   */\r\n  function checkRoundingDigits(d, i, rm, repeating) {\r\n    var di, k, r, rd;\r\n\r\n    // Get the length of the first word of the array d.\r\n    for (k = d[0]; k >= 10; k /= 10) --i;\r\n\r\n    // Is the rounding digit in the first word of d?\r\n    if (--i < 0) {\r\n      i += LOG_BASE;\r\n      di = 0;\r\n    } else {\r\n      di = Math.ceil((i + 1) / LOG_BASE);\r\n      i %= LOG_BASE;\r\n    }\r\n\r\n    // i is the index (0 - 6) of the rounding digit.\r\n    // E.g. if within the word 3487563 the first rounding digit is 5,\r\n    // then i = 4, k = 1000, rd = 3487563 % 1000 = 563\r\n    k = mathpow(10, LOG_BASE - i);\r\n    rd = d[di] % k | 0;\r\n\r\n    if (repeating == null) {\r\n      if (i < 3) {\r\n        if (i == 0) rd = rd / 100 | 0;\r\n        else if (i == 1) rd = rd / 10 | 0;\r\n        r = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 50000 || rd == 0;\r\n      } else {\r\n        r = (rm < 4 && rd + 1 == k || rm > 3 && rd + 1 == k / 2) &&\r\n          (d[di + 1] / k / 100 | 0) == mathpow(10, i - 2) - 1 ||\r\n            (rd == k / 2 || rd == 0) && (d[di + 1] / k / 100 | 0) == 0;\r\n      }\r\n    } else {\r\n      if (i < 4) {\r\n        if (i == 0) rd = rd / 1000 | 0;\r\n        else if (i == 1) rd = rd / 100 | 0;\r\n        else if (i == 2) rd = rd / 10 | 0;\r\n        r = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;\r\n      } else {\r\n        r = ((repeating || rm < 4) && rd + 1 == k ||\r\n        (!repeating && rm > 3) && rd + 1 == k / 2) &&\r\n          (d[di + 1] / k / 1000 | 0) == mathpow(10, i - 3) - 1;\r\n      }\r\n    }\r\n\r\n    return r;\r\n  }\r\n\r\n\r\n  // Convert string of `baseIn` to an array of numbers of `baseOut`.\r\n  // Eg. convertBase('255', 10, 16) returns [15, 15].\r\n  // Eg. convertBase('ff', 16, 10) returns [2, 5, 5].\r\n  function convertBase(str, baseIn, baseOut) {\r\n    var j,\r\n      arr = [0],\r\n      arrL,\r\n      i = 0,\r\n      strL = str.length;\r\n\r\n    for (; i < strL;) {\r\n      for (arrL = arr.length; arrL--;) arr[arrL] *= baseIn;\r\n      arr[0] += NUMERALS.indexOf(str.charAt(i++));\r\n      for (j = 0; j < arr.length; j++) {\r\n        if (arr[j] > baseOut - 1) {\r\n          if (arr[j + 1] === void 0) arr[j + 1] = 0;\r\n          arr[j + 1] += arr[j] / baseOut | 0;\r\n          arr[j] %= baseOut;\r\n        }\r\n      }\r\n    }\r\n\r\n    return arr.reverse();\r\n  }\r\n\r\n\r\n  /*\r\n   * cos(x) = 1 - x^2/2! + x^4/4! - ...\r\n   * |x| < pi/2\r\n   *\r\n   */\r\n  function cosine(Ctor, x) {\r\n    var k, len, y;\r\n\r\n    if (x.isZero()) return x;\r\n\r\n    // Argument reduction: cos(4x) = 8*(cos^4(x) - cos^2(x)) + 1\r\n    // i.e. cos(x) = 8*(cos^4(x/4) - cos^2(x/4)) + 1\r\n\r\n    // Estimate the optimum number of times to use the argument reduction.\r\n    len = x.d.length;\r\n    if (len < 32) {\r\n      k = Math.ceil(len / 3);\r\n      y = (1 / tinyPow(4, k)).toString();\r\n    } else {\r\n      k = 16;\r\n      y = '2.3283064365386962890625e-10';\r\n    }\r\n\r\n    Ctor.precision += k;\r\n\r\n    x = taylorSeries(Ctor, 1, x.times(y), new Ctor(1));\r\n\r\n    // Reverse argument reduction\r\n    for (var i = k; i--;) {\r\n      var cos2x = x.times(x);\r\n      x = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);\r\n    }\r\n\r\n    Ctor.precision -= k;\r\n\r\n    return x;\r\n  }\r\n\r\n\r\n  /*\r\n   * Perform division in the specified base.\r\n   */\r\n  var divide = (function () {\r\n\r\n    // Assumes non-zero x and k, and hence non-zero result.\r\n    function multiplyInteger(x, k, base) {\r\n      var temp,\r\n        carry = 0,\r\n        i = x.length;\r\n\r\n      for (x = x.slice(); i--;) {\r\n        temp = x[i] * k + carry;\r\n        x[i] = temp % base | 0;\r\n        carry = temp / base | 0;\r\n      }\r\n\r\n      if (carry) x.unshift(carry);\r\n\r\n      return x;\r\n    }\r\n\r\n    function compare(a, b, aL, bL) {\r\n      var i, r;\r\n\r\n      if (aL != bL) {\r\n        r = aL > bL ? 1 : -1;\r\n      } else {\r\n        for (i = r = 0; i < aL; i++) {\r\n          if (a[i] != b[i]) {\r\n            r = a[i] > b[i] ? 1 : -1;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      return r;\r\n    }\r\n\r\n    function subtract(a, b, aL, base) {\r\n      var i = 0;\r\n\r\n      // Subtract b from a.\r\n      for (; aL--;) {\r\n        a[aL] -= i;\r\n        i = a[aL] < b[aL] ? 1 : 0;\r\n        a[aL] = i * base + a[aL] - b[aL];\r\n      }\r\n\r\n      // Remove leading zeros.\r\n      for (; !a[0] && a.length > 1;) a.shift();\r\n    }\r\n\r\n    return function (x, y, pr, rm, dp, base) {\r\n      var cmp, e, i, k, logBase, more, prod, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0,\r\n        yL, yz,\r\n        Ctor = x.constructor,\r\n        sign = x.s == y.s ? 1 : -1,\r\n        xd = x.d,\r\n        yd = y.d;\r\n\r\n      // Either NaN, Infinity or 0?\r\n      if (!xd || !xd[0] || !yd || !yd[0]) {\r\n\r\n        return new Ctor(// Return NaN if either NaN, or both Infinity or 0.\r\n          !x.s || !y.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN :\r\n\r\n          // Return ±0 if x is 0 or y is ±Infinity, or return ±Infinity as y is 0.\r\n          xd && xd[0] == 0 || !yd ? sign * 0 : sign / 0);\r\n      }\r\n\r\n      if (base) {\r\n        logBase = 1;\r\n        e = x.e - y.e;\r\n      } else {\r\n        base = BASE;\r\n        logBase = LOG_BASE;\r\n        e = mathfloor(x.e / logBase) - mathfloor(y.e / logBase);\r\n      }\r\n\r\n      yL = yd.length;\r\n      xL = xd.length;\r\n      q = new Ctor(sign);\r\n      qd = q.d = [];\r\n\r\n      // Result exponent may be one less than e.\r\n      // The digit array of a Decimal from toStringBinary may have trailing zeros.\r\n      for (i = 0; yd[i] == (xd[i] || 0); i++);\r\n\r\n      if (yd[i] > (xd[i] || 0)) e--;\r\n\r\n      if (pr == null) {\r\n        sd = pr = Ctor.precision;\r\n        rm = Ctor.rounding;\r\n      } else if (dp) {\r\n        sd = pr + (x.e - y.e) + 1;\r\n      } else {\r\n        sd = pr;\r\n      }\r\n\r\n      if (sd < 0) {\r\n        qd.push(1);\r\n        more = true;\r\n      } else {\r\n\r\n        // Convert precision in number of base 10 digits to base 1e7 digits.\r\n        sd = sd / logBase + 2 | 0;\r\n        i = 0;\r\n\r\n        // divisor < 1e7\r\n        if (yL == 1) {\r\n          k = 0;\r\n          yd = yd[0];\r\n          sd++;\r\n\r\n          // k is the carry.\r\n          for (; (i < xL || k) && sd--; i++) {\r\n            t = k * base + (xd[i] || 0);\r\n            qd[i] = t / yd | 0;\r\n            k = t % yd | 0;\r\n          }\r\n\r\n          more = k || i < xL;\r\n\r\n        // divisor >= 1e7\r\n        } else {\r\n\r\n          // Normalise xd and yd so highest order digit of yd is >= base/2\r\n          k = base / (yd[0] + 1) | 0;\r\n\r\n          if (k > 1) {\r\n            yd = multiplyInteger(yd, k, base);\r\n            xd = multiplyInteger(xd, k, base);\r\n            yL = yd.length;\r\n            xL = xd.length;\r\n          }\r\n\r\n          xi = yL;\r\n          rem = xd.slice(0, yL);\r\n          remL = rem.length;\r\n\r\n          // Add zeros to make remainder as long as divisor.\r\n          for (; remL < yL;) rem[remL++] = 0;\r\n\r\n          yz = yd.slice();\r\n          yz.unshift(0);\r\n          yd0 = yd[0];\r\n\r\n          if (yd[1] >= base / 2) ++yd0;\r\n\r\n          do {\r\n            k = 0;\r\n\r\n            // Compare divisor and remainder.\r\n            cmp = compare(yd, rem, yL, remL);\r\n\r\n            // If divisor < remainder.\r\n            if (cmp < 0) {\r\n\r\n              // Calculate trial digit, k.\r\n              rem0 = rem[0];\r\n              if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);\r\n\r\n              // k will be how many times the divisor goes into the current remainder.\r\n              k = rem0 / yd0 | 0;\r\n\r\n              //  Algorithm:\r\n              //  1. product = divisor * trial digit (k)\r\n              //  2. if product > remainder: product -= divisor, k--\r\n              //  3. remainder -= product\r\n              //  4. if product was < remainder at 2:\r\n              //    5. compare new remainder and divisor\r\n              //    6. If remainder > divisor: remainder -= divisor, k++\r\n\r\n              if (k > 1) {\r\n                if (k >= base) k = base - 1;\r\n\r\n                // product = divisor * trial digit.\r\n                prod = multiplyInteger(yd, k, base);\r\n                prodL = prod.length;\r\n                remL = rem.length;\r\n\r\n                // Compare product and remainder.\r\n                cmp = compare(prod, rem, prodL, remL);\r\n\r\n                // product > remainder.\r\n                if (cmp == 1) {\r\n                  k--;\r\n\r\n                  // Subtract divisor from product.\r\n                  subtract(prod, yL < prodL ? yz : yd, prodL, base);\r\n                }\r\n              } else {\r\n\r\n                // cmp is -1.\r\n                // If k is 0, there is no need to compare yd and rem again below, so change cmp to 1\r\n                // to avoid it. If k is 1 there is a need to compare yd and rem again below.\r\n                if (k == 0) cmp = k = 1;\r\n                prod = yd.slice();\r\n              }\r\n\r\n              prodL = prod.length;\r\n              if (prodL < remL) prod.unshift(0);\r\n\r\n              // Subtract product from remainder.\r\n              subtract(rem, prod, remL, base);\r\n\r\n              // If product was < previous remainder.\r\n              if (cmp == -1) {\r\n                remL = rem.length;\r\n\r\n                // Compare divisor and new remainder.\r\n                cmp = compare(yd, rem, yL, remL);\r\n\r\n                // If divisor < new remainder, subtract divisor from remainder.\r\n                if (cmp < 1) {\r\n                  k++;\r\n\r\n                  // Subtract divisor from remainder.\r\n                  subtract(rem, yL < remL ? yz : yd, remL, base);\r\n                }\r\n              }\r\n\r\n              remL = rem.length;\r\n            } else if (cmp === 0) {\r\n              k++;\r\n              rem = [0];\r\n            }    // if cmp === 1, k will be 0\r\n\r\n            // Add the next digit, k, to the result array.\r\n            qd[i++] = k;\r\n\r\n            // Update the remainder.\r\n            if (cmp && rem[0]) {\r\n              rem[remL++] = xd[xi] || 0;\r\n            } else {\r\n              rem = [xd[xi]];\r\n              remL = 1;\r\n            }\r\n\r\n          } while ((xi++ < xL || rem[0] !== void 0) && sd--);\r\n\r\n          more = rem[0] !== void 0;\r\n        }\r\n\r\n        // Leading zero?\r\n        if (!qd[0]) qd.shift();\r\n      }\r\n\r\n      // logBase is 1 when divide is being used for base conversion.\r\n      if (logBase == 1) {\r\n        q.e = e;\r\n        inexact = more;\r\n      } else {\r\n\r\n        // To calculate q.e, first get the number of digits of qd[0].\r\n        for (i = 1, k = qd[0]; k >= 10; k /= 10) i++;\r\n        q.e = i + e * logBase - 1;\r\n\r\n        finalise(q, dp ? pr + q.e + 1 : pr, rm, more);\r\n      }\r\n\r\n      return q;\r\n    };\r\n  })();\r\n\r\n\r\n  /*\r\n   * Round `x` to `sd` significant digits using rounding mode `rm`.\r\n   * Check for over/under-flow.\r\n   */\r\n   function finalise(x, sd, rm, isTruncated) {\r\n    var digits, i, j, k, rd, roundUp, w, xd, xdi,\r\n      Ctor = x.constructor;\r\n\r\n    // Don't round if sd is null or undefined.\r\n    out: if (sd != null) {\r\n      xd = x.d;\r\n\r\n      // Infinity/NaN.\r\n      if (!xd) return x;\r\n\r\n      // rd: the rounding digit, i.e. the digit after the digit that may be rounded up.\r\n      // w: the word of xd containing rd, a base 1e7 number.\r\n      // xdi: the index of w within xd.\r\n      // digits: the number of digits of w.\r\n      // i: what would be the index of rd within w if all the numbers were 7 digits long (i.e. if\r\n      // they had leading zeros)\r\n      // j: if > 0, the actual index of rd within w (if < 0, rd is a leading zero).\r\n\r\n      // Get the length of the first word of the digits array xd.\r\n      for (digits = 1, k = xd[0]; k >= 10; k /= 10) digits++;\r\n      i = sd - digits;\r\n\r\n      // Is the rounding digit in the first word of xd?\r\n      if (i < 0) {\r\n        i += LOG_BASE;\r\n        j = sd;\r\n        w = xd[xdi = 0];\r\n\r\n        // Get the rounding digit at index j of w.\r\n        rd = w / mathpow(10, digits - j - 1) % 10 | 0;\r\n      } else {\r\n        xdi = Math.ceil((i + 1) / LOG_BASE);\r\n        k = xd.length;\r\n        if (xdi >= k) {\r\n          if (isTruncated) {\r\n\r\n            // Needed by `naturalExponential`, `naturalLogarithm` and `squareRoot`.\r\n            for (; k++ <= xdi;) xd.push(0);\r\n            w = rd = 0;\r\n            digits = 1;\r\n            i %= LOG_BASE;\r\n            j = i - LOG_BASE + 1;\r\n          } else {\r\n            break out;\r\n          }\r\n        } else {\r\n          w = k = xd[xdi];\r\n\r\n          // Get the number of digits of w.\r\n          for (digits = 1; k >= 10; k /= 10) digits++;\r\n\r\n          // Get the index of rd within w.\r\n          i %= LOG_BASE;\r\n\r\n          // Get the index of rd within w, adjusted for leading zeros.\r\n          // The number of leading zeros of w is given by LOG_BASE - digits.\r\n          j = i - LOG_BASE + digits;\r\n\r\n          // Get the rounding digit at index j of w.\r\n          rd = j < 0 ? 0 : w / mathpow(10, digits - j - 1) % 10 | 0;\r\n        }\r\n      }\r\n\r\n      // Are there any non-zero digits after the rounding digit?\r\n      isTruncated = isTruncated || sd < 0 ||\r\n        xd[xdi + 1] !== void 0 || (j < 0 ? w : w % mathpow(10, digits - j - 1));\r\n\r\n      // The expression `w % mathpow(10, digits - j - 1)` returns all the digits of w to the right\r\n      // of the digit at (left-to-right) index j, e.g. if w is 908714 and j is 2, the expression\r\n      // will give 714.\r\n\r\n      roundUp = rm < 4\r\n        ? (rd || isTruncated) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))\r\n        : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 &&\r\n\r\n          // Check whether the digit to the left of the rounding digit is odd.\r\n          ((i > 0 ? j > 0 ? w / mathpow(10, digits - j) : 0 : xd[xdi - 1]) % 10) & 1 ||\r\n            rm == (x.s < 0 ? 8 : 7));\r\n\r\n      if (sd < 1 || !xd[0]) {\r\n        xd.length = 0;\r\n        if (roundUp) {\r\n\r\n          // Convert sd to decimal places.\r\n          sd -= x.e + 1;\r\n\r\n          // 1, 0.1, 0.01, 0.001, 0.0001 etc.\r\n          xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);\r\n          x.e = -sd || 0;\r\n        } else {\r\n\r\n          // Zero.\r\n          xd[0] = x.e = 0;\r\n        }\r\n\r\n        return x;\r\n      }\r\n\r\n      // Remove excess digits.\r\n      if (i == 0) {\r\n        xd.length = xdi;\r\n        k = 1;\r\n        xdi--;\r\n      } else {\r\n        xd.length = xdi + 1;\r\n        k = mathpow(10, LOG_BASE - i);\r\n\r\n        // E.g. 56700 becomes 56000 if 7 is the rounding digit.\r\n        // j > 0 means i > number of leading zeros of w.\r\n        xd[xdi] = j > 0 ? (w / mathpow(10, digits - j) % mathpow(10, j) | 0) * k : 0;\r\n      }\r\n\r\n      if (roundUp) {\r\n        for (;;) {\r\n\r\n          // Is the digit to be rounded up in the first word of xd?\r\n          if (xdi == 0) {\r\n\r\n            // i will be the length of xd[0] before k is added.\r\n            for (i = 1, j = xd[0]; j >= 10; j /= 10) i++;\r\n            j = xd[0] += k;\r\n            for (k = 1; j >= 10; j /= 10) k++;\r\n\r\n            // if i != k the length has increased.\r\n            if (i != k) {\r\n              x.e++;\r\n              if (xd[0] == BASE) xd[0] = 1;\r\n            }\r\n\r\n            break;\r\n          } else {\r\n            xd[xdi] += k;\r\n            if (xd[xdi] != BASE) break;\r\n            xd[xdi--] = 0;\r\n            k = 1;\r\n          }\r\n        }\r\n      }\r\n\r\n      // Remove trailing zeros.\r\n      for (i = xd.length; xd[--i] === 0;) xd.pop();\r\n    }\r\n\r\n    if (external) {\r\n\r\n      // Overflow?\r\n      if (x.e > Ctor.maxE) {\r\n\r\n        // Infinity.\r\n        x.d = null;\r\n        x.e = NaN;\r\n\r\n      // Underflow?\r\n      } else if (x.e < Ctor.minE) {\r\n\r\n        // Zero.\r\n        x.e = 0;\r\n        x.d = [0];\r\n        // Ctor.underflow = true;\r\n      } // else Ctor.underflow = false;\r\n    }\r\n\r\n    return x;\r\n  }\r\n\r\n\r\n  function finiteToString(x, isExp, sd) {\r\n    if (!x.isFinite()) return nonFiniteToString(x);\r\n    var k,\r\n      e = x.e,\r\n      str = digitsToString(x.d),\r\n      len = str.length;\r\n\r\n    if (isExp) {\r\n      if (sd && (k = sd - len) > 0) {\r\n        str = str.charAt(0) + '.' + str.slice(1) + getZeroString(k);\r\n      } else if (len > 1) {\r\n        str = str.charAt(0) + '.' + str.slice(1);\r\n      }\r\n\r\n      str = str + (x.e < 0 ? 'e' : 'e+') + x.e;\r\n    } else if (e < 0) {\r\n      str = '0.' + getZeroString(-e - 1) + str;\r\n      if (sd && (k = sd - len) > 0) str += getZeroString(k);\r\n    } else if (e >= len) {\r\n      str += getZeroString(e + 1 - len);\r\n      if (sd && (k = sd - e - 1) > 0) str = str + '.' + getZeroString(k);\r\n    } else {\r\n      if ((k = e + 1) < len) str = str.slice(0, k) + '.' + str.slice(k);\r\n      if (sd && (k = sd - len) > 0) {\r\n        if (e + 1 === len) str += '.';\r\n        str += getZeroString(k);\r\n      }\r\n    }\r\n\r\n    return str;\r\n  }\r\n\r\n\r\n  // Calculate the base 10 exponent from the base 1e7 exponent.\r\n  function getBase10Exponent(digits, e) {\r\n    var w = digits[0];\r\n\r\n    // Add the number of digits of the first word of the digits array.\r\n    for ( e *= LOG_BASE; w >= 10; w /= 10) e++;\r\n    return e;\r\n  }\r\n\r\n\r\n  function getLn10(Ctor, sd, pr) {\r\n    if (sd > LN10_PRECISION) {\r\n\r\n      // Reset global state in case the exception is caught.\r\n      external = true;\r\n      if (pr) Ctor.precision = pr;\r\n      throw Error(precisionLimitExceeded);\r\n    }\r\n    return finalise(new Ctor(LN10), sd, 1, true);\r\n  }\r\n\r\n\r\n  function getPi(Ctor, sd, rm) {\r\n    if (sd > PI_PRECISION) throw Error(precisionLimitExceeded);\r\n    return finalise(new Ctor(PI), sd, rm, true);\r\n  }\r\n\r\n\r\n  function getPrecision(digits) {\r\n    var w = digits.length - 1,\r\n      len = w * LOG_BASE + 1;\r\n\r\n    w = digits[w];\r\n\r\n    // If non-zero...\r\n    if (w) {\r\n\r\n      // Subtract the number of trailing zeros of the last word.\r\n      for (; w % 10 == 0; w /= 10) len--;\r\n\r\n      // Add the number of digits of the first word.\r\n      for (w = digits[0]; w >= 10; w /= 10) len++;\r\n    }\r\n\r\n    return len;\r\n  }\r\n\r\n\r\n  function getZeroString(k) {\r\n    var zs = '';\r\n    for (; k--;) zs += '0';\r\n    return zs;\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of Decimal `x` to the power `n`, where `n` is an\r\n   * integer of type number.\r\n   *\r\n   * Implements 'exponentiation by squaring'. Called by `pow` and `parseOther`.\r\n   *\r\n   */\r\n  function intPow(Ctor, x, n, pr) {\r\n    var isTruncated,\r\n      r = new Ctor(1),\r\n\r\n      // Max n of 9007199254740991 takes 53 loop iterations.\r\n      // Maximum digits array length; leaves [28, 34] guard digits.\r\n      k = Math.ceil(pr / LOG_BASE + 4);\r\n\r\n    external = false;\r\n\r\n    for (;;) {\r\n      if (n % 2) {\r\n        r = r.times(x);\r\n        if (truncate(r.d, k)) isTruncated = true;\r\n      }\r\n\r\n      n = mathfloor(n / 2);\r\n      if (n === 0) {\r\n\r\n        // To ensure correct rounding when r.d is truncated, increment the last word if it is zero.\r\n        n = r.d.length - 1;\r\n        if (isTruncated && r.d[n] === 0) ++r.d[n];\r\n        break;\r\n      }\r\n\r\n      x = x.times(x);\r\n      truncate(x.d, k);\r\n    }\r\n\r\n    external = true;\r\n\r\n    return r;\r\n  }\r\n\r\n\r\n  function isOdd(n) {\r\n    return n.d[n.d.length - 1] & 1;\r\n  }\r\n\r\n\r\n  /*\r\n   * Handle `max` and `min`. `ltgt` is 'lt' or 'gt'.\r\n   */\r\n  function maxOrMin(Ctor, args, ltgt) {\r\n    var y,\r\n      x = new Ctor(args[0]),\r\n      i = 0;\r\n\r\n    for (; ++i < args.length;) {\r\n      y = new Ctor(args[i]);\r\n      if (!y.s) {\r\n        x = y;\r\n        break;\r\n      } else if (x[ltgt](y)) {\r\n        x = y;\r\n      }\r\n    }\r\n\r\n    return x;\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the natural exponential of `x` rounded to `sd` significant\r\n   * digits.\r\n   *\r\n   * Taylor/Maclaurin series.\r\n   *\r\n   * exp(x) = x^0/0! + x^1/1! + x^2/2! + x^3/3! + ...\r\n   *\r\n   * Argument reduction:\r\n   *   Repeat x = x / 32, k += 5, until |x| < 0.1\r\n   *   exp(x) = exp(x / 2^k)^(2^k)\r\n   *\r\n   * Previously, the argument was initially reduced by\r\n   * exp(x) = exp(r) * 10^k  where r = x - k * ln10, k = floor(x / ln10)\r\n   * to first put r in the range [0, ln10], before dividing by 32 until |x| < 0.1, but this was\r\n   * found to be slower than just dividing repeatedly by 32 as above.\r\n   *\r\n   * Max integer argument: exp('20723265836946413') = 6.3e+9000000000000000\r\n   * Min integer argument: exp('-20723265836946411') = 1.2e-9000000000000000\r\n   * (Math object integer min/max: Math.exp(709) = 8.2e+307, Math.exp(-745) = 5e-324)\r\n   *\r\n   *  exp(Infinity)  = Infinity\r\n   *  exp(-Infinity) = 0\r\n   *  exp(NaN)       = NaN\r\n   *  exp(±0)        = 1\r\n   *\r\n   *  exp(x) is non-terminating for any finite, non-zero x.\r\n   *\r\n   *  The result will always be correctly rounded.\r\n   *\r\n   */\r\n  function naturalExponential(x, sd) {\r\n    var denominator, guard, j, pow, sum, t, wpr,\r\n      rep = 0,\r\n      i = 0,\r\n      k = 0,\r\n      Ctor = x.constructor,\r\n      rm = Ctor.rounding,\r\n      pr = Ctor.precision;\r\n\r\n    // 0/NaN/Infinity?\r\n    if (!x.d || !x.d[0] || x.e > 17) {\r\n\r\n      return new Ctor(x.d\r\n        ? !x.d[0] ? 1 : x.s < 0 ? 0 : 1 / 0\r\n        : x.s ? x.s < 0 ? 0 : x : 0 / 0);\r\n    }\r\n\r\n    if (sd == null) {\r\n      external = false;\r\n      wpr = pr;\r\n    } else {\r\n      wpr = sd;\r\n    }\r\n\r\n    t = new Ctor(0.03125);\r\n\r\n    // while abs(x) >= 0.1\r\n    while (x.e > -2) {\r\n\r\n      // x = x / 2^5\r\n      x = x.times(t);\r\n      k += 5;\r\n    }\r\n\r\n    // Use 2 * log10(2^k) + 5 (empirically derived) to estimate the increase in precision\r\n    // necessary to ensure the first 4 rounding digits are correct.\r\n    guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;\r\n    wpr += guard;\r\n    denominator = pow = sum = new Ctor(1);\r\n    Ctor.precision = wpr;\r\n\r\n    for (;;) {\r\n      pow = finalise(pow.times(x), wpr, 1);\r\n      denominator = denominator.times(++i);\r\n      t = sum.plus(divide(pow, denominator, wpr, 1));\r\n\r\n      if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {\r\n        j = k;\r\n        while (j--) sum = finalise(sum.times(sum), wpr, 1);\r\n\r\n        // Check to see if the first 4 rounding digits are [49]999.\r\n        // If so, repeat the summation with a higher precision, otherwise\r\n        // e.g. with precision: 18, rounding: 1\r\n        // exp(18.404272462595034083567793919843761) = 98372560.1229999999 (should be 98372560.123)\r\n        // `wpr - guard` is the index of first rounding digit.\r\n        if (sd == null) {\r\n\r\n          if (rep < 3 && checkRoundingDigits(sum.d, wpr - guard, rm, rep)) {\r\n            Ctor.precision = wpr += 10;\r\n            denominator = pow = t = new Ctor(1);\r\n            i = 0;\r\n            rep++;\r\n          } else {\r\n            return finalise(sum, Ctor.precision = pr, rm, external = true);\r\n          }\r\n        } else {\r\n          Ctor.precision = pr;\r\n          return sum;\r\n        }\r\n      }\r\n\r\n      sum = t;\r\n    }\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the natural logarithm of `x` rounded to `sd` significant\r\n   * digits.\r\n   *\r\n   *  ln(-n)        = NaN\r\n   *  ln(0)         = -Infinity\r\n   *  ln(-0)        = -Infinity\r\n   *  ln(1)         = 0\r\n   *  ln(Infinity)  = Infinity\r\n   *  ln(-Infinity) = NaN\r\n   *  ln(NaN)       = NaN\r\n   *\r\n   *  ln(n) (n != 1) is non-terminating.\r\n   *\r\n   */\r\n  function naturalLogarithm(y, sd) {\r\n    var c, c0, denominator, e, numerator, rep, sum, t, wpr, x1, x2,\r\n      n = 1,\r\n      guard = 10,\r\n      x = y,\r\n      xd = x.d,\r\n      Ctor = x.constructor,\r\n      rm = Ctor.rounding,\r\n      pr = Ctor.precision;\r\n\r\n    // Is x negative or Infinity, NaN, 0 or 1?\r\n    if (x.s < 0 || !xd || !xd[0] || !x.e && xd[0] == 1 && xd.length == 1) {\r\n      return new Ctor(xd && !xd[0] ? -1 / 0 : x.s != 1 ? NaN : xd ? 0 : x);\r\n    }\r\n\r\n    if (sd == null) {\r\n      external = false;\r\n      wpr = pr;\r\n    } else {\r\n      wpr = sd;\r\n    }\r\n\r\n    Ctor.precision = wpr += guard;\r\n    c = digitsToString(xd);\r\n    c0 = c.charAt(0);\r\n\r\n    if (Math.abs(e = x.e) < 1.5e15) {\r\n\r\n      // Argument reduction.\r\n      // The series converges faster the closer the argument is to 1, so using\r\n      // ln(a^b) = b * ln(a),   ln(a) = ln(a^b) / b\r\n      // multiply the argument by itself until the leading digits of the significand are 7, 8, 9,\r\n      // 10, 11, 12 or 13, recording the number of multiplications so the sum of the series can\r\n      // later be divided by this number, then separate out the power of 10 using\r\n      // ln(a*10^b) = ln(a) + b*ln(10).\r\n\r\n      // max n is 21 (gives 0.9, 1.0 or 1.1) (9e15 / 21 = 4.2e14).\r\n      //while (c0 < 9 && c0 != 1 || c0 == 1 && c.charAt(1) > 1) {\r\n      // max n is 6 (gives 0.7 - 1.3)\r\n      while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {\r\n        x = x.times(y);\r\n        c = digitsToString(x.d);\r\n        c0 = c.charAt(0);\r\n        n++;\r\n      }\r\n\r\n      e = x.e;\r\n\r\n      if (c0 > 1) {\r\n        x = new Ctor('0.' + c);\r\n        e++;\r\n      } else {\r\n        x = new Ctor(c0 + '.' + c.slice(1));\r\n      }\r\n    } else {\r\n\r\n      // The argument reduction method above may result in overflow if the argument y is a massive\r\n      // number with exponent >= 1500000000000000 (9e15 / 6 = 1.5e15), so instead recall this\r\n      // function using ln(x*10^e) = ln(x) + e*ln(10).\r\n      t = getLn10(Ctor, wpr + 2, pr).times(e + '');\r\n      x = naturalLogarithm(new Ctor(c0 + '.' + c.slice(1)), wpr - guard).plus(t);\r\n      Ctor.precision = pr;\r\n\r\n      return sd == null ? finalise(x, pr, rm, external = true) : x;\r\n    }\r\n\r\n    // x1 is x reduced to a value near 1.\r\n    x1 = x;\r\n\r\n    // Taylor series.\r\n    // ln(y) = ln((1 + x)/(1 - x)) = 2(x + x^3/3 + x^5/5 + x^7/7 + ...)\r\n    // where x = (y - 1)/(y + 1)    (|x| < 1)\r\n    sum = numerator = x = divide(x.minus(1), x.plus(1), wpr, 1);\r\n    x2 = finalise(x.times(x), wpr, 1);\r\n    denominator = 3;\r\n\r\n    for (;;) {\r\n      numerator = finalise(numerator.times(x2), wpr, 1);\r\n      t = sum.plus(divide(numerator, new Ctor(denominator), wpr, 1));\r\n\r\n      if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {\r\n        sum = sum.times(2);\r\n\r\n        // Reverse the argument reduction. Check that e is not 0 because, besides preventing an\r\n        // unnecessary calculation, -0 + 0 = +0 and to ensure correct rounding -0 needs to stay -0.\r\n        if (e !== 0) sum = sum.plus(getLn10(Ctor, wpr + 2, pr).times(e + ''));\r\n        sum = divide(sum, new Ctor(n), wpr, 1);\r\n\r\n        // Is rm > 3 and the first 4 rounding digits 4999, or rm < 4 (or the summation has\r\n        // been repeated previously) and the first 4 rounding digits 9999?\r\n        // If so, restart the summation with a higher precision, otherwise\r\n        // e.g. with precision: 12, rounding: 1\r\n        // ln(135520028.6126091714265381533) = 18.7246299999 when it should be 18.72463.\r\n        // `wpr - guard` is the index of first rounding digit.\r\n        if (sd == null) {\r\n          if (checkRoundingDigits(sum.d, wpr - guard, rm, rep)) {\r\n            Ctor.precision = wpr += guard;\r\n            t = numerator = x = divide(x1.minus(1), x1.plus(1), wpr, 1);\r\n            x2 = finalise(x.times(x), wpr, 1);\r\n            denominator = rep = 1;\r\n          } else {\r\n            return finalise(sum, Ctor.precision = pr, rm, external = true);\r\n          }\r\n        } else {\r\n          Ctor.precision = pr;\r\n          return sum;\r\n        }\r\n      }\r\n\r\n      sum = t;\r\n      denominator += 2;\r\n    }\r\n  }\r\n\r\n\r\n  // ±Infinity, NaN.\r\n  function nonFiniteToString(x) {\r\n    // Unsigned.\r\n    return String(x.s * x.s / 0);\r\n  }\r\n\r\n\r\n  /*\r\n   * Parse the value of a new Decimal `x` from string `str`.\r\n   */\r\n  function parseDecimal(x, str) {\r\n    var e, i, len;\r\n\r\n    // Decimal point?\r\n    if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');\r\n\r\n    // Exponential form?\r\n    if ((i = str.search(/e/i)) > 0) {\r\n\r\n      // Determine exponent.\r\n      if (e < 0) e = i;\r\n      e += +str.slice(i + 1);\r\n      str = str.substring(0, i);\r\n    } else if (e < 0) {\r\n\r\n      // Integer.\r\n      e = str.length;\r\n    }\r\n\r\n    // Determine leading zeros.\r\n    for (i = 0; str.charCodeAt(i) === 48; i++);\r\n\r\n    // Determine trailing zeros.\r\n    for (len = str.length; str.charCodeAt(len - 1) === 48; --len);\r\n    str = str.slice(i, len);\r\n\r\n    if (str) {\r\n      len -= i;\r\n      x.e = e = e - i - 1;\r\n      x.d = [];\r\n\r\n      // Transform base\r\n\r\n      // e is the base 10 exponent.\r\n      // i is where to slice str to get the first word of the digits array.\r\n      i = (e + 1) % LOG_BASE;\r\n      if (e < 0) i += LOG_BASE;\r\n\r\n      if (i < len) {\r\n        if (i) x.d.push(+str.slice(0, i));\r\n        for (len -= LOG_BASE; i < len;) x.d.push(+str.slice(i, i += LOG_BASE));\r\n        str = str.slice(i);\r\n        i = LOG_BASE - str.length;\r\n      } else {\r\n        i -= len;\r\n      }\r\n\r\n      for (; i--;) str += '0';\r\n      x.d.push(+str);\r\n\r\n      if (external) {\r\n\r\n        // Overflow?\r\n        if (x.e > x.constructor.maxE) {\r\n\r\n          // Infinity.\r\n          x.d = null;\r\n          x.e = NaN;\r\n\r\n        // Underflow?\r\n        } else if (x.e < x.constructor.minE) {\r\n\r\n          // Zero.\r\n          x.e = 0;\r\n          x.d = [0];\r\n          // x.constructor.underflow = true;\r\n        } // else x.constructor.underflow = false;\r\n      }\r\n    } else {\r\n\r\n      // Zero.\r\n      x.e = 0;\r\n      x.d = [0];\r\n    }\r\n\r\n    return x;\r\n  }\r\n\r\n\r\n  /*\r\n   * Parse the value of a new Decimal `x` from a string `str`, which is not a decimal value.\r\n   */\r\n  function parseOther(x, str) {\r\n    var base, Ctor, divisor, i, isFloat, len, p, xd, xe;\r\n\r\n    if (str.indexOf('_') > -1) {\r\n      str = str.replace(/(\\d)_(?=\\d)/g, '$1');\r\n      if (isDecimal.test(str)) return parseDecimal(x, str);\r\n    } else if (str === 'Infinity' || str === 'NaN') {\r\n      if (!+str) x.s = NaN;\r\n      x.e = NaN;\r\n      x.d = null;\r\n      return x;\r\n    }\r\n\r\n    if (isHex.test(str))  {\r\n      base = 16;\r\n      str = str.toLowerCase();\r\n    } else if (isBinary.test(str))  {\r\n      base = 2;\r\n    } else if (isOctal.test(str))  {\r\n      base = 8;\r\n    } else {\r\n      throw Error(invalidArgument + str);\r\n    }\r\n\r\n    // Is there a binary exponent part?\r\n    i = str.search(/p/i);\r\n\r\n    if (i > 0) {\r\n      p = +str.slice(i + 1);\r\n      str = str.substring(2, i);\r\n    } else {\r\n      str = str.slice(2);\r\n    }\r\n\r\n    // Convert `str` as an integer then divide the result by `base` raised to a power such that the\r\n    // fraction part will be restored.\r\n    i = str.indexOf('.');\r\n    isFloat = i >= 0;\r\n    Ctor = x.constructor;\r\n\r\n    if (isFloat) {\r\n      str = str.replace('.', '');\r\n      len = str.length;\r\n      i = len - i;\r\n\r\n      // log[10](16) = 1.2041... , log[10](88) = 1.9444....\r\n      divisor = intPow(Ctor, new Ctor(base), i, i * 2);\r\n    }\r\n\r\n    xd = convertBase(str, base, BASE);\r\n    xe = xd.length - 1;\r\n\r\n    // Remove trailing zeros.\r\n    for (i = xe; xd[i] === 0; --i) xd.pop();\r\n    if (i < 0) return new Ctor(x.s * 0);\r\n    x.e = getBase10Exponent(xd, xe);\r\n    x.d = xd;\r\n    external = false;\r\n\r\n    // At what precision to perform the division to ensure exact conversion?\r\n    // maxDecimalIntegerPartDigitCount = ceil(log[10](b) * otherBaseIntegerPartDigitCount)\r\n    // log[10](2) = 0.30103, log[10](8) = 0.90309, log[10](16) = 1.20412\r\n    // E.g. ceil(1.2 * 3) = 4, so up to 4 decimal digits are needed to represent 3 hex int digits.\r\n    // maxDecimalFractionPartDigitCount = {Hex:4|Oct:3|Bin:1} * otherBaseFractionPartDigitCount\r\n    // Therefore using 4 * the number of digits of str will always be enough.\r\n    if (isFloat) x = divide(x, divisor, len * 4);\r\n\r\n    // Multiply by the binary exponent part if present.\r\n    if (p) x = x.times(Math.abs(p) < 54 ? mathpow(2, p) : Decimal.pow(2, p));\r\n    external = true;\r\n\r\n    return x;\r\n  }\r\n\r\n\r\n  /*\r\n   * sin(x) = x - x^3/3! + x^5/5! - ...\r\n   * |x| < pi/2\r\n   *\r\n   */\r\n  function sine(Ctor, x) {\r\n    var k,\r\n      len = x.d.length;\r\n\r\n    if (len < 3) {\r\n      return x.isZero() ? x : taylorSeries(Ctor, 2, x, x);\r\n    }\r\n\r\n    // Argument reduction: sin(5x) = 16*sin^5(x) - 20*sin^3(x) + 5*sin(x)\r\n    // i.e. sin(x) = 16*sin^5(x/5) - 20*sin^3(x/5) + 5*sin(x/5)\r\n    // and  sin(x) = sin(x/5)(5 + sin^2(x/5)(16sin^2(x/5) - 20))\r\n\r\n    // Estimate the optimum number of times to use the argument reduction.\r\n    k = 1.4 * Math.sqrt(len);\r\n    k = k > 16 ? 16 : k | 0;\r\n\r\n    x = x.times(1 / tinyPow(5, k));\r\n    x = taylorSeries(Ctor, 2, x, x);\r\n\r\n    // Reverse argument reduction\r\n    var sin2_x,\r\n      d5 = new Ctor(5),\r\n      d16 = new Ctor(16),\r\n      d20 = new Ctor(20);\r\n    for (; k--;) {\r\n      sin2_x = x.times(x);\r\n      x = x.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));\r\n    }\r\n\r\n    return x;\r\n  }\r\n\r\n\r\n  // Calculate Taylor series for `cos`, `cosh`, `sin` and `sinh`.\r\n  function taylorSeries(Ctor, n, x, y, isHyperbolic) {\r\n    var j, t, u, x2,\r\n      i = 1,\r\n      pr = Ctor.precision,\r\n      k = Math.ceil(pr / LOG_BASE);\r\n\r\n    external = false;\r\n    x2 = x.times(x);\r\n    u = new Ctor(y);\r\n\r\n    for (;;) {\r\n      t = divide(u.times(x2), new Ctor(n++ * n++), pr, 1);\r\n      u = isHyperbolic ? y.plus(t) : y.minus(t);\r\n      y = divide(t.times(x2), new Ctor(n++ * n++), pr, 1);\r\n      t = u.plus(y);\r\n\r\n      if (t.d[k] !== void 0) {\r\n        for (j = k; t.d[j] === u.d[j] && j--;);\r\n        if (j == -1) break;\r\n      }\r\n\r\n      j = u;\r\n      u = y;\r\n      y = t;\r\n      t = j;\r\n      i++;\r\n    }\r\n\r\n    external = true;\r\n    t.d.length = k + 1;\r\n\r\n    return t;\r\n  }\r\n\r\n\r\n  // Exponent e must be positive and non-zero.\r\n  function tinyPow(b, e) {\r\n    var n = b;\r\n    while (--e) n *= b;\r\n    return n;\r\n  }\r\n\r\n\r\n  // Return the absolute value of `x` reduced to less than or equal to half pi.\r\n  function toLessThanHalfPi(Ctor, x) {\r\n    var t,\r\n      isNeg = x.s < 0,\r\n      pi = getPi(Ctor, Ctor.precision, 1),\r\n      halfPi = pi.times(0.5);\r\n\r\n    x = x.abs();\r\n\r\n    if (x.lte(halfPi)) {\r\n      quadrant = isNeg ? 4 : 1;\r\n      return x;\r\n    }\r\n\r\n    t = x.divToInt(pi);\r\n\r\n    if (t.isZero()) {\r\n      quadrant = isNeg ? 3 : 2;\r\n    } else {\r\n      x = x.minus(t.times(pi));\r\n\r\n      // 0 <= x < pi\r\n      if (x.lte(halfPi)) {\r\n        quadrant = isOdd(t) ? (isNeg ? 2 : 3) : (isNeg ? 4 : 1);\r\n        return x;\r\n      }\r\n\r\n      quadrant = isOdd(t) ? (isNeg ? 1 : 4) : (isNeg ? 3 : 2);\r\n    }\r\n\r\n    return x.minus(pi).abs();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return the value of Decimal `x` as a string in base `baseOut`.\r\n   *\r\n   * If the optional `sd` argument is present include a binary exponent suffix.\r\n   */\r\n  function toStringBinary(x, baseOut, sd, rm) {\r\n    var base, e, i, k, len, roundUp, str, xd, y,\r\n      Ctor = x.constructor,\r\n      isExp = sd !== void 0;\r\n\r\n    if (isExp) {\r\n      checkInt32(sd, 1, MAX_DIGITS);\r\n      if (rm === void 0) rm = Ctor.rounding;\r\n      else checkInt32(rm, 0, 8);\r\n    } else {\r\n      sd = Ctor.precision;\r\n      rm = Ctor.rounding;\r\n    }\r\n\r\n    if (!x.isFinite()) {\r\n      str = nonFiniteToString(x);\r\n    } else {\r\n      str = finiteToString(x);\r\n      i = str.indexOf('.');\r\n\r\n      // Use exponential notation according to `toExpPos` and `toExpNeg`? No, but if required:\r\n      // maxBinaryExponent = floor((decimalExponent + 1) * log[2](10))\r\n      // minBinaryExponent = floor(decimalExponent * log[2](10))\r\n      // log[2](10) = 3.321928094887362347870319429489390175864\r\n\r\n      if (isExp) {\r\n        base = 2;\r\n        if (baseOut == 16) {\r\n          sd = sd * 4 - 3;\r\n        } else if (baseOut == 8) {\r\n          sd = sd * 3 - 2;\r\n        }\r\n      } else {\r\n        base = baseOut;\r\n      }\r\n\r\n      // Convert the number as an integer then divide the result by its base raised to a power such\r\n      // that the fraction part will be restored.\r\n\r\n      // Non-integer.\r\n      if (i >= 0) {\r\n        str = str.replace('.', '');\r\n        y = new Ctor(1);\r\n        y.e = str.length - i;\r\n        y.d = convertBase(finiteToString(y), 10, base);\r\n        y.e = y.d.length;\r\n      }\r\n\r\n      xd = convertBase(str, 10, base);\r\n      e = len = xd.length;\r\n\r\n      // Remove trailing zeros.\r\n      for (; xd[--len] == 0;) xd.pop();\r\n\r\n      if (!xd[0]) {\r\n        str = isExp ? '0p+0' : '0';\r\n      } else {\r\n        if (i < 0) {\r\n          e--;\r\n        } else {\r\n          x = new Ctor(x);\r\n          x.d = xd;\r\n          x.e = e;\r\n          x = divide(x, y, sd, rm, 0, base);\r\n          xd = x.d;\r\n          e = x.e;\r\n          roundUp = inexact;\r\n        }\r\n\r\n        // The rounding digit, i.e. the digit after the digit that may be rounded up.\r\n        i = xd[sd];\r\n        k = base / 2;\r\n        roundUp = roundUp || xd[sd + 1] !== void 0;\r\n\r\n        roundUp = rm < 4\r\n          ? (i !== void 0 || roundUp) && (rm === 0 || rm === (x.s < 0 ? 3 : 2))\r\n          : i > k || i === k && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 ||\r\n            rm === (x.s < 0 ? 8 : 7));\r\n\r\n        xd.length = sd;\r\n\r\n        if (roundUp) {\r\n\r\n          // Rounding up may mean the previous digit has to be rounded up and so on.\r\n          for (; ++xd[--sd] > base - 1;) {\r\n            xd[sd] = 0;\r\n            if (!sd) {\r\n              ++e;\r\n              xd.unshift(1);\r\n            }\r\n          }\r\n        }\r\n\r\n        // Determine trailing zeros.\r\n        for (len = xd.length; !xd[len - 1]; --len);\r\n\r\n        // E.g. [4, 11, 15] becomes 4bf.\r\n        for (i = 0, str = ''; i < len; i++) str += NUMERALS.charAt(xd[i]);\r\n\r\n        // Add binary exponent suffix?\r\n        if (isExp) {\r\n          if (len > 1) {\r\n            if (baseOut == 16 || baseOut == 8) {\r\n              i = baseOut == 16 ? 4 : 3;\r\n              for (--len; len % i; len++) str += '0';\r\n              xd = convertBase(str, base, baseOut);\r\n              for (len = xd.length; !xd[len - 1]; --len);\r\n\r\n              // xd[0] will always be be 1\r\n              for (i = 1, str = '1.'; i < len; i++) str += NUMERALS.charAt(xd[i]);\r\n            } else {\r\n              str = str.charAt(0) + '.' + str.slice(1);\r\n            }\r\n          }\r\n\r\n          str =  str + (e < 0 ? 'p' : 'p+') + e;\r\n        } else if (e < 0) {\r\n          for (; ++e;) str = '0' + str;\r\n          str = '0.' + str;\r\n        } else {\r\n          if (++e > len) for (e -= len; e-- ;) str += '0';\r\n          else if (e < len) str = str.slice(0, e) + '.' + str.slice(e);\r\n        }\r\n      }\r\n\r\n      str = (baseOut == 16 ? '0x' : baseOut == 2 ? '0b' : baseOut == 8 ? '0o' : '') + str;\r\n    }\r\n\r\n    return x.s < 0 ? '-' + str : str;\r\n  }\r\n\r\n\r\n  // Does not strip trailing zeros.\r\n  function truncate(arr, len) {\r\n    if (arr.length > len) {\r\n      arr.length = len;\r\n      return true;\r\n    }\r\n  }\r\n\r\n\r\n  // Decimal methods\r\n\r\n\r\n  /*\r\n   *  abs\r\n   *  acos\r\n   *  acosh\r\n   *  add\r\n   *  asin\r\n   *  asinh\r\n   *  atan\r\n   *  atanh\r\n   *  atan2\r\n   *  cbrt\r\n   *  ceil\r\n   *  clamp\r\n   *  clone\r\n   *  config\r\n   *  cos\r\n   *  cosh\r\n   *  div\r\n   *  exp\r\n   *  floor\r\n   *  hypot\r\n   *  ln\r\n   *  log\r\n   *  log2\r\n   *  log10\r\n   *  max\r\n   *  min\r\n   *  mod\r\n   *  mul\r\n   *  pow\r\n   *  random\r\n   *  round\r\n   *  set\r\n   *  sign\r\n   *  sin\r\n   *  sinh\r\n   *  sqrt\r\n   *  sub\r\n   *  sum\r\n   *  tan\r\n   *  tanh\r\n   *  trunc\r\n   */\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the absolute value of `x`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function abs(x) {\r\n    return new this(x).abs();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the arccosine in radians of `x`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function acos(x) {\r\n    return new this(x).acos();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the inverse of the hyperbolic cosine of `x`, rounded to\r\n   * `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\r\n  function acosh(x) {\r\n    return new this(x).acosh();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the sum of `x` and `y`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   * y {number|string|Decimal}\r\n   *\r\n   */\r\n  function add(x, y) {\r\n    return new this(x).plus(y);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the arcsine in radians of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function asin(x) {\r\n    return new this(x).asin();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the inverse of the hyperbolic sine of `x`, rounded to\r\n   * `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\r\n  function asinh(x) {\r\n    return new this(x).asinh();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the arctangent in radians of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function atan(x) {\r\n    return new this(x).atan();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the inverse of the hyperbolic tangent of `x`, rounded to\r\n   * `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\r\n  function atanh(x) {\r\n    return new this(x).atanh();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the arctangent in radians of `y/x` in the range -pi to pi\r\n   * (inclusive), rounded to `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-pi, pi]\r\n   *\r\n   * y {number|string|Decimal} The y-coordinate.\r\n   * x {number|string|Decimal} The x-coordinate.\r\n   *\r\n   * atan2(±0, -0)               = ±pi\r\n   * atan2(±0, +0)               = ±0\r\n   * atan2(±0, -x)               = ±pi for x > 0\r\n   * atan2(±0, x)                = ±0 for x > 0\r\n   * atan2(-y, ±0)               = -pi/2 for y > 0\r\n   * atan2(y, ±0)                = pi/2 for y > 0\r\n   * atan2(±y, -Infinity)        = ±pi for finite y > 0\r\n   * atan2(±y, +Infinity)        = ±0 for finite y > 0\r\n   * atan2(±Infinity, x)         = ±pi/2 for finite x\r\n   * atan2(±Infinity, -Infinity) = ±3*pi/4\r\n   * atan2(±Infinity, +Infinity) = ±pi/4\r\n   * atan2(NaN, x) = NaN\r\n   * atan2(y, NaN) = NaN\r\n   *\r\n   */\r\n  function atan2(y, x) {\r\n    y = new this(y);\r\n    x = new this(x);\r\n    var r,\r\n      pr = this.precision,\r\n      rm = this.rounding,\r\n      wpr = pr + 4;\r\n\r\n    // Either NaN\r\n    if (!y.s || !x.s) {\r\n      r = new this(NaN);\r\n\r\n    // Both ±Infinity\r\n    } else if (!y.d && !x.d) {\r\n      r = getPi(this, wpr, 1).times(x.s > 0 ? 0.25 : 0.75);\r\n      r.s = y.s;\r\n\r\n    // x is ±Infinity or y is ±0\r\n    } else if (!x.d || y.isZero()) {\r\n      r = x.s < 0 ? getPi(this, pr, rm) : new this(0);\r\n      r.s = y.s;\r\n\r\n    // y is ±Infinity or x is ±0\r\n    } else if (!y.d || x.isZero()) {\r\n      r = getPi(this, wpr, 1).times(0.5);\r\n      r.s = y.s;\r\n\r\n    // Both non-zero and finite\r\n    } else if (x.s < 0) {\r\n      this.precision = wpr;\r\n      this.rounding = 1;\r\n      r = this.atan(divide(y, x, wpr, 1));\r\n      x = getPi(this, wpr, 1);\r\n      this.precision = pr;\r\n      this.rounding = rm;\r\n      r = y.s < 0 ? r.minus(x) : r.plus(x);\r\n    } else {\r\n      r = this.atan(divide(y, x, wpr, 1));\r\n    }\r\n\r\n    return r;\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the cube root of `x`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function cbrt(x) {\r\n    return new this(x).cbrt();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` rounded to an integer using `ROUND_CEIL`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function ceil(x) {\r\n    return finalise(x = new this(x), x.e + 1, 2);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` clamped to the range delineated by `min` and `max`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   * min {number|string|Decimal}\r\n   * max {number|string|Decimal}\r\n   *\r\n   */\r\n  function clamp(x, min, max) {\r\n    return new this(x).clamp(min, max);\r\n  }\r\n\r\n\r\n  /*\r\n   * Configure global settings for a Decimal constructor.\r\n   *\r\n   * `obj` is an object with one or more of the following properties,\r\n   *\r\n   *   precision  {number}\r\n   *   rounding   {number}\r\n   *   toExpNeg   {number}\r\n   *   toExpPos   {number}\r\n   *   maxE       {number}\r\n   *   minE       {number}\r\n   *   modulo     {number}\r\n   *   crypto     {boolean|number}\r\n   *   defaults   {true}\r\n   *\r\n   * E.g. Decimal.config({ precision: 20, rounding: 4 })\r\n   *\r\n   */\r\n  function config(obj) {\r\n    if (!obj || typeof obj !== 'object') throw Error(decimalError + 'Object expected');\r\n    var i, p, v,\r\n      useDefaults = obj.defaults === true,\r\n      ps = [\r\n        'precision', 1, MAX_DIGITS,\r\n        'rounding', 0, 8,\r\n        'toExpNeg', -EXP_LIMIT, 0,\r\n        'toExpPos', 0, EXP_LIMIT,\r\n        'maxE', 0, EXP_LIMIT,\r\n        'minE', -EXP_LIMIT, 0,\r\n        'modulo', 0, 9\r\n      ];\r\n\r\n    for (i = 0; i < ps.length; i += 3) {\r\n      if (p = ps[i], useDefaults) this[p] = DEFAULTS[p];\r\n      if ((v = obj[p]) !== void 0) {\r\n        if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2]) this[p] = v;\r\n        else throw Error(invalidArgument + p + ': ' + v);\r\n      }\r\n    }\r\n\r\n    if (p = 'crypto', useDefaults) this[p] = DEFAULTS[p];\r\n    if ((v = obj[p]) !== void 0) {\r\n      if (v === true || v === false || v === 0 || v === 1) {\r\n        if (v) {\r\n          if (typeof crypto != 'undefined' && crypto &&\r\n            (crypto.getRandomValues || crypto.randomBytes)) {\r\n            this[p] = true;\r\n          } else {\r\n            throw Error(cryptoUnavailable);\r\n          }\r\n        } else {\r\n          this[p] = false;\r\n        }\r\n      } else {\r\n        throw Error(invalidArgument + p + ': ' + v);\r\n      }\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the cosine of `x`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\r\n  function cos(x) {\r\n    return new this(x).cos();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the hyperbolic cosine of `x`, rounded to precision\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\r\n  function cosh(x) {\r\n    return new this(x).cosh();\r\n  }\r\n\r\n\r\n  /*\r\n   * Create and return a Decimal constructor with the same configuration properties as this Decimal\r\n   * constructor.\r\n   *\r\n   */\r\n  function clone(obj) {\r\n    var i, p, ps;\r\n\r\n    /*\r\n     * The Decimal constructor and exported function.\r\n     * Return a new Decimal instance.\r\n     *\r\n     * v {number|string|Decimal} A numeric value.\r\n     *\r\n     */\r\n    function Decimal(v) {\r\n      var e, i, t,\r\n        x = this;\r\n\r\n      // Decimal called without new.\r\n      if (!(x instanceof Decimal)) return new Decimal(v);\r\n\r\n      // Retain a reference to this Decimal constructor, and shadow Decimal.prototype.constructor\r\n      // which points to Object.\r\n      x.constructor = Decimal;\r\n\r\n      // Duplicate.\r\n      if (isDecimalInstance(v)) {\r\n        x.s = v.s;\r\n\r\n        if (external) {\r\n          if (!v.d || v.e > Decimal.maxE) {\r\n\r\n            // Infinity.\r\n            x.e = NaN;\r\n            x.d = null;\r\n          } else if (v.e < Decimal.minE) {\r\n\r\n            // Zero.\r\n            x.e = 0;\r\n            x.d = [0];\r\n          } else {\r\n            x.e = v.e;\r\n            x.d = v.d.slice();\r\n          }\r\n        } else {\r\n          x.e = v.e;\r\n          x.d = v.d ? v.d.slice() : v.d;\r\n        }\r\n\r\n        return;\r\n      }\r\n\r\n      t = typeof v;\r\n\r\n      if (t === 'number') {\r\n        if (v === 0) {\r\n          x.s = 1 / v < 0 ? -1 : 1;\r\n          x.e = 0;\r\n          x.d = [0];\r\n          return;\r\n        }\r\n\r\n        if (v < 0) {\r\n          v = -v;\r\n          x.s = -1;\r\n        } else {\r\n          x.s = 1;\r\n        }\r\n\r\n        // Fast path for small integers.\r\n        if (v === ~~v && v < 1e7) {\r\n          for (e = 0, i = v; i >= 10; i /= 10) e++;\r\n\r\n          if (external) {\r\n            if (e > Decimal.maxE) {\r\n              x.e = NaN;\r\n              x.d = null;\r\n            } else if (e < Decimal.minE) {\r\n              x.e = 0;\r\n              x.d = [0];\r\n            } else {\r\n              x.e = e;\r\n              x.d = [v];\r\n            }\r\n          } else {\r\n            x.e = e;\r\n            x.d = [v];\r\n          }\r\n\r\n          return;\r\n\r\n        // Infinity, NaN.\r\n        } else if (v * 0 !== 0) {\r\n          if (!v) x.s = NaN;\r\n          x.e = NaN;\r\n          x.d = null;\r\n          return;\r\n        }\r\n\r\n        return parseDecimal(x, v.toString());\r\n\r\n      } else if (t !== 'string') {\r\n        throw Error(invalidArgument + v);\r\n      }\r\n\r\n      // Minus sign?\r\n      if ((i = v.charCodeAt(0)) === 45) {\r\n        v = v.slice(1);\r\n        x.s = -1;\r\n      } else {\r\n        // Plus sign?\r\n        if (i === 43) v = v.slice(1);\r\n        x.s = 1;\r\n      }\r\n\r\n      return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);\r\n    }\r\n\r\n    Decimal.prototype = P;\r\n\r\n    Decimal.ROUND_UP = 0;\r\n    Decimal.ROUND_DOWN = 1;\r\n    Decimal.ROUND_CEIL = 2;\r\n    Decimal.ROUND_FLOOR = 3;\r\n    Decimal.ROUND_HALF_UP = 4;\r\n    Decimal.ROUND_HALF_DOWN = 5;\r\n    Decimal.ROUND_HALF_EVEN = 6;\r\n    Decimal.ROUND_HALF_CEIL = 7;\r\n    Decimal.ROUND_HALF_FLOOR = 8;\r\n    Decimal.EUCLID = 9;\r\n\r\n    Decimal.config = Decimal.set = config;\r\n    Decimal.clone = clone;\r\n    Decimal.isDecimal = isDecimalInstance;\r\n\r\n    Decimal.abs = abs;\r\n    Decimal.acos = acos;\r\n    Decimal.acosh = acosh;        // ES6\r\n    Decimal.add = add;\r\n    Decimal.asin = asin;\r\n    Decimal.asinh = asinh;        // ES6\r\n    Decimal.atan = atan;\r\n    Decimal.atanh = atanh;        // ES6\r\n    Decimal.atan2 = atan2;\r\n    Decimal.cbrt = cbrt;          // ES6\r\n    Decimal.ceil = ceil;\r\n    Decimal.clamp = clamp;\r\n    Decimal.cos = cos;\r\n    Decimal.cosh = cosh;          // ES6\r\n    Decimal.div = div;\r\n    Decimal.exp = exp;\r\n    Decimal.floor = floor;\r\n    Decimal.hypot = hypot;        // ES6\r\n    Decimal.ln = ln;\r\n    Decimal.log = log;\r\n    Decimal.log10 = log10;        // ES6\r\n    Decimal.log2 = log2;          // ES6\r\n    Decimal.max = max;\r\n    Decimal.min = min;\r\n    Decimal.mod = mod;\r\n    Decimal.mul = mul;\r\n    Decimal.pow = pow;\r\n    Decimal.random = random;\r\n    Decimal.round = round;\r\n    Decimal.sign = sign;          // ES6\r\n    Decimal.sin = sin;\r\n    Decimal.sinh = sinh;          // ES6\r\n    Decimal.sqrt = sqrt;\r\n    Decimal.sub = sub;\r\n    Decimal.sum = sum;\r\n    Decimal.tan = tan;\r\n    Decimal.tanh = tanh;          // ES6\r\n    Decimal.trunc = trunc;        // ES6\r\n\r\n    if (obj === void 0) obj = {};\r\n    if (obj) {\r\n      if (obj.defaults !== true) {\r\n        ps = ['precision', 'rounding', 'toExpNeg', 'toExpPos', 'maxE', 'minE', 'modulo', 'crypto'];\r\n        for (i = 0; i < ps.length;) if (!obj.hasOwnProperty(p = ps[i++])) obj[p] = this[p];\r\n      }\r\n    }\r\n\r\n    Decimal.config(obj);\r\n\r\n    return Decimal;\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` divided by `y`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   * y {number|string|Decimal}\r\n   *\r\n   */\r\n  function div(x, y) {\r\n    return new this(x).div(y);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the natural exponential of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} The power to which to raise the base of the natural log.\r\n   *\r\n   */\r\n  function exp(x) {\r\n    return new this(x).exp();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` round to an integer using `ROUND_FLOOR`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function floor(x) {\r\n    return finalise(x = new this(x), x.e + 1, 3);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the square root of the sum of the squares of the arguments,\r\n   * rounded to `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * hypot(a, b, ...) = sqrt(a^2 + b^2 + ...)\r\n   *\r\n   * arguments {number|string|Decimal}\r\n   *\r\n   */\r\n  function hypot() {\r\n    var i, n,\r\n      t = new this(0);\r\n\r\n    external = false;\r\n\r\n    for (i = 0; i < arguments.length;) {\r\n      n = new this(arguments[i++]);\r\n      if (!n.d) {\r\n        if (n.s) {\r\n          external = true;\r\n          return new this(1 / 0);\r\n        }\r\n        t = n;\r\n      } else if (t.d) {\r\n        t = t.plus(n.times(n));\r\n      }\r\n    }\r\n\r\n    external = true;\r\n\r\n    return t.sqrt();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return true if object is a Decimal instance (where Decimal is any Decimal constructor),\r\n   * otherwise return false.\r\n   *\r\n   */\r\n  function isDecimalInstance(obj) {\r\n    return obj instanceof Decimal || obj && obj.toStringTag === tag || false;\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the natural logarithm of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function ln(x) {\r\n    return new this(x).ln();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the log of `x` to the base `y`, or to base 10 if no base\r\n   * is specified, rounded to `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * log[y](x)\r\n   *\r\n   * x {number|string|Decimal} The argument of the logarithm.\r\n   * y {number|string|Decimal} The base of the logarithm.\r\n   *\r\n   */\r\n  function log(x, y) {\r\n    return new this(x).log(y);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the base 2 logarithm of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function log2(x) {\r\n    return new this(x).log(2);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the base 10 logarithm of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function log10(x) {\r\n    return new this(x).log(10);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the maximum of the arguments.\r\n   *\r\n   * arguments {number|string|Decimal}\r\n   *\r\n   */\r\n  function max() {\r\n    return maxOrMin(this, arguments, 'lt');\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the minimum of the arguments.\r\n   *\r\n   * arguments {number|string|Decimal}\r\n   *\r\n   */\r\n  function min() {\r\n    return maxOrMin(this, arguments, 'gt');\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` modulo `y`, rounded to `precision` significant digits\r\n   * using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   * y {number|string|Decimal}\r\n   *\r\n   */\r\n  function mod(x, y) {\r\n    return new this(x).mod(y);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` multiplied by `y`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   * y {number|string|Decimal}\r\n   *\r\n   */\r\n  function mul(x, y) {\r\n    return new this(x).mul(y);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` raised to the power `y`, rounded to precision\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} The base.\r\n   * y {number|string|Decimal} The exponent.\r\n   *\r\n   */\r\n  function pow(x, y) {\r\n    return new this(x).pow(y);\r\n  }\r\n\r\n\r\n  /*\r\n   * Returns a new Decimal with a random value equal to or greater than 0 and less than 1, and with\r\n   * `sd`, or `Decimal.precision` if `sd` is omitted, significant digits (or less if trailing zeros\r\n   * are produced).\r\n   *\r\n   * [sd] {number} Significant digits. Integer, 0 to MAX_DIGITS inclusive.\r\n   *\r\n   */\r\n  function random(sd) {\r\n    var d, e, k, n,\r\n      i = 0,\r\n      r = new this(1),\r\n      rd = [];\r\n\r\n    if (sd === void 0) sd = this.precision;\r\n    else checkInt32(sd, 1, MAX_DIGITS);\r\n\r\n    k = Math.ceil(sd / LOG_BASE);\r\n\r\n    if (!this.crypto) {\r\n      for (; i < k;) rd[i++] = Math.random() * 1e7 | 0;\r\n\r\n    // Browsers supporting crypto.getRandomValues.\r\n    } else if (crypto.getRandomValues) {\r\n      d = crypto.getRandomValues(new Uint32Array(k));\r\n\r\n      for (; i < k;) {\r\n        n = d[i];\r\n\r\n        // 0 <= n < 4294967296\r\n        // Probability n >= 4.29e9, is 4967296 / 4294967296 = 0.00116 (1 in 865).\r\n        if (n >= 4.29e9) {\r\n          d[i] = crypto.getRandomValues(new Uint32Array(1))[0];\r\n        } else {\r\n\r\n          // 0 <= n <= 4289999999\r\n          // 0 <= (n % 1e7) <= 9999999\r\n          rd[i++] = n % 1e7;\r\n        }\r\n      }\r\n\r\n    // Node.js supporting crypto.randomBytes.\r\n    } else if (crypto.randomBytes) {\r\n\r\n      // buffer\r\n      d = crypto.randomBytes(k *= 4);\r\n\r\n      for (; i < k;) {\r\n\r\n        // 0 <= n < 2147483648\r\n        n = d[i] + (d[i + 1] << 8) + (d[i + 2] << 16) + ((d[i + 3] & 0x7f) << 24);\r\n\r\n        // Probability n >= 2.14e9, is 7483648 / 2147483648 = 0.0035 (1 in 286).\r\n        if (n >= 2.14e9) {\r\n          crypto.randomBytes(4).copy(d, i);\r\n        } else {\r\n\r\n          // 0 <= n <= 2139999999\r\n          // 0 <= (n % 1e7) <= 9999999\r\n          rd.push(n % 1e7);\r\n          i += 4;\r\n        }\r\n      }\r\n\r\n      i = k / 4;\r\n    } else {\r\n      throw Error(cryptoUnavailable);\r\n    }\r\n\r\n    k = rd[--i];\r\n    sd %= LOG_BASE;\r\n\r\n    // Convert trailing digits to zeros according to sd.\r\n    if (k && sd) {\r\n      n = mathpow(10, LOG_BASE - sd);\r\n      rd[i] = (k / n | 0) * n;\r\n    }\r\n\r\n    // Remove trailing words which are zero.\r\n    for (; rd[i] === 0; i--) rd.pop();\r\n\r\n    // Zero?\r\n    if (i < 0) {\r\n      e = 0;\r\n      rd = [0];\r\n    } else {\r\n      e = -1;\r\n\r\n      // Remove leading words which are zero and adjust exponent accordingly.\r\n      for (; rd[0] === 0; e -= LOG_BASE) rd.shift();\r\n\r\n      // Count the digits of the first word of rd to determine leading zeros.\r\n      for (k = 1, n = rd[0]; n >= 10; n /= 10) k++;\r\n\r\n      // Adjust the exponent for leading zeros of the first word of rd.\r\n      if (k < LOG_BASE) e -= LOG_BASE - k;\r\n    }\r\n\r\n    r.e = e;\r\n    r.d = rd;\r\n\r\n    return r;\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` rounded to an integer using rounding mode `rounding`.\r\n   *\r\n   * To emulate `Math.round`, set rounding to 7 (ROUND_HALF_CEIL).\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function round(x) {\r\n    return finalise(x = new this(x), x.e + 1, this.rounding);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return\r\n   *   1    if x > 0,\r\n   *  -1    if x < 0,\r\n   *   0    if x is 0,\r\n   *  -0    if x is -0,\r\n   *   NaN  otherwise\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function sign(x) {\r\n    x = new this(x);\r\n    return x.d ? (x.d[0] ? x.s : 0 * x.s) : x.s || NaN;\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the sine of `x`, rounded to `precision` significant digits\r\n   * using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\r\n  function sin(x) {\r\n    return new this(x).sin();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the hyperbolic sine of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\r\n  function sinh(x) {\r\n    return new this(x).sinh();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the square root of `x`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function sqrt(x) {\r\n    return new this(x).sqrt();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` minus `y`, rounded to `precision` significant digits\r\n   * using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   * y {number|string|Decimal}\r\n   *\r\n   */\r\n  function sub(x, y) {\r\n    return new this(x).sub(y);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the sum of the arguments, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * Only the result is rounded, not the intermediate calculations.\r\n   *\r\n   * arguments {number|string|Decimal}\r\n   *\r\n   */\r\n  function sum() {\r\n    var i = 0,\r\n      args = arguments,\r\n      x = new this(args[i]);\r\n\r\n    external = false;\r\n    for (; x.s && ++i < args.length;) x = x.plus(args[i]);\r\n    external = true;\r\n\r\n    return finalise(x, this.precision, this.rounding);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the tangent of `x`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\r\n  function tan(x) {\r\n    return new this(x).tan();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the hyperbolic tangent of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\r\n  function tanh(x) {\r\n    return new this(x).tanh();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` truncated to an integer.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function trunc(x) {\r\n    return finalise(x = new this(x), x.e + 1, 1);\r\n  }\r\n\r\n\r\n  // Create and configure initial Decimal constructor.\r\n  Decimal = clone(DEFAULTS);\r\n  Decimal.prototype.constructor = Decimal;\r\n  Decimal['default'] = Decimal.Decimal = Decimal;\r\n\r\n  // Create the internal constants from their string values.\r\n  LN10 = new Decimal(LN10);\r\n  PI = new Decimal(PI);\r\n\r\n\r\n  // Export.\r\n\r\n\r\n  // AMD.\r\n  if (typeof define == 'function' && define.amd) {\r\n    define(function () {\r\n      return Decimal;\r\n    });\r\n\r\n  // Node and other environments that support module.exports.\r\n  } else if (typeof module != 'undefined' && module.exports) {\r\n    if (typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol') {\r\n      P[Symbol['for']('nodejs.util.inspect.custom')] = P.toString;\r\n      P[Symbol.toStringTag] = 'Decimal';\r\n    }\r\n\r\n    module.exports = Decimal;\r\n\r\n  // Browser.\r\n  } else {\r\n    if (!globalScope) {\r\n      globalScope = typeof self != 'undefined' && self && self.self == self ? self : window;\r\n    }\r\n\r\n    noConflict = globalScope.Decimal;\r\n    Decimal.noConflict = function () {\r\n      globalScope.Decimal = noConflict;\r\n      return Decimal;\r\n    };\r\n\r\n    globalScope.Decimal = Decimal;\r\n  }\r\n})(this);\r\n\n},{}],2:[function(require,module,exports){\n/**\n* Fable Core Pre-initialization Service Base\n*\n* For a couple services, we need to be able to instantiate them before the Fable object is fully initialized.\n* This is a base class for those services.\n*\n* @author <steven@velozo.com>\n*/\n\nclass FableCoreServiceProviderBase\n{\n\tconstructor(pOptions, pServiceHash)\n\t{\n\t\tthis.fable = false;\n\n\t\tthis.options = (typeof(pOptions) === 'object') ? pOptions : {};\n\n\t\tthis.serviceType = 'Unknown';\n\n\t\t// The hash will be a non-standard UUID ... the UUID service uses this base class!\n\t\tthis.UUID = `CORESVC-${Math.floor((Math.random() * (99999 - 10000)) + 10000)}`;\n\n\t\tthis.Hash = (typeof(pServiceHash) === 'string') ? pServiceHash : `${this.UUID}`;\n\t}\n\n\n\tstatic isFableService = true;\n\n\t// After fable is initialized, it would be expected to be wired in as a normal service.\n\tconnectFable(pFable)\n\t{\n\t\tthis.fable = pFable;\n\n\t\treturn true;\n\t}\n}\n\nmodule.exports = FableCoreServiceProviderBase;\n\n},{}],3:[function(require,module,exports){\n/**\n* Fable Service Base\n* @author <steven@velozo.com>\n*/\n\nclass FableServiceProviderBase\n{\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tthis.fable = pFable;\n\n\t\tthis.options = (typeof(pOptions) === 'object') ? pOptions\n\t\t\t\t\t\t: ((typeof(pFable) === 'object') && !pFable.isFable) ? pFable\n\t\t\t\t\t\t: {};\n\n\t\tthis.serviceType = 'Unknown';\n\n\t\tif (typeof(pFable.getUUID) == 'function')\n\t\t{\n\t\t\tthis.UUID = pFable.getUUID();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.UUID = `NoFABLESVC-${Math.floor((Math.random() * (99999 - 10000)) + 10000)}`\n\t\t}\n\n\t\tthis.Hash = (typeof(pServiceHash) === 'string') ? pServiceHash : `${this.UUID}`;\n\n\t\t// Pull back a few things\n\t\tthis.log = this.fable.log;\n\t\tthis.servicesMap = this.fable.serviceMap;\n\t\tthis.services = this.fable.services;\n\t}\n\n\tstatic isFableService = true;\n}\n\nmodule.exports = FableServiceProviderBase;\n\nmodule.exports.CoreServiceProviderBase = require('./Fable-ServiceProviderBase-Preinit.js');\n},{\"./Fable-ServiceProviderBase-Preinit.js\":2}],4:[function(require,module,exports){\n/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\n\n/**\n* Instruction Set Bace Class.\n*\n* @class ElucidatorInstructionSet\n*/\nclass ElucidatorInstructionSet\n{\n    constructor(pElucidator)\n    {\n        this.elucidator = pElucidator;\n\n        this.namespace = 'default';\n    }\n\n    // Create an empty namespace for instructions and operations if either one doesn't exist\n    initializeNamespace(pNamespace)\n    {\n        if (typeof(pNamespace) == 'string')\n        {\n            this.namespace = pNamespace;\n        }\n        if (!this.elucidator.instructionSets.hasOwnProperty(this.namespace))\n        {\n            this.elucidator.instructionSets[this.namespace.toLowerCase()] = {};\n        }\n        if (!this.elucidator.operationSets.hasOwnProperty(this.namespace))\n        {\n            this.elucidator.operationSets[this.namespace.toLowerCase()] = {};\n        }\n    }\n\n    // Add an instruction to the set\n    addInstruction(pInstructionHash, fInstructionFunction)\n    {\n        if (typeof(pInstructionHash) != 'string')\n        {\n            this.elucidator.log.error(`Attempted to add an instruction with an invalid hash; expected a string but the instruction hash type was ${typeof(pInstructionHash)}`);\n            return false;\n        }\n        if (typeof(fInstructionFunction) != 'function')\n        {\n            this.elucidator.log.error(`Attempted to add an instruction with an invalid function; expected a function but type was ${typeof(fInstructionFunction)}`);\n            return false;\n        }\n\n        this.elucidator.instructionSets[this.namespace.toLowerCase()][pInstructionHash] = fInstructionFunction;\n        return true;\n    }\n\n    initializeInstructions()\n    {\n        // This is where we map in the instructions.\n        // If the extending class calls super it will inject a harmless noop into the scope.\n        // It isn't recommended to do these inline as lambdas, but this code is generally not expected to be called.\n        // Unless the developer wants a noop in their instruction set...........\n        this.addInstruction('noop', \n            (pOperation) =>\n            {\n                pOperation.log.info('Executing a no-operation operation.');\n                return true;\n            });\n\n        return true;\n    }\n\n    // Add an operation to the set\n    addOperation(pOperationHash, pOperation)\n    {\n        if (typeof(pOperationHash) != 'string')\n        {\n            this.elucidator.log.error(`Attempted to add an operation with an invalid hash; expected a string but the operation hash type was ${typeof(pOperationHash)}`, pOperation);\n            return false;\n        }\n        if (typeof(pOperation) != 'object')\n        {\n            this.elucidator.log.error(`Attempted to add an invalid operation; expected an object data type but the type was ${typeof(pOperation)}`, pOperation);\n            return false;\n        }\n        // Validate the Description subobject, which is key to functioning.\n        if (!pOperation.hasOwnProperty(\"Description\"))\n        {\n            this.elucidator.log.error(`Attempted to add an operation with an invalid description; no Description subobject set.`, pOperation);\n            return false;\n        }\n        if (typeof(pOperation.Description) != 'object')\n        {\n            this.elucidator.log.error(`Attempted to add an operation with an invalid description; Description subobject was not an object.  The type was ${typeof(pOperation.Description)}.`, pOperation);\n            return false;\n        }\n        if (typeof(pOperation.Description.Hash) != 'string')\n        {\n            if (typeof(pOperation.Description.Operation) == 'string')\n            {\n                // Use the \"Operation\" as the \"Hash\"\n                pOperation.Description.Hash = pOperation.Description.Operation;\n            }\n            else\n            {\n                this.elucidator.log.error(`Attempted to add an operation with an invalid description; Description subobject did not contain a valid Hash which is required to call the operation.`, pOperation);\n                return false;\n            }\n        }\n\n        // Now auto create data if it is missing or wrong in the Description\n        if ((typeof(pOperation.Description.Namespace) != 'string') || (pOperation.Description.Namespace != this.namespace))\n        {\n            pOperation.Description.Namespace = this.namespace;\n        }\n        if (typeof(pOperation.Description.Summary) != 'string')\n        {\n            pOperation.Description.Summary = `[${pOperation.Description.Namespace}] [${pOperation.Description.Hash}] operation.`;\n        }\n\n        // If there are no inputs, or outputs, or steps, add them.\n        if (!pOperation.hasOwnProperty('Inputs'))\n        {\n            pOperation.Inputs = {};\n        }\n        if (!pOperation.hasOwnProperty('Outputs'))\n        {\n            pOperation.Outputs = {};\n        }\n        if (!pOperation.hasOwnProperty('Steps'))\n        {\n            pOperation.Steps = [];\n        }\n\n        // If there are no inputs, or outputs, or steps, add them.\n        // TODO: Add a step where we try to load this into Manyfest and see that it's valid.\n        if (typeof(pOperation.Inputs) !== 'object')\n        {\n            this.elucidator.log.error(`Attempted to add an operation with an invalid Inputs object.`, pOperation);\n            return false;\n        }\n        // If there are no inputs, or outputs, or steps, add them.\n        // TODO: Add a step where we try to load this into Manyfest and see that it's valid.\n        if (typeof(pOperation.Outputs) !== 'object')\n        {\n            this.elucidator.log.error(`Attempted to add an operation with an invalid Outputs object.`, pOperation);\n            return false;\n        }\n        if (!Array.isArray(pOperation.Steps))\n        {\n            this.elucidator.log.error(`Attempted to add an operation with an invalid Steps array.`, pOperation);\n            return false;\n        }\n\n\n        this.elucidator.operationSets[this.namespace.toLowerCase()][pOperationHash.toLowerCase()] = pOperation;\n        return true;\n    }\n\n    initializeOperations()\n    {\n        this.addOperation('noop', \n            {\n                \"Description\":\n                {\n                    \"Operation\": \"noop\",\n                    \"Description\": \"No operation - no affect on any data.\"\n                }\n            });\n\n        return true;\n    }\n};\n\nmodule.exports = ElucidatorInstructionSet;\n},{}],5:[function(require,module,exports){\n/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\nconst libFableServiceProviderBase = require('fable-serviceproviderbase');\nconst libElucidatorInstructionSet = require('./Elucidator-InstructionSet.js');\n\n/**\n* Elucidator object address-based descriptions and manipulations.\n*\n* @class Elucidator\n*/\nclass Elucidator extends libFableServiceProviderBase\n{\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tsuper(pFable, pOptions, pServiceHash);\n\n\t\t// Instructions are the basic building blocks for operations\n\t\tthis.instructionSets = {};\n\n\t\t// Operations are the solvers that can be called (instructions can't be called directly)\n\t\t// These can be added at run-time as well\n\t\tthis.operationSets = {};\n\n\t\t// Decide later how to make this truly unique.\n\t\tthis.UUID = 0;\n\n\t\tthis.loadDefaultInstructionSets();\n\n\t\tif (this.options.OperationSet)\n\t\t{\n\t\t\tlet tmpSolverHashes = Object.keys(this.options.OperationSet);\n\t\t\tfor (let i = 0; i < tmpSolverHashes.length; i++)\n\t\t\t{\n\t\t\t\tthis.addOperation('Custom',tmpSolverHashes[i], this.options.OperationSet[tmpSolverHashes[i]]);\n\t\t\t}\n\t\t}\n    }\n\n\t// Load an instruction set\n\tloadInstructionSet(cInstructionSet)\n\t{\n\t\tlet tmpInstructionSet = new cInstructionSet(this);\n\t\t// Setup the namespace\n\t\ttmpInstructionSet.initializeNamespace();\n\t\ttmpInstructionSet.initializeInstructions();\n\t\ttmpInstructionSet.initializeOperations();\n\t}\n\n\tloadDefaultInstructionSets()\n\t{\n\t\t// The javascript math instructions and operations\n\t\t// These provide the \"Math\" namespace\n\t\tthis.loadInstructionSet(require(`./InstructionSets/Math-Javascript.js`));\n\n\t\t// A precision javascript math library that is consistent across browsers, stable and without mantissa issues\n\t\t// Uses Decimal.js\n\t\t// These provide the \"PreciseMath\" namespace\n\t\tthis.loadInstructionSet(require(`./InstructionSets/PreciseMath-Decimal.js`));\n\n\t\t// The abstract geometry instructions and operations (rectangle area, circle area, etc.)\n\t\t// These provide the \"Geometry\" namespace\n\t\tthis.loadInstructionSet(require(`./InstructionSets/Geometry.js`));\n\n\t\t// The logic operations (if, execution of instructions, etc.)\n\t\t// These provide the \"Logic\" namespace\n\t\tthis.loadInstructionSet(require(`./InstructionSets/Logic.js`));\n\n\t\t// Basic string manipulation instructions and operations\n\t\t// These provide the \"String\" namespace\n\t\tthis.loadInstructionSet(require(`./InstructionSets/String.js`));\n\n\t\t// Basic set manipulation instructions and operations\n\t\t// These provide the \"Set\" namespace\n\t\tthis.loadInstructionSet(require(`./InstructionSets/Set.js`));\n\t}\n\n\toperationExists(pNamespace, pOperationHash)\n\t{\n\t\tif ((typeof(pNamespace) != 'string') || (typeof(pOperationHash) != 'string'))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\tlet tmpNamespace = pNamespace.toLowerCase();\n\t\treturn (this.operationSets.hasOwnProperty(tmpNamespace) && this.operationSets[tmpNamespace].hasOwnProperty(pOperationHash.toLowerCase()));\n\t}\n\n\taddOperation(pNamespace, pOperationHash, pOperation)\n\t{\n        if (typeof(pNamespace) != 'string')\n        {\n            this.log.error(`Attempted to add an operation at runtime via Elucidator.addOperation with an invalid namespace; expected a string but the type was ${typeof(pNamespace)}`, pOperation);\n            return false;\n        }\n\n\t\tlet tmpOperationInjector = new libElucidatorInstructionSet(this);\n\t\ttmpOperationInjector.initializeNamespace(pNamespace);\n\n\t\treturn tmpOperationInjector.addOperation(pOperationHash, pOperation);\n\t}\n\n\tsolveInternalOperation(pNamespace, pOperationHash, pInputObject, pOutputObject, pDescriptionManyfest, pInputAddressMapping, pOutputAddressMapping, pSolutionContext)\n\t{\n\t\tif (!this.operationExists(pNamespace, pOperationHash))\n\t\t{\n\t\t\tthis.log.error(`Attempted to solveInternalOperation for namespace ${pNamespace} operationHash ${pOperationHash} but the operation was not found.`);\n\t\t\t// TODO: Should this return something with an error log populated?\n\t\t\treturn false;\n\t\t}\n\t\tlet tmpOperation = this.operationSets[pNamespace.toLowerCase()][pOperationHash.toLowerCase()];\n\t\treturn this.solveOperation(tmpOperation, pInputObject, pOutputObject, pDescriptionManyfest, pInputAddressMapping, pOutputAddressMapping, pSolutionContext);\n\t}\n\n\tsolveOperation(pOperationObject, pInputObject, pOutputObject, pDescriptionManyfest, pInputAddressMapping, pOutputAddressMapping, pSolutionContext)\n\t{\n\t\tlet tmpOperation = JSON.parse(JSON.stringify(pOperationObject));\n\n\t\tif (typeof(pInputObject) != 'object')\n\t\t{\n            this.log.error(`Attempted to run a solve but the passed in Input was not an object.  The type was ${typeof(pInputObject)}.`);\n\t\t\treturn false;\n\t\t}\n\t\tlet tmpInputObject = pInputObject;\n\n\t\t// Default to reusing the input object as the output object.\n\t\tlet tmpOutputObject = tmpInputObject;\n\n\t\t// This is how recursive solutions bind their context together.\n\t\tlet tmpSolutionContext = pSolutionContext;\n\t\tif (typeof(tmpSolutionContext) === 'undefined')\n\t\t{\n\t\t\ttmpSolutionContext = (\n\t\t\t\t{\n\t\t\t\t\t\"SolutionGUID\": `Solution-${this.UUID++}`, \n\t\t\t\t\t\"SolutionBaseNamespace\": pOperationObject.Description.Namespace,\n\t\t\t\t\t\"SolutionBaseOperation\": pOperationObject.Description.Operation,\n\t\t\t\t\t\"SolutionLog\": []\n\t\t\t\t});\n\t\t\t\n\t\t\t// This is the root operation, see if there are Inputs and Outputs created ... if not, create them.\n\t\t\tif (!tmpOperation.hasOwnProperty('Inputs'))\n\t\t\t{\n\t\t\t\ttmpOperation.Inputs = {};\n\t\t\t}\n\t\t\tif (!tmpOperation.hasOwnProperty('Outputs'))\n\t\t\t{\n\t\t\t\ttmpOperation.Outputs = {};\n\t\t\t}\n\n\t\t\t// This is the root Operation, see if there is a hash translation available for either side (input or output)\n\t\t\tif (tmpOperation.hasOwnProperty('InputHashTranslationTable'))\n\t\t\t{\n\t\t\t\ttmpSolutionContext.InputHashMapping = JSON.parse(JSON.stringify(tmpOperation.InputHashTranslationTable));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttmpSolutionContext.InputHashMapping = {};\n\t\t\t}\n\n\t\t\tif (tmpOperation.hasOwnProperty('OutputHashTranslationTable'))\n\t\t\t{\n\t\t\t\ttmpSolutionContext.OutputHashMapping = JSON.parse(JSON.stringify(tmpOperation.OutputHashTranslationTable));\n\t\t\t}\n\n\t\t\tif ((typeof(pOutputObject) != 'object')\n\t\t\t\t&& (typeof(tmpOutputHashMapping) == 'undefined') \n\t\t\t\t&& (typeof(tmpInputHashMapping) != 'undefined'))\n\t\t\t{\n\t\t\t\t// Reuse the input hash mapping if:\n\t\t\t\t//   1) we auto-mapped the input hash mapping to the output because only an input object was supplied\n\t\t\t\t//   2) there *was not* an output hash mapping supplied\n\t\t\t\t//   3) there *was* an input hash mapping supplied\n\t\t\t\t//\n\t\t\t\t// This seems simple at first but exposes some really interesting behaviors in terms of\n\t\t\t\t// reusing the same object and schema for input and output, but having different hash\n\t\t\t\t// mappings for each of them.\n\t\t\t\ttmpSolutionContext.OutputHashMapping = tmpSolutionContext.InputHashMapping;\n\t\t\t}\n\t\t}\n\n\t\tif (typeof(pOutputObject) == 'object')\n\t\t{\n\t\t\t// If the call defined an explicit, different output object from the input object use that instead.\n\t\t\ttmpOutputObject = pOutputObject;\n\t\t}\n\n\t\tlet tmpDescriptionManyfest = false;\n\t\tif (typeof(pDescriptionManyfest) === 'undefined')\n\t\t{\n\t\t\t// We are going to use this for some clever schema manipulations, then recreate the object\n\t\t\ttmpDescriptionManyfest = this.fable.serviceManager.instantiateServiceProviderWithoutRegistration('Manifest');\n\t\t\t// Synthesize a manyfest from the Input and Output properties\n\t\t\tlet tmpManyfestSchema = (\n\t\t\t\t{\n\t\t\t\t\tScope: 'Solver Data Part Descriptions',\n\t\t\t\t\tDescriptors: tmpDescriptionManyfest.schemaManipulations.mergeAddressMappings(tmpOperation.Inputs, tmpOperation.Outputs)\n\t\t\t\t});\n\t\t\t}\n\t\telse\n\t\t{\n\t\t\t// Clone the passed-in manyfest, so mutations do not alter the upstream version\n\t\t\ttmpDescriptionManyfest = pDescriptionManyfest.clone();\n\t\t}\n\t\t// Now that the operation object has been created uniquely, apply any passed-in address-hash and hash-hash remappings\n\t\tif (pInputAddressMapping)\n\t\t{\n\t\t\ttmpDescriptionManyfest.schemaManipulations.resolveAddressMappings(tmpOperation.Inputs, pInputAddressMapping);\n\t\t}\n\t\tif (pOutputAddressMapping)\n\t\t{\n\t\t\ttmpDescriptionManyfest.schemaManipulations.resolveAddressMappings(tmpOperation.Inputs, pOutputAddressMapping);\n\t\t}\n\t\tif (tmpSolutionContext.InputHashMapping)\n\t\t{\n\t\t\ttmpDescriptionManyfest.hashTranslations.addTranslation(tmpSolutionContext.InputHashMapping);\n\t\t}\n\t\tif (tmpSolutionContext.OutputHashMapping)\n\t\t{\n\t\t\ttmpDescriptionManyfest.hashTranslations.addTranslation(tmpSolutionContext.OutputHashMapping);\t\t\t\n\t\t}\n\n\n\t\t// Set some kind of unique identifier for the operation\n\t\ttmpOperation.UUID = this.UUID++;\n\t\ttmpOperation.SolutionContext = tmpSolutionContext;\n\n\t\tif (tmpOperation.Description.Synopsys)\n\t\t{\n\t\t\ttmpSolutionContext.SolutionLog.push(`[${tmpOperation.UUID}]: Solver running operation ${tmpOperation.Description.Synopsys}`);\n\t\t}\n\n\t\tlet tmpPrecedent = this.fable.serviceManager.instantiateServiceProviderWithoutRegistration('MetaTemplate');\n\t\ttmpPrecedent.addPattern('{{Name:', '}}',\n\t\t\t(pHash)=>\n\t\t\t{\n\t\t\t\tlet tmpHash = pHash.trim();\n\t\t\t\tlet tmpDescriptor = tmpDescriptionManyfest.getDescriptorByHash(tmpHash)\n\n\t\t\t\t// Return a human readable value\n\t\t\t\tif ((typeof(tmpDescriptor) == 'object')  && tmpDescriptor.hasOwnProperty('Name'))\n\t\t\t\t{\n\t\t\t\t\treturn tmpDescriptor.Name;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treturn tmpHash;\n\t\t\t\t}\n\t\t\t});\n\t\ttmpPrecedent.addPattern('{{InputValue:', '}}',\n\t\t\t(pHash)=>\n\t\t\t{\n\t\t\t\tlet tmpHash = pHash.trim();\n\t\t\t\treturn tmpDescriptionManyfest.getValueByHash(tmpInputObject,tmpHash);\n\t\t\t});\n\t\ttmpPrecedent.addPattern('{{OutputValue:', '}}',\n\t\t\t(pHash)=>\n\t\t\t{\n\t\t\t\tlet tmpHash = pHash.trim();\n\t\t\t\treturn tmpDescriptionManyfest.getValueByHash(tmpOutputObject,tmpHash);\n\t\t\t});\n\n\t\tif (tmpOperation.hasOwnProperty('Log') && tmpOperation.Log.hasOwnProperty('PreOperation'))\n\t\t{\n\t\t\tif (typeof(tmpOperation.Log.PreOperation) == 'string')\n\t\t\t{\n\t\t\t\ttmpOperation.SolutionContext.SolutionLog.push(tmpPrecedent.parseString(tmpOperation.Log.PreOperation));\n\t\t\t}\n\t\t\telse if (Array.isArray(tmpOperation.Log.PreOperation))\n\t\t\t{\n\t\t\t\tfor (let i = 0; i < tmpOperation.Log.PreOperation.length; i++)\n\t\t\t\t{\n\t\t\t\t\tif ((typeof(tmpOperation.Log.PreOperation[i]) == 'string'))\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpOperation.SolutionContext.SolutionLog.push(tmpPrecedent.parseString(tmpOperation.Log.PreOperation[i]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Now step through each operation and solve\n\t\tfor (let i = 0; i < tmpOperation.Steps.length; i++)\n\t\t{\n\t\t\tlet tmpStep = tmpOperation.Steps[i];\n\n\t\t\t// Instructions are always endpoints -- they *do not* recurse.\n\t\t\tif (tmpStep.hasOwnProperty('Instruction'))\n\t\t\t{\n\t\t\t\tlet tmpInputSchema = (\n\t\t\t\t\t{\n\t\t\t\t\t\t\"Scope\": \"InputObject\",\n\t\t\t\t\t\t\"Descriptors\": JSON.parse(JSON.stringify(tmpOperation.Inputs))\n\t\t\t\t\t});\n\t\t\t\t// Perform step-specific address mappings.\n\t\t\t\ttmpDescriptionManyfest.schemaManipulations.resolveAddressMappings(tmpInputSchema.Descriptors, tmpStep.InputHashAddressMap);\n\t\t\t\tlet tmpInputManyfest = this.fable.serviceManager.instantiateServiceProviderWithoutRegistration('Manifest', tmpInputSchema);\n\t\t\t\tif (tmpSolutionContext.InputHashMapping)\n\t\t\t\t{\n\t\t\t\t\ttmpInputManyfest.hashTranslations.addTranslation(tmpSolutionContext.InputHashMapping);\n\t\t\t\t}\n\n\t\t\t\tlet tmpOutputSchema = (\n\t\t\t\t\t{\n\t\t\t\t\t\t\"Scope\": \"OutputObject\",\n\t\t\t\t\t\t\"Descriptors\": JSON.parse(JSON.stringify(tmpOperation.Outputs))\n\t\t\t\t\t});\n\t\t\t\t\ttmpDescriptionManyfest.schemaManipulations.resolveAddressMappings(tmpOutputSchema.Descriptors, tmpStep.OutputHashAddressMap);\n\t\t\t\tlet tmpOutputManyfest = this.fable.serviceManager.instantiateServiceProviderWithoutRegistration('Manifest', tmpOutputSchema);\n\t\t\t\tif (tmpSolutionContext.OutputHashMapping)\n\t\t\t\t{\n\t\t\t\t\ttmpOutputManyfest.hashTranslations.addTranslation(tmpSolutionContext.OutputHashMapping);\n\t\t\t\t}\n\t\n\t\t\t\t// Construct the instruction state object\n\t\t\t\tlet tmpInstructionState = (\n\t\t\t\t{\n\t\t\t\t\tElucidator: this,\n\n\t\t\t\t\tNamespace: tmpStep.Namespace.toLowerCase(),\n\t\t\t\t\tInstruction: tmpStep.Instruction.toLowerCase(),\n\n\t\t\t\t\tOperation: tmpOperation,\n\n\t\t\t\t\tSolutionContext: tmpSolutionContext,\n\n\t\t\t\t\tDescriptionManyfest: tmpDescriptionManyfest,\n\n\t\t\t\t\tInputObject: tmpInputObject,\n\t\t\t\t\tInputManyfest: tmpInputManyfest,\n\n\t\t\t\t\tOutputObject: tmpOutputObject,\n\t\t\t\t\tOutputManyfest: tmpOutputManyfest\n\t\t\t\t});\n\n\t\t\t\ttmpInstructionState.logError = \n\t\t\t\t\t(pMessage) => \n\t\t\t\t\t{\n\t\t\t\t\t\tlet tmpErrorMessage = `[Operation ${tmpInstructionState.Operation.Description.Namespace}:${tmpInstructionState.Operation.Description.Hash} - Step #${i}:${tmpStep.Namespace}:${tmpStep.Instruction}] ${pMessage}`;\n\t\t\t\t\t\tthis.log.error(tmpErrorMessage)\n\t\t\t\t\t\ttmpSolutionContext.SolutionLog.push(`[ERROR]${tmpErrorMessage}`)\n\t\t\t\t\t};\n\n\t\t\t\ttmpInstructionState.logInfo = \n\t\t\t\t\t(pMessage) => \n\t\t\t\t\t{\n\t\t\t\t\t\tlet tmpInfoMessage = `[Operation ${tmpInstructionState.Operation.Description.Namespace}:${tmpInstructionState.Operation.Description.Hash} - Step #${i}:${tmpStep.Namespace}:${tmpStep.Instruction}] ${pMessage}`;\n\t\t\t\t\t\ttmpSolutionContext.SolutionLog.push(`[INFO]${tmpInfoMessage}`)\n\t\t\t\t\t};\n\n\t\t\t\tif (this.instructionSets[tmpInstructionState.Namespace].hasOwnProperty(tmpInstructionState.Instruction))\n\t\t\t\t{\n\t\t\t\t\tlet fInstruction = this.instructionSets[tmpInstructionState.Namespace][tmpInstructionState.Instruction];\n\t\t\t\t\tfInstruction(tmpInstructionState);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Operations recurse.\n\t\t\tif (tmpStep.hasOwnProperty('Operation'))\n\t\t\t{\n\t\t\t\tif (typeof(tmpStep.Operation) == 'string')\n\t\t\t\t{\n\t\t\t\t\tthis.solveInternalOperation(tmpStep.Namespace, tmpStep.Operation, tmpInputObject, tmpOutputObject, tmpDescriptionManyfest, tmpStep.InputHashAddressMap, tmpStep.OutputHashAddressMap, tmpSolutionContext);\n\t\t\t\t}\n\t\t\t\telse if (typeof(tmpStep.Operation) == 'object')\n\t\t\t\t{\n\t\t\t\t\t// You can even define an inline object operation!  This gets crazy fast\n\t\t\t\t\tthis.solveOperation(tmpStep.Operation, tmpInputObject, tmpOutputObject, tmpDescriptionManyfest, tmpStep.InputHashAddressMap, tmpStep.OutputHashAddressMap, tmpSolutionContext);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (tmpOperation.hasOwnProperty('Log') && tmpOperation.Log.hasOwnProperty('PostOperation'))\n\t\t{\n\t\t\tif (typeof(tmpOperation.Log.PostOperation) == 'string')\n\t\t\t{\n\t\t\t\ttmpOperation.SolutionContext.SolutionLog.push(tmpPrecedent.parseString(tmpOperation.Log.PostOperation));\n\t\t\t}\n\t\t\telse if (Array.isArray(tmpOperation.Log.PreOperation))\n\t\t\t{\n\t\t\t\tfor (let i = 0; i < tmpOperation.Log.PostOperation.length; i++)\n\t\t\t\t{\n\t\t\t\t\tif ((typeof(tmpOperation.Log.PostOperation[i]) == 'string'))\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpOperation.SolutionContext.SolutionLog.push(tmpPrecedent.parseString(tmpOperation.Log.PostOperation[i]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn tmpSolutionContext;\n\t}\n};\n\nmodule.exports = Elucidator;\n},{\"./Elucidator-InstructionSet.js\":4,\"./InstructionSets/Geometry.js\":6,\"./InstructionSets/Logic.js\":7,\"./InstructionSets/Math-Javascript.js\":8,\"./InstructionSets/PreciseMath-Decimal.js\":32,\"./InstructionSets/Set.js\":33,\"./InstructionSets/String.js\":34,\"fable-serviceproviderbase\":3}],6:[function(require,module,exports){\n// Solution providers are meant to be stateless, and not classes.\n// These solution providers are akin to drivers, connecting code libraries or \n// other types of behavior to mapping operations.\n\nlet libElucidatorInstructionSet = require('../Elucidator-InstructionSet.js');\n\nclass Geometry extends libElucidatorInstructionSet\n{\n    constructor(pElucidator)\n    {\n        super(pElucidator);\n        this.namespace = 'Geometry';\n    }\n\n    // Geometry provides no instructions\n    initializeInstructions()\n    {\n        return true;\n    }\n\n    initializeOperations()\n    {\n        this.addOperation('rectanglearea', require(`./Operations/Geometry-RectangleArea.json`));\n\n        return true;\n    }\n}\n\nmodule.exports = Geometry;\n},{\"../Elucidator-InstructionSet.js\":4,\"./Operations/Geometry-RectangleArea.json\":9}],7:[function(require,module,exports){\n// Solution providers are meant to be stateless, and not classes.\n// These solution providers are akin to drivers, connecting code libraries or \n// other types of behavior to mapping operations.\n\nlet libElucidatorInstructionSet = require('../Elucidator-InstructionSet.js');\n\nconst ifInstruction = (pOperation) =>\n{\n    let tmpLeftValue = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'leftValue');\n    let tmpRightValue = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'rightValue');\n    let tmpComparator = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'comparator').toString().toLowerCase();\n\n    let tmpComparisonOperator = 'equal';\n\n    // This may eventually come from configuration; for now just leave it here.\n    let tmpComparisonOperatorMapping = (\n        {\n            '==':'equal',\n            'eq':'equal',\n            'equal':'equal',\n\n            '!=':'notequal',\n            'noteq':'notequal',\n            'notequal':'notequal',\n\n            '===':'identity',\n            'id':'identity',\n            'identity':'identity',\n\n            '>':'greaterthan',\n            'gt':'greaterthan',\n            'greaterthan':'greaterthan',\n\n            '>=':'greaterthanorequal',\n            'gte':'greaterthanorequal',\n            'greaterthanorequal':'greaterthanorequal',\n\n            '<':'lessthan',\n            'lt':'lessthan',\n            'lessthan':'lessthan',\n\n            '<=':'lessthanorequal',\n            'lte':'lessthanorequal',\n            'lessthanorequal':'lessthanorequal'\n        });\n\n    if (tmpComparisonOperatorMapping.hasOwnProperty(tmpComparator))\n    {\n        tmpComparisonOperator = tmpComparisonOperatorMapping[tmpComparator];\n    }\n\n    let tmpTrueNamespace = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'trueNamespace');\n    let tmpTrueOperation = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'trueOperation');\n\n    let tmpFalseNamespace = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'falseNamespace');\n    let tmpFalseOperation = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'falseOperation');\n\n    let tmpTruthiness = null;\n\n    switch(tmpComparisonOperator)\n    {\n        case 'equal':\n            tmpTruthiness = (tmpLeftValue == tmpRightValue);\n            break;\n        case 'identity':\n            tmpTruthiness = (tmpLeftValue === tmpRightValue);\n            break;\n        case 'notequal':\n            tmpTruthiness = (tmpLeftValue != tmpRightValue);\n            break;\n        case 'greaterthan':\n            tmpTruthiness = (tmpLeftValue > tmpRightValue);\n            break;\n        case 'greaterthanorequal':\n            tmpTruthiness = (tmpLeftValue >= tmpRightValue);\n            break;\n        case 'lessthan':\n            tmpTruthiness = (tmpLeftValue < tmpRightValue);\n            break;\n        case 'lessthanorequal':\n            tmpTruthiness = (tmpLeftValue <= tmpRightValue);\n            break;\n    }\n\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'truthinessResult', tmpTruthiness);\n\n    // Now execute the operations (unless it is a noop or a bunk operation)\n    // This is, frankly, kindof a mind-blowing amount of recursion possibility.\n    // Both of these are falling back on the base solution hash mapping.\n    // --> Not certain if this is the correct approach and the only way to tell will be through exercise of this\n    if (tmpTruthiness && (typeof(tmpTrueNamespace) == 'string') && (typeof(tmpTrueOperation) == 'string') && (tmpTrueOperation != 'noop'))\n    {\n        pOperation.Elucidator.solveInternalOperation(tmpTrueNamespace, tmpTrueOperation, pOperation.InputObject, pOperation.OutputObject, pOperation.DescriptionManyfest, pOperation.SolutionContext.InputHashMapping, pOperation.SolutionContext.OutputHashMapping, pOperation.SolutionContext);\n    }\n    else if ((typeof(tmpFalseNamespace) == 'string') &&  (typeof(tmpFalseOperation) == 'string') && (tmpFalseOperation != 'noop'))\n    {\n        pOperation.Elucidator.solveInternalOperation(tmpFalseNamespace, tmpFalseOperation, pOperation.InputObject, pOperation.OutputObject, pOperation.DescriptionManyfest, pOperation.SolutionContext.InputHashMapping, pOperation.SolutionContext.OutputHashMapping, pOperation.SolutionContext);\n    }\n\n    return true;\n};\n\nconst executeOperation = (pOperation) =>\n{\n    let tmpNamespace = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'namespace');\n    let tmpOperation = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'operation');\n\n    pOperation.Elucidator.solveInternalOperation(tmpNamespace, tmpOperation, pOperation.InputObject, pOperation.OutputObject, pOperation.DescriptionManyfest, pOperation.SolutionContext.InputHashMapping, pOperation.SolutionContext.OutputHashMapping, pOperation.SolutionContext);\n\n    return true;\n}\n\nclass Logic extends libElucidatorInstructionSet\n{\n    constructor(pElucidator)\n    {\n        super(pElucidator);\n        this.namespace = 'Logic';\n    }\n\n    initializeInstructions()\n    {\n        // Logic actually wants a noop instruction!\n        super.initializeInstructions();\n\n        this.addInstruction('if', ifInstruction);\n        this.addInstruction('execute', executeOperation);\n\n        return true;\n    }\n\n    initializeOperations()\n    {\n        this.addOperation('if', require(`./Operations/Logic-If.json`));\n        this.addOperation('execute', require(`./Operations/Logic-Execute.json`));\n\n        return true;\n    }\n}\n\nmodule.exports = Logic;\n},{\"../Elucidator-InstructionSet.js\":4,\"./Operations/Logic-Execute.json\":10,\"./Operations/Logic-If.json\":11}],8:[function(require,module,exports){\n// Solution providers are meant to be stateless, and not classes.\n// These solution providers are akin to drivers, connecting code libraries or \n// other types of behavior to mapping operations.\n\nlet libElucidatorInstructionSet = require('../Elucidator-InstructionSet.js');\n\nlet add = (pOperation) =>\n{\n    // This could be done in one line, but, would be more difficult to comprehend.\n    let tmpA = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'a');\n    let tmpB = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'b');\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'x', tmpA + tmpB);\n    return true;\n};\n\nlet subtract = (pOperation) =>\n{\n    // This could be done in one line, but, would be more difficult to comprehend.\n    let tmpA = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'a');\n    let tmpB = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'b');\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'x', tmpA - tmpB);\n    return true;\n};\n\nlet multiply = (pOperation) =>\n{\n    // This could be done in one line, but, would be more difficult to comprehend.\n    let tmpA = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'a');\n    let tmpB = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'b');\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'x', tmpA * tmpB);\n    return true;\n};\n\nlet divide = (pOperation) =>\n{\n    // This could be done in one line, but, would be more difficult to comprehend.\n    let tmpA = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'a');\n    let tmpB = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'b');\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'x', tmpA / tmpB);\n    return true;\n};\n\nlet aggregate = (pOperation) =>\n{\n    let tmpA = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'a');\n\n    let tmpObjectType = typeof(tmpA);\n\n    let tmpAggregationValue = 0;\n\n    if (tmpObjectType == 'object')\n    {\n        if (Array.isArray(tmpA))\n        {\n            for (let i = 0; i < tmpA.length; i++)\n            {\n                // If this is an array, enumerate it and try to aggregate each number\n                let tmpValue = parseInt(tmpA[i]);\n\n                if (isNaN(tmpValue))\n                {\n                    pOperation.logError(`Array element index [${i}] could not be parsed as a number; skipping.  (${tmpA[i]})`);\n                }\n                else\n                {\n                    tmpAggregationValue += tmpValue;\n                    pOperation.logInfo(`Adding element [${i}] value ${tmpValue} totaling: ${tmpAggregationValue}`)\n                }\n            }\n        }\n        else\n        {\n            let tmpObjectKeys = Object.keys(tmpA);\n            for (let i = 0; i < tmpObjectKeys.length; i++)\n            {\n                let tmpValue = parseInt(tmpA[tmpObjectKeys[i]]);\n\n                if (isNaN(tmpValue))\n                {\n                    pOperation.logError(`Object property [${tmpObjectKeys[i]}] could not be parsed as a number; skipping.  (${tmpA[tmpObjectKeys[i]]})`);\n                }\n                else\n                {\n                    tmpAggregationValue += tmpValue;\n                    pOperation.logInfo(`Adding object property [${tmpObjectKeys[i]}] value ${tmpValue} totaling: ${tmpAggregationValue}`)\n                }\n            }\n        }\n    }\n    else\n    {\n        let tmpValue = parseInt(tmpA);\n\n        if (isNaN(tmpValue))\n        {\n            pOperation.logError(`Direct value could not be parsed as a number; skipping.  (${tmpA})`);\n        }\n        else\n        {\n            tmpAggregationValue += tmpValue;\n        }\n    }\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'x', tmpAggregationValue);\n    return true;\n};\n\nclass MathJavascript extends libElucidatorInstructionSet\n{\n    constructor(pElucidator)\n    {\n        super(pElucidator);\n        this.namespace = 'Math';\n    }\n\n    initializeInstructions()\n    {\n        this.addInstruction('add', add);\n\n        this.addInstruction('subtract', subtract);\n        this.addInstruction('sub', subtract);\n\n        this.addInstruction('multiply', multiply);\n        this.addInstruction('mul', multiply);\n\n        this.addInstruction('divide', divide);\n        this.addInstruction('div', divide);\n\n        this.addInstruction('aggregate', aggregate);\n\n        return true;\n    }\n\n    initializeOperations()\n    {\n        this.addOperation('add', require(`./Operations/Math-Add.json`));\n        this.addOperation('subtract', require(`./Operations/Math-Subtract.json`));\n        this.addOperation('multiply', require(`./Operations/Math-Multiply.json`));\n        this.addOperation('divide', require(`./Operations/Math-Divide.json`));\n\n        this.addOperation('aggregate', require(`./Operations/Math-Aggregate.json`));\n\n        return true;\n    }\n}\n\nmodule.exports = MathJavascript;\n},{\"../Elucidator-InstructionSet.js\":4,\"./Operations/Math-Add.json\":12,\"./Operations/Math-Aggregate.json\":13,\"./Operations/Math-Divide.json\":14,\"./Operations/Math-Multiply.json\":15,\"./Operations/Math-Subtract.json\":16}],9:[function(require,module,exports){\nmodule.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"Geometry\",\n\t\t\"Operation\": \"RectangleArea\",\n\t\t\"Synopsis\": \"Solve for the area of a rectangle:  Area = Width * Height\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"Width\": { \"Hash\":\"Width\", \"Type\":\"Number\" },\n\t\t\"Height\": { \"Hash\":\"Height\", \"Type\":\"Number\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"Area\": { \"Hash\":\"Area\", \"Name\": \"Area of the Rectangle\"},\n\t\t\"Ratio\": { \"Hash\":\"Ratio\", \"Name\": \"The Ratio between the Width and the Height\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Solve for [ {{Name:Area}} ] based on [ {{Name:Width}} ] and [ {{Name:Height}} ].\",\n\t\t\"PostOperation\": \"Operation complete; [ {{Name:Area}} ] = {{InputValue:Width}} * {{InputValue:Height}} = {{OutputValue:Area}}\"\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"PreciseMath\",\n\t\t\t\"Instruction\": \"multiply\",\n\t\t\t\"InputHashAddressMap\": \n\t\t\t\t{\n\t\t\t\t\t\"a\": \"Width\",\n\t\t\t\t\t\"b\": \"Height\"\n\t\t\t\t},\n\t\t\t\"OutputHashAddressMap\":\n\t\t\t\t{\n\t\t\t\t\t\"x\": \"Area\"\n\t\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"Namespace\": \"PreciseMath\",\n\t\t\t\"Instruction\": \"divide\",\n\t\t\t\"InputHashAddressMap\": \n\t\t\t\t{\n\t\t\t\t\t\"a\": \"Width\",\n\t\t\t\t\t\"b\": \"Height\"\n\t\t\t\t},\n\t\t\t\"OutputHashAddressMap\":\n\t\t\t\t{\n\t\t\t\t\t\"x\": \"Ratio\"\n\t\t\t\t}\n\t\t}\n\t]\n}\n},{}],10:[function(require,module,exports){\nmodule.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"Logic\",\n\t\t\"Operation\": \"Execute\",\n\t\t\"Synopsis\": \"Execute an operation based on namespace and operation.\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"namespace\": { \"Hash\": \"namespace\", \"Type\": \"string\", \"Default\":\"logic\" },\n\t\t\"operation\": { \"Hash\": \"operation\", \"Type\": \"string\", \"Default\":\"noop\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Execute the {{InputValue:operation}} operation in namespace {{InputValue:namespace}}.\",\n\t\t\"PostOperation\": \"Operation [{{InputValue:namespace}}:{{InputValue:operation}}] execution complete.\"\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"Logic\",\n\t\t\t\"Instruction\": \"execute\"\n\t\t}\n\t]\n}\n},{}],11:[function(require,module,exports){\nmodule.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"Logic\",\n\t\t\"Operation\": \"If\",\n\t\t\"Synopsis\": \"Comparison-based if of leftValue and RightValue based on comparator.  Executes trueNamespace:trueOperation or falseNamespace:falseOperation based on truthiness of result.  Also outputs a true or false to truthinessResult.\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"leftValue\": { \"Hash\":\"leftValue\", \"Type\":\"Any\" },\n\t\t\"rightValue\": { \"Hash\":\"rightValue\", \"Type\":\"Any\", \"Default\": true },\n\t\t\"comparator\": { \"Hash\":\"comparator\", \"Type\":\"String\", \"Default\":\"==\" },\n\n\t\t\"trueNamespace\": {\"Hash\":\"trueNamespace\", \"Type\":\"String\", \"Default\":\"logic\" },\n\t\t\"trueOperation\": {\"Hash\":\"trueOperation\", \"Type\":\"String\", \"Default\":\"noop\" },\n\n\t\t\"falseNamespace\": {\"Hash\":\"falseNamespace\", \"Type\":\"String\", \"Default\":\"logic\" },\n\t\t\"falseOperation\": {\"Hash\":\"falseOperation\", \"Type\":\"String\", \"Default\":\"noop\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"truthinessResult\": { \"Hash\": \"truthinessResult\", \"Type\": \"Boolean\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Compare {{Name:leftValue}} and {{Name:rightValue}} with the {{InputValue:comparator}} operator, storing the truthiness in {{Name:truthinessResult}}.\",\n\t\t\"PostOperation\": \"Operation complete: {{InputValue:leftValue}} {{InputValue:comparator}} {{InputValue:rightValue}} evaluated to {{OutputValue:truthinessResult}}\"\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"Logic\",\n\t\t\t\"Instruction\": \"If\"\n\t\t}\n\t]\n}\n},{}],12:[function(require,module,exports){\nmodule.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"Math\",\n\t\t\"Operation\": \"Add\",\n\t\t\"Synopsis\": \"Add two numbers:  x = a + b\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"a\": { \"Hash\": \"a\", \"Type\": \"Number\" },\n\t\t\"b\": { \"Hash\": \"b\", \"Type\": \"Number\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"x\": { \"Hash\": \"x\", \"Type\": \"Number\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Add {{Name:a}} and {{Name:b}}, storing the value in {{Name:x}}.\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:x}} = {{InputValue:a}} + {{InputValue:b}} = {{OutputValue:x}}\"\t\t\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"Math\",\n\t\t\t\"Instruction\": \"add\"\n\t\t}\n\t]\n}\n},{}],13:[function(require,module,exports){\nmodule.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"Math\",\n\t\t\"Operation\": \"Aggregate\",\n\t\t\"Synopsis\": \"Aggregate a set of numbers (from array or object address):  x = a + b + ... + z\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"a\": { \"Hash\": \"a\", \"Type\": \"Set\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"x\": { \"Hash\": \"x\", \"Type\": \"Number\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Aggregate all numeric values in {{Name:a}}, storing the resultant in {{Name:x}}.\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:x}} = {{OutputValue:x}}\"\t\t\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"Math\",\n\t\t\t\"Instruction\": \"aggregate\"\n\t\t}\n\t]\n}\n},{}],14:[function(require,module,exports){\nmodule.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"Math\",\n\t\t\"Operation\": \"Divide\",\n\t\t\"Synopsis\": \"Divide two numbers:  x = a / b\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"a\": { \"Hash\": \"a\", \"Type\": \"Number\" },\n\t\t\"b\": { \"Hash\": \"b\", \"Type\": \"Number\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"x\": { \"Hash\": \"x\", \"Type\": \"Number\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Divide {{Name:a}} over {{Name:b}}, storing the value in {{Name:x}}.\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:x}} = {{InputValue:a}} / {{InputValue:b}} = {{OutputValue:x}}\"\t\t\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"Math\",\n\t\t\t\"Instruction\": \"divide\"\n\t\t}\n\t]\n}\n},{}],15:[function(require,module,exports){\nmodule.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"Math\",\n\t\t\"Operation\": \"Multiply\",\n\t\t\"Synopsis\": \"Multiply two numbers:  x = a * b\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"a\": { \"Hash\": \"a\", \"Type\": \"Number\" },\n\t\t\"b\": { \"Hash\": \"b\", \"Type\": \"Number\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"x\": { \"Hash\": \"x\", \"Type\": \"Number\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Multiply {{Name:a}} and {{Name:b}}, storing the value in {{Name:x}}.\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:x}} = {{InputValue:a}} * {{InputValue:b}} = {{OutputValue:x}}\"\t\t\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"Math\",\n\t\t\t\"Instruction\": \"multiply\"\n\t\t}\n\t]\n}\n},{}],16:[function(require,module,exports){\nmodule.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"Math\",\n\t\t\"Operation\": \"Subtract\",\n\t\t\"Synopsis\": \"Subtract two numbers:  x = a - b\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"a\": { \"Hash\": \"a\", \"Type\": \"Number\" },\n\t\t\"b\": { \"Hash\": \"b\", \"Type\": \"Number\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"x\": { \"Hash\": \"x\", \"Type\": \"Number\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Subtract {{Name:a}} and {{Name:b}}, storing the value in {{Name:x}}.\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:x}} = {{InputValue:a}} - {{InputValue:b}} = {{OutputValue:x}}\"\t\t\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"Math\",\n\t\t\t\"Instruction\": \"subtract\"\n\t\t}\n\t]\n}\n},{}],17:[function(require,module,exports){\nmodule.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"PreciseMath\",\n\t\t\"Operation\": \"Add\",\n\t\t\"Synopsis\": \"Precisely add two numbers:  x = a + b\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"a\": { \"Hash\": \"a\", \"Type\": \"Number\" },\n\t\t\"b\": { \"Hash\": \"b\", \"Type\": \"Number\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"x\": { \"Hash\": \"x\", \"Type\": \"Number\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Add {{Name:a}} and {{Name:b}}, storing the value in {{Name:x}}.\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:x}} = {{InputValue:a}} + {{InputValue:b}} = {{OutputValue:x}}\"\t\t\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"PreciseMath\",\n\t\t\t\"Instruction\": \"add\"\n\t\t}\n\t]\n}\n},{}],18:[function(require,module,exports){\nmodule.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"PreciseMath\",\n\t\t\"Operation\": \"Aggregate\",\n\t\t\"Synopsis\": \"Precisely aggregate a set of numbers (from array or object address):  x = a + b + ... + z\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"a\": { \"Hash\": \"a\", \"Type\": \"Set\" },\n\t\t\"ValueNames\": { \"Hash\": \"ValueNames\", \"Type\": \"Set\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"x\": { \"Hash\": \"x\", \"Type\": \"Number\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Aggregate all numeric values in {{Name:a}}, storing the resultant in {{Name:x}}.\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:x}} = {{OutputValue:x}}\"\t\t\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"PreciseMath\",\n\t\t\t\"Instruction\": \"aggregate\"\n\t\t}\n\t]\n}\n},{}],19:[function(require,module,exports){\nmodule.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"PreciseMath\",\n\t\t\"Operation\": \"Divide\",\n\t\t\"Synopsis\": \"Precisely divide two numbers:  x = a / b\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"a\": { \"Hash\": \"a\", \"Type\": \"Number\" },\n\t\t\"b\": { \"Hash\": \"b\", \"Type\": \"Number\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"x\": { \"Hash\": \"x\", \"Type\": \"Number\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Divide {{Name:a}} over {{Name:b}}, storing the value in {{Name:x}}.\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:x}} = {{InputValue:a}} / {{InputValue:b}} = {{OutputValue:x}}\"\t\t\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"PreciseMath\",\n\t\t\t\"Instruction\": \"divide\"\n\t\t}\n\t]\n}\n},{}],20:[function(require,module,exports){\nmodule.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"PreciseMath\",\n\t\t\"Operation\": \"GroupValuesAndAggregate\",\n\t\t\"Synopsis\": \"Group values in a set and aggregate the set of numbers (from array or object addresses)\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"inputDataSet\": { \"Hash\":\"inputDataSet\", \"Type\":\"Set\" },\n\t\t\"groupByProperty\": { \"Hash\":\"groupByProperty\", \"Type\":\"Any\"},\n\t\t\"groupValueProperty\": { \"Hash\":\"groupValueProperty\", \"Type\":\"Any\"},\n\t\t\"recordIndicatorProperty\": { \"Hash\":\"recordIndicatorProperty\", \"Type\":\"String\", \"Default\":false}\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"outputDataSet\": { \"Hash\": \"outputDataSet\", \"Type\": \"Set\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Group {{Name:inputDataSet}} by {{Name:groupByProperty}} and create a map, storing the resultant in {{Name:outputDataSet}}.\",\n\t\t\"PostOperation\": \"Operation complete: Grouping {{Name:inputDataSet}} by {{Name:groupByProperty}} into aggregated values in {{Name:outputDataSet}}\"\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"PreciseMath\",\n\t\t\t\"Instruction\": \"groupvaluesandaggregate\"\n\t\t}\n\t]\n}\n},{}],21:[function(require,module,exports){\nmodule.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"PreciseMath\",\n\t\t\"Operation\": \"Multiply\",\n\t\t\"Synopsis\": \"Precisely multiply two numbers:  x = a * b\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"a\": { \"Hash\": \"a\", \"Type\": \"Number\" },\n\t\t\"b\": { \"Hash\": \"b\", \"Type\": \"Number\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"x\": { \"Hash\": \"x\", \"Type\": \"Number\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Multiply {{Name:a}} and {{Name:b}}, storing the value in {{Name:x}}.\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:x}} = {{InputValue:a}} * {{InputValue:b}} = {{OutputValue:x}}\"\t\t\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"PreciseMath\",\n\t\t\t\"Instruction\": \"multiply\"\n\t\t}\n\t]\n}\n},{}],22:[function(require,module,exports){\nmodule.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"PreciseMath\",\n\t\t\"Operation\": \"Round\",\n\t\t\"Synopsis\": \"Precisely round a number.\"\n\t},\n\n\t\"Inputs\":\n\t{\n\t\t\"a\": { \"Hash\": \"a\", \"Type\": \"Number\" },\n\t\t\"precision\": { \"Hash\": \"precision\", \"Type\": \"Number\" },\n\t\t\"roundingmode\": { \"Hash\": \"roundingmode\", \"Type\":\"String\" }\n\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"x\": { \"Hash\": \"x\", \"Type\": \"Number\" }\n\t},\n\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Round {{Name:a}}, storing the value in {{Name:x}}.\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:x}} = Round({{InputValue:a}}) = {{OutputValue:x}}\"\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"PreciseMath\",\n\t\t\t\"Instruction\": \"round\"\n\t\t}\n\t]\n}\n},{}],23:[function(require,module,exports){\nmodule.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"PreciseMath\",\n\t\t\"Operation\": \"SetPrecision\",\n\t\t\"Synopsis\": \"Set the precision.\"\n\t},\n\n\t\"Inputs\":\n\t{\n\t\t\"precision\": { \"Hash\": \"precision\", \"Type\":\"Number\", \"Default\":2}\n\n\t},\n\n\t\"Outputs\":\n\t{\n\t},\n\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Set precision to {{InputValue:precision}}.\",\n\t\t\"PostOperation\": \"Operation complete: Default precision set to {{InputValue:precision}}.\"\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"PreciseMath\",\n\t\t\t\"Instruction\": \"setprecision\"\n\t\t}\n\t]\n}\n},{}],24:[function(require,module,exports){\nmodule.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"PreciseMath\",\n\t\t\"Operation\": \"SetRoundingMode\",\n\t\t\"Synopsis\": \"Set the rounding mode.\"\n\t},\n\n\t\"Inputs\":\n\t{\n\t\t\"roundingmode\": { \"Hash\": \"roundingmode\", \"Type\":\"String\", \"Default\":\"ROUND_HALF_UP\"}\n\n\t},\n\n\t\"Outputs\":\n\t{\n\t},\n\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Set rounding mode to {{InputValue:roundingmode}}.\",\n\t\t\"PostOperation\": \"Operation complete: Default rounding mode set to {{InputValue:roundingmode}}.\"\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"PreciseMath\",\n\t\t\t\"Instruction\": \"setroundingmode\"\n\t\t}\n\t]\n}\n},{}],25:[function(require,module,exports){\nmodule.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"PreciseMath\",\n\t\t\"Operation\": \"Subtract\",\n\t\t\"Synopsis\": \"Precisely subtract two numbers:  x = a - b\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"a\": { \"Hash\": \"a\", \"Type\": \"Number\" },\n\t\t\"b\": { \"Hash\": \"b\", \"Type\": \"Number\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"x\": { \"Hash\": \"x\", \"Type\": \"Number\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Subtract {{Name:a}} and {{Name:b}}, storing the value in {{Name:x}}.\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:x}} = {{InputValue:a}} - {{InputValue:b}} = {{OutputValue:x}}\"\t\t\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"PreciseMath\",\n\t\t\t\"Instruction\": \"subtract\"\n\t\t}\n\t]\n}\n},{}],26:[function(require,module,exports){\nmodule.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"PreciseMath\",\n\t\t\"Operation\": \"ToDecimalPlaces\",\n\t\t\"Synopsis\": \"Precisely round a number to a certain number of decimal places.\"\n\t},\n\n\t\"Inputs\":\n\t{\n\t\t\"a\": { \"Hash\": \"a\", \"Type\": \"Number\" },\n\t\t\"decimalplaces\": { \"Hash\": \"decimalplaces\", \"Type\": \"Number\", \"Default\":2 },\n\t\t\"roundingmode\": { \"Hash\": \"roundingmode\", \"Type\":\"String\" }\n\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"x\": { \"Hash\": \"x\", \"Type\": \"Number\" }\n\t},\n\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Round {{Name:a}} to {{Value:decimalplaces}} decimal places, storing the value in {{Name:x}}.\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:x}} = Round({{InputValue:a}} TO {{Value:decimalplaces}} decimal places) = {{OutputValue:x}}\"\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"PreciseMath\",\n\t\t\t\"Instruction\": \"todecimalplaces\"\n\t\t}\n\t]\n}\n},{}],27:[function(require,module,exports){\nmodule.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"PreciseMath\",\n\t\t\"Operation\": \"ToSignificantDigits\",\n\t\t\"Synopsis\": \"Precisely round a number to a specific number of significant digits.\"\n\t},\n\n\t\"Inputs\":\n\t{\n\t\t\"a\": { \"Hash\": \"a\", \"Type\": \"Number\" },\n\t\t\"digits\": { \"Hash\": \"digits\", \"Type\": \"Number\", \"Default\":12 },\n\t\t\"roundingmode\": { \"Hash\": \"roundingmode\", \"Type\":\"String\" }\n\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"x\": { \"Hash\": \"x\", \"Type\": \"Number\" }\n\t},\n\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Round {{Name:a}} to {{InputValue:digits}}, storing the value in {{Name:x}}.\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:x}} = Round({{InputValue:a}} TO {{InputValue:digits}}) = {{OutputValue:x}}\"\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"PreciseMath\",\n\t\t\t\"Instruction\": \"tosignificantdigits\"\n\t\t}\n\t]\n}\n},{}],28:[function(require,module,exports){\nmodule.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"Set\",\n\t\t\"Operation\": \"GroupValuesBy\",\n\t\t\"Synopsis\": \"Group set of Sub object values by another property in the objects.\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"inputDataSet\": { \"Hash\":\"inputDataSet\", \"Type\":\"Set\" },\n\t\t\"groupByProperty\": { \"Hash\":\"groupByProperty\", \"Type\":\"Any\"},\n\t\t\"groupValueProperty\": { \"Hash\":\"groupValueProperty\", \"Type\":\"Any\"}\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"outputDataSet\": { \"Hash\": \"outputDataSet\", \"Type\": \"Set\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Group {{Name:inputDataSet}} by {{Name:groupByProperty}} and create a mapped result set into {{Name:outputDataSet}}.\",\n\t\t\"PostOperation\": \"Operation complete: Grouping {{Name:inputDataSet}} by {{Name:groupByProperty}} into {{Name:outputDataSet}}\"\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"Set\",\n\t\t\t\"Instruction\": \"GroupValuesBy\"\n\t\t}\n\t]\n}\n},{}],29:[function(require,module,exports){\nmodule.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"String\",\n\t\t\"Operation\": \"Replace\",\n\t\t\"Synopsis\": \"Replace all instances of searchFor with replaceWith in inputString\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"inputString\": { \"Hash\": \"inputString\", \"Type\": \"String\" },\n\t\t\"searchFor\": { \"Hash\": \"searchFor\", \"Type\": \"String\" },\n\t\t\"replaceWith\": { \"Hash\": \"replaceWith\", \"Type\": \"String\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"outputString\": { \"Hash\": \"outputString\", \"Type\": \"String\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Search for [{{InputValue:searchFor}}] and replace it with [{{InputValue:replaceWith}}] in [{{InputValue:inputString}}].\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:outputString}} = [{{OutputValue:outputString}}] from [{{InputValue:inputString}}] replacing [{{InputValue:searchFor}}] with [{{InputValue:replaceWith}}].\"\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"String\",\n\t\t\t\"Instruction\": \"replace\"\n\t\t}\n\t]\n}\n},{}],30:[function(require,module,exports){\nmodule.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"String\",\n\t\t\"Operation\": \"Substring\",\n\t\t\"Synopsis\": \"Get all characters between indexStart and indexEnd (optional) for a given inputString.\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"inputString\": { \"Hash\": \"inputString\", \"Type\": \"String\" },\n\t\t\"indexStart\": { \"Hash\": \"indexStart\", \"Type\": \"Number\", \"Default\":0 },\n\t\t\"indexEnd\": { \"Hash\": \"indexEnd\", \"Type\": \"String\", \"Default\":null }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"outputString\": { \"Hash\": \"outputString\", \"Type\": \"String\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Get all characters between {{InputValue:indexStart}} and {{InputValue:indexEnd}} in [{{InputValue:inputString}}].\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:outputString}} = [{{OutputValue:outputString}}] from [{{InputValue:inputString}}] between {{InputValue:indexStart}} and {{InputValue:indexEnd}}.\"\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"String\",\n\t\t\t\"Instruction\": \"substring\"\n\t\t}\n\t]\n}\n},{}],31:[function(require,module,exports){\nmodule.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"String\",\n\t\t\"Operation\": \"Trim\",\n\t\t\"Synopsis\": \"Trim whitespace off the end of string in inputString, putting the result in outputString\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"inputString\": { \"Hash\": \"inputString\", \"Type\": \"String\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"outputString\": { \"Hash\": \"outputString\", \"Type\": \"String\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Trim the whitespace from value [{{InputValue:inputString}}].\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:outputString}} = [{{OutputValue:outputString}}] from [{{InputValue:inputString}}]\"\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"String\",\n\t\t\t\"Instruction\": \"trim\"\n\t\t}\n\t]\n}\n},{}],32:[function(require,module,exports){\nlet libElucidatorInstructionSet = require('../Elucidator-InstructionSet.js');\n\nconst libDecimal = require('decimal.js');\n\nlet add = (pOperation) =>\n{\n\t// This could be done in one line, but, would be more difficult to comprehend.\n\tlet tmpA = new libDecimal(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'a'));\n\tlet tmpB = new libDecimal(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'b'));\n\tpOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'x', tmpA.plus(tmpB).toString());\n\treturn true;\n};\n\nlet subtract = (pOperation) =>\n{\n\t// This could be done in one line, but, would be more difficult to comprehend.\n\tlet tmpA = new libDecimal(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'a'));\n\tlet tmpB = new libDecimal(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'b'));\n\tpOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'x', tmpA.sub(tmpB).toString());\n\treturn true;\n};\n\nlet multiply = (pOperation) =>\n{\n\t// This could be done in one line, but, would be more difficult to comprehend.\n\tlet tmpA = new libDecimal(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'a'));\n\tlet tmpB = new libDecimal(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'b'));\n\tpOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'x', tmpA.mul(tmpB).toString());\n\treturn true;\n};\n\nlet divide = (pOperation) =>\n{\n\t// This could be done in one line, but, would be more difficult to comprehend.\n\tlet tmpA = new libDecimal(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'a'));\n\tlet tmpB = new libDecimal(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'b'));\n\tpOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'x', tmpA.div(tmpB).toString());\n\treturn true;\n};\n\nlet round = (pOperation) =>\n{\n\tlet tmpA = new libDecimal(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'a'));\n\n\tlet tmpPrecision = parseInt(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'precision'));\n\tlet tmpRoundingMode = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'roundingmode')\n\n\t// Eventually don't set this every time...\n\tif (tmpRoundingMode)\n\t{\n\t\tswitch (tmpRoundingMode.toString().toLowerCase())\n\t\t{\n\t\t\tcase 'round_up':\n\t\t\t\tlibDecimal.set({ rounding: libDecimal.ROUND_UP });\n\t\t\t\tbreak;\n\t\t\tcase 'round_down':\n\t\t\t\tlibDecimal.set({ rounding: libDecimal.ROUND_DOWN });\n\t\t\t\tbreak;\n\t\t\tcase 'round_ceil':\n\t\t\t\tlibDecimal.set({ rounding: libDecimal.ROUND_CEIL });\n\t\t\t\tbreak;\n\t\t\tcase 'round_floor':\n\t\t\t\tlibDecimal.set({ rounding: libDecimal.ROUND_FLOOR });\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\tcase 'round_half_up':\n\t\t\t\tlibDecimal.set({ rounding: libDecimal.ROUND_HALF_UP });\n\t\t\t\tbreak;\n\t\t\tcase 'round_half_down':\n\t\t\t\tlibDecimal.set({ rounding: libDecimal.ROUND_HALF_DOWN });\n\t\t\t\tbreak;\n\t\t\tcase 'round_half_even':\n\t\t\t\tlibDecimal.set({ rounding: libDecimal.ROUND_HALF_EVEN });\n\t\t\t\tbreak;\n\t\t\tcase 'round_half_ceil':\n\t\t\t\tlibDecimal.set({ rounding: libDecimal.ROUND_HALF_CEIL });\n\t\t\t\tbreak;\n\t\t\tcase 'round_half_floor':\n\t\t\t\tlibDecimal.set({ rounding: libDecimal.ROUND_HALF_FLOOR });\n\t\t\t\tbreak;\n\t\t\tcase 'euclid':\n\t\t\t\tlibDecimal.set({ rounding: libDecimal.EUCLID });\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!isNaN(tmpPrecision))\n\t{\n\t\tlibDecimal.set({ precision: tmpPrecision });\n\t}\n\n\tpOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'x', libDecimal.round(tmpA).toString());\n};\n\n\nlet tosignificantdigits = (pOperation) =>\n{\n\tlet tmpA = new libDecimal(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'a'));\n\n\tlet tmpDigits = parseInt(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'digits'));\n\tlet tmpRoundingMode = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'roundingmode')\n\n\t// Eventually don't set this every time...\n\tif (tmpRoundingMode)\n\t{\n\t\tswitch (tmpRoundingMode.toString().toLowerCase())\n\t\t{\n\t\t\tcase 'round_up':\n\t\t\t\tlibDecimal.set({ rounding: libDecimal.ROUND_UP });\n\t\t\t\tbreak;\n\t\t\tcase 'round_down':\n\t\t\t\tlibDecimal.set({ rounding: libDecimal.ROUND_DOWN });\n\t\t\t\tbreak;\n\t\t\tcase 'round_ceil':\n\t\t\t\tlibDecimal.set({ rounding: libDecimal.ROUND_CEIL });\n\t\t\t\tbreak;\n\t\t\tcase 'round_floor':\n\t\t\t\tlibDecimal.set({ rounding: libDecimal.ROUND_FLOOR });\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\tcase 'round_half_up':\n\t\t\t\tlibDecimal.set({ rounding: libDecimal.ROUND_HALF_UP });\n\t\t\t\tbreak;\n\t\t\tcase 'round_half_down':\n\t\t\t\tlibDecimal.set({ rounding: libDecimal.ROUND_HALF_DOWN });\n\t\t\t\tbreak;\n\t\t\tcase 'round_half_even':\n\t\t\t\tlibDecimal.set({ rounding: libDecimal.ROUND_HALF_EVEN });\n\t\t\t\tbreak;\n\t\t\tcase 'round_half_ceil':\n\t\t\t\tlibDecimal.set({ rounding: libDecimal.ROUND_HALF_CEIL });\n\t\t\t\tbreak;\n\t\t\tcase 'round_half_floor':\n\t\t\t\tlibDecimal.set({ rounding: libDecimal.ROUND_HALF_FLOOR });\n\t\t\t\tbreak;\n\t\t\tcase 'euclid':\n\t\t\t\tlibDecimal.set({ rounding: libDecimal.EUCLID });\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (isNaN(tmpDigits))\n\t{\n\t\ttmpDigits = 12;\n\t}\n\n\tpOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'x', tmpA.toSignificantDigits(tmpDigits).toString());\n};\n\nlet todecimalplaces = (pOperation) =>\n{\n\tlet tmpA = new libDecimal(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'a'));\n\n\tlet tmpDecimalPlaces = parseInt(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'decimalplaces'));\n\tlet tmpRoundingMode = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'roundingmode')\n\n\t// Eventually don't set this every time...\n\tif (tmpRoundingMode)\n\t{\n\t\tswitch (tmpRoundingMode.toString().toLowerCase())\n\t\t{\n\t\t\tcase 'round_up':\n\t\t\t\tlibDecimal.set({ rounding: libDecimal.ROUND_UP });\n\t\t\t\tbreak;\n\t\t\tcase 'round_down':\n\t\t\t\tlibDecimal.set({ rounding: libDecimal.ROUND_DOWN });\n\t\t\t\tbreak;\n\t\t\tcase 'round_ceil':\n\t\t\t\tlibDecimal.set({ rounding: libDecimal.ROUND_CEIL });\n\t\t\t\tbreak;\n\t\t\tcase 'round_floor':\n\t\t\t\tlibDecimal.set({ rounding: libDecimal.ROUND_FLOOR });\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\tcase 'round_half_up':\n\t\t\t\tlibDecimal.set({ rounding: libDecimal.ROUND_HALF_UP });\n\t\t\t\tbreak;\n\t\t\tcase 'round_half_down':\n\t\t\t\tlibDecimal.set({ rounding: libDecimal.ROUND_HALF_DOWN });\n\t\t\t\tbreak;\n\t\t\tcase 'round_half_even':\n\t\t\t\tlibDecimal.set({ rounding: libDecimal.ROUND_HALF_EVEN });\n\t\t\t\tbreak;\n\t\t\tcase 'round_half_ceil':\n\t\t\t\tlibDecimal.set({ rounding: libDecimal.ROUND_HALF_CEIL });\n\t\t\t\tbreak;\n\t\t\tcase 'round_half_floor':\n\t\t\t\tlibDecimal.set({ rounding: libDecimal.ROUND_HALF_FLOOR });\n\t\t\t\tbreak;\n\t\t\tcase 'euclid':\n\t\t\t\tlibDecimal.set({ rounding: libDecimal.EUCLID });\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (isNaN(tmpDecimalPlaces))\n\t{\n\t\ttmpDecimalPlaces = 2;\n\t}\n\n\tpOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'x', tmpA.toDecimalPlaces(tmpDecimalPlaces).toString());\n};\n\nlet setprecision = (pOperation) =>\n{\n\tlet tmpPrecision = parseInt(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'precision'));\n\n\tconsole.log(tmpPrecision)\n\tif (!isNaN(tmpPrecision))\n\t{\n\t\tlibDecimal.set({ precision: tmpPrecision });\n\t}\n};\n\nlet setroundingmode = (pOperation) =>\n{\n\tlet tmpRoundingMode = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'roundingmode')\n\n\t// Eventually don't set this every time...\n\tif (tmpRoundingMode)\n\t{\n\t\tswitch (tmpRoundingMode.toString().toLowerCase())\n\t\t{\n\t\t\tcase 'round_up':\n\t\t\t\tlibDecimal.set({ rounding: libDecimal.ROUND_UP });\n\t\t\t\tbreak;\n\t\t\tcase 'round_down':\n\t\t\t\tlibDecimal.set({ rounding: libDecimal.ROUND_DOWN });\n\t\t\t\tbreak;\n\t\t\tcase 'round_ceil':\n\t\t\t\tlibDecimal.set({ rounding: libDecimal.ROUND_CEIL });\n\t\t\t\tbreak;\n\t\t\tcase 'round_floor':\n\t\t\t\tlibDecimal.set({ rounding: libDecimal.ROUND_FLOOR });\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\tcase 'round_half_up':\n\t\t\t\tlibDecimal.set({ rounding: libDecimal.ROUND_HALF_UP });\n\t\t\t\tbreak;\n\t\t\tcase 'round_half_down':\n\t\t\t\tlibDecimal.set({ rounding: libDecimal.ROUND_HALF_DOWN });\n\t\t\t\tbreak;\n\t\t\tcase 'round_half_even':\n\t\t\t\tlibDecimal.set({ rounding: libDecimal.ROUND_HALF_EVEN });\n\t\t\t\tbreak;\n\t\t\tcase 'round_half_ceil':\n\t\t\t\tlibDecimal.set({ rounding: libDecimal.ROUND_HALF_CEIL });\n\t\t\t\tbreak;\n\t\t\tcase 'round_half_floor':\n\t\t\t\tlibDecimal.set({ rounding: libDecimal.ROUND_HALF_FLOOR });\n\t\t\t\tbreak;\n\t\t\tcase 'euclid':\n\t\t\t\tlibDecimal.set({ rounding: libDecimal.EUCLID });\n\t\t\t\tbreak;\n\t\t}\n\t}\n};\n\nlet aggregate = (pOperation) =>\n{\n\tlet tmpA = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'a');\n\n\tlet tmpObjectType = typeof (tmpA);\n\n\tlet tmpAggregationValue = new libDecimal(0);\n\n\tif (tmpObjectType == 'object')\n\t{\n\t\tif (Array.isArray(tmpA))\n\t\t{\n\t\t\tfor (let i = 0; i < tmpA.length; i++)\n\t\t\t{\n\t\t\t\t// If this is an array, enumerate it and try to aggregate each number\n\t\t\t\tlet tmpValue = new libDecimal(tmpA[i]);\n\n\t\t\t\tif (isNaN(tmpValue))\n\t\t\t\t{\n\t\t\t\t\tpOperation.logError(`Array element index [${i}] could not be parsed as a number by Decimal.js; skipping.  (${tmpA[i]})`);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttmpAggregationValue = tmpAggregationValue.plus(tmpValue);\n\t\t\t\t\tpOperation.logInfo(`Adding element [${i}] value ${tmpValue} totaling: ${tmpAggregationValue}`)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlet tmpObjectKeys = Object.keys(tmpA);\n\t\t\tfor (let i = 0; i < tmpObjectKeys.length; i++)\n\t\t\t{\n\t\t\t\tlet tmpValue = new libDecimal(tmpA[tmpObjectKeys[i]]);\n\n\t\t\t\tif (isNaN(tmpValue))\n\t\t\t\t{\n\t\t\t\t\tpOperation.logError(`Object property [${tmpObjectKeys[i]}] could not be parsed as a number; skipping.  (${tmpA[tmpObjectKeys[i]]})`);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttmpAggregationValue = tmpAggregationValue.plus(tmpValue);\n\t\t\t\t\tpOperation.logInfo(`Adding object property [${tmpObjectKeys[i]}] value ${tmpValue} totaling: ${tmpAggregationValue}`)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tlet tmpValue = new libDecimal(tmpA);\n\n\t\tif (isNaN(tmpValue))\n\t\t{\n\t\t\tpOperation.logError(`Direct value could not be parsed as a number; skipping.  (${tmpA})`);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttmpAggregationValue = tmpValue;\n\t\t}\n\t}\n\tpOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'x', tmpAggregationValue.toString());\n\treturn true;\n};\n\nconst groupValuesAndAggregate = (pOperation) =>\n{\n\tlet tmpInputDataSet = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'inputDataSet');\n\tlet tmpGroupByProperty = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'groupByProperty');\n\tlet tmpGroupValueProperty = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'groupValueProperty');\n\n\tlet tmpOutputDataSet = {};\n\tlet tmpProcessedOutputDataSet = {};\n\n\tlet tmpObjectType = typeof (tmpInputDataSet);\n\n\tif (tmpObjectType == 'object')\n\t{\n\t\tif (Array.isArray(tmpInputDataSet))\n\t\t{\n\t\t\tfor (let i = 0; i < tmpInputDataSet.length; i++)\n\t\t\t{\n\t\t\t\tif (typeof (tmpInputDataSet[i]) !== 'object')\n\t\t\t\t{\n\t\t\t\t\tpOperation.logInfo(`Element [${i}] was not an object; skipping group operation.`);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tlet tmpValue = tmpInputDataSet[i];\n\t\t\t\t\tlet tmpGroupByValue = tmpValue[tmpGroupByProperty];\n\t\t\t\t\tif (!tmpValue.hasOwnProperty(tmpGroupByProperty))\n\t\t\t\t\t{\n\t\t\t\t\t\tpOperation.logInfo(`Element [${i}] doesn't have the group by property [${tmpGroupByProperty}]; setting group to [__NO_GROUP].`);\n\t\t\t\t\t\ttmpGroupByValue = '__NO_GROUP';\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!tmpValue.hasOwnProperty(tmpGroupValueProperty))\n\t\t\t\t\t{\n\t\t\t\t\t\tpOperation.logInfo(`Element [${i}] doesn't have the group value property [${tmpGroupValueProperty}]; skipping group operation.`);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tlet tmpDecimalValue = new libDecimal(tmpValue[tmpGroupValueProperty]);\n\n\t\t\t\t\t\tif (isNaN(tmpDecimalValue))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpOperation.logError(`Object property [${i}] could not be parsed as a number; skipping.  (${tmpValue[tmpGroupValueProperty]})`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (!tmpOutputDataSet.hasOwnProperty(tmpGroupByValue))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttmpOutputDataSet[tmpGroupByValue] = tmpDecimalValue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttmpOutputDataSet[tmpGroupByValue] = tmpOutputDataSet[tmpGroupByValue].plus(tmpDecimalValue);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpOperation.logInfo(`Adding object property [${i}] value ${tmpDecimalValue} totaling: ${tmpOutputDataSet[tmpGroupByValue]}`)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlet tmpObjectKeys = Object.keys(tmpInputDataSet);\n\t\t\tfor (let i = 0; i < tmpObjectKeys.length; i++)\n\t\t\t{\n\t\t\t\tif (typeof (tmpInputDataSet[tmpObjectKeys[i]]) !== 'object')\n\t\t\t\t{\n\t\t\t\t\tpOperation.logInfo(`Element [${i}] was not an object; skipping group operation.`);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tlet tmpValue = tmpInputDataSet[tmpObjectKeys[i]];\n\t\t\t\t\tlet tmpGroupByValue = tmpValue[tmpGroupByProperty];\n\t\t\t\t\tif (!tmpValue.hasOwnProperty(tmpGroupByProperty))\n\t\t\t\t\t{\n\t\t\t\t\t\tpOperation.logInfo(`Element [${tmpObjectKeys[i]}][${i}] doesn't have the group by property [${tmpGroupByProperty}]; setting group to [__NO_GROUP].`);\n\t\t\t\t\t\ttmpGroupByValue = '__NO_GROUP';\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!tmpValue.hasOwnProperty(tmpGroupValueProperty))\n\t\t\t\t\t{\n\t\t\t\t\t\tpOperation.logInfo(`Element [${tmpObjectKeys[i]}][${i}] doesn't have the group value property [${tmpGroupValueProperty}]; skipping group operation.`);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tlet tmpDecimalValue = new libDecimal(tmpValue[tmpGroupValueProperty]);\n\n\t\t\t\t\t\tif (isNaN(tmpDecimalValue))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpOperation.logError(`Object property [${tmpObjectKeys[i]}][${i}] to group ${tmpGroupByValue} could not be parsed as a number; skipping.  (${tmpValue[tmpGroupValueProperty]})`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (!tmpOutputDataSet.hasOwnProperty(tmpGroupByValue))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttmpOutputDataSet[tmpGroupByValue] = tmpDecimalValue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttmpOutputDataSet[tmpGroupByValue] = tmpOutputDataSet[tmpGroupByValue].plus(tmpDecimalValue);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpOperation.logInfo(`Adding object property [${tmpObjectKeys[i]}][${i}] to group ${tmpGroupByValue} value ${tmpDecimalValue} totaling: ${tmpOutputDataSet[tmpGroupByValue]}`)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Now marshal the aggregated values\n\t\tlet tmpOutputGroups = Object.keys(tmpOutputDataSet);\n\t\tfor (let j = 0; j < tmpOutputGroups.length; j++)\n\t\t{\n\t\t\ttmpProcessedOutputDataSet[tmpOutputGroups[j]] = tmpOutputDataSet[tmpOutputGroups[j]].toString();\n\t\t}\n\t}\n\telse\n\t{\n\t\tpOperation.logError(`Input set is neither an Array nor an Object`);\n\t}\n\n\tpOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'outputDataSet', tmpProcessedOutputDataSet);\n\n\treturn true;\n}\n\nlet toFraction = (pOperation) =>\n{\n\t// This could be done in one line, but, would be more difficult to comprehend.\n\tlet tmpA = new libDecimal(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'a'));\n\tpOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'x', tmpA.toFraction().toString());\n\treturn true;\n};\n\n\nclass PreciseMath extends libElucidatorInstructionSet\n{\n\tconstructor(pElucidator)\n\t{\n\t\tsuper(pElucidator);\n\t\tthis.namespace = 'PreciseMath';\n\t}\n\n\tinitializeInstructions()\n\t{\n\t\tthis.addInstruction('add', add);\n\n\t\tthis.addInstruction('subtract', subtract);\n\t\tthis.addInstruction('sub', subtract);\n\n\t\tthis.addInstruction('multiply', multiply);\n\t\tthis.addInstruction('mul', multiply);\n\n\t\tthis.addInstruction('divide', divide);\n\t\tthis.addInstruction('div', divide);\n\n\t\tthis.addInstruction('aggregate', aggregate);\n\t\tthis.addInstruction('groupvaluesandaggregate', groupValuesAndAggregate);\n\n\t\tthis.addInstruction('setprecision', setprecision);\n\t\tthis.addInstruction('setroundingmode', setroundingmode);\n\n\t\tthis.addInstruction('todecimalplaces', todecimalplaces);\n\t\tthis.addInstruction('tosignificantdigits', tosignificantdigits);\n\t\tthis.addInstruction('round', round);\n\t\tthis.addInstruction('tofraction', toFraction);\n\n\n\t\treturn true;\n\t}\n\n\tinitializeOperations()\n\t{\n\t\tthis.addOperation('add', require(`./Operations/PreciseMath-Add.json`));\n\t\tthis.addOperation('subtract', require(`./Operations/PreciseMath-Subtract.json`));\n\t\tthis.addOperation('multiply', require(`./Operations/PreciseMath-Multiply.json`));\n\t\tthis.addOperation('divide', require(`./Operations/PreciseMath-Divide.json`));\n\n\t\tthis.addOperation('aggregate', require('./Operations/PreciseMath-Aggregate.json'));\n\t\tthis.addOperation('groupvaluesandaggregate', require('./Operations/PreciseMath-GroupValuesAndAggregate.json'));\n\n\t\tthis.addOperation('setprecision', require('./Operations/PreciseMath-SetPrecision.json'));\n\t\tthis.addOperation('setroundingmode', require('./Operations/PreciseMath-SetRoundingMode.json'));\n\n\t\tthis.addOperation('tosignificantdigits', require('./Operations/PreciseMath-ToSignificantDigits.json'));\n\t\tthis.addOperation('todecimalplaces', require('./Operations/PreciseMath-ToDecimalPlaces.json'));\n\t\tthis.addOperation('round', require('./Operations/PreciseMath-Round.json'));\n\n\t\treturn true;\n\t}\n}\n\nmodule.exports = PreciseMath;\n},{\"../Elucidator-InstructionSet.js\":4,\"./Operations/PreciseMath-Add.json\":17,\"./Operations/PreciseMath-Aggregate.json\":18,\"./Operations/PreciseMath-Divide.json\":19,\"./Operations/PreciseMath-GroupValuesAndAggregate.json\":20,\"./Operations/PreciseMath-Multiply.json\":21,\"./Operations/PreciseMath-Round.json\":22,\"./Operations/PreciseMath-SetPrecision.json\":23,\"./Operations/PreciseMath-SetRoundingMode.json\":24,\"./Operations/PreciseMath-Subtract.json\":25,\"./Operations/PreciseMath-ToDecimalPlaces.json\":26,\"./Operations/PreciseMath-ToSignificantDigits.json\":27,\"decimal.js\":1}],33:[function(require,module,exports){\n// Solution providers are meant to be stateless, and not classes.\n// These solution providers are akin to drivers, connecting code libraries or \n// other types of behavior to mapping operations.\n\nlet libElucidatorInstructionSet = require('../Elucidator-InstructionSet.js');\n\nconst groupValuesBy = (pOperation) =>\n{\n    let tmpInputDataSet = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'inputDataSet');\n    let tmpGroupByProperty = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'groupByProperty');\n    let tmpGroupValueProperty = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'groupValueProperty');\n\n    let tmpOutputDataSet = {};\n \n    let tmpObjectType = typeof(tmpInputDataSet);\n\n    if (tmpObjectType == 'object')\n    {\n        if (Array.isArray(tmpInputDataSet))\n        {\n            for (let i = 0; i < tmpInputDataSet.length; i++)\n            {\n                if (typeof(tmpInputDataSet[i]) !== 'object')\n                {\n                    pOperation.logInfo(`Element [${i}] was not an object; skipping group operation.`);\n                }\n                else\n                {\n                    let tmpValue = tmpInputDataSet[i];\n                    let tmpGroupByValue = tmpValue[tmpGroupByProperty];\n                    if (!tmpValue.hasOwnProperty(tmpGroupByProperty))\n                    {\n                        pOperation.logInfo(`Element [${i}] doesn't have the group by property [${tmpGroupByProperty}]; setting group to [__NO_GROUP].`);\n                        tmpGroupByValue = '__NO_GROUP';\n                    }\n\n                    if (!tmpValue.hasOwnProperty(tmpGroupValueProperty))\n                    {\n                        pOperation.logInfo(`Element [${i}] doesn't have the group value property [${tmpGroupValueProperty}]; skipping group operation.`);\n                    }\n                    else\n                    {\n                        if (!tmpOutputDataSet.hasOwnProperty(tmpGroupByValue))\n                        {\n                            // Create a new grouped value\n                            pOperation.logInfo(`Creating a new group [${tmpGroupByValue}] for element [${i}].`);\n                            tmpOutputDataSet[tmpGroupByValue] = [];\n                        }\n\n                        tmpOutputDataSet[tmpGroupByValue].push(tmpValue[tmpGroupValueProperty]);\n                    }\n                }\n            }\n        }\n        else\n        {\n            let tmpObjectKeys = Object.keys(tmpInputDataSet);\n            for (let i = 0; i < tmpObjectKeys.length; i++)\n            {\n                if (typeof(tmpInputDataSet[tmpObjectKeys[i]]) !== 'object')\n                {\n                    pOperation.logInfo(`Element [${i}] was not an object; skipping group operation.`);\n                }\n                else\n                {\n                    let tmpValue = tmpInputDataSet[tmpObjectKeys[i]];\n                    let tmpGroupByValue = tmpValue[tmpGroupByProperty];\n                    if (!tmpValue.hasOwnProperty(tmpGroupByProperty))\n                    {\n                        pOperation.logInfo(`Element [${tmpObjectKeys[i]}][${i}] doesn't have the group by property [${tmpGroupByProperty}]; setting group to [__NO_GROUP].`);\n                        tmpGroupByValue = '__NO_GROUP';\n                    }\n\n                    if (!tmpValue.hasOwnProperty(tmpGroupValueProperty))\n                    {\n                        pOperation.logInfo(`Element [${tmpObjectKeys[i]}][${i}] doesn't have the group value property [${tmpGroupValueProperty}]; skipping group operation.`);\n                    }\n                    else\n                    {\n                        if (!tmpOutputDataSet.hasOwnProperty(tmpGroupByValue))\n                        {\n                            // Create a new grouped value\n                            pOperation.logInfo(`Creating a new group [${tmpGroupByValue}] for element [${tmpObjectKeys[i]}][${i}].`);\n                            tmpOutputDataSet[tmpGroupByValue] = [];\n                        }\n\n                        tmpOutputDataSet[tmpGroupByValue].push(tmpValue[tmpGroupValueProperty]);\n                    }\n                }\n            }\n        }\n    }\n    else\n    {\n        pOperation.logError(`Input set is neither an Array nor an Object`);\n    }\n\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'outputDataSet', tmpOutputDataSet);\n\n    return true;\n}\n\nclass Set extends libElucidatorInstructionSet\n{\n    constructor(pElucidator)\n    {\n        super(pElucidator);\n        this.namespace = 'Set';\n    }\n\n    initializeInstructions()\n    {\n        // Logic actually wants a noop instruction!\n        super.initializeInstructions();\n\n        this.addInstruction('groupvaluesby', groupValuesBy);\n\n        return true;\n    }\n\n    initializeOperations()\n    {\n        this.addOperation('groupvaluesby', require(`./Operations/Set-GroupValuesBy.json`));\n\n        return true;\n    }\n}\n\nmodule.exports = Set;\n},{\"../Elucidator-InstructionSet.js\":4,\"./Operations/Set-GroupValuesBy.json\":28}],34:[function(require,module,exports){\n// Solution providers are meant to be stateless, and not classes.\n// These solution providers are akin to drivers, connecting code libraries or \n// other types of behavior to mapping operations.\n\nlet libElucidatorInstructionSet = require('../Elucidator-InstructionSet.js');\n\nlet trim = (pOperation) =>\n{\n    let tmpInputString = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'inputString');\n\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'outputString', tmpInputString.trim());\n\n    return true;\n};\n\nlet replace = (pOperation) =>\n{\n    let tmpInputString = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'inputString');\n    let tmpSearchFor = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'searchFor');\n    let tmpReplaceWith = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'replaceWith');\n\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'outputString', tmpInputString.replace(tmpSearchFor, tmpReplaceWith));\n\n    return true;\n};\n\nlet substring = (pOperation) =>\n{\n    let tmpInputString = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'inputString');\n    let indexStart = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'indexStart');\n    let indexEnd = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'indexEnd');\n\n    if (indexEnd != null)\n    {\n        pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'outputString', tmpInputString.substring(indexStart, indexEnd));\n    }\n    else\n    {\n        pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'outputString', tmpInputString.substring(indexStart));\n    }\n\n    return true;\n};\n\nclass StringOperations extends libElucidatorInstructionSet\n{\n    constructor(pElucidator)\n    {\n        super(pElucidator);\n        this.namespace = 'String';\n    }\n\n    initializeInstructions()\n    {\n        this.addInstruction('trim', trim);\n        this.addInstruction('replace', replace);\n        this.addInstruction('substring', substring);\n\n        return true;\n    }\n\n    initializeOperations()\n    {\n        this.addOperation('trim', require(`./Operations/String-Trim.json`));\n        this.addOperation('replace', require(`./Operations/String-Replace.json`));\n        this.addOperation('substring', require(`./Operations/String-Substring.json`));\n\n        return true;\n    }\n}\n\nmodule.exports = StringOperations;\n},{\"../Elucidator-InstructionSet.js\":4,\"./Operations/String-Replace.json\":29,\"./Operations/String-Substring.json\":30,\"./Operations/String-Trim.json\":31}]},{},[5])(5)\n});\n\n","(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()",";(function (globalScope) {\r\n  'use strict';\r\n\r\n\r\n  /*!\r\n   *  decimal.js v10.4.3\r\n   *  An arbitrary-precision Decimal type for JavaScript.\r\n   *  https://github.com/MikeMcl/decimal.js\r\n   *  Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>\r\n   *  MIT Licence\r\n   */\r\n\r\n\r\n  // -----------------------------------  EDITABLE DEFAULTS  ------------------------------------ //\r\n\r\n\r\n    // The maximum exponent magnitude.\r\n    // The limit on the value of `toExpNeg`, `toExpPos`, `minE` and `maxE`.\r\n  var EXP_LIMIT = 9e15,                      // 0 to 9e15\r\n\r\n    // The limit on the value of `precision`, and on the value of the first argument to\r\n    // `toDecimalPlaces`, `toExponential`, `toFixed`, `toPrecision` and `toSignificantDigits`.\r\n    MAX_DIGITS = 1e9,                        // 0 to 1e9\r\n\r\n    // Base conversion alphabet.\r\n    NUMERALS = '0123456789abcdef',\r\n\r\n    // The natural logarithm of 10 (1025 digits).\r\n    LN10 = '2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058',\r\n\r\n    // Pi (1025 digits).\r\n    PI = '3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789',\r\n\r\n\r\n    // The initial configuration properties of the Decimal constructor.\r\n    DEFAULTS = {\r\n\r\n      // These values must be integers within the stated ranges (inclusive).\r\n      // Most of these values can be changed at run-time using the `Decimal.config` method.\r\n\r\n      // The maximum number of significant digits of the result of a calculation or base conversion.\r\n      // E.g. `Decimal.config({ precision: 20 });`\r\n      precision: 20,                         // 1 to MAX_DIGITS\r\n\r\n      // The rounding mode used when rounding to `precision`.\r\n      //\r\n      // ROUND_UP         0 Away from zero.\r\n      // ROUND_DOWN       1 Towards zero.\r\n      // ROUND_CEIL       2 Towards +Infinity.\r\n      // ROUND_FLOOR      3 Towards -Infinity.\r\n      // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.\r\n      // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.\r\n      // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.\r\n      // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.\r\n      // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.\r\n      //\r\n      // E.g.\r\n      // `Decimal.rounding = 4;`\r\n      // `Decimal.rounding = Decimal.ROUND_HALF_UP;`\r\n      rounding: 4,                           // 0 to 8\r\n\r\n      // The modulo mode used when calculating the modulus: a mod n.\r\n      // The quotient (q = a / n) is calculated according to the corresponding rounding mode.\r\n      // The remainder (r) is calculated as: r = a - n * q.\r\n      //\r\n      // UP         0 The remainder is positive if the dividend is negative, else is negative.\r\n      // DOWN       1 The remainder has the same sign as the dividend (JavaScript %).\r\n      // FLOOR      3 The remainder has the same sign as the divisor (Python %).\r\n      // HALF_EVEN  6 The IEEE 754 remainder function.\r\n      // EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.\r\n      //\r\n      // Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian\r\n      // division (9) are commonly used for the modulus operation. The other rounding modes can also\r\n      // be used, but they may not give useful results.\r\n      modulo: 1,                             // 0 to 9\r\n\r\n      // The exponent value at and beneath which `toString` returns exponential notation.\r\n      // JavaScript numbers: -7\r\n      toExpNeg: -7,                          // 0 to -EXP_LIMIT\r\n\r\n      // The exponent value at and above which `toString` returns exponential notation.\r\n      // JavaScript numbers: 21\r\n      toExpPos:  21,                         // 0 to EXP_LIMIT\r\n\r\n      // The minimum exponent value, beneath which underflow to zero occurs.\r\n      // JavaScript numbers: -324  (5e-324)\r\n      minE: -EXP_LIMIT,                      // -1 to -EXP_LIMIT\r\n\r\n      // The maximum exponent value, above which overflow to Infinity occurs.\r\n      // JavaScript numbers: 308  (1.7976931348623157e+308)\r\n      maxE: EXP_LIMIT,                       // 1 to EXP_LIMIT\r\n\r\n      // Whether to use cryptographically-secure random number generation, if available.\r\n      crypto: false                          // true/false\r\n    },\r\n\r\n\r\n  // ----------------------------------- END OF EDITABLE DEFAULTS ------------------------------- //\r\n\r\n\r\n    Decimal, inexact, noConflict, quadrant,\r\n    external = true,\r\n\r\n    decimalError = '[DecimalError] ',\r\n    invalidArgument = decimalError + 'Invalid argument: ',\r\n    precisionLimitExceeded = decimalError + 'Precision limit exceeded',\r\n    cryptoUnavailable = decimalError + 'crypto unavailable',\r\n    tag = '[object Decimal]',\r\n\r\n    mathfloor = Math.floor,\r\n    mathpow = Math.pow,\r\n\r\n    isBinary = /^0b([01]+(\\.[01]*)?|\\.[01]+)(p[+-]?\\d+)?$/i,\r\n    isHex = /^0x([0-9a-f]+(\\.[0-9a-f]*)?|\\.[0-9a-f]+)(p[+-]?\\d+)?$/i,\r\n    isOctal = /^0o([0-7]+(\\.[0-7]*)?|\\.[0-7]+)(p[+-]?\\d+)?$/i,\r\n    isDecimal = /^(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?$/i,\r\n\r\n    BASE = 1e7,\r\n    LOG_BASE = 7,\r\n    MAX_SAFE_INTEGER = 9007199254740991,\r\n\r\n    LN10_PRECISION = LN10.length - 1,\r\n    PI_PRECISION = PI.length - 1,\r\n\r\n    // Decimal.prototype object\r\n    P = { toStringTag: tag };\r\n\r\n\r\n  // Decimal prototype methods\r\n\r\n\r\n  /*\r\n   *  absoluteValue             abs\r\n   *  ceil\r\n   *  clampedTo                 clamp\r\n   *  comparedTo                cmp\r\n   *  cosine                    cos\r\n   *  cubeRoot                  cbrt\r\n   *  decimalPlaces             dp\r\n   *  dividedBy                 div\r\n   *  dividedToIntegerBy        divToInt\r\n   *  equals                    eq\r\n   *  floor\r\n   *  greaterThan               gt\r\n   *  greaterThanOrEqualTo      gte\r\n   *  hyperbolicCosine          cosh\r\n   *  hyperbolicSine            sinh\r\n   *  hyperbolicTangent         tanh\r\n   *  inverseCosine             acos\r\n   *  inverseHyperbolicCosine   acosh\r\n   *  inverseHyperbolicSine     asinh\r\n   *  inverseHyperbolicTangent  atanh\r\n   *  inverseSine               asin\r\n   *  inverseTangent            atan\r\n   *  isFinite\r\n   *  isInteger                 isInt\r\n   *  isNaN\r\n   *  isNegative                isNeg\r\n   *  isPositive                isPos\r\n   *  isZero\r\n   *  lessThan                  lt\r\n   *  lessThanOrEqualTo         lte\r\n   *  logarithm                 log\r\n   *  [maximum]                 [max]\r\n   *  [minimum]                 [min]\r\n   *  minus                     sub\r\n   *  modulo                    mod\r\n   *  naturalExponential        exp\r\n   *  naturalLogarithm          ln\r\n   *  negated                   neg\r\n   *  plus                      add\r\n   *  precision                 sd\r\n   *  round\r\n   *  sine                      sin\r\n   *  squareRoot                sqrt\r\n   *  tangent                   tan\r\n   *  times                     mul\r\n   *  toBinary\r\n   *  toDecimalPlaces           toDP\r\n   *  toExponential\r\n   *  toFixed\r\n   *  toFraction\r\n   *  toHexadecimal             toHex\r\n   *  toNearest\r\n   *  toNumber\r\n   *  toOctal\r\n   *  toPower                   pow\r\n   *  toPrecision\r\n   *  toSignificantDigits       toSD\r\n   *  toString\r\n   *  truncated                 trunc\r\n   *  valueOf                   toJSON\r\n   */\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the absolute value of this Decimal.\r\n   *\r\n   */\r\n  P.absoluteValue = P.abs = function () {\r\n    var x = new this.constructor(this);\r\n    if (x.s < 0) x.s = 1;\r\n    return finalise(x);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal rounded to a whole number in the\r\n   * direction of positive Infinity.\r\n   *\r\n   */\r\n  P.ceil = function () {\r\n    return finalise(new this.constructor(this), this.e + 1, 2);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal clamped to the range\r\n   * delineated by `min` and `max`.\r\n   *\r\n   * min {number|string|Decimal}\r\n   * max {number|string|Decimal}\r\n   *\r\n   */\r\n  P.clampedTo = P.clamp = function (min, max) {\r\n    var k,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n    min = new Ctor(min);\r\n    max = new Ctor(max);\r\n    if (!min.s || !max.s) return new Ctor(NaN);\r\n    if (min.gt(max)) throw Error(invalidArgument + max);\r\n    k = x.cmp(min);\r\n    return k < 0 ? min : x.cmp(max) > 0 ? max : new Ctor(x);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return\r\n   *   1    if the value of this Decimal is greater than the value of `y`,\r\n   *  -1    if the value of this Decimal is less than the value of `y`,\r\n   *   0    if they have the same value,\r\n   *   NaN  if the value of either Decimal is NaN.\r\n   *\r\n   */\r\n  P.comparedTo = P.cmp = function (y) {\r\n    var i, j, xdL, ydL,\r\n      x = this,\r\n      xd = x.d,\r\n      yd = (y = new x.constructor(y)).d,\r\n      xs = x.s,\r\n      ys = y.s;\r\n\r\n    // Either NaN or ±Infinity?\r\n    if (!xd || !yd) {\r\n      return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;\r\n    }\r\n\r\n    // Either zero?\r\n    if (!xd[0] || !yd[0]) return xd[0] ? xs : yd[0] ? -ys : 0;\r\n\r\n    // Signs differ?\r\n    if (xs !== ys) return xs;\r\n\r\n    // Compare exponents.\r\n    if (x.e !== y.e) return x.e > y.e ^ xs < 0 ? 1 : -1;\r\n\r\n    xdL = xd.length;\r\n    ydL = yd.length;\r\n\r\n    // Compare digit by digit.\r\n    for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) {\r\n      if (xd[i] !== yd[i]) return xd[i] > yd[i] ^ xs < 0 ? 1 : -1;\r\n    }\r\n\r\n    // Compare lengths.\r\n    return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the cosine of the value in radians of this Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-1, 1]\r\n   *\r\n   * cos(0)         = 1\r\n   * cos(-0)        = 1\r\n   * cos(Infinity)  = NaN\r\n   * cos(-Infinity) = NaN\r\n   * cos(NaN)       = NaN\r\n   *\r\n   */\r\n  P.cosine = P.cos = function () {\r\n    var pr, rm,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (!x.d) return new Ctor(NaN);\r\n\r\n    // cos(0) = cos(-0) = 1\r\n    if (!x.d[0]) return new Ctor(1);\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n    Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;\r\n    Ctor.rounding = 1;\r\n\r\n    x = cosine(Ctor, toLessThanHalfPi(Ctor, x));\r\n\r\n    Ctor.precision = pr;\r\n    Ctor.rounding = rm;\r\n\r\n    return finalise(quadrant == 2 || quadrant == 3 ? x.neg() : x, pr, rm, true);\r\n  };\r\n\r\n\r\n  /*\r\n   *\r\n   * Return a new Decimal whose value is the cube root of the value of this Decimal, rounded to\r\n   * `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   *  cbrt(0)  =  0\r\n   *  cbrt(-0) = -0\r\n   *  cbrt(1)  =  1\r\n   *  cbrt(-1) = -1\r\n   *  cbrt(N)  =  N\r\n   *  cbrt(-I) = -I\r\n   *  cbrt(I)  =  I\r\n   *\r\n   * Math.cbrt(x) = (x < 0 ? -Math.pow(-x, 1/3) : Math.pow(x, 1/3))\r\n   *\r\n   */\r\n  P.cubeRoot = P.cbrt = function () {\r\n    var e, m, n, r, rep, s, sd, t, t3, t3plusx,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (!x.isFinite() || x.isZero()) return new Ctor(x);\r\n    external = false;\r\n\r\n    // Initial estimate.\r\n    s = x.s * mathpow(x.s * x, 1 / 3);\r\n\r\n     // Math.cbrt underflow/overflow?\r\n     // Pass x to Math.pow as integer, then adjust the exponent of the result.\r\n    if (!s || Math.abs(s) == 1 / 0) {\r\n      n = digitsToString(x.d);\r\n      e = x.e;\r\n\r\n      // Adjust n exponent so it is a multiple of 3 away from x exponent.\r\n      if (s = (e - n.length + 1) % 3) n += (s == 1 || s == -2 ? '0' : '00');\r\n      s = mathpow(n, 1 / 3);\r\n\r\n      // Rarely, e may be one less than the result exponent value.\r\n      e = mathfloor((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2));\r\n\r\n      if (s == 1 / 0) {\r\n        n = '5e' + e;\r\n      } else {\r\n        n = s.toExponential();\r\n        n = n.slice(0, n.indexOf('e') + 1) + e;\r\n      }\r\n\r\n      r = new Ctor(n);\r\n      r.s = x.s;\r\n    } else {\r\n      r = new Ctor(s.toString());\r\n    }\r\n\r\n    sd = (e = Ctor.precision) + 3;\r\n\r\n    // Halley's method.\r\n    // TODO? Compare Newton's method.\r\n    for (;;) {\r\n      t = r;\r\n      t3 = t.times(t).times(t);\r\n      t3plusx = t3.plus(x);\r\n      r = divide(t3plusx.plus(x).times(t), t3plusx.plus(t3), sd + 2, 1);\r\n\r\n      // TODO? Replace with for-loop and checkRoundingDigits.\r\n      if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {\r\n        n = n.slice(sd - 3, sd + 1);\r\n\r\n        // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or 4999\r\n        // , i.e. approaching a rounding boundary, continue the iteration.\r\n        if (n == '9999' || !rep && n == '4999') {\r\n\r\n          // On the first iteration only, check to see if rounding up gives the exact result as the\r\n          // nines may infinitely repeat.\r\n          if (!rep) {\r\n            finalise(t, e + 1, 0);\r\n\r\n            if (t.times(t).times(t).eq(x)) {\r\n              r = t;\r\n              break;\r\n            }\r\n          }\r\n\r\n          sd += 4;\r\n          rep = 1;\r\n        } else {\r\n\r\n          // If the rounding digits are null, 0{0,4} or 50{0,3}, check for an exact result.\r\n          // If not, then there are further digits and m will be truthy.\r\n          if (!+n || !+n.slice(1) && n.charAt(0) == '5') {\r\n\r\n            // Truncate to the first rounding digit.\r\n            finalise(r, e + 1, 1);\r\n            m = !r.times(r).times(r).eq(x);\r\n          }\r\n\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    external = true;\r\n\r\n    return finalise(r, e, Ctor.rounding, m);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return the number of decimal places of the value of this Decimal.\r\n   *\r\n   */\r\n  P.decimalPlaces = P.dp = function () {\r\n    var w,\r\n      d = this.d,\r\n      n = NaN;\r\n\r\n    if (d) {\r\n      w = d.length - 1;\r\n      n = (w - mathfloor(this.e / LOG_BASE)) * LOG_BASE;\r\n\r\n      // Subtract the number of trailing zeros of the last word.\r\n      w = d[w];\r\n      if (w) for (; w % 10 == 0; w /= 10) n--;\r\n      if (n < 0) n = 0;\r\n    }\r\n\r\n    return n;\r\n  };\r\n\r\n\r\n  /*\r\n   *  n / 0 = I\r\n   *  n / N = N\r\n   *  n / I = 0\r\n   *  0 / n = 0\r\n   *  0 / 0 = N\r\n   *  0 / N = N\r\n   *  0 / I = 0\r\n   *  N / n = N\r\n   *  N / 0 = N\r\n   *  N / N = N\r\n   *  N / I = N\r\n   *  I / n = I\r\n   *  I / 0 = I\r\n   *  I / N = N\r\n   *  I / I = N\r\n   *\r\n   * Return a new Decimal whose value is the value of this Decimal divided by `y`, rounded to\r\n   * `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   */\r\n  P.dividedBy = P.div = function (y) {\r\n    return divide(this, new this.constructor(y));\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the integer part of dividing the value of this Decimal\r\n   * by the value of `y`, rounded to `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   */\r\n  P.dividedToIntegerBy = P.divToInt = function (y) {\r\n    var x = this,\r\n      Ctor = x.constructor;\r\n    return finalise(divide(x, new Ctor(y), 0, 1, 1), Ctor.precision, Ctor.rounding);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is equal to the value of `y`, otherwise return false.\r\n   *\r\n   */\r\n  P.equals = P.eq = function (y) {\r\n    return this.cmp(y) === 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal rounded to a whole number in the\r\n   * direction of negative Infinity.\r\n   *\r\n   */\r\n  P.floor = function () {\r\n    return finalise(new this.constructor(this), this.e + 1, 3);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is greater than the value of `y`, otherwise return\r\n   * false.\r\n   *\r\n   */\r\n  P.greaterThan = P.gt = function (y) {\r\n    return this.cmp(y) > 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is greater than or equal to the value of `y`,\r\n   * otherwise return false.\r\n   *\r\n   */\r\n  P.greaterThanOrEqualTo = P.gte = function (y) {\r\n    var k = this.cmp(y);\r\n    return k == 1 || k === 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the hyperbolic cosine of the value in radians of this\r\n   * Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [1, Infinity]\r\n   *\r\n   * cosh(x) = 1 + x^2/2! + x^4/4! + x^6/6! + ...\r\n   *\r\n   * cosh(0)         = 1\r\n   * cosh(-0)        = 1\r\n   * cosh(Infinity)  = Infinity\r\n   * cosh(-Infinity) = Infinity\r\n   * cosh(NaN)       = NaN\r\n   *\r\n   *  x        time taken (ms)   result\r\n   * 1000      9                 9.8503555700852349694e+433\r\n   * 10000     25                4.4034091128314607936e+4342\r\n   * 100000    171               1.4033316802130615897e+43429\r\n   * 1000000   3817              1.5166076984010437725e+434294\r\n   * 10000000  abandoned after 2 minute wait\r\n   *\r\n   * TODO? Compare performance of cosh(x) = 0.5 * (exp(x) + exp(-x))\r\n   *\r\n   */\r\n  P.hyperbolicCosine = P.cosh = function () {\r\n    var k, n, pr, rm, len,\r\n      x = this,\r\n      Ctor = x.constructor,\r\n      one = new Ctor(1);\r\n\r\n    if (!x.isFinite()) return new Ctor(x.s ? 1 / 0 : NaN);\r\n    if (x.isZero()) return one;\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n    Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;\r\n    Ctor.rounding = 1;\r\n    len = x.d.length;\r\n\r\n    // Argument reduction: cos(4x) = 1 - 8cos^2(x) + 8cos^4(x) + 1\r\n    // i.e. cos(x) = 1 - cos^2(x/4)(8 - 8cos^2(x/4))\r\n\r\n    // Estimate the optimum number of times to use the argument reduction.\r\n    // TODO? Estimation reused from cosine() and may not be optimal here.\r\n    if (len < 32) {\r\n      k = Math.ceil(len / 3);\r\n      n = (1 / tinyPow(4, k)).toString();\r\n    } else {\r\n      k = 16;\r\n      n = '2.3283064365386962890625e-10';\r\n    }\r\n\r\n    x = taylorSeries(Ctor, 1, x.times(n), new Ctor(1), true);\r\n\r\n    // Reverse argument reduction\r\n    var cosh2_x,\r\n      i = k,\r\n      d8 = new Ctor(8);\r\n    for (; i--;) {\r\n      cosh2_x = x.times(x);\r\n      x = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));\r\n    }\r\n\r\n    return finalise(x, Ctor.precision = pr, Ctor.rounding = rm, true);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the hyperbolic sine of the value in radians of this\r\n   * Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-Infinity, Infinity]\r\n   *\r\n   * sinh(x) = x + x^3/3! + x^5/5! + x^7/7! + ...\r\n   *\r\n   * sinh(0)         = 0\r\n   * sinh(-0)        = -0\r\n   * sinh(Infinity)  = Infinity\r\n   * sinh(-Infinity) = -Infinity\r\n   * sinh(NaN)       = NaN\r\n   *\r\n   * x        time taken (ms)\r\n   * 10       2 ms\r\n   * 100      5 ms\r\n   * 1000     14 ms\r\n   * 10000    82 ms\r\n   * 100000   886 ms            1.4033316802130615897e+43429\r\n   * 200000   2613 ms\r\n   * 300000   5407 ms\r\n   * 400000   8824 ms\r\n   * 500000   13026 ms          8.7080643612718084129e+217146\r\n   * 1000000  48543 ms\r\n   *\r\n   * TODO? Compare performance of sinh(x) = 0.5 * (exp(x) - exp(-x))\r\n   *\r\n   */\r\n  P.hyperbolicSine = P.sinh = function () {\r\n    var k, pr, rm, len,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (!x.isFinite() || x.isZero()) return new Ctor(x);\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n    Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;\r\n    Ctor.rounding = 1;\r\n    len = x.d.length;\r\n\r\n    if (len < 3) {\r\n      x = taylorSeries(Ctor, 2, x, x, true);\r\n    } else {\r\n\r\n      // Alternative argument reduction: sinh(3x) = sinh(x)(3 + 4sinh^2(x))\r\n      // i.e. sinh(x) = sinh(x/3)(3 + 4sinh^2(x/3))\r\n      // 3 multiplications and 1 addition\r\n\r\n      // Argument reduction: sinh(5x) = sinh(x)(5 + sinh^2(x)(20 + 16sinh^2(x)))\r\n      // i.e. sinh(x) = sinh(x/5)(5 + sinh^2(x/5)(20 + 16sinh^2(x/5)))\r\n      // 4 multiplications and 2 additions\r\n\r\n      // Estimate the optimum number of times to use the argument reduction.\r\n      k = 1.4 * Math.sqrt(len);\r\n      k = k > 16 ? 16 : k | 0;\r\n\r\n      x = x.times(1 / tinyPow(5, k));\r\n      x = taylorSeries(Ctor, 2, x, x, true);\r\n\r\n      // Reverse argument reduction\r\n      var sinh2_x,\r\n        d5 = new Ctor(5),\r\n        d16 = new Ctor(16),\r\n        d20 = new Ctor(20);\r\n      for (; k--;) {\r\n        sinh2_x = x.times(x);\r\n        x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));\r\n      }\r\n    }\r\n\r\n    Ctor.precision = pr;\r\n    Ctor.rounding = rm;\r\n\r\n    return finalise(x, pr, rm, true);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the hyperbolic tangent of the value in radians of this\r\n   * Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-1, 1]\r\n   *\r\n   * tanh(x) = sinh(x) / cosh(x)\r\n   *\r\n   * tanh(0)         = 0\r\n   * tanh(-0)        = -0\r\n   * tanh(Infinity)  = 1\r\n   * tanh(-Infinity) = -1\r\n   * tanh(NaN)       = NaN\r\n   *\r\n   */\r\n  P.hyperbolicTangent = P.tanh = function () {\r\n    var pr, rm,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (!x.isFinite()) return new Ctor(x.s);\r\n    if (x.isZero()) return new Ctor(x);\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n    Ctor.precision = pr + 7;\r\n    Ctor.rounding = 1;\r\n\r\n    return divide(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the arccosine (inverse cosine) in radians of the value of\r\n   * this Decimal.\r\n   *\r\n   * Domain: [-1, 1]\r\n   * Range: [0, pi]\r\n   *\r\n   * acos(x) = pi/2 - asin(x)\r\n   *\r\n   * acos(0)       = pi/2\r\n   * acos(-0)      = pi/2\r\n   * acos(1)       = 0\r\n   * acos(-1)      = pi\r\n   * acos(1/2)     = pi/3\r\n   * acos(-1/2)    = 2*pi/3\r\n   * acos(|x| > 1) = NaN\r\n   * acos(NaN)     = NaN\r\n   *\r\n   */\r\n  P.inverseCosine = P.acos = function () {\r\n    var halfPi,\r\n      x = this,\r\n      Ctor = x.constructor,\r\n      k = x.abs().cmp(1),\r\n      pr = Ctor.precision,\r\n      rm = Ctor.rounding;\r\n\r\n    if (k !== -1) {\r\n      return k === 0\r\n        // |x| is 1\r\n        ? x.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0)\r\n        // |x| > 1 or x is NaN\r\n        : new Ctor(NaN);\r\n    }\r\n\r\n    if (x.isZero()) return getPi(Ctor, pr + 4, rm).times(0.5);\r\n\r\n    // TODO? Special case acos(0.5) = pi/3 and acos(-0.5) = 2*pi/3\r\n\r\n    Ctor.precision = pr + 6;\r\n    Ctor.rounding = 1;\r\n\r\n    x = x.asin();\r\n    halfPi = getPi(Ctor, pr + 4, rm).times(0.5);\r\n\r\n    Ctor.precision = pr;\r\n    Ctor.rounding = rm;\r\n\r\n    return halfPi.minus(x);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the inverse of the hyperbolic cosine in radians of the\r\n   * value of this Decimal.\r\n   *\r\n   * Domain: [1, Infinity]\r\n   * Range: [0, Infinity]\r\n   *\r\n   * acosh(x) = ln(x + sqrt(x^2 - 1))\r\n   *\r\n   * acosh(x < 1)     = NaN\r\n   * acosh(NaN)       = NaN\r\n   * acosh(Infinity)  = Infinity\r\n   * acosh(-Infinity) = NaN\r\n   * acosh(0)         = NaN\r\n   * acosh(-0)        = NaN\r\n   * acosh(1)         = 0\r\n   * acosh(-1)        = NaN\r\n   *\r\n   */\r\n  P.inverseHyperbolicCosine = P.acosh = function () {\r\n    var pr, rm,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (x.lte(1)) return new Ctor(x.eq(1) ? 0 : NaN);\r\n    if (!x.isFinite()) return new Ctor(x);\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n    Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;\r\n    Ctor.rounding = 1;\r\n    external = false;\r\n\r\n    x = x.times(x).minus(1).sqrt().plus(x);\r\n\r\n    external = true;\r\n    Ctor.precision = pr;\r\n    Ctor.rounding = rm;\r\n\r\n    return x.ln();\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the inverse of the hyperbolic sine in radians of the value\r\n   * of this Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-Infinity, Infinity]\r\n   *\r\n   * asinh(x) = ln(x + sqrt(x^2 + 1))\r\n   *\r\n   * asinh(NaN)       = NaN\r\n   * asinh(Infinity)  = Infinity\r\n   * asinh(-Infinity) = -Infinity\r\n   * asinh(0)         = 0\r\n   * asinh(-0)        = -0\r\n   *\r\n   */\r\n  P.inverseHyperbolicSine = P.asinh = function () {\r\n    var pr, rm,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (!x.isFinite() || x.isZero()) return new Ctor(x);\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n    Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6;\r\n    Ctor.rounding = 1;\r\n    external = false;\r\n\r\n    x = x.times(x).plus(1).sqrt().plus(x);\r\n\r\n    external = true;\r\n    Ctor.precision = pr;\r\n    Ctor.rounding = rm;\r\n\r\n    return x.ln();\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the inverse of the hyperbolic tangent in radians of the\r\n   * value of this Decimal.\r\n   *\r\n   * Domain: [-1, 1]\r\n   * Range: [-Infinity, Infinity]\r\n   *\r\n   * atanh(x) = 0.5 * ln((1 + x) / (1 - x))\r\n   *\r\n   * atanh(|x| > 1)   = NaN\r\n   * atanh(NaN)       = NaN\r\n   * atanh(Infinity)  = NaN\r\n   * atanh(-Infinity) = NaN\r\n   * atanh(0)         = 0\r\n   * atanh(-0)        = -0\r\n   * atanh(1)         = Infinity\r\n   * atanh(-1)        = -Infinity\r\n   *\r\n   */\r\n  P.inverseHyperbolicTangent = P.atanh = function () {\r\n    var pr, rm, wpr, xsd,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (!x.isFinite()) return new Ctor(NaN);\r\n    if (x.e >= 0) return new Ctor(x.abs().eq(1) ? x.s / 0 : x.isZero() ? x : NaN);\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n    xsd = x.sd();\r\n\r\n    if (Math.max(xsd, pr) < 2 * -x.e - 1) return finalise(new Ctor(x), pr, rm, true);\r\n\r\n    Ctor.precision = wpr = xsd - x.e;\r\n\r\n    x = divide(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1);\r\n\r\n    Ctor.precision = pr + 4;\r\n    Ctor.rounding = 1;\r\n\r\n    x = x.ln();\r\n\r\n    Ctor.precision = pr;\r\n    Ctor.rounding = rm;\r\n\r\n    return x.times(0.5);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the arcsine (inverse sine) in radians of the value of this\r\n   * Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-pi/2, pi/2]\r\n   *\r\n   * asin(x) = 2*atan(x/(1 + sqrt(1 - x^2)))\r\n   *\r\n   * asin(0)       = 0\r\n   * asin(-0)      = -0\r\n   * asin(1/2)     = pi/6\r\n   * asin(-1/2)    = -pi/6\r\n   * asin(1)       = pi/2\r\n   * asin(-1)      = -pi/2\r\n   * asin(|x| > 1) = NaN\r\n   * asin(NaN)     = NaN\r\n   *\r\n   * TODO? Compare performance of Taylor series.\r\n   *\r\n   */\r\n  P.inverseSine = P.asin = function () {\r\n    var halfPi, k,\r\n      pr, rm,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (x.isZero()) return new Ctor(x);\r\n\r\n    k = x.abs().cmp(1);\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n\r\n    if (k !== -1) {\r\n\r\n      // |x| is 1\r\n      if (k === 0) {\r\n        halfPi = getPi(Ctor, pr + 4, rm).times(0.5);\r\n        halfPi.s = x.s;\r\n        return halfPi;\r\n      }\r\n\r\n      // |x| > 1 or x is NaN\r\n      return new Ctor(NaN);\r\n    }\r\n\r\n    // TODO? Special case asin(1/2) = pi/6 and asin(-1/2) = -pi/6\r\n\r\n    Ctor.precision = pr + 6;\r\n    Ctor.rounding = 1;\r\n\r\n    x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan();\r\n\r\n    Ctor.precision = pr;\r\n    Ctor.rounding = rm;\r\n\r\n    return x.times(2);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the arctangent (inverse tangent) in radians of the value\r\n   * of this Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-pi/2, pi/2]\r\n   *\r\n   * atan(x) = x - x^3/3 + x^5/5 - x^7/7 + ...\r\n   *\r\n   * atan(0)         = 0\r\n   * atan(-0)        = -0\r\n   * atan(1)         = pi/4\r\n   * atan(-1)        = -pi/4\r\n   * atan(Infinity)  = pi/2\r\n   * atan(-Infinity) = -pi/2\r\n   * atan(NaN)       = NaN\r\n   *\r\n   */\r\n  P.inverseTangent = P.atan = function () {\r\n    var i, j, k, n, px, t, r, wpr, x2,\r\n      x = this,\r\n      Ctor = x.constructor,\r\n      pr = Ctor.precision,\r\n      rm = Ctor.rounding;\r\n\r\n    if (!x.isFinite()) {\r\n      if (!x.s) return new Ctor(NaN);\r\n      if (pr + 4 <= PI_PRECISION) {\r\n        r = getPi(Ctor, pr + 4, rm).times(0.5);\r\n        r.s = x.s;\r\n        return r;\r\n      }\r\n    } else if (x.isZero()) {\r\n      return new Ctor(x);\r\n    } else if (x.abs().eq(1) && pr + 4 <= PI_PRECISION) {\r\n      r = getPi(Ctor, pr + 4, rm).times(0.25);\r\n      r.s = x.s;\r\n      return r;\r\n    }\r\n\r\n    Ctor.precision = wpr = pr + 10;\r\n    Ctor.rounding = 1;\r\n\r\n    // TODO? if (x >= 1 && pr <= PI_PRECISION) atan(x) = halfPi * x.s - atan(1 / x);\r\n\r\n    // Argument reduction\r\n    // Ensure |x| < 0.42\r\n    // atan(x) = 2 * atan(x / (1 + sqrt(1 + x^2)))\r\n\r\n    k = Math.min(28, wpr / LOG_BASE + 2 | 0);\r\n\r\n    for (i = k; i; --i) x = x.div(x.times(x).plus(1).sqrt().plus(1));\r\n\r\n    external = false;\r\n\r\n    j = Math.ceil(wpr / LOG_BASE);\r\n    n = 1;\r\n    x2 = x.times(x);\r\n    r = new Ctor(x);\r\n    px = x;\r\n\r\n    // atan(x) = x - x^3/3 + x^5/5 - x^7/7 + ...\r\n    for (; i !== -1;) {\r\n      px = px.times(x2);\r\n      t = r.minus(px.div(n += 2));\r\n\r\n      px = px.times(x2);\r\n      r = t.plus(px.div(n += 2));\r\n\r\n      if (r.d[j] !== void 0) for (i = j; r.d[i] === t.d[i] && i--;);\r\n    }\r\n\r\n    if (k) r = r.times(2 << (k - 1));\r\n\r\n    external = true;\r\n\r\n    return finalise(r, Ctor.precision = pr, Ctor.rounding = rm, true);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is a finite number, otherwise return false.\r\n   *\r\n   */\r\n  P.isFinite = function () {\r\n    return !!this.d;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is an integer, otherwise return false.\r\n   *\r\n   */\r\n  P.isInteger = P.isInt = function () {\r\n    return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is NaN, otherwise return false.\r\n   *\r\n   */\r\n  P.isNaN = function () {\r\n    return !this.s;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is negative, otherwise return false.\r\n   *\r\n   */\r\n  P.isNegative = P.isNeg = function () {\r\n    return this.s < 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is positive, otherwise return false.\r\n   *\r\n   */\r\n  P.isPositive = P.isPos = function () {\r\n    return this.s > 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is 0 or -0, otherwise return false.\r\n   *\r\n   */\r\n  P.isZero = function () {\r\n    return !!this.d && this.d[0] === 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is less than `y`, otherwise return false.\r\n   *\r\n   */\r\n  P.lessThan = P.lt = function (y) {\r\n    return this.cmp(y) < 0;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return true if the value of this Decimal is less than or equal to `y`, otherwise return false.\r\n   *\r\n   */\r\n  P.lessThanOrEqualTo = P.lte = function (y) {\r\n    return this.cmp(y) < 1;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return the logarithm of the value of this Decimal to the specified base, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * If no base is specified, return log[10](arg).\r\n   *\r\n   * log[base](arg) = ln(arg) / ln(base)\r\n   *\r\n   * The result will always be correctly rounded if the base of the log is 10, and 'almost always'\r\n   * otherwise:\r\n   *\r\n   * Depending on the rounding mode, the result may be incorrectly rounded if the first fifteen\r\n   * rounding digits are [49]99999999999999 or [50]00000000000000. In that case, the maximum error\r\n   * between the result and the correctly rounded result will be one ulp (unit in the last place).\r\n   *\r\n   * log[-b](a)       = NaN\r\n   * log[0](a)        = NaN\r\n   * log[1](a)        = NaN\r\n   * log[NaN](a)      = NaN\r\n   * log[Infinity](a) = NaN\r\n   * log[b](0)        = -Infinity\r\n   * log[b](-0)       = -Infinity\r\n   * log[b](-a)       = NaN\r\n   * log[b](1)        = 0\r\n   * log[b](Infinity) = Infinity\r\n   * log[b](NaN)      = NaN\r\n   *\r\n   * [base] {number|string|Decimal} The base of the logarithm.\r\n   *\r\n   */\r\n  P.logarithm = P.log = function (base) {\r\n    var isBase10, d, denominator, k, inf, num, sd, r,\r\n      arg = this,\r\n      Ctor = arg.constructor,\r\n      pr = Ctor.precision,\r\n      rm = Ctor.rounding,\r\n      guard = 5;\r\n\r\n    // Default base is 10.\r\n    if (base == null) {\r\n      base = new Ctor(10);\r\n      isBase10 = true;\r\n    } else {\r\n      base = new Ctor(base);\r\n      d = base.d;\r\n\r\n      // Return NaN if base is negative, or non-finite, or is 0 or 1.\r\n      if (base.s < 0 || !d || !d[0] || base.eq(1)) return new Ctor(NaN);\r\n\r\n      isBase10 = base.eq(10);\r\n    }\r\n\r\n    d = arg.d;\r\n\r\n    // Is arg negative, non-finite, 0 or 1?\r\n    if (arg.s < 0 || !d || !d[0] || arg.eq(1)) {\r\n      return new Ctor(d && !d[0] ? -1 / 0 : arg.s != 1 ? NaN : d ? 0 : 1 / 0);\r\n    }\r\n\r\n    // The result will have a non-terminating decimal expansion if base is 10 and arg is not an\r\n    // integer power of 10.\r\n    if (isBase10) {\r\n      if (d.length > 1) {\r\n        inf = true;\r\n      } else {\r\n        for (k = d[0]; k % 10 === 0;) k /= 10;\r\n        inf = k !== 1;\r\n      }\r\n    }\r\n\r\n    external = false;\r\n    sd = pr + guard;\r\n    num = naturalLogarithm(arg, sd);\r\n    denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);\r\n\r\n    // The result will have 5 rounding digits.\r\n    r = divide(num, denominator, sd, 1);\r\n\r\n    // If at a rounding boundary, i.e. the result's rounding digits are [49]9999 or [50]0000,\r\n    // calculate 10 further digits.\r\n    //\r\n    // If the result is known to have an infinite decimal expansion, repeat this until it is clear\r\n    // that the result is above or below the boundary. Otherwise, if after calculating the 10\r\n    // further digits, the last 14 are nines, round up and assume the result is exact.\r\n    // Also assume the result is exact if the last 14 are zero.\r\n    //\r\n    // Example of a result that will be incorrectly rounded:\r\n    // log[1048576](4503599627370502) = 2.60000000000000009610279511444746...\r\n    // The above result correctly rounded using ROUND_CEIL to 1 decimal place should be 2.7, but it\r\n    // will be given as 2.6 as there are 15 zeros immediately after the requested decimal place, so\r\n    // the exact result would be assumed to be 2.6, which rounded using ROUND_CEIL to 1 decimal\r\n    // place is still 2.6.\r\n    if (checkRoundingDigits(r.d, k = pr, rm)) {\r\n\r\n      do {\r\n        sd += 10;\r\n        num = naturalLogarithm(arg, sd);\r\n        denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);\r\n        r = divide(num, denominator, sd, 1);\r\n\r\n        if (!inf) {\r\n\r\n          // Check for 14 nines from the 2nd rounding digit, as the first may be 4.\r\n          if (+digitsToString(r.d).slice(k + 1, k + 15) + 1 == 1e14) {\r\n            r = finalise(r, pr + 1, 0);\r\n          }\r\n\r\n          break;\r\n        }\r\n      } while (checkRoundingDigits(r.d, k += 10, rm));\r\n    }\r\n\r\n    external = true;\r\n\r\n    return finalise(r, pr, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the maximum of the arguments and the value of this Decimal.\r\n   *\r\n   * arguments {number|string|Decimal}\r\n   *\r\n  P.max = function () {\r\n    Array.prototype.push.call(arguments, this);\r\n    return maxOrMin(this.constructor, arguments, 'lt');\r\n  };\r\n   */\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the minimum of the arguments and the value of this Decimal.\r\n   *\r\n   * arguments {number|string|Decimal}\r\n   *\r\n  P.min = function () {\r\n    Array.prototype.push.call(arguments, this);\r\n    return maxOrMin(this.constructor, arguments, 'gt');\r\n  };\r\n   */\r\n\r\n\r\n  /*\r\n   *  n - 0 = n\r\n   *  n - N = N\r\n   *  n - I = -I\r\n   *  0 - n = -n\r\n   *  0 - 0 = 0\r\n   *  0 - N = N\r\n   *  0 - I = -I\r\n   *  N - n = N\r\n   *  N - 0 = N\r\n   *  N - N = N\r\n   *  N - I = N\r\n   *  I - n = I\r\n   *  I - 0 = I\r\n   *  I - N = N\r\n   *  I - I = N\r\n   *\r\n   * Return a new Decimal whose value is the value of this Decimal minus `y`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   */\r\n  P.minus = P.sub = function (y) {\r\n    var d, e, i, j, k, len, pr, rm, xd, xe, xLTy, yd,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    y = new Ctor(y);\r\n\r\n    // If either is not finite...\r\n    if (!x.d || !y.d) {\r\n\r\n      // Return NaN if either is NaN.\r\n      if (!x.s || !y.s) y = new Ctor(NaN);\r\n\r\n      // Return y negated if x is finite and y is ±Infinity.\r\n      else if (x.d) y.s = -y.s;\r\n\r\n      // Return x if y is finite and x is ±Infinity.\r\n      // Return x if both are ±Infinity with different signs.\r\n      // Return NaN if both are ±Infinity with the same sign.\r\n      else y = new Ctor(y.d || x.s !== y.s ? x : NaN);\r\n\r\n      return y;\r\n    }\r\n\r\n    // If signs differ...\r\n    if (x.s != y.s) {\r\n      y.s = -y.s;\r\n      return x.plus(y);\r\n    }\r\n\r\n    xd = x.d;\r\n    yd = y.d;\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n\r\n    // If either is zero...\r\n    if (!xd[0] || !yd[0]) {\r\n\r\n      // Return y negated if x is zero and y is non-zero.\r\n      if (yd[0]) y.s = -y.s;\r\n\r\n      // Return x if y is zero and x is non-zero.\r\n      else if (xd[0]) y = new Ctor(x);\r\n\r\n      // Return zero if both are zero.\r\n      // From IEEE 754 (2008) 6.3: 0 - 0 = -0 - -0 = -0 when rounding to -Infinity.\r\n      else return new Ctor(rm === 3 ? -0 : 0);\r\n\r\n      return external ? finalise(y, pr, rm) : y;\r\n    }\r\n\r\n    // x and y are finite, non-zero numbers with the same sign.\r\n\r\n    // Calculate base 1e7 exponents.\r\n    e = mathfloor(y.e / LOG_BASE);\r\n    xe = mathfloor(x.e / LOG_BASE);\r\n\r\n    xd = xd.slice();\r\n    k = xe - e;\r\n\r\n    // If base 1e7 exponents differ...\r\n    if (k) {\r\n      xLTy = k < 0;\r\n\r\n      if (xLTy) {\r\n        d = xd;\r\n        k = -k;\r\n        len = yd.length;\r\n      } else {\r\n        d = yd;\r\n        e = xe;\r\n        len = xd.length;\r\n      }\r\n\r\n      // Numbers with massively different exponents would result in a very high number of\r\n      // zeros needing to be prepended, but this can be avoided while still ensuring correct\r\n      // rounding by limiting the number of zeros to `Math.ceil(pr / LOG_BASE) + 2`.\r\n      i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;\r\n\r\n      if (k > i) {\r\n        k = i;\r\n        d.length = 1;\r\n      }\r\n\r\n      // Prepend zeros to equalise exponents.\r\n      d.reverse();\r\n      for (i = k; i--;) d.push(0);\r\n      d.reverse();\r\n\r\n    // Base 1e7 exponents equal.\r\n    } else {\r\n\r\n      // Check digits to determine which is the bigger number.\r\n\r\n      i = xd.length;\r\n      len = yd.length;\r\n      xLTy = i < len;\r\n      if (xLTy) len = i;\r\n\r\n      for (i = 0; i < len; i++) {\r\n        if (xd[i] != yd[i]) {\r\n          xLTy = xd[i] < yd[i];\r\n          break;\r\n        }\r\n      }\r\n\r\n      k = 0;\r\n    }\r\n\r\n    if (xLTy) {\r\n      d = xd;\r\n      xd = yd;\r\n      yd = d;\r\n      y.s = -y.s;\r\n    }\r\n\r\n    len = xd.length;\r\n\r\n    // Append zeros to `xd` if shorter.\r\n    // Don't add zeros to `yd` if shorter as subtraction only needs to start at `yd` length.\r\n    for (i = yd.length - len; i > 0; --i) xd[len++] = 0;\r\n\r\n    // Subtract yd from xd.\r\n    for (i = yd.length; i > k;) {\r\n\r\n      if (xd[--i] < yd[i]) {\r\n        for (j = i; j && xd[--j] === 0;) xd[j] = BASE - 1;\r\n        --xd[j];\r\n        xd[i] += BASE;\r\n      }\r\n\r\n      xd[i] -= yd[i];\r\n    }\r\n\r\n    // Remove trailing zeros.\r\n    for (; xd[--len] === 0;) xd.pop();\r\n\r\n    // Remove leading zeros and adjust exponent accordingly.\r\n    for (; xd[0] === 0; xd.shift()) --e;\r\n\r\n    // Zero?\r\n    if (!xd[0]) return new Ctor(rm === 3 ? -0 : 0);\r\n\r\n    y.d = xd;\r\n    y.e = getBase10Exponent(xd, e);\r\n\r\n    return external ? finalise(y, pr, rm) : y;\r\n  };\r\n\r\n\r\n  /*\r\n   *   n % 0 =  N\r\n   *   n % N =  N\r\n   *   n % I =  n\r\n   *   0 % n =  0\r\n   *  -0 % n = -0\r\n   *   0 % 0 =  N\r\n   *   0 % N =  N\r\n   *   0 % I =  0\r\n   *   N % n =  N\r\n   *   N % 0 =  N\r\n   *   N % N =  N\r\n   *   N % I =  N\r\n   *   I % n =  N\r\n   *   I % 0 =  N\r\n   *   I % N =  N\r\n   *   I % I =  N\r\n   *\r\n   * Return a new Decimal whose value is the value of this Decimal modulo `y`, rounded to\r\n   * `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * The result depends on the modulo mode.\r\n   *\r\n   */\r\n  P.modulo = P.mod = function (y) {\r\n    var q,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    y = new Ctor(y);\r\n\r\n    // Return NaN if x is ±Infinity or NaN, or y is NaN or ±0.\r\n    if (!x.d || !y.s || y.d && !y.d[0]) return new Ctor(NaN);\r\n\r\n    // Return x if y is ±Infinity or x is ±0.\r\n    if (!y.d || x.d && !x.d[0]) {\r\n      return finalise(new Ctor(x), Ctor.precision, Ctor.rounding);\r\n    }\r\n\r\n    // Prevent rounding of intermediate calculations.\r\n    external = false;\r\n\r\n    if (Ctor.modulo == 9) {\r\n\r\n      // Euclidian division: q = sign(y) * floor(x / abs(y))\r\n      // result = x - q * y    where  0 <= result < abs(y)\r\n      q = divide(x, y.abs(), 0, 3, 1);\r\n      q.s *= y.s;\r\n    } else {\r\n      q = divide(x, y, 0, Ctor.modulo, 1);\r\n    }\r\n\r\n    q = q.times(y);\r\n\r\n    external = true;\r\n\r\n    return x.minus(q);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the natural exponential of the value of this Decimal,\r\n   * i.e. the base e raised to the power the value of this Decimal, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   */\r\n  P.naturalExponential = P.exp = function () {\r\n    return naturalExponential(this);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the natural logarithm of the value of this Decimal,\r\n   * rounded to `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   */\r\n  P.naturalLogarithm = P.ln = function () {\r\n    return naturalLogarithm(this);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal negated, i.e. as if multiplied by\r\n   * -1.\r\n   *\r\n   */\r\n  P.negated = P.neg = function () {\r\n    var x = new this.constructor(this);\r\n    x.s = -x.s;\r\n    return finalise(x);\r\n  };\r\n\r\n\r\n  /*\r\n   *  n + 0 = n\r\n   *  n + N = N\r\n   *  n + I = I\r\n   *  0 + n = n\r\n   *  0 + 0 = 0\r\n   *  0 + N = N\r\n   *  0 + I = I\r\n   *  N + n = N\r\n   *  N + 0 = N\r\n   *  N + N = N\r\n   *  N + I = N\r\n   *  I + n = I\r\n   *  I + 0 = I\r\n   *  I + N = N\r\n   *  I + I = I\r\n   *\r\n   * Return a new Decimal whose value is the value of this Decimal plus `y`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   */\r\n  P.plus = P.add = function (y) {\r\n    var carry, d, e, i, k, len, pr, rm, xd, yd,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    y = new Ctor(y);\r\n\r\n    // If either is not finite...\r\n    if (!x.d || !y.d) {\r\n\r\n      // Return NaN if either is NaN.\r\n      if (!x.s || !y.s) y = new Ctor(NaN);\r\n\r\n      // Return x if y is finite and x is ±Infinity.\r\n      // Return x if both are ±Infinity with the same sign.\r\n      // Return NaN if both are ±Infinity with different signs.\r\n      // Return y if x is finite and y is ±Infinity.\r\n      else if (!x.d) y = new Ctor(y.d || x.s === y.s ? x : NaN);\r\n\r\n      return y;\r\n    }\r\n\r\n     // If signs differ...\r\n    if (x.s != y.s) {\r\n      y.s = -y.s;\r\n      return x.minus(y);\r\n    }\r\n\r\n    xd = x.d;\r\n    yd = y.d;\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n\r\n    // If either is zero...\r\n    if (!xd[0] || !yd[0]) {\r\n\r\n      // Return x if y is zero.\r\n      // Return y if y is non-zero.\r\n      if (!yd[0]) y = new Ctor(x);\r\n\r\n      return external ? finalise(y, pr, rm) : y;\r\n    }\r\n\r\n    // x and y are finite, non-zero numbers with the same sign.\r\n\r\n    // Calculate base 1e7 exponents.\r\n    k = mathfloor(x.e / LOG_BASE);\r\n    e = mathfloor(y.e / LOG_BASE);\r\n\r\n    xd = xd.slice();\r\n    i = k - e;\r\n\r\n    // If base 1e7 exponents differ...\r\n    if (i) {\r\n\r\n      if (i < 0) {\r\n        d = xd;\r\n        i = -i;\r\n        len = yd.length;\r\n      } else {\r\n        d = yd;\r\n        e = k;\r\n        len = xd.length;\r\n      }\r\n\r\n      // Limit number of zeros prepended to max(ceil(pr / LOG_BASE), len) + 1.\r\n      k = Math.ceil(pr / LOG_BASE);\r\n      len = k > len ? k + 1 : len + 1;\r\n\r\n      if (i > len) {\r\n        i = len;\r\n        d.length = 1;\r\n      }\r\n\r\n      // Prepend zeros to equalise exponents. Note: Faster to use reverse then do unshifts.\r\n      d.reverse();\r\n      for (; i--;) d.push(0);\r\n      d.reverse();\r\n    }\r\n\r\n    len = xd.length;\r\n    i = yd.length;\r\n\r\n    // If yd is longer than xd, swap xd and yd so xd points to the longer array.\r\n    if (len - i < 0) {\r\n      i = len;\r\n      d = yd;\r\n      yd = xd;\r\n      xd = d;\r\n    }\r\n\r\n    // Only start adding at yd.length - 1 as the further digits of xd can be left as they are.\r\n    for (carry = 0; i;) {\r\n      carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;\r\n      xd[i] %= BASE;\r\n    }\r\n\r\n    if (carry) {\r\n      xd.unshift(carry);\r\n      ++e;\r\n    }\r\n\r\n    // Remove trailing zeros.\r\n    // No need to check for zero, as +x + +y != 0 && -x + -y != 0\r\n    for (len = xd.length; xd[--len] == 0;) xd.pop();\r\n\r\n    y.d = xd;\r\n    y.e = getBase10Exponent(xd, e);\r\n\r\n    return external ? finalise(y, pr, rm) : y;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return the number of significant digits of the value of this Decimal.\r\n   *\r\n   * [z] {boolean|number} Whether to count integer-part trailing zeros: true, false, 1 or 0.\r\n   *\r\n   */\r\n  P.precision = P.sd = function (z) {\r\n    var k,\r\n      x = this;\r\n\r\n    if (z !== void 0 && z !== !!z && z !== 1 && z !== 0) throw Error(invalidArgument + z);\r\n\r\n    if (x.d) {\r\n      k = getPrecision(x.d);\r\n      if (z && x.e + 1 > k) k = x.e + 1;\r\n    } else {\r\n      k = NaN;\r\n    }\r\n\r\n    return k;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal rounded to a whole number using\r\n   * rounding mode `rounding`.\r\n   *\r\n   */\r\n  P.round = function () {\r\n    var x = this,\r\n      Ctor = x.constructor;\r\n\r\n    return finalise(new Ctor(x), x.e + 1, Ctor.rounding);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the sine of the value in radians of this Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-1, 1]\r\n   *\r\n   * sin(x) = x - x^3/3! + x^5/5! - ...\r\n   *\r\n   * sin(0)         = 0\r\n   * sin(-0)        = -0\r\n   * sin(Infinity)  = NaN\r\n   * sin(-Infinity) = NaN\r\n   * sin(NaN)       = NaN\r\n   *\r\n   */\r\n  P.sine = P.sin = function () {\r\n    var pr, rm,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (!x.isFinite()) return new Ctor(NaN);\r\n    if (x.isZero()) return new Ctor(x);\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n    Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;\r\n    Ctor.rounding = 1;\r\n\r\n    x = sine(Ctor, toLessThanHalfPi(Ctor, x));\r\n\r\n    Ctor.precision = pr;\r\n    Ctor.rounding = rm;\r\n\r\n    return finalise(quadrant > 2 ? x.neg() : x, pr, rm, true);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the square root of this Decimal, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   *  sqrt(-n) =  N\r\n   *  sqrt(N)  =  N\r\n   *  sqrt(-I) =  N\r\n   *  sqrt(I)  =  I\r\n   *  sqrt(0)  =  0\r\n   *  sqrt(-0) = -0\r\n   *\r\n   */\r\n  P.squareRoot = P.sqrt = function () {\r\n    var m, n, sd, r, rep, t,\r\n      x = this,\r\n      d = x.d,\r\n      e = x.e,\r\n      s = x.s,\r\n      Ctor = x.constructor;\r\n\r\n    // Negative/NaN/Infinity/zero?\r\n    if (s !== 1 || !d || !d[0]) {\r\n      return new Ctor(!s || s < 0 && (!d || d[0]) ? NaN : d ? x : 1 / 0);\r\n    }\r\n\r\n    external = false;\r\n\r\n    // Initial estimate.\r\n    s = Math.sqrt(+x);\r\n\r\n    // Math.sqrt underflow/overflow?\r\n    // Pass x to Math.sqrt as integer, then adjust the exponent of the result.\r\n    if (s == 0 || s == 1 / 0) {\r\n      n = digitsToString(d);\r\n\r\n      if ((n.length + e) % 2 == 0) n += '0';\r\n      s = Math.sqrt(n);\r\n      e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);\r\n\r\n      if (s == 1 / 0) {\r\n        n = '5e' + e;\r\n      } else {\r\n        n = s.toExponential();\r\n        n = n.slice(0, n.indexOf('e') + 1) + e;\r\n      }\r\n\r\n      r = new Ctor(n);\r\n    } else {\r\n      r = new Ctor(s.toString());\r\n    }\r\n\r\n    sd = (e = Ctor.precision) + 3;\r\n\r\n    // Newton-Raphson iteration.\r\n    for (;;) {\r\n      t = r;\r\n      r = t.plus(divide(x, t, sd + 2, 1)).times(0.5);\r\n\r\n      // TODO? Replace with for-loop and checkRoundingDigits.\r\n      if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {\r\n        n = n.slice(sd - 3, sd + 1);\r\n\r\n        // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or\r\n        // 4999, i.e. approaching a rounding boundary, continue the iteration.\r\n        if (n == '9999' || !rep && n == '4999') {\r\n\r\n          // On the first iteration only, check to see if rounding up gives the exact result as the\r\n          // nines may infinitely repeat.\r\n          if (!rep) {\r\n            finalise(t, e + 1, 0);\r\n\r\n            if (t.times(t).eq(x)) {\r\n              r = t;\r\n              break;\r\n            }\r\n          }\r\n\r\n          sd += 4;\r\n          rep = 1;\r\n        } else {\r\n\r\n          // If the rounding digits are null, 0{0,4} or 50{0,3}, check for an exact result.\r\n          // If not, then there are further digits and m will be truthy.\r\n          if (!+n || !+n.slice(1) && n.charAt(0) == '5') {\r\n\r\n            // Truncate to the first rounding digit.\r\n            finalise(r, e + 1, 1);\r\n            m = !r.times(r).eq(x);\r\n          }\r\n\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    external = true;\r\n\r\n    return finalise(r, e, Ctor.rounding, m);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the tangent of the value in radians of this Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-Infinity, Infinity]\r\n   *\r\n   * tan(0)         = 0\r\n   * tan(-0)        = -0\r\n   * tan(Infinity)  = NaN\r\n   * tan(-Infinity) = NaN\r\n   * tan(NaN)       = NaN\r\n   *\r\n   */\r\n  P.tangent = P.tan = function () {\r\n    var pr, rm,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (!x.isFinite()) return new Ctor(NaN);\r\n    if (x.isZero()) return new Ctor(x);\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n    Ctor.precision = pr + 10;\r\n    Ctor.rounding = 1;\r\n\r\n    x = x.sin();\r\n    x.s = 1;\r\n    x = divide(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);\r\n\r\n    Ctor.precision = pr;\r\n    Ctor.rounding = rm;\r\n\r\n    return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);\r\n  };\r\n\r\n\r\n  /*\r\n   *  n * 0 = 0\r\n   *  n * N = N\r\n   *  n * I = I\r\n   *  0 * n = 0\r\n   *  0 * 0 = 0\r\n   *  0 * N = N\r\n   *  0 * I = N\r\n   *  N * n = N\r\n   *  N * 0 = N\r\n   *  N * N = N\r\n   *  N * I = N\r\n   *  I * n = I\r\n   *  I * 0 = N\r\n   *  I * N = N\r\n   *  I * I = I\r\n   *\r\n   * Return a new Decimal whose value is this Decimal times `y`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   */\r\n  P.times = P.mul = function (y) {\r\n    var carry, e, i, k, r, rL, t, xdL, ydL,\r\n      x = this,\r\n      Ctor = x.constructor,\r\n      xd = x.d,\r\n      yd = (y = new Ctor(y)).d;\r\n\r\n    y.s *= x.s;\r\n\r\n     // If either is NaN, ±Infinity or ±0...\r\n    if (!xd || !xd[0] || !yd || !yd[0]) {\r\n\r\n      return new Ctor(!y.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd\r\n\r\n        // Return NaN if either is NaN.\r\n        // Return NaN if x is ±0 and y is ±Infinity, or y is ±0 and x is ±Infinity.\r\n        ? NaN\r\n\r\n        // Return ±Infinity if either is ±Infinity.\r\n        // Return ±0 if either is ±0.\r\n        : !xd || !yd ? y.s / 0 : y.s * 0);\r\n    }\r\n\r\n    e = mathfloor(x.e / LOG_BASE) + mathfloor(y.e / LOG_BASE);\r\n    xdL = xd.length;\r\n    ydL = yd.length;\r\n\r\n    // Ensure xd points to the longer array.\r\n    if (xdL < ydL) {\r\n      r = xd;\r\n      xd = yd;\r\n      yd = r;\r\n      rL = xdL;\r\n      xdL = ydL;\r\n      ydL = rL;\r\n    }\r\n\r\n    // Initialise the result array with zeros.\r\n    r = [];\r\n    rL = xdL + ydL;\r\n    for (i = rL; i--;) r.push(0);\r\n\r\n    // Multiply!\r\n    for (i = ydL; --i >= 0;) {\r\n      carry = 0;\r\n      for (k = xdL + i; k > i;) {\r\n        t = r[k] + yd[i] * xd[k - i - 1] + carry;\r\n        r[k--] = t % BASE | 0;\r\n        carry = t / BASE | 0;\r\n      }\r\n\r\n      r[k] = (r[k] + carry) % BASE | 0;\r\n    }\r\n\r\n    // Remove trailing zeros.\r\n    for (; !r[--rL];) r.pop();\r\n\r\n    if (carry) ++e;\r\n    else r.shift();\r\n\r\n    y.d = r;\r\n    y.e = getBase10Exponent(r, e);\r\n\r\n    return external ? finalise(y, Ctor.precision, Ctor.rounding) : y;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Decimal in base 2, round to `sd` significant\r\n   * digits using rounding mode `rm`.\r\n   *\r\n   * If the optional `sd` argument is present then return binary exponential notation.\r\n   *\r\n   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   */\r\n  P.toBinary = function (sd, rm) {\r\n    return toStringBinary(this, 2, sd, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `dp`\r\n   * decimal places using rounding mode `rm` or `rounding` if `rm` is omitted.\r\n   *\r\n   * If `dp` is omitted, return a new Decimal whose value is the value of this Decimal.\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   */\r\n  P.toDecimalPlaces = P.toDP = function (dp, rm) {\r\n    var x = this,\r\n      Ctor = x.constructor;\r\n\r\n    x = new Ctor(x);\r\n    if (dp === void 0) return x;\r\n\r\n    checkInt32(dp, 0, MAX_DIGITS);\r\n\r\n    if (rm === void 0) rm = Ctor.rounding;\r\n    else checkInt32(rm, 0, 8);\r\n\r\n    return finalise(x, dp + x.e + 1, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Decimal in exponential notation rounded to\r\n   * `dp` fixed decimal places using rounding mode `rounding`.\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   */\r\n  P.toExponential = function (dp, rm) {\r\n    var str,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (dp === void 0) {\r\n      str = finiteToString(x, true);\r\n    } else {\r\n      checkInt32(dp, 0, MAX_DIGITS);\r\n\r\n      if (rm === void 0) rm = Ctor.rounding;\r\n      else checkInt32(rm, 0, 8);\r\n\r\n      x = finalise(new Ctor(x), dp + 1, rm);\r\n      str = finiteToString(x, true, dp + 1);\r\n    }\r\n\r\n    return x.isNeg() && !x.isZero() ? '-' + str : str;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Decimal in normal (fixed-point) notation to\r\n   * `dp` fixed decimal places and rounded using rounding mode `rm` or `rounding` if `rm` is\r\n   * omitted.\r\n   *\r\n   * As with JavaScript numbers, (-0).toFixed(0) is '0', but e.g. (-0.00001).toFixed(0) is '-0'.\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * (-0).toFixed(0) is '0', but (-0.1).toFixed(0) is '-0'.\r\n   * (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.\r\n   * (-0).toFixed(3) is '0.000'.\r\n   * (-0.5).toFixed(0) is '-0'.\r\n   *\r\n   */\r\n  P.toFixed = function (dp, rm) {\r\n    var str, y,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (dp === void 0) {\r\n      str = finiteToString(x);\r\n    } else {\r\n      checkInt32(dp, 0, MAX_DIGITS);\r\n\r\n      if (rm === void 0) rm = Ctor.rounding;\r\n      else checkInt32(rm, 0, 8);\r\n\r\n      y = finalise(new Ctor(x), dp + x.e + 1, rm);\r\n      str = finiteToString(y, false, dp + y.e + 1);\r\n    }\r\n\r\n    // To determine whether to add the minus sign look at the value before it was rounded,\r\n    // i.e. look at `x` rather than `y`.\r\n    return x.isNeg() && !x.isZero() ? '-' + str : str;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return an array representing the value of this Decimal as a simple fraction with an integer\r\n   * numerator and an integer denominator.\r\n   *\r\n   * The denominator will be a positive non-zero value less than or equal to the specified maximum\r\n   * denominator. If a maximum denominator is not specified, the denominator will be the lowest\r\n   * value necessary to represent the number exactly.\r\n   *\r\n   * [maxD] {number|string|Decimal} Maximum denominator. Integer >= 1 and < Infinity.\r\n   *\r\n   */\r\n  P.toFraction = function (maxD) {\r\n    var d, d0, d1, d2, e, k, n, n0, n1, pr, q, r,\r\n      x = this,\r\n      xd = x.d,\r\n      Ctor = x.constructor;\r\n\r\n    if (!xd) return new Ctor(x);\r\n\r\n    n1 = d0 = new Ctor(1);\r\n    d1 = n0 = new Ctor(0);\r\n\r\n    d = new Ctor(d1);\r\n    e = d.e = getPrecision(xd) - x.e - 1;\r\n    k = e % LOG_BASE;\r\n    d.d[0] = mathpow(10, k < 0 ? LOG_BASE + k : k);\r\n\r\n    if (maxD == null) {\r\n\r\n      // d is 10**e, the minimum max-denominator needed.\r\n      maxD = e > 0 ? d : n1;\r\n    } else {\r\n      n = new Ctor(maxD);\r\n      if (!n.isInt() || n.lt(n1)) throw Error(invalidArgument + n);\r\n      maxD = n.gt(d) ? (e > 0 ? d : n1) : n;\r\n    }\r\n\r\n    external = false;\r\n    n = new Ctor(digitsToString(xd));\r\n    pr = Ctor.precision;\r\n    Ctor.precision = e = xd.length * LOG_BASE * 2;\r\n\r\n    for (;;)  {\r\n      q = divide(n, d, 0, 1, 1);\r\n      d2 = d0.plus(q.times(d1));\r\n      if (d2.cmp(maxD) == 1) break;\r\n      d0 = d1;\r\n      d1 = d2;\r\n      d2 = n1;\r\n      n1 = n0.plus(q.times(d2));\r\n      n0 = d2;\r\n      d2 = d;\r\n      d = n.minus(q.times(d2));\r\n      n = d2;\r\n    }\r\n\r\n    d2 = divide(maxD.minus(d0), d1, 0, 1, 1);\r\n    n0 = n0.plus(d2.times(n1));\r\n    d0 = d0.plus(d2.times(d1));\r\n    n0.s = n1.s = x.s;\r\n\r\n    // Determine which fraction is closer to x, n0/d0 or n1/d1?\r\n    r = divide(n1, d1, e, 1).minus(x).abs().cmp(divide(n0, d0, e, 1).minus(x).abs()) < 1\r\n        ? [n1, d1] : [n0, d0];\r\n\r\n    Ctor.precision = pr;\r\n    external = true;\r\n\r\n    return r;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Decimal in base 16, round to `sd` significant\r\n   * digits using rounding mode `rm`.\r\n   *\r\n   * If the optional `sd` argument is present then return binary exponential notation.\r\n   *\r\n   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   */\r\n  P.toHexadecimal = P.toHex = function (sd, rm) {\r\n    return toStringBinary(this, 16, sd, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Returns a new Decimal whose value is the nearest multiple of `y` in the direction of rounding\r\n   * mode `rm`, or `Decimal.rounding` if `rm` is omitted, to the value of this Decimal.\r\n   *\r\n   * The return value will always have the same sign as this Decimal, unless either this Decimal\r\n   * or `y` is NaN, in which case the return value will be also be NaN.\r\n   *\r\n   * The return value is not affected by the value of `precision`.\r\n   *\r\n   * y {number|string|Decimal} The magnitude to round to a multiple of.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * 'toNearest() rounding mode not an integer: {rm}'\r\n   * 'toNearest() rounding mode out of range: {rm}'\r\n   *\r\n   */\r\n  P.toNearest = function (y, rm) {\r\n    var x = this,\r\n      Ctor = x.constructor;\r\n\r\n    x = new Ctor(x);\r\n\r\n    if (y == null) {\r\n\r\n      // If x is not finite, return x.\r\n      if (!x.d) return x;\r\n\r\n      y = new Ctor(1);\r\n      rm = Ctor.rounding;\r\n    } else {\r\n      y = new Ctor(y);\r\n      if (rm === void 0) {\r\n        rm = Ctor.rounding;\r\n      } else {\r\n        checkInt32(rm, 0, 8);\r\n      }\r\n\r\n      // If x is not finite, return x if y is not NaN, else NaN.\r\n      if (!x.d) return y.s ? x : y;\r\n\r\n      // If y is not finite, return Infinity with the sign of x if y is Infinity, else NaN.\r\n      if (!y.d) {\r\n        if (y.s) y.s = x.s;\r\n        return y;\r\n      }\r\n    }\r\n\r\n    // If y is not zero, calculate the nearest multiple of y to x.\r\n    if (y.d[0]) {\r\n      external = false;\r\n      x = divide(x, y, 0, rm, 1).times(y);\r\n      external = true;\r\n      finalise(x);\r\n\r\n    // If y is zero, return zero with the sign of x.\r\n    } else {\r\n      y.s = x.s;\r\n      x = y;\r\n    }\r\n\r\n    return x;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return the value of this Decimal converted to a number primitive.\r\n   * Zero keeps its sign.\r\n   *\r\n   */\r\n  P.toNumber = function () {\r\n    return +this;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Decimal in base 8, round to `sd` significant\r\n   * digits using rounding mode `rm`.\r\n   *\r\n   * If the optional `sd` argument is present then return binary exponential notation.\r\n   *\r\n   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   */\r\n  P.toOctal = function (sd, rm) {\r\n    return toStringBinary(this, 8, sd, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal raised to the power `y`, rounded\r\n   * to `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * ECMAScript compliant.\r\n   *\r\n   *   pow(x, NaN)                           = NaN\r\n   *   pow(x, ±0)                            = 1\r\n\r\n   *   pow(NaN, non-zero)                    = NaN\r\n   *   pow(abs(x) > 1, +Infinity)            = +Infinity\r\n   *   pow(abs(x) > 1, -Infinity)            = +0\r\n   *   pow(abs(x) == 1, ±Infinity)           = NaN\r\n   *   pow(abs(x) < 1, +Infinity)            = +0\r\n   *   pow(abs(x) < 1, -Infinity)            = +Infinity\r\n   *   pow(+Infinity, y > 0)                 = +Infinity\r\n   *   pow(+Infinity, y < 0)                 = +0\r\n   *   pow(-Infinity, odd integer > 0)       = -Infinity\r\n   *   pow(-Infinity, even integer > 0)      = +Infinity\r\n   *   pow(-Infinity, odd integer < 0)       = -0\r\n   *   pow(-Infinity, even integer < 0)      = +0\r\n   *   pow(+0, y > 0)                        = +0\r\n   *   pow(+0, y < 0)                        = +Infinity\r\n   *   pow(-0, odd integer > 0)              = -0\r\n   *   pow(-0, even integer > 0)             = +0\r\n   *   pow(-0, odd integer < 0)              = -Infinity\r\n   *   pow(-0, even integer < 0)             = +Infinity\r\n   *   pow(finite x < 0, finite non-integer) = NaN\r\n   *\r\n   * For non-integer or very large exponents pow(x, y) is calculated using\r\n   *\r\n   *   x^y = exp(y*ln(x))\r\n   *\r\n   * Assuming the first 15 rounding digits are each equally likely to be any digit 0-9, the\r\n   * probability of an incorrectly rounded result\r\n   * P([49]9{14} | [50]0{14}) = 2 * 0.2 * 10^-14 = 4e-15 = 1/2.5e+14\r\n   * i.e. 1 in 250,000,000,000,000\r\n   *\r\n   * If a result is incorrectly rounded the maximum error will be 1 ulp (unit in last place).\r\n   *\r\n   * y {number|string|Decimal} The power to which to raise this Decimal.\r\n   *\r\n   */\r\n  P.toPower = P.pow = function (y) {\r\n    var e, k, pr, r, rm, s,\r\n      x = this,\r\n      Ctor = x.constructor,\r\n      yn = +(y = new Ctor(y));\r\n\r\n    // Either ±Infinity, NaN or ±0?\r\n    if (!x.d || !y.d || !x.d[0] || !y.d[0]) return new Ctor(mathpow(+x, yn));\r\n\r\n    x = new Ctor(x);\r\n\r\n    if (x.eq(1)) return x;\r\n\r\n    pr = Ctor.precision;\r\n    rm = Ctor.rounding;\r\n\r\n    if (y.eq(1)) return finalise(x, pr, rm);\r\n\r\n    // y exponent\r\n    e = mathfloor(y.e / LOG_BASE);\r\n\r\n    // If y is a small integer use the 'exponentiation by squaring' algorithm.\r\n    if (e >= y.d.length - 1 && (k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {\r\n      r = intPow(Ctor, x, k, pr);\r\n      return y.s < 0 ? new Ctor(1).div(r) : finalise(r, pr, rm);\r\n    }\r\n\r\n    s = x.s;\r\n\r\n    // if x is negative\r\n    if (s < 0) {\r\n\r\n      // if y is not an integer\r\n      if (e < y.d.length - 1) return new Ctor(NaN);\r\n\r\n      // Result is positive if x is negative and the last digit of integer y is even.\r\n      if ((y.d[e] & 1) == 0) s = 1;\r\n\r\n      // if x.eq(-1)\r\n      if (x.e == 0 && x.d[0] == 1 && x.d.length == 1) {\r\n        x.s = s;\r\n        return x;\r\n      }\r\n    }\r\n\r\n    // Estimate result exponent.\r\n    // x^y = 10^e,  where e = y * log10(x)\r\n    // log10(x) = log10(x_significand) + x_exponent\r\n    // log10(x_significand) = ln(x_significand) / ln(10)\r\n    k = mathpow(+x, yn);\r\n    e = k == 0 || !isFinite(k)\r\n      ? mathfloor(yn * (Math.log('0.' + digitsToString(x.d)) / Math.LN10 + x.e + 1))\r\n      : new Ctor(k + '').e;\r\n\r\n    // Exponent estimate may be incorrect e.g. x: 0.999999999999999999, y: 2.29, e: 0, r.e: -1.\r\n\r\n    // Overflow/underflow?\r\n    if (e > Ctor.maxE + 1 || e < Ctor.minE - 1) return new Ctor(e > 0 ? s / 0 : 0);\r\n\r\n    external = false;\r\n    Ctor.rounding = x.s = 1;\r\n\r\n    // Estimate the extra guard digits needed to ensure five correct rounding digits from\r\n    // naturalLogarithm(x). Example of failure without these extra digits (precision: 10):\r\n    // new Decimal(2.32456).pow('2087987436534566.46411')\r\n    // should be 1.162377823e+764914905173815, but is 1.162355823e+764914905173815\r\n    k = Math.min(12, (e + '').length);\r\n\r\n    // r = x^y = exp(y*ln(x))\r\n    r = naturalExponential(y.times(naturalLogarithm(x, pr + k)), pr);\r\n\r\n    // r may be Infinity, e.g. (0.9999999999999999).pow(-1e+40)\r\n    if (r.d) {\r\n\r\n      // Truncate to the required precision plus five rounding digits.\r\n      r = finalise(r, pr + 5, 1);\r\n\r\n      // If the rounding digits are [49]9999 or [50]0000 increase the precision by 10 and recalculate\r\n      // the result.\r\n      if (checkRoundingDigits(r.d, pr, rm)) {\r\n        e = pr + 10;\r\n\r\n        // Truncate to the increased precision plus five rounding digits.\r\n        r = finalise(naturalExponential(y.times(naturalLogarithm(x, e + k)), e), e + 5, 1);\r\n\r\n        // Check for 14 nines from the 2nd rounding digit (the first rounding digit may be 4 or 9).\r\n        if (+digitsToString(r.d).slice(pr + 1, pr + 15) + 1 == 1e14) {\r\n          r = finalise(r, pr + 1, 0);\r\n        }\r\n      }\r\n    }\r\n\r\n    r.s = s;\r\n    external = true;\r\n    Ctor.rounding = rm;\r\n\r\n    return finalise(r, pr, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Decimal rounded to `sd` significant digits\r\n   * using rounding mode `rounding`.\r\n   *\r\n   * Return exponential notation if `sd` is less than the number of digits necessary to represent\r\n   * the integer part of the value in normal notation.\r\n   *\r\n   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   */\r\n  P.toPrecision = function (sd, rm) {\r\n    var str,\r\n      x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (sd === void 0) {\r\n      str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);\r\n    } else {\r\n      checkInt32(sd, 1, MAX_DIGITS);\r\n\r\n      if (rm === void 0) rm = Ctor.rounding;\r\n      else checkInt32(rm, 0, 8);\r\n\r\n      x = finalise(new Ctor(x), sd, rm);\r\n      str = finiteToString(x, sd <= x.e || x.e <= Ctor.toExpNeg, sd);\r\n    }\r\n\r\n    return x.isNeg() && !x.isZero() ? '-' + str : str;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `sd`\r\n   * significant digits using rounding mode `rm`, or to `precision` and `rounding` respectively if\r\n   * omitted.\r\n   *\r\n   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * 'toSD() digits out of range: {sd}'\r\n   * 'toSD() digits not an integer: {sd}'\r\n   * 'toSD() rounding mode not an integer: {rm}'\r\n   * 'toSD() rounding mode out of range: {rm}'\r\n   *\r\n   */\r\n  P.toSignificantDigits = P.toSD = function (sd, rm) {\r\n    var x = this,\r\n      Ctor = x.constructor;\r\n\r\n    if (sd === void 0) {\r\n      sd = Ctor.precision;\r\n      rm = Ctor.rounding;\r\n    } else {\r\n      checkInt32(sd, 1, MAX_DIGITS);\r\n\r\n      if (rm === void 0) rm = Ctor.rounding;\r\n      else checkInt32(rm, 0, 8);\r\n    }\r\n\r\n    return finalise(new Ctor(x), sd, rm);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Decimal.\r\n   *\r\n   * Return exponential notation if this Decimal has a positive exponent equal to or greater than\r\n   * `toExpPos`, or a negative exponent equal to or less than `toExpNeg`.\r\n   *\r\n   */\r\n  P.toString = function () {\r\n    var x = this,\r\n      Ctor = x.constructor,\r\n      str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);\r\n\r\n    return x.isNeg() && !x.isZero() ? '-' + str : str;\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of this Decimal truncated to a whole number.\r\n   *\r\n   */\r\n  P.truncated = P.trunc = function () {\r\n    return finalise(new this.constructor(this), this.e + 1, 1);\r\n  };\r\n\r\n\r\n  /*\r\n   * Return a string representing the value of this Decimal.\r\n   * Unlike `toString`, negative zero will include the minus sign.\r\n   *\r\n   */\r\n  P.valueOf = P.toJSON = function () {\r\n    var x = this,\r\n      Ctor = x.constructor,\r\n      str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);\r\n\r\n    return x.isNeg() ? '-' + str : str;\r\n  };\r\n\r\n\r\n  // Helper functions for Decimal.prototype (P) and/or Decimal methods, and their callers.\r\n\r\n\r\n  /*\r\n   *  digitsToString           P.cubeRoot, P.logarithm, P.squareRoot, P.toFraction, P.toPower,\r\n   *                           finiteToString, naturalExponential, naturalLogarithm\r\n   *  checkInt32               P.toDecimalPlaces, P.toExponential, P.toFixed, P.toNearest,\r\n   *                           P.toPrecision, P.toSignificantDigits, toStringBinary, random\r\n   *  checkRoundingDigits      P.logarithm, P.toPower, naturalExponential, naturalLogarithm\r\n   *  convertBase              toStringBinary, parseOther\r\n   *  cos                      P.cos\r\n   *  divide                   P.atanh, P.cubeRoot, P.dividedBy, P.dividedToIntegerBy,\r\n   *                           P.logarithm, P.modulo, P.squareRoot, P.tan, P.tanh, P.toFraction,\r\n   *                           P.toNearest, toStringBinary, naturalExponential, naturalLogarithm,\r\n   *                           taylorSeries, atan2, parseOther\r\n   *  finalise                 P.absoluteValue, P.atan, P.atanh, P.ceil, P.cos, P.cosh,\r\n   *                           P.cubeRoot, P.dividedToIntegerBy, P.floor, P.logarithm, P.minus,\r\n   *                           P.modulo, P.negated, P.plus, P.round, P.sin, P.sinh, P.squareRoot,\r\n   *                           P.tan, P.times, P.toDecimalPlaces, P.toExponential, P.toFixed,\r\n   *                           P.toNearest, P.toPower, P.toPrecision, P.toSignificantDigits,\r\n   *                           P.truncated, divide, getLn10, getPi, naturalExponential,\r\n   *                           naturalLogarithm, ceil, floor, round, trunc\r\n   *  finiteToString           P.toExponential, P.toFixed, P.toPrecision, P.toString, P.valueOf,\r\n   *                           toStringBinary\r\n   *  getBase10Exponent        P.minus, P.plus, P.times, parseOther\r\n   *  getLn10                  P.logarithm, naturalLogarithm\r\n   *  getPi                    P.acos, P.asin, P.atan, toLessThanHalfPi, atan2\r\n   *  getPrecision             P.precision, P.toFraction\r\n   *  getZeroString            digitsToString, finiteToString\r\n   *  intPow                   P.toPower, parseOther\r\n   *  isOdd                    toLessThanHalfPi\r\n   *  maxOrMin                 max, min\r\n   *  naturalExponential       P.naturalExponential, P.toPower\r\n   *  naturalLogarithm         P.acosh, P.asinh, P.atanh, P.logarithm, P.naturalLogarithm,\r\n   *                           P.toPower, naturalExponential\r\n   *  nonFiniteToString        finiteToString, toStringBinary\r\n   *  parseDecimal             Decimal\r\n   *  parseOther               Decimal\r\n   *  sin                      P.sin\r\n   *  taylorSeries             P.cosh, P.sinh, cos, sin\r\n   *  toLessThanHalfPi         P.cos, P.sin\r\n   *  toStringBinary           P.toBinary, P.toHexadecimal, P.toOctal\r\n   *  truncate                 intPow\r\n   *\r\n   *  Throws:                  P.logarithm, P.precision, P.toFraction, checkInt32, getLn10, getPi,\r\n   *                           naturalLogarithm, config, parseOther, random, Decimal\r\n   */\r\n\r\n\r\n  function digitsToString(d) {\r\n    var i, k, ws,\r\n      indexOfLastWord = d.length - 1,\r\n      str = '',\r\n      w = d[0];\r\n\r\n    if (indexOfLastWord > 0) {\r\n      str += w;\r\n      for (i = 1; i < indexOfLastWord; i++) {\r\n        ws = d[i] + '';\r\n        k = LOG_BASE - ws.length;\r\n        if (k) str += getZeroString(k);\r\n        str += ws;\r\n      }\r\n\r\n      w = d[i];\r\n      ws = w + '';\r\n      k = LOG_BASE - ws.length;\r\n      if (k) str += getZeroString(k);\r\n    } else if (w === 0) {\r\n      return '0';\r\n    }\r\n\r\n    // Remove trailing zeros of last w.\r\n    for (; w % 10 === 0;) w /= 10;\r\n\r\n    return str + w;\r\n  }\r\n\r\n\r\n  function checkInt32(i, min, max) {\r\n    if (i !== ~~i || i < min || i > max) {\r\n      throw Error(invalidArgument + i);\r\n    }\r\n  }\r\n\r\n\r\n  /*\r\n   * Check 5 rounding digits if `repeating` is null, 4 otherwise.\r\n   * `repeating == null` if caller is `log` or `pow`,\r\n   * `repeating != null` if caller is `naturalLogarithm` or `naturalExponential`.\r\n   */\r\n  function checkRoundingDigits(d, i, rm, repeating) {\r\n    var di, k, r, rd;\r\n\r\n    // Get the length of the first word of the array d.\r\n    for (k = d[0]; k >= 10; k /= 10) --i;\r\n\r\n    // Is the rounding digit in the first word of d?\r\n    if (--i < 0) {\r\n      i += LOG_BASE;\r\n      di = 0;\r\n    } else {\r\n      di = Math.ceil((i + 1) / LOG_BASE);\r\n      i %= LOG_BASE;\r\n    }\r\n\r\n    // i is the index (0 - 6) of the rounding digit.\r\n    // E.g. if within the word 3487563 the first rounding digit is 5,\r\n    // then i = 4, k = 1000, rd = 3487563 % 1000 = 563\r\n    k = mathpow(10, LOG_BASE - i);\r\n    rd = d[di] % k | 0;\r\n\r\n    if (repeating == null) {\r\n      if (i < 3) {\r\n        if (i == 0) rd = rd / 100 | 0;\r\n        else if (i == 1) rd = rd / 10 | 0;\r\n        r = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 50000 || rd == 0;\r\n      } else {\r\n        r = (rm < 4 && rd + 1 == k || rm > 3 && rd + 1 == k / 2) &&\r\n          (d[di + 1] / k / 100 | 0) == mathpow(10, i - 2) - 1 ||\r\n            (rd == k / 2 || rd == 0) && (d[di + 1] / k / 100 | 0) == 0;\r\n      }\r\n    } else {\r\n      if (i < 4) {\r\n        if (i == 0) rd = rd / 1000 | 0;\r\n        else if (i == 1) rd = rd / 100 | 0;\r\n        else if (i == 2) rd = rd / 10 | 0;\r\n        r = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;\r\n      } else {\r\n        r = ((repeating || rm < 4) && rd + 1 == k ||\r\n        (!repeating && rm > 3) && rd + 1 == k / 2) &&\r\n          (d[di + 1] / k / 1000 | 0) == mathpow(10, i - 3) - 1;\r\n      }\r\n    }\r\n\r\n    return r;\r\n  }\r\n\r\n\r\n  // Convert string of `baseIn` to an array of numbers of `baseOut`.\r\n  // Eg. convertBase('255', 10, 16) returns [15, 15].\r\n  // Eg. convertBase('ff', 16, 10) returns [2, 5, 5].\r\n  function convertBase(str, baseIn, baseOut) {\r\n    var j,\r\n      arr = [0],\r\n      arrL,\r\n      i = 0,\r\n      strL = str.length;\r\n\r\n    for (; i < strL;) {\r\n      for (arrL = arr.length; arrL--;) arr[arrL] *= baseIn;\r\n      arr[0] += NUMERALS.indexOf(str.charAt(i++));\r\n      for (j = 0; j < arr.length; j++) {\r\n        if (arr[j] > baseOut - 1) {\r\n          if (arr[j + 1] === void 0) arr[j + 1] = 0;\r\n          arr[j + 1] += arr[j] / baseOut | 0;\r\n          arr[j] %= baseOut;\r\n        }\r\n      }\r\n    }\r\n\r\n    return arr.reverse();\r\n  }\r\n\r\n\r\n  /*\r\n   * cos(x) = 1 - x^2/2! + x^4/4! - ...\r\n   * |x| < pi/2\r\n   *\r\n   */\r\n  function cosine(Ctor, x) {\r\n    var k, len, y;\r\n\r\n    if (x.isZero()) return x;\r\n\r\n    // Argument reduction: cos(4x) = 8*(cos^4(x) - cos^2(x)) + 1\r\n    // i.e. cos(x) = 8*(cos^4(x/4) - cos^2(x/4)) + 1\r\n\r\n    // Estimate the optimum number of times to use the argument reduction.\r\n    len = x.d.length;\r\n    if (len < 32) {\r\n      k = Math.ceil(len / 3);\r\n      y = (1 / tinyPow(4, k)).toString();\r\n    } else {\r\n      k = 16;\r\n      y = '2.3283064365386962890625e-10';\r\n    }\r\n\r\n    Ctor.precision += k;\r\n\r\n    x = taylorSeries(Ctor, 1, x.times(y), new Ctor(1));\r\n\r\n    // Reverse argument reduction\r\n    for (var i = k; i--;) {\r\n      var cos2x = x.times(x);\r\n      x = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);\r\n    }\r\n\r\n    Ctor.precision -= k;\r\n\r\n    return x;\r\n  }\r\n\r\n\r\n  /*\r\n   * Perform division in the specified base.\r\n   */\r\n  var divide = (function () {\r\n\r\n    // Assumes non-zero x and k, and hence non-zero result.\r\n    function multiplyInteger(x, k, base) {\r\n      var temp,\r\n        carry = 0,\r\n        i = x.length;\r\n\r\n      for (x = x.slice(); i--;) {\r\n        temp = x[i] * k + carry;\r\n        x[i] = temp % base | 0;\r\n        carry = temp / base | 0;\r\n      }\r\n\r\n      if (carry) x.unshift(carry);\r\n\r\n      return x;\r\n    }\r\n\r\n    function compare(a, b, aL, bL) {\r\n      var i, r;\r\n\r\n      if (aL != bL) {\r\n        r = aL > bL ? 1 : -1;\r\n      } else {\r\n        for (i = r = 0; i < aL; i++) {\r\n          if (a[i] != b[i]) {\r\n            r = a[i] > b[i] ? 1 : -1;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      return r;\r\n    }\r\n\r\n    function subtract(a, b, aL, base) {\r\n      var i = 0;\r\n\r\n      // Subtract b from a.\r\n      for (; aL--;) {\r\n        a[aL] -= i;\r\n        i = a[aL] < b[aL] ? 1 : 0;\r\n        a[aL] = i * base + a[aL] - b[aL];\r\n      }\r\n\r\n      // Remove leading zeros.\r\n      for (; !a[0] && a.length > 1;) a.shift();\r\n    }\r\n\r\n    return function (x, y, pr, rm, dp, base) {\r\n      var cmp, e, i, k, logBase, more, prod, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0,\r\n        yL, yz,\r\n        Ctor = x.constructor,\r\n        sign = x.s == y.s ? 1 : -1,\r\n        xd = x.d,\r\n        yd = y.d;\r\n\r\n      // Either NaN, Infinity or 0?\r\n      if (!xd || !xd[0] || !yd || !yd[0]) {\r\n\r\n        return new Ctor(// Return NaN if either NaN, or both Infinity or 0.\r\n          !x.s || !y.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN :\r\n\r\n          // Return ±0 if x is 0 or y is ±Infinity, or return ±Infinity as y is 0.\r\n          xd && xd[0] == 0 || !yd ? sign * 0 : sign / 0);\r\n      }\r\n\r\n      if (base) {\r\n        logBase = 1;\r\n        e = x.e - y.e;\r\n      } else {\r\n        base = BASE;\r\n        logBase = LOG_BASE;\r\n        e = mathfloor(x.e / logBase) - mathfloor(y.e / logBase);\r\n      }\r\n\r\n      yL = yd.length;\r\n      xL = xd.length;\r\n      q = new Ctor(sign);\r\n      qd = q.d = [];\r\n\r\n      // Result exponent may be one less than e.\r\n      // The digit array of a Decimal from toStringBinary may have trailing zeros.\r\n      for (i = 0; yd[i] == (xd[i] || 0); i++);\r\n\r\n      if (yd[i] > (xd[i] || 0)) e--;\r\n\r\n      if (pr == null) {\r\n        sd = pr = Ctor.precision;\r\n        rm = Ctor.rounding;\r\n      } else if (dp) {\r\n        sd = pr + (x.e - y.e) + 1;\r\n      } else {\r\n        sd = pr;\r\n      }\r\n\r\n      if (sd < 0) {\r\n        qd.push(1);\r\n        more = true;\r\n      } else {\r\n\r\n        // Convert precision in number of base 10 digits to base 1e7 digits.\r\n        sd = sd / logBase + 2 | 0;\r\n        i = 0;\r\n\r\n        // divisor < 1e7\r\n        if (yL == 1) {\r\n          k = 0;\r\n          yd = yd[0];\r\n          sd++;\r\n\r\n          // k is the carry.\r\n          for (; (i < xL || k) && sd--; i++) {\r\n            t = k * base + (xd[i] || 0);\r\n            qd[i] = t / yd | 0;\r\n            k = t % yd | 0;\r\n          }\r\n\r\n          more = k || i < xL;\r\n\r\n        // divisor >= 1e7\r\n        } else {\r\n\r\n          // Normalise xd and yd so highest order digit of yd is >= base/2\r\n          k = base / (yd[0] + 1) | 0;\r\n\r\n          if (k > 1) {\r\n            yd = multiplyInteger(yd, k, base);\r\n            xd = multiplyInteger(xd, k, base);\r\n            yL = yd.length;\r\n            xL = xd.length;\r\n          }\r\n\r\n          xi = yL;\r\n          rem = xd.slice(0, yL);\r\n          remL = rem.length;\r\n\r\n          // Add zeros to make remainder as long as divisor.\r\n          for (; remL < yL;) rem[remL++] = 0;\r\n\r\n          yz = yd.slice();\r\n          yz.unshift(0);\r\n          yd0 = yd[0];\r\n\r\n          if (yd[1] >= base / 2) ++yd0;\r\n\r\n          do {\r\n            k = 0;\r\n\r\n            // Compare divisor and remainder.\r\n            cmp = compare(yd, rem, yL, remL);\r\n\r\n            // If divisor < remainder.\r\n            if (cmp < 0) {\r\n\r\n              // Calculate trial digit, k.\r\n              rem0 = rem[0];\r\n              if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);\r\n\r\n              // k will be how many times the divisor goes into the current remainder.\r\n              k = rem0 / yd0 | 0;\r\n\r\n              //  Algorithm:\r\n              //  1. product = divisor * trial digit (k)\r\n              //  2. if product > remainder: product -= divisor, k--\r\n              //  3. remainder -= product\r\n              //  4. if product was < remainder at 2:\r\n              //    5. compare new remainder and divisor\r\n              //    6. If remainder > divisor: remainder -= divisor, k++\r\n\r\n              if (k > 1) {\r\n                if (k >= base) k = base - 1;\r\n\r\n                // product = divisor * trial digit.\r\n                prod = multiplyInteger(yd, k, base);\r\n                prodL = prod.length;\r\n                remL = rem.length;\r\n\r\n                // Compare product and remainder.\r\n                cmp = compare(prod, rem, prodL, remL);\r\n\r\n                // product > remainder.\r\n                if (cmp == 1) {\r\n                  k--;\r\n\r\n                  // Subtract divisor from product.\r\n                  subtract(prod, yL < prodL ? yz : yd, prodL, base);\r\n                }\r\n              } else {\r\n\r\n                // cmp is -1.\r\n                // If k is 0, there is no need to compare yd and rem again below, so change cmp to 1\r\n                // to avoid it. If k is 1 there is a need to compare yd and rem again below.\r\n                if (k == 0) cmp = k = 1;\r\n                prod = yd.slice();\r\n              }\r\n\r\n              prodL = prod.length;\r\n              if (prodL < remL) prod.unshift(0);\r\n\r\n              // Subtract product from remainder.\r\n              subtract(rem, prod, remL, base);\r\n\r\n              // If product was < previous remainder.\r\n              if (cmp == -1) {\r\n                remL = rem.length;\r\n\r\n                // Compare divisor and new remainder.\r\n                cmp = compare(yd, rem, yL, remL);\r\n\r\n                // If divisor < new remainder, subtract divisor from remainder.\r\n                if (cmp < 1) {\r\n                  k++;\r\n\r\n                  // Subtract divisor from remainder.\r\n                  subtract(rem, yL < remL ? yz : yd, remL, base);\r\n                }\r\n              }\r\n\r\n              remL = rem.length;\r\n            } else if (cmp === 0) {\r\n              k++;\r\n              rem = [0];\r\n            }    // if cmp === 1, k will be 0\r\n\r\n            // Add the next digit, k, to the result array.\r\n            qd[i++] = k;\r\n\r\n            // Update the remainder.\r\n            if (cmp && rem[0]) {\r\n              rem[remL++] = xd[xi] || 0;\r\n            } else {\r\n              rem = [xd[xi]];\r\n              remL = 1;\r\n            }\r\n\r\n          } while ((xi++ < xL || rem[0] !== void 0) && sd--);\r\n\r\n          more = rem[0] !== void 0;\r\n        }\r\n\r\n        // Leading zero?\r\n        if (!qd[0]) qd.shift();\r\n      }\r\n\r\n      // logBase is 1 when divide is being used for base conversion.\r\n      if (logBase == 1) {\r\n        q.e = e;\r\n        inexact = more;\r\n      } else {\r\n\r\n        // To calculate q.e, first get the number of digits of qd[0].\r\n        for (i = 1, k = qd[0]; k >= 10; k /= 10) i++;\r\n        q.e = i + e * logBase - 1;\r\n\r\n        finalise(q, dp ? pr + q.e + 1 : pr, rm, more);\r\n      }\r\n\r\n      return q;\r\n    };\r\n  })();\r\n\r\n\r\n  /*\r\n   * Round `x` to `sd` significant digits using rounding mode `rm`.\r\n   * Check for over/under-flow.\r\n   */\r\n   function finalise(x, sd, rm, isTruncated) {\r\n    var digits, i, j, k, rd, roundUp, w, xd, xdi,\r\n      Ctor = x.constructor;\r\n\r\n    // Don't round if sd is null or undefined.\r\n    out: if (sd != null) {\r\n      xd = x.d;\r\n\r\n      // Infinity/NaN.\r\n      if (!xd) return x;\r\n\r\n      // rd: the rounding digit, i.e. the digit after the digit that may be rounded up.\r\n      // w: the word of xd containing rd, a base 1e7 number.\r\n      // xdi: the index of w within xd.\r\n      // digits: the number of digits of w.\r\n      // i: what would be the index of rd within w if all the numbers were 7 digits long (i.e. if\r\n      // they had leading zeros)\r\n      // j: if > 0, the actual index of rd within w (if < 0, rd is a leading zero).\r\n\r\n      // Get the length of the first word of the digits array xd.\r\n      for (digits = 1, k = xd[0]; k >= 10; k /= 10) digits++;\r\n      i = sd - digits;\r\n\r\n      // Is the rounding digit in the first word of xd?\r\n      if (i < 0) {\r\n        i += LOG_BASE;\r\n        j = sd;\r\n        w = xd[xdi = 0];\r\n\r\n        // Get the rounding digit at index j of w.\r\n        rd = w / mathpow(10, digits - j - 1) % 10 | 0;\r\n      } else {\r\n        xdi = Math.ceil((i + 1) / LOG_BASE);\r\n        k = xd.length;\r\n        if (xdi >= k) {\r\n          if (isTruncated) {\r\n\r\n            // Needed by `naturalExponential`, `naturalLogarithm` and `squareRoot`.\r\n            for (; k++ <= xdi;) xd.push(0);\r\n            w = rd = 0;\r\n            digits = 1;\r\n            i %= LOG_BASE;\r\n            j = i - LOG_BASE + 1;\r\n          } else {\r\n            break out;\r\n          }\r\n        } else {\r\n          w = k = xd[xdi];\r\n\r\n          // Get the number of digits of w.\r\n          for (digits = 1; k >= 10; k /= 10) digits++;\r\n\r\n          // Get the index of rd within w.\r\n          i %= LOG_BASE;\r\n\r\n          // Get the index of rd within w, adjusted for leading zeros.\r\n          // The number of leading zeros of w is given by LOG_BASE - digits.\r\n          j = i - LOG_BASE + digits;\r\n\r\n          // Get the rounding digit at index j of w.\r\n          rd = j < 0 ? 0 : w / mathpow(10, digits - j - 1) % 10 | 0;\r\n        }\r\n      }\r\n\r\n      // Are there any non-zero digits after the rounding digit?\r\n      isTruncated = isTruncated || sd < 0 ||\r\n        xd[xdi + 1] !== void 0 || (j < 0 ? w : w % mathpow(10, digits - j - 1));\r\n\r\n      // The expression `w % mathpow(10, digits - j - 1)` returns all the digits of w to the right\r\n      // of the digit at (left-to-right) index j, e.g. if w is 908714 and j is 2, the expression\r\n      // will give 714.\r\n\r\n      roundUp = rm < 4\r\n        ? (rd || isTruncated) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))\r\n        : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 &&\r\n\r\n          // Check whether the digit to the left of the rounding digit is odd.\r\n          ((i > 0 ? j > 0 ? w / mathpow(10, digits - j) : 0 : xd[xdi - 1]) % 10) & 1 ||\r\n            rm == (x.s < 0 ? 8 : 7));\r\n\r\n      if (sd < 1 || !xd[0]) {\r\n        xd.length = 0;\r\n        if (roundUp) {\r\n\r\n          // Convert sd to decimal places.\r\n          sd -= x.e + 1;\r\n\r\n          // 1, 0.1, 0.01, 0.001, 0.0001 etc.\r\n          xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);\r\n          x.e = -sd || 0;\r\n        } else {\r\n\r\n          // Zero.\r\n          xd[0] = x.e = 0;\r\n        }\r\n\r\n        return x;\r\n      }\r\n\r\n      // Remove excess digits.\r\n      if (i == 0) {\r\n        xd.length = xdi;\r\n        k = 1;\r\n        xdi--;\r\n      } else {\r\n        xd.length = xdi + 1;\r\n        k = mathpow(10, LOG_BASE - i);\r\n\r\n        // E.g. 56700 becomes 56000 if 7 is the rounding digit.\r\n        // j > 0 means i > number of leading zeros of w.\r\n        xd[xdi] = j > 0 ? (w / mathpow(10, digits - j) % mathpow(10, j) | 0) * k : 0;\r\n      }\r\n\r\n      if (roundUp) {\r\n        for (;;) {\r\n\r\n          // Is the digit to be rounded up in the first word of xd?\r\n          if (xdi == 0) {\r\n\r\n            // i will be the length of xd[0] before k is added.\r\n            for (i = 1, j = xd[0]; j >= 10; j /= 10) i++;\r\n            j = xd[0] += k;\r\n            for (k = 1; j >= 10; j /= 10) k++;\r\n\r\n            // if i != k the length has increased.\r\n            if (i != k) {\r\n              x.e++;\r\n              if (xd[0] == BASE) xd[0] = 1;\r\n            }\r\n\r\n            break;\r\n          } else {\r\n            xd[xdi] += k;\r\n            if (xd[xdi] != BASE) break;\r\n            xd[xdi--] = 0;\r\n            k = 1;\r\n          }\r\n        }\r\n      }\r\n\r\n      // Remove trailing zeros.\r\n      for (i = xd.length; xd[--i] === 0;) xd.pop();\r\n    }\r\n\r\n    if (external) {\r\n\r\n      // Overflow?\r\n      if (x.e > Ctor.maxE) {\r\n\r\n        // Infinity.\r\n        x.d = null;\r\n        x.e = NaN;\r\n\r\n      // Underflow?\r\n      } else if (x.e < Ctor.minE) {\r\n\r\n        // Zero.\r\n        x.e = 0;\r\n        x.d = [0];\r\n        // Ctor.underflow = true;\r\n      } // else Ctor.underflow = false;\r\n    }\r\n\r\n    return x;\r\n  }\r\n\r\n\r\n  function finiteToString(x, isExp, sd) {\r\n    if (!x.isFinite()) return nonFiniteToString(x);\r\n    var k,\r\n      e = x.e,\r\n      str = digitsToString(x.d),\r\n      len = str.length;\r\n\r\n    if (isExp) {\r\n      if (sd && (k = sd - len) > 0) {\r\n        str = str.charAt(0) + '.' + str.slice(1) + getZeroString(k);\r\n      } else if (len > 1) {\r\n        str = str.charAt(0) + '.' + str.slice(1);\r\n      }\r\n\r\n      str = str + (x.e < 0 ? 'e' : 'e+') + x.e;\r\n    } else if (e < 0) {\r\n      str = '0.' + getZeroString(-e - 1) + str;\r\n      if (sd && (k = sd - len) > 0) str += getZeroString(k);\r\n    } else if (e >= len) {\r\n      str += getZeroString(e + 1 - len);\r\n      if (sd && (k = sd - e - 1) > 0) str = str + '.' + getZeroString(k);\r\n    } else {\r\n      if ((k = e + 1) < len) str = str.slice(0, k) + '.' + str.slice(k);\r\n      if (sd && (k = sd - len) > 0) {\r\n        if (e + 1 === len) str += '.';\r\n        str += getZeroString(k);\r\n      }\r\n    }\r\n\r\n    return str;\r\n  }\r\n\r\n\r\n  // Calculate the base 10 exponent from the base 1e7 exponent.\r\n  function getBase10Exponent(digits, e) {\r\n    var w = digits[0];\r\n\r\n    // Add the number of digits of the first word of the digits array.\r\n    for ( e *= LOG_BASE; w >= 10; w /= 10) e++;\r\n    return e;\r\n  }\r\n\r\n\r\n  function getLn10(Ctor, sd, pr) {\r\n    if (sd > LN10_PRECISION) {\r\n\r\n      // Reset global state in case the exception is caught.\r\n      external = true;\r\n      if (pr) Ctor.precision = pr;\r\n      throw Error(precisionLimitExceeded);\r\n    }\r\n    return finalise(new Ctor(LN10), sd, 1, true);\r\n  }\r\n\r\n\r\n  function getPi(Ctor, sd, rm) {\r\n    if (sd > PI_PRECISION) throw Error(precisionLimitExceeded);\r\n    return finalise(new Ctor(PI), sd, rm, true);\r\n  }\r\n\r\n\r\n  function getPrecision(digits) {\r\n    var w = digits.length - 1,\r\n      len = w * LOG_BASE + 1;\r\n\r\n    w = digits[w];\r\n\r\n    // If non-zero...\r\n    if (w) {\r\n\r\n      // Subtract the number of trailing zeros of the last word.\r\n      for (; w % 10 == 0; w /= 10) len--;\r\n\r\n      // Add the number of digits of the first word.\r\n      for (w = digits[0]; w >= 10; w /= 10) len++;\r\n    }\r\n\r\n    return len;\r\n  }\r\n\r\n\r\n  function getZeroString(k) {\r\n    var zs = '';\r\n    for (; k--;) zs += '0';\r\n    return zs;\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the value of Decimal `x` to the power `n`, where `n` is an\r\n   * integer of type number.\r\n   *\r\n   * Implements 'exponentiation by squaring'. Called by `pow` and `parseOther`.\r\n   *\r\n   */\r\n  function intPow(Ctor, x, n, pr) {\r\n    var isTruncated,\r\n      r = new Ctor(1),\r\n\r\n      // Max n of 9007199254740991 takes 53 loop iterations.\r\n      // Maximum digits array length; leaves [28, 34] guard digits.\r\n      k = Math.ceil(pr / LOG_BASE + 4);\r\n\r\n    external = false;\r\n\r\n    for (;;) {\r\n      if (n % 2) {\r\n        r = r.times(x);\r\n        if (truncate(r.d, k)) isTruncated = true;\r\n      }\r\n\r\n      n = mathfloor(n / 2);\r\n      if (n === 0) {\r\n\r\n        // To ensure correct rounding when r.d is truncated, increment the last word if it is zero.\r\n        n = r.d.length - 1;\r\n        if (isTruncated && r.d[n] === 0) ++r.d[n];\r\n        break;\r\n      }\r\n\r\n      x = x.times(x);\r\n      truncate(x.d, k);\r\n    }\r\n\r\n    external = true;\r\n\r\n    return r;\r\n  }\r\n\r\n\r\n  function isOdd(n) {\r\n    return n.d[n.d.length - 1] & 1;\r\n  }\r\n\r\n\r\n  /*\r\n   * Handle `max` and `min`. `ltgt` is 'lt' or 'gt'.\r\n   */\r\n  function maxOrMin(Ctor, args, ltgt) {\r\n    var y,\r\n      x = new Ctor(args[0]),\r\n      i = 0;\r\n\r\n    for (; ++i < args.length;) {\r\n      y = new Ctor(args[i]);\r\n      if (!y.s) {\r\n        x = y;\r\n        break;\r\n      } else if (x[ltgt](y)) {\r\n        x = y;\r\n      }\r\n    }\r\n\r\n    return x;\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the natural exponential of `x` rounded to `sd` significant\r\n   * digits.\r\n   *\r\n   * Taylor/Maclaurin series.\r\n   *\r\n   * exp(x) = x^0/0! + x^1/1! + x^2/2! + x^3/3! + ...\r\n   *\r\n   * Argument reduction:\r\n   *   Repeat x = x / 32, k += 5, until |x| < 0.1\r\n   *   exp(x) = exp(x / 2^k)^(2^k)\r\n   *\r\n   * Previously, the argument was initially reduced by\r\n   * exp(x) = exp(r) * 10^k  where r = x - k * ln10, k = floor(x / ln10)\r\n   * to first put r in the range [0, ln10], before dividing by 32 until |x| < 0.1, but this was\r\n   * found to be slower than just dividing repeatedly by 32 as above.\r\n   *\r\n   * Max integer argument: exp('20723265836946413') = 6.3e+9000000000000000\r\n   * Min integer argument: exp('-20723265836946411') = 1.2e-9000000000000000\r\n   * (Math object integer min/max: Math.exp(709) = 8.2e+307, Math.exp(-745) = 5e-324)\r\n   *\r\n   *  exp(Infinity)  = Infinity\r\n   *  exp(-Infinity) = 0\r\n   *  exp(NaN)       = NaN\r\n   *  exp(±0)        = 1\r\n   *\r\n   *  exp(x) is non-terminating for any finite, non-zero x.\r\n   *\r\n   *  The result will always be correctly rounded.\r\n   *\r\n   */\r\n  function naturalExponential(x, sd) {\r\n    var denominator, guard, j, pow, sum, t, wpr,\r\n      rep = 0,\r\n      i = 0,\r\n      k = 0,\r\n      Ctor = x.constructor,\r\n      rm = Ctor.rounding,\r\n      pr = Ctor.precision;\r\n\r\n    // 0/NaN/Infinity?\r\n    if (!x.d || !x.d[0] || x.e > 17) {\r\n\r\n      return new Ctor(x.d\r\n        ? !x.d[0] ? 1 : x.s < 0 ? 0 : 1 / 0\r\n        : x.s ? x.s < 0 ? 0 : x : 0 / 0);\r\n    }\r\n\r\n    if (sd == null) {\r\n      external = false;\r\n      wpr = pr;\r\n    } else {\r\n      wpr = sd;\r\n    }\r\n\r\n    t = new Ctor(0.03125);\r\n\r\n    // while abs(x) >= 0.1\r\n    while (x.e > -2) {\r\n\r\n      // x = x / 2^5\r\n      x = x.times(t);\r\n      k += 5;\r\n    }\r\n\r\n    // Use 2 * log10(2^k) + 5 (empirically derived) to estimate the increase in precision\r\n    // necessary to ensure the first 4 rounding digits are correct.\r\n    guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;\r\n    wpr += guard;\r\n    denominator = pow = sum = new Ctor(1);\r\n    Ctor.precision = wpr;\r\n\r\n    for (;;) {\r\n      pow = finalise(pow.times(x), wpr, 1);\r\n      denominator = denominator.times(++i);\r\n      t = sum.plus(divide(pow, denominator, wpr, 1));\r\n\r\n      if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {\r\n        j = k;\r\n        while (j--) sum = finalise(sum.times(sum), wpr, 1);\r\n\r\n        // Check to see if the first 4 rounding digits are [49]999.\r\n        // If so, repeat the summation with a higher precision, otherwise\r\n        // e.g. with precision: 18, rounding: 1\r\n        // exp(18.404272462595034083567793919843761) = 98372560.1229999999 (should be 98372560.123)\r\n        // `wpr - guard` is the index of first rounding digit.\r\n        if (sd == null) {\r\n\r\n          if (rep < 3 && checkRoundingDigits(sum.d, wpr - guard, rm, rep)) {\r\n            Ctor.precision = wpr += 10;\r\n            denominator = pow = t = new Ctor(1);\r\n            i = 0;\r\n            rep++;\r\n          } else {\r\n            return finalise(sum, Ctor.precision = pr, rm, external = true);\r\n          }\r\n        } else {\r\n          Ctor.precision = pr;\r\n          return sum;\r\n        }\r\n      }\r\n\r\n      sum = t;\r\n    }\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the natural logarithm of `x` rounded to `sd` significant\r\n   * digits.\r\n   *\r\n   *  ln(-n)        = NaN\r\n   *  ln(0)         = -Infinity\r\n   *  ln(-0)        = -Infinity\r\n   *  ln(1)         = 0\r\n   *  ln(Infinity)  = Infinity\r\n   *  ln(-Infinity) = NaN\r\n   *  ln(NaN)       = NaN\r\n   *\r\n   *  ln(n) (n != 1) is non-terminating.\r\n   *\r\n   */\r\n  function naturalLogarithm(y, sd) {\r\n    var c, c0, denominator, e, numerator, rep, sum, t, wpr, x1, x2,\r\n      n = 1,\r\n      guard = 10,\r\n      x = y,\r\n      xd = x.d,\r\n      Ctor = x.constructor,\r\n      rm = Ctor.rounding,\r\n      pr = Ctor.precision;\r\n\r\n    // Is x negative or Infinity, NaN, 0 or 1?\r\n    if (x.s < 0 || !xd || !xd[0] || !x.e && xd[0] == 1 && xd.length == 1) {\r\n      return new Ctor(xd && !xd[0] ? -1 / 0 : x.s != 1 ? NaN : xd ? 0 : x);\r\n    }\r\n\r\n    if (sd == null) {\r\n      external = false;\r\n      wpr = pr;\r\n    } else {\r\n      wpr = sd;\r\n    }\r\n\r\n    Ctor.precision = wpr += guard;\r\n    c = digitsToString(xd);\r\n    c0 = c.charAt(0);\r\n\r\n    if (Math.abs(e = x.e) < 1.5e15) {\r\n\r\n      // Argument reduction.\r\n      // The series converges faster the closer the argument is to 1, so using\r\n      // ln(a^b) = b * ln(a),   ln(a) = ln(a^b) / b\r\n      // multiply the argument by itself until the leading digits of the significand are 7, 8, 9,\r\n      // 10, 11, 12 or 13, recording the number of multiplications so the sum of the series can\r\n      // later be divided by this number, then separate out the power of 10 using\r\n      // ln(a*10^b) = ln(a) + b*ln(10).\r\n\r\n      // max n is 21 (gives 0.9, 1.0 or 1.1) (9e15 / 21 = 4.2e14).\r\n      //while (c0 < 9 && c0 != 1 || c0 == 1 && c.charAt(1) > 1) {\r\n      // max n is 6 (gives 0.7 - 1.3)\r\n      while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {\r\n        x = x.times(y);\r\n        c = digitsToString(x.d);\r\n        c0 = c.charAt(0);\r\n        n++;\r\n      }\r\n\r\n      e = x.e;\r\n\r\n      if (c0 > 1) {\r\n        x = new Ctor('0.' + c);\r\n        e++;\r\n      } else {\r\n        x = new Ctor(c0 + '.' + c.slice(1));\r\n      }\r\n    } else {\r\n\r\n      // The argument reduction method above may result in overflow if the argument y is a massive\r\n      // number with exponent >= 1500000000000000 (9e15 / 6 = 1.5e15), so instead recall this\r\n      // function using ln(x*10^e) = ln(x) + e*ln(10).\r\n      t = getLn10(Ctor, wpr + 2, pr).times(e + '');\r\n      x = naturalLogarithm(new Ctor(c0 + '.' + c.slice(1)), wpr - guard).plus(t);\r\n      Ctor.precision = pr;\r\n\r\n      return sd == null ? finalise(x, pr, rm, external = true) : x;\r\n    }\r\n\r\n    // x1 is x reduced to a value near 1.\r\n    x1 = x;\r\n\r\n    // Taylor series.\r\n    // ln(y) = ln((1 + x)/(1 - x)) = 2(x + x^3/3 + x^5/5 + x^7/7 + ...)\r\n    // where x = (y - 1)/(y + 1)    (|x| < 1)\r\n    sum = numerator = x = divide(x.minus(1), x.plus(1), wpr, 1);\r\n    x2 = finalise(x.times(x), wpr, 1);\r\n    denominator = 3;\r\n\r\n    for (;;) {\r\n      numerator = finalise(numerator.times(x2), wpr, 1);\r\n      t = sum.plus(divide(numerator, new Ctor(denominator), wpr, 1));\r\n\r\n      if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {\r\n        sum = sum.times(2);\r\n\r\n        // Reverse the argument reduction. Check that e is not 0 because, besides preventing an\r\n        // unnecessary calculation, -0 + 0 = +0 and to ensure correct rounding -0 needs to stay -0.\r\n        if (e !== 0) sum = sum.plus(getLn10(Ctor, wpr + 2, pr).times(e + ''));\r\n        sum = divide(sum, new Ctor(n), wpr, 1);\r\n\r\n        // Is rm > 3 and the first 4 rounding digits 4999, or rm < 4 (or the summation has\r\n        // been repeated previously) and the first 4 rounding digits 9999?\r\n        // If so, restart the summation with a higher precision, otherwise\r\n        // e.g. with precision: 12, rounding: 1\r\n        // ln(135520028.6126091714265381533) = 18.7246299999 when it should be 18.72463.\r\n        // `wpr - guard` is the index of first rounding digit.\r\n        if (sd == null) {\r\n          if (checkRoundingDigits(sum.d, wpr - guard, rm, rep)) {\r\n            Ctor.precision = wpr += guard;\r\n            t = numerator = x = divide(x1.minus(1), x1.plus(1), wpr, 1);\r\n            x2 = finalise(x.times(x), wpr, 1);\r\n            denominator = rep = 1;\r\n          } else {\r\n            return finalise(sum, Ctor.precision = pr, rm, external = true);\r\n          }\r\n        } else {\r\n          Ctor.precision = pr;\r\n          return sum;\r\n        }\r\n      }\r\n\r\n      sum = t;\r\n      denominator += 2;\r\n    }\r\n  }\r\n\r\n\r\n  // ±Infinity, NaN.\r\n  function nonFiniteToString(x) {\r\n    // Unsigned.\r\n    return String(x.s * x.s / 0);\r\n  }\r\n\r\n\r\n  /*\r\n   * Parse the value of a new Decimal `x` from string `str`.\r\n   */\r\n  function parseDecimal(x, str) {\r\n    var e, i, len;\r\n\r\n    // Decimal point?\r\n    if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');\r\n\r\n    // Exponential form?\r\n    if ((i = str.search(/e/i)) > 0) {\r\n\r\n      // Determine exponent.\r\n      if (e < 0) e = i;\r\n      e += +str.slice(i + 1);\r\n      str = str.substring(0, i);\r\n    } else if (e < 0) {\r\n\r\n      // Integer.\r\n      e = str.length;\r\n    }\r\n\r\n    // Determine leading zeros.\r\n    for (i = 0; str.charCodeAt(i) === 48; i++);\r\n\r\n    // Determine trailing zeros.\r\n    for (len = str.length; str.charCodeAt(len - 1) === 48; --len);\r\n    str = str.slice(i, len);\r\n\r\n    if (str) {\r\n      len -= i;\r\n      x.e = e = e - i - 1;\r\n      x.d = [];\r\n\r\n      // Transform base\r\n\r\n      // e is the base 10 exponent.\r\n      // i is where to slice str to get the first word of the digits array.\r\n      i = (e + 1) % LOG_BASE;\r\n      if (e < 0) i += LOG_BASE;\r\n\r\n      if (i < len) {\r\n        if (i) x.d.push(+str.slice(0, i));\r\n        for (len -= LOG_BASE; i < len;) x.d.push(+str.slice(i, i += LOG_BASE));\r\n        str = str.slice(i);\r\n        i = LOG_BASE - str.length;\r\n      } else {\r\n        i -= len;\r\n      }\r\n\r\n      for (; i--;) str += '0';\r\n      x.d.push(+str);\r\n\r\n      if (external) {\r\n\r\n        // Overflow?\r\n        if (x.e > x.constructor.maxE) {\r\n\r\n          // Infinity.\r\n          x.d = null;\r\n          x.e = NaN;\r\n\r\n        // Underflow?\r\n        } else if (x.e < x.constructor.minE) {\r\n\r\n          // Zero.\r\n          x.e = 0;\r\n          x.d = [0];\r\n          // x.constructor.underflow = true;\r\n        } // else x.constructor.underflow = false;\r\n      }\r\n    } else {\r\n\r\n      // Zero.\r\n      x.e = 0;\r\n      x.d = [0];\r\n    }\r\n\r\n    return x;\r\n  }\r\n\r\n\r\n  /*\r\n   * Parse the value of a new Decimal `x` from a string `str`, which is not a decimal value.\r\n   */\r\n  function parseOther(x, str) {\r\n    var base, Ctor, divisor, i, isFloat, len, p, xd, xe;\r\n\r\n    if (str.indexOf('_') > -1) {\r\n      str = str.replace(/(\\d)_(?=\\d)/g, '$1');\r\n      if (isDecimal.test(str)) return parseDecimal(x, str);\r\n    } else if (str === 'Infinity' || str === 'NaN') {\r\n      if (!+str) x.s = NaN;\r\n      x.e = NaN;\r\n      x.d = null;\r\n      return x;\r\n    }\r\n\r\n    if (isHex.test(str))  {\r\n      base = 16;\r\n      str = str.toLowerCase();\r\n    } else if (isBinary.test(str))  {\r\n      base = 2;\r\n    } else if (isOctal.test(str))  {\r\n      base = 8;\r\n    } else {\r\n      throw Error(invalidArgument + str);\r\n    }\r\n\r\n    // Is there a binary exponent part?\r\n    i = str.search(/p/i);\r\n\r\n    if (i > 0) {\r\n      p = +str.slice(i + 1);\r\n      str = str.substring(2, i);\r\n    } else {\r\n      str = str.slice(2);\r\n    }\r\n\r\n    // Convert `str` as an integer then divide the result by `base` raised to a power such that the\r\n    // fraction part will be restored.\r\n    i = str.indexOf('.');\r\n    isFloat = i >= 0;\r\n    Ctor = x.constructor;\r\n\r\n    if (isFloat) {\r\n      str = str.replace('.', '');\r\n      len = str.length;\r\n      i = len - i;\r\n\r\n      // log[10](16) = 1.2041... , log[10](88) = 1.9444....\r\n      divisor = intPow(Ctor, new Ctor(base), i, i * 2);\r\n    }\r\n\r\n    xd = convertBase(str, base, BASE);\r\n    xe = xd.length - 1;\r\n\r\n    // Remove trailing zeros.\r\n    for (i = xe; xd[i] === 0; --i) xd.pop();\r\n    if (i < 0) return new Ctor(x.s * 0);\r\n    x.e = getBase10Exponent(xd, xe);\r\n    x.d = xd;\r\n    external = false;\r\n\r\n    // At what precision to perform the division to ensure exact conversion?\r\n    // maxDecimalIntegerPartDigitCount = ceil(log[10](b) * otherBaseIntegerPartDigitCount)\r\n    // log[10](2) = 0.30103, log[10](8) = 0.90309, log[10](16) = 1.20412\r\n    // E.g. ceil(1.2 * 3) = 4, so up to 4 decimal digits are needed to represent 3 hex int digits.\r\n    // maxDecimalFractionPartDigitCount = {Hex:4|Oct:3|Bin:1} * otherBaseFractionPartDigitCount\r\n    // Therefore using 4 * the number of digits of str will always be enough.\r\n    if (isFloat) x = divide(x, divisor, len * 4);\r\n\r\n    // Multiply by the binary exponent part if present.\r\n    if (p) x = x.times(Math.abs(p) < 54 ? mathpow(2, p) : Decimal.pow(2, p));\r\n    external = true;\r\n\r\n    return x;\r\n  }\r\n\r\n\r\n  /*\r\n   * sin(x) = x - x^3/3! + x^5/5! - ...\r\n   * |x| < pi/2\r\n   *\r\n   */\r\n  function sine(Ctor, x) {\r\n    var k,\r\n      len = x.d.length;\r\n\r\n    if (len < 3) {\r\n      return x.isZero() ? x : taylorSeries(Ctor, 2, x, x);\r\n    }\r\n\r\n    // Argument reduction: sin(5x) = 16*sin^5(x) - 20*sin^3(x) + 5*sin(x)\r\n    // i.e. sin(x) = 16*sin^5(x/5) - 20*sin^3(x/5) + 5*sin(x/5)\r\n    // and  sin(x) = sin(x/5)(5 + sin^2(x/5)(16sin^2(x/5) - 20))\r\n\r\n    // Estimate the optimum number of times to use the argument reduction.\r\n    k = 1.4 * Math.sqrt(len);\r\n    k = k > 16 ? 16 : k | 0;\r\n\r\n    x = x.times(1 / tinyPow(5, k));\r\n    x = taylorSeries(Ctor, 2, x, x);\r\n\r\n    // Reverse argument reduction\r\n    var sin2_x,\r\n      d5 = new Ctor(5),\r\n      d16 = new Ctor(16),\r\n      d20 = new Ctor(20);\r\n    for (; k--;) {\r\n      sin2_x = x.times(x);\r\n      x = x.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));\r\n    }\r\n\r\n    return x;\r\n  }\r\n\r\n\r\n  // Calculate Taylor series for `cos`, `cosh`, `sin` and `sinh`.\r\n  function taylorSeries(Ctor, n, x, y, isHyperbolic) {\r\n    var j, t, u, x2,\r\n      i = 1,\r\n      pr = Ctor.precision,\r\n      k = Math.ceil(pr / LOG_BASE);\r\n\r\n    external = false;\r\n    x2 = x.times(x);\r\n    u = new Ctor(y);\r\n\r\n    for (;;) {\r\n      t = divide(u.times(x2), new Ctor(n++ * n++), pr, 1);\r\n      u = isHyperbolic ? y.plus(t) : y.minus(t);\r\n      y = divide(t.times(x2), new Ctor(n++ * n++), pr, 1);\r\n      t = u.plus(y);\r\n\r\n      if (t.d[k] !== void 0) {\r\n        for (j = k; t.d[j] === u.d[j] && j--;);\r\n        if (j == -1) break;\r\n      }\r\n\r\n      j = u;\r\n      u = y;\r\n      y = t;\r\n      t = j;\r\n      i++;\r\n    }\r\n\r\n    external = true;\r\n    t.d.length = k + 1;\r\n\r\n    return t;\r\n  }\r\n\r\n\r\n  // Exponent e must be positive and non-zero.\r\n  function tinyPow(b, e) {\r\n    var n = b;\r\n    while (--e) n *= b;\r\n    return n;\r\n  }\r\n\r\n\r\n  // Return the absolute value of `x` reduced to less than or equal to half pi.\r\n  function toLessThanHalfPi(Ctor, x) {\r\n    var t,\r\n      isNeg = x.s < 0,\r\n      pi = getPi(Ctor, Ctor.precision, 1),\r\n      halfPi = pi.times(0.5);\r\n\r\n    x = x.abs();\r\n\r\n    if (x.lte(halfPi)) {\r\n      quadrant = isNeg ? 4 : 1;\r\n      return x;\r\n    }\r\n\r\n    t = x.divToInt(pi);\r\n\r\n    if (t.isZero()) {\r\n      quadrant = isNeg ? 3 : 2;\r\n    } else {\r\n      x = x.minus(t.times(pi));\r\n\r\n      // 0 <= x < pi\r\n      if (x.lte(halfPi)) {\r\n        quadrant = isOdd(t) ? (isNeg ? 2 : 3) : (isNeg ? 4 : 1);\r\n        return x;\r\n      }\r\n\r\n      quadrant = isOdd(t) ? (isNeg ? 1 : 4) : (isNeg ? 3 : 2);\r\n    }\r\n\r\n    return x.minus(pi).abs();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return the value of Decimal `x` as a string in base `baseOut`.\r\n   *\r\n   * If the optional `sd` argument is present include a binary exponent suffix.\r\n   */\r\n  function toStringBinary(x, baseOut, sd, rm) {\r\n    var base, e, i, k, len, roundUp, str, xd, y,\r\n      Ctor = x.constructor,\r\n      isExp = sd !== void 0;\r\n\r\n    if (isExp) {\r\n      checkInt32(sd, 1, MAX_DIGITS);\r\n      if (rm === void 0) rm = Ctor.rounding;\r\n      else checkInt32(rm, 0, 8);\r\n    } else {\r\n      sd = Ctor.precision;\r\n      rm = Ctor.rounding;\r\n    }\r\n\r\n    if (!x.isFinite()) {\r\n      str = nonFiniteToString(x);\r\n    } else {\r\n      str = finiteToString(x);\r\n      i = str.indexOf('.');\r\n\r\n      // Use exponential notation according to `toExpPos` and `toExpNeg`? No, but if required:\r\n      // maxBinaryExponent = floor((decimalExponent + 1) * log[2](10))\r\n      // minBinaryExponent = floor(decimalExponent * log[2](10))\r\n      // log[2](10) = 3.321928094887362347870319429489390175864\r\n\r\n      if (isExp) {\r\n        base = 2;\r\n        if (baseOut == 16) {\r\n          sd = sd * 4 - 3;\r\n        } else if (baseOut == 8) {\r\n          sd = sd * 3 - 2;\r\n        }\r\n      } else {\r\n        base = baseOut;\r\n      }\r\n\r\n      // Convert the number as an integer then divide the result by its base raised to a power such\r\n      // that the fraction part will be restored.\r\n\r\n      // Non-integer.\r\n      if (i >= 0) {\r\n        str = str.replace('.', '');\r\n        y = new Ctor(1);\r\n        y.e = str.length - i;\r\n        y.d = convertBase(finiteToString(y), 10, base);\r\n        y.e = y.d.length;\r\n      }\r\n\r\n      xd = convertBase(str, 10, base);\r\n      e = len = xd.length;\r\n\r\n      // Remove trailing zeros.\r\n      for (; xd[--len] == 0;) xd.pop();\r\n\r\n      if (!xd[0]) {\r\n        str = isExp ? '0p+0' : '0';\r\n      } else {\r\n        if (i < 0) {\r\n          e--;\r\n        } else {\r\n          x = new Ctor(x);\r\n          x.d = xd;\r\n          x.e = e;\r\n          x = divide(x, y, sd, rm, 0, base);\r\n          xd = x.d;\r\n          e = x.e;\r\n          roundUp = inexact;\r\n        }\r\n\r\n        // The rounding digit, i.e. the digit after the digit that may be rounded up.\r\n        i = xd[sd];\r\n        k = base / 2;\r\n        roundUp = roundUp || xd[sd + 1] !== void 0;\r\n\r\n        roundUp = rm < 4\r\n          ? (i !== void 0 || roundUp) && (rm === 0 || rm === (x.s < 0 ? 3 : 2))\r\n          : i > k || i === k && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 ||\r\n            rm === (x.s < 0 ? 8 : 7));\r\n\r\n        xd.length = sd;\r\n\r\n        if (roundUp) {\r\n\r\n          // Rounding up may mean the previous digit has to be rounded up and so on.\r\n          for (; ++xd[--sd] > base - 1;) {\r\n            xd[sd] = 0;\r\n            if (!sd) {\r\n              ++e;\r\n              xd.unshift(1);\r\n            }\r\n          }\r\n        }\r\n\r\n        // Determine trailing zeros.\r\n        for (len = xd.length; !xd[len - 1]; --len);\r\n\r\n        // E.g. [4, 11, 15] becomes 4bf.\r\n        for (i = 0, str = ''; i < len; i++) str += NUMERALS.charAt(xd[i]);\r\n\r\n        // Add binary exponent suffix?\r\n        if (isExp) {\r\n          if (len > 1) {\r\n            if (baseOut == 16 || baseOut == 8) {\r\n              i = baseOut == 16 ? 4 : 3;\r\n              for (--len; len % i; len++) str += '0';\r\n              xd = convertBase(str, base, baseOut);\r\n              for (len = xd.length; !xd[len - 1]; --len);\r\n\r\n              // xd[0] will always be be 1\r\n              for (i = 1, str = '1.'; i < len; i++) str += NUMERALS.charAt(xd[i]);\r\n            } else {\r\n              str = str.charAt(0) + '.' + str.slice(1);\r\n            }\r\n          }\r\n\r\n          str =  str + (e < 0 ? 'p' : 'p+') + e;\r\n        } else if (e < 0) {\r\n          for (; ++e;) str = '0' + str;\r\n          str = '0.' + str;\r\n        } else {\r\n          if (++e > len) for (e -= len; e-- ;) str += '0';\r\n          else if (e < len) str = str.slice(0, e) + '.' + str.slice(e);\r\n        }\r\n      }\r\n\r\n      str = (baseOut == 16 ? '0x' : baseOut == 2 ? '0b' : baseOut == 8 ? '0o' : '') + str;\r\n    }\r\n\r\n    return x.s < 0 ? '-' + str : str;\r\n  }\r\n\r\n\r\n  // Does not strip trailing zeros.\r\n  function truncate(arr, len) {\r\n    if (arr.length > len) {\r\n      arr.length = len;\r\n      return true;\r\n    }\r\n  }\r\n\r\n\r\n  // Decimal methods\r\n\r\n\r\n  /*\r\n   *  abs\r\n   *  acos\r\n   *  acosh\r\n   *  add\r\n   *  asin\r\n   *  asinh\r\n   *  atan\r\n   *  atanh\r\n   *  atan2\r\n   *  cbrt\r\n   *  ceil\r\n   *  clamp\r\n   *  clone\r\n   *  config\r\n   *  cos\r\n   *  cosh\r\n   *  div\r\n   *  exp\r\n   *  floor\r\n   *  hypot\r\n   *  ln\r\n   *  log\r\n   *  log2\r\n   *  log10\r\n   *  max\r\n   *  min\r\n   *  mod\r\n   *  mul\r\n   *  pow\r\n   *  random\r\n   *  round\r\n   *  set\r\n   *  sign\r\n   *  sin\r\n   *  sinh\r\n   *  sqrt\r\n   *  sub\r\n   *  sum\r\n   *  tan\r\n   *  tanh\r\n   *  trunc\r\n   */\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the absolute value of `x`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function abs(x) {\r\n    return new this(x).abs();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the arccosine in radians of `x`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function acos(x) {\r\n    return new this(x).acos();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the inverse of the hyperbolic cosine of `x`, rounded to\r\n   * `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\r\n  function acosh(x) {\r\n    return new this(x).acosh();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the sum of `x` and `y`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   * y {number|string|Decimal}\r\n   *\r\n   */\r\n  function add(x, y) {\r\n    return new this(x).plus(y);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the arcsine in radians of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function asin(x) {\r\n    return new this(x).asin();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the inverse of the hyperbolic sine of `x`, rounded to\r\n   * `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\r\n  function asinh(x) {\r\n    return new this(x).asinh();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the arctangent in radians of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function atan(x) {\r\n    return new this(x).atan();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the inverse of the hyperbolic tangent of `x`, rounded to\r\n   * `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\r\n  function atanh(x) {\r\n    return new this(x).atanh();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the arctangent in radians of `y/x` in the range -pi to pi\r\n   * (inclusive), rounded to `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-pi, pi]\r\n   *\r\n   * y {number|string|Decimal} The y-coordinate.\r\n   * x {number|string|Decimal} The x-coordinate.\r\n   *\r\n   * atan2(±0, -0)               = ±pi\r\n   * atan2(±0, +0)               = ±0\r\n   * atan2(±0, -x)               = ±pi for x > 0\r\n   * atan2(±0, x)                = ±0 for x > 0\r\n   * atan2(-y, ±0)               = -pi/2 for y > 0\r\n   * atan2(y, ±0)                = pi/2 for y > 0\r\n   * atan2(±y, -Infinity)        = ±pi for finite y > 0\r\n   * atan2(±y, +Infinity)        = ±0 for finite y > 0\r\n   * atan2(±Infinity, x)         = ±pi/2 for finite x\r\n   * atan2(±Infinity, -Infinity) = ±3*pi/4\r\n   * atan2(±Infinity, +Infinity) = ±pi/4\r\n   * atan2(NaN, x) = NaN\r\n   * atan2(y, NaN) = NaN\r\n   *\r\n   */\r\n  function atan2(y, x) {\r\n    y = new this(y);\r\n    x = new this(x);\r\n    var r,\r\n      pr = this.precision,\r\n      rm = this.rounding,\r\n      wpr = pr + 4;\r\n\r\n    // Either NaN\r\n    if (!y.s || !x.s) {\r\n      r = new this(NaN);\r\n\r\n    // Both ±Infinity\r\n    } else if (!y.d && !x.d) {\r\n      r = getPi(this, wpr, 1).times(x.s > 0 ? 0.25 : 0.75);\r\n      r.s = y.s;\r\n\r\n    // x is ±Infinity or y is ±0\r\n    } else if (!x.d || y.isZero()) {\r\n      r = x.s < 0 ? getPi(this, pr, rm) : new this(0);\r\n      r.s = y.s;\r\n\r\n    // y is ±Infinity or x is ±0\r\n    } else if (!y.d || x.isZero()) {\r\n      r = getPi(this, wpr, 1).times(0.5);\r\n      r.s = y.s;\r\n\r\n    // Both non-zero and finite\r\n    } else if (x.s < 0) {\r\n      this.precision = wpr;\r\n      this.rounding = 1;\r\n      r = this.atan(divide(y, x, wpr, 1));\r\n      x = getPi(this, wpr, 1);\r\n      this.precision = pr;\r\n      this.rounding = rm;\r\n      r = y.s < 0 ? r.minus(x) : r.plus(x);\r\n    } else {\r\n      r = this.atan(divide(y, x, wpr, 1));\r\n    }\r\n\r\n    return r;\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the cube root of `x`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function cbrt(x) {\r\n    return new this(x).cbrt();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` rounded to an integer using `ROUND_CEIL`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function ceil(x) {\r\n    return finalise(x = new this(x), x.e + 1, 2);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` clamped to the range delineated by `min` and `max`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   * min {number|string|Decimal}\r\n   * max {number|string|Decimal}\r\n   *\r\n   */\r\n  function clamp(x, min, max) {\r\n    return new this(x).clamp(min, max);\r\n  }\r\n\r\n\r\n  /*\r\n   * Configure global settings for a Decimal constructor.\r\n   *\r\n   * `obj` is an object with one or more of the following properties,\r\n   *\r\n   *   precision  {number}\r\n   *   rounding   {number}\r\n   *   toExpNeg   {number}\r\n   *   toExpPos   {number}\r\n   *   maxE       {number}\r\n   *   minE       {number}\r\n   *   modulo     {number}\r\n   *   crypto     {boolean|number}\r\n   *   defaults   {true}\r\n   *\r\n   * E.g. Decimal.config({ precision: 20, rounding: 4 })\r\n   *\r\n   */\r\n  function config(obj) {\r\n    if (!obj || typeof obj !== 'object') throw Error(decimalError + 'Object expected');\r\n    var i, p, v,\r\n      useDefaults = obj.defaults === true,\r\n      ps = [\r\n        'precision', 1, MAX_DIGITS,\r\n        'rounding', 0, 8,\r\n        'toExpNeg', -EXP_LIMIT, 0,\r\n        'toExpPos', 0, EXP_LIMIT,\r\n        'maxE', 0, EXP_LIMIT,\r\n        'minE', -EXP_LIMIT, 0,\r\n        'modulo', 0, 9\r\n      ];\r\n\r\n    for (i = 0; i < ps.length; i += 3) {\r\n      if (p = ps[i], useDefaults) this[p] = DEFAULTS[p];\r\n      if ((v = obj[p]) !== void 0) {\r\n        if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2]) this[p] = v;\r\n        else throw Error(invalidArgument + p + ': ' + v);\r\n      }\r\n    }\r\n\r\n    if (p = 'crypto', useDefaults) this[p] = DEFAULTS[p];\r\n    if ((v = obj[p]) !== void 0) {\r\n      if (v === true || v === false || v === 0 || v === 1) {\r\n        if (v) {\r\n          if (typeof crypto != 'undefined' && crypto &&\r\n            (crypto.getRandomValues || crypto.randomBytes)) {\r\n            this[p] = true;\r\n          } else {\r\n            throw Error(cryptoUnavailable);\r\n          }\r\n        } else {\r\n          this[p] = false;\r\n        }\r\n      } else {\r\n        throw Error(invalidArgument + p + ': ' + v);\r\n      }\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the cosine of `x`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\r\n  function cos(x) {\r\n    return new this(x).cos();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the hyperbolic cosine of `x`, rounded to precision\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\r\n  function cosh(x) {\r\n    return new this(x).cosh();\r\n  }\r\n\r\n\r\n  /*\r\n   * Create and return a Decimal constructor with the same configuration properties as this Decimal\r\n   * constructor.\r\n   *\r\n   */\r\n  function clone(obj) {\r\n    var i, p, ps;\r\n\r\n    /*\r\n     * The Decimal constructor and exported function.\r\n     * Return a new Decimal instance.\r\n     *\r\n     * v {number|string|Decimal} A numeric value.\r\n     *\r\n     */\r\n    function Decimal(v) {\r\n      var e, i, t,\r\n        x = this;\r\n\r\n      // Decimal called without new.\r\n      if (!(x instanceof Decimal)) return new Decimal(v);\r\n\r\n      // Retain a reference to this Decimal constructor, and shadow Decimal.prototype.constructor\r\n      // which points to Object.\r\n      x.constructor = Decimal;\r\n\r\n      // Duplicate.\r\n      if (isDecimalInstance(v)) {\r\n        x.s = v.s;\r\n\r\n        if (external) {\r\n          if (!v.d || v.e > Decimal.maxE) {\r\n\r\n            // Infinity.\r\n            x.e = NaN;\r\n            x.d = null;\r\n          } else if (v.e < Decimal.minE) {\r\n\r\n            // Zero.\r\n            x.e = 0;\r\n            x.d = [0];\r\n          } else {\r\n            x.e = v.e;\r\n            x.d = v.d.slice();\r\n          }\r\n        } else {\r\n          x.e = v.e;\r\n          x.d = v.d ? v.d.slice() : v.d;\r\n        }\r\n\r\n        return;\r\n      }\r\n\r\n      t = typeof v;\r\n\r\n      if (t === 'number') {\r\n        if (v === 0) {\r\n          x.s = 1 / v < 0 ? -1 : 1;\r\n          x.e = 0;\r\n          x.d = [0];\r\n          return;\r\n        }\r\n\r\n        if (v < 0) {\r\n          v = -v;\r\n          x.s = -1;\r\n        } else {\r\n          x.s = 1;\r\n        }\r\n\r\n        // Fast path for small integers.\r\n        if (v === ~~v && v < 1e7) {\r\n          for (e = 0, i = v; i >= 10; i /= 10) e++;\r\n\r\n          if (external) {\r\n            if (e > Decimal.maxE) {\r\n              x.e = NaN;\r\n              x.d = null;\r\n            } else if (e < Decimal.minE) {\r\n              x.e = 0;\r\n              x.d = [0];\r\n            } else {\r\n              x.e = e;\r\n              x.d = [v];\r\n            }\r\n          } else {\r\n            x.e = e;\r\n            x.d = [v];\r\n          }\r\n\r\n          return;\r\n\r\n        // Infinity, NaN.\r\n        } else if (v * 0 !== 0) {\r\n          if (!v) x.s = NaN;\r\n          x.e = NaN;\r\n          x.d = null;\r\n          return;\r\n        }\r\n\r\n        return parseDecimal(x, v.toString());\r\n\r\n      } else if (t !== 'string') {\r\n        throw Error(invalidArgument + v);\r\n      }\r\n\r\n      // Minus sign?\r\n      if ((i = v.charCodeAt(0)) === 45) {\r\n        v = v.slice(1);\r\n        x.s = -1;\r\n      } else {\r\n        // Plus sign?\r\n        if (i === 43) v = v.slice(1);\r\n        x.s = 1;\r\n      }\r\n\r\n      return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);\r\n    }\r\n\r\n    Decimal.prototype = P;\r\n\r\n    Decimal.ROUND_UP = 0;\r\n    Decimal.ROUND_DOWN = 1;\r\n    Decimal.ROUND_CEIL = 2;\r\n    Decimal.ROUND_FLOOR = 3;\r\n    Decimal.ROUND_HALF_UP = 4;\r\n    Decimal.ROUND_HALF_DOWN = 5;\r\n    Decimal.ROUND_HALF_EVEN = 6;\r\n    Decimal.ROUND_HALF_CEIL = 7;\r\n    Decimal.ROUND_HALF_FLOOR = 8;\r\n    Decimal.EUCLID = 9;\r\n\r\n    Decimal.config = Decimal.set = config;\r\n    Decimal.clone = clone;\r\n    Decimal.isDecimal = isDecimalInstance;\r\n\r\n    Decimal.abs = abs;\r\n    Decimal.acos = acos;\r\n    Decimal.acosh = acosh;        // ES6\r\n    Decimal.add = add;\r\n    Decimal.asin = asin;\r\n    Decimal.asinh = asinh;        // ES6\r\n    Decimal.atan = atan;\r\n    Decimal.atanh = atanh;        // ES6\r\n    Decimal.atan2 = atan2;\r\n    Decimal.cbrt = cbrt;          // ES6\r\n    Decimal.ceil = ceil;\r\n    Decimal.clamp = clamp;\r\n    Decimal.cos = cos;\r\n    Decimal.cosh = cosh;          // ES6\r\n    Decimal.div = div;\r\n    Decimal.exp = exp;\r\n    Decimal.floor = floor;\r\n    Decimal.hypot = hypot;        // ES6\r\n    Decimal.ln = ln;\r\n    Decimal.log = log;\r\n    Decimal.log10 = log10;        // ES6\r\n    Decimal.log2 = log2;          // ES6\r\n    Decimal.max = max;\r\n    Decimal.min = min;\r\n    Decimal.mod = mod;\r\n    Decimal.mul = mul;\r\n    Decimal.pow = pow;\r\n    Decimal.random = random;\r\n    Decimal.round = round;\r\n    Decimal.sign = sign;          // ES6\r\n    Decimal.sin = sin;\r\n    Decimal.sinh = sinh;          // ES6\r\n    Decimal.sqrt = sqrt;\r\n    Decimal.sub = sub;\r\n    Decimal.sum = sum;\r\n    Decimal.tan = tan;\r\n    Decimal.tanh = tanh;          // ES6\r\n    Decimal.trunc = trunc;        // ES6\r\n\r\n    if (obj === void 0) obj = {};\r\n    if (obj) {\r\n      if (obj.defaults !== true) {\r\n        ps = ['precision', 'rounding', 'toExpNeg', 'toExpPos', 'maxE', 'minE', 'modulo', 'crypto'];\r\n        for (i = 0; i < ps.length;) if (!obj.hasOwnProperty(p = ps[i++])) obj[p] = this[p];\r\n      }\r\n    }\r\n\r\n    Decimal.config(obj);\r\n\r\n    return Decimal;\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` divided by `y`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   * y {number|string|Decimal}\r\n   *\r\n   */\r\n  function div(x, y) {\r\n    return new this(x).div(y);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the natural exponential of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} The power to which to raise the base of the natural log.\r\n   *\r\n   */\r\n  function exp(x) {\r\n    return new this(x).exp();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` round to an integer using `ROUND_FLOOR`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function floor(x) {\r\n    return finalise(x = new this(x), x.e + 1, 3);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the square root of the sum of the squares of the arguments,\r\n   * rounded to `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * hypot(a, b, ...) = sqrt(a^2 + b^2 + ...)\r\n   *\r\n   * arguments {number|string|Decimal}\r\n   *\r\n   */\r\n  function hypot() {\r\n    var i, n,\r\n      t = new this(0);\r\n\r\n    external = false;\r\n\r\n    for (i = 0; i < arguments.length;) {\r\n      n = new this(arguments[i++]);\r\n      if (!n.d) {\r\n        if (n.s) {\r\n          external = true;\r\n          return new this(1 / 0);\r\n        }\r\n        t = n;\r\n      } else if (t.d) {\r\n        t = t.plus(n.times(n));\r\n      }\r\n    }\r\n\r\n    external = true;\r\n\r\n    return t.sqrt();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return true if object is a Decimal instance (where Decimal is any Decimal constructor),\r\n   * otherwise return false.\r\n   *\r\n   */\r\n  function isDecimalInstance(obj) {\r\n    return obj instanceof Decimal || obj && obj.toStringTag === tag || false;\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the natural logarithm of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function ln(x) {\r\n    return new this(x).ln();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the log of `x` to the base `y`, or to base 10 if no base\r\n   * is specified, rounded to `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * log[y](x)\r\n   *\r\n   * x {number|string|Decimal} The argument of the logarithm.\r\n   * y {number|string|Decimal} The base of the logarithm.\r\n   *\r\n   */\r\n  function log(x, y) {\r\n    return new this(x).log(y);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the base 2 logarithm of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function log2(x) {\r\n    return new this(x).log(2);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the base 10 logarithm of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function log10(x) {\r\n    return new this(x).log(10);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the maximum of the arguments.\r\n   *\r\n   * arguments {number|string|Decimal}\r\n   *\r\n   */\r\n  function max() {\r\n    return maxOrMin(this, arguments, 'lt');\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the minimum of the arguments.\r\n   *\r\n   * arguments {number|string|Decimal}\r\n   *\r\n   */\r\n  function min() {\r\n    return maxOrMin(this, arguments, 'gt');\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` modulo `y`, rounded to `precision` significant digits\r\n   * using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   * y {number|string|Decimal}\r\n   *\r\n   */\r\n  function mod(x, y) {\r\n    return new this(x).mod(y);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` multiplied by `y`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   * y {number|string|Decimal}\r\n   *\r\n   */\r\n  function mul(x, y) {\r\n    return new this(x).mul(y);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` raised to the power `y`, rounded to precision\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} The base.\r\n   * y {number|string|Decimal} The exponent.\r\n   *\r\n   */\r\n  function pow(x, y) {\r\n    return new this(x).pow(y);\r\n  }\r\n\r\n\r\n  /*\r\n   * Returns a new Decimal with a random value equal to or greater than 0 and less than 1, and with\r\n   * `sd`, or `Decimal.precision` if `sd` is omitted, significant digits (or less if trailing zeros\r\n   * are produced).\r\n   *\r\n   * [sd] {number} Significant digits. Integer, 0 to MAX_DIGITS inclusive.\r\n   *\r\n   */\r\n  function random(sd) {\r\n    var d, e, k, n,\r\n      i = 0,\r\n      r = new this(1),\r\n      rd = [];\r\n\r\n    if (sd === void 0) sd = this.precision;\r\n    else checkInt32(sd, 1, MAX_DIGITS);\r\n\r\n    k = Math.ceil(sd / LOG_BASE);\r\n\r\n    if (!this.crypto) {\r\n      for (; i < k;) rd[i++] = Math.random() * 1e7 | 0;\r\n\r\n    // Browsers supporting crypto.getRandomValues.\r\n    } else if (crypto.getRandomValues) {\r\n      d = crypto.getRandomValues(new Uint32Array(k));\r\n\r\n      for (; i < k;) {\r\n        n = d[i];\r\n\r\n        // 0 <= n < 4294967296\r\n        // Probability n >= 4.29e9, is 4967296 / 4294967296 = 0.00116 (1 in 865).\r\n        if (n >= 4.29e9) {\r\n          d[i] = crypto.getRandomValues(new Uint32Array(1))[0];\r\n        } else {\r\n\r\n          // 0 <= n <= 4289999999\r\n          // 0 <= (n % 1e7) <= 9999999\r\n          rd[i++] = n % 1e7;\r\n        }\r\n      }\r\n\r\n    // Node.js supporting crypto.randomBytes.\r\n    } else if (crypto.randomBytes) {\r\n\r\n      // buffer\r\n      d = crypto.randomBytes(k *= 4);\r\n\r\n      for (; i < k;) {\r\n\r\n        // 0 <= n < 2147483648\r\n        n = d[i] + (d[i + 1] << 8) + (d[i + 2] << 16) + ((d[i + 3] & 0x7f) << 24);\r\n\r\n        // Probability n >= 2.14e9, is 7483648 / 2147483648 = 0.0035 (1 in 286).\r\n        if (n >= 2.14e9) {\r\n          crypto.randomBytes(4).copy(d, i);\r\n        } else {\r\n\r\n          // 0 <= n <= 2139999999\r\n          // 0 <= (n % 1e7) <= 9999999\r\n          rd.push(n % 1e7);\r\n          i += 4;\r\n        }\r\n      }\r\n\r\n      i = k / 4;\r\n    } else {\r\n      throw Error(cryptoUnavailable);\r\n    }\r\n\r\n    k = rd[--i];\r\n    sd %= LOG_BASE;\r\n\r\n    // Convert trailing digits to zeros according to sd.\r\n    if (k && sd) {\r\n      n = mathpow(10, LOG_BASE - sd);\r\n      rd[i] = (k / n | 0) * n;\r\n    }\r\n\r\n    // Remove trailing words which are zero.\r\n    for (; rd[i] === 0; i--) rd.pop();\r\n\r\n    // Zero?\r\n    if (i < 0) {\r\n      e = 0;\r\n      rd = [0];\r\n    } else {\r\n      e = -1;\r\n\r\n      // Remove leading words which are zero and adjust exponent accordingly.\r\n      for (; rd[0] === 0; e -= LOG_BASE) rd.shift();\r\n\r\n      // Count the digits of the first word of rd to determine leading zeros.\r\n      for (k = 1, n = rd[0]; n >= 10; n /= 10) k++;\r\n\r\n      // Adjust the exponent for leading zeros of the first word of rd.\r\n      if (k < LOG_BASE) e -= LOG_BASE - k;\r\n    }\r\n\r\n    r.e = e;\r\n    r.d = rd;\r\n\r\n    return r;\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` rounded to an integer using rounding mode `rounding`.\r\n   *\r\n   * To emulate `Math.round`, set rounding to 7 (ROUND_HALF_CEIL).\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function round(x) {\r\n    return finalise(x = new this(x), x.e + 1, this.rounding);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return\r\n   *   1    if x > 0,\r\n   *  -1    if x < 0,\r\n   *   0    if x is 0,\r\n   *  -0    if x is -0,\r\n   *   NaN  otherwise\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function sign(x) {\r\n    x = new this(x);\r\n    return x.d ? (x.d[0] ? x.s : 0 * x.s) : x.s || NaN;\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the sine of `x`, rounded to `precision` significant digits\r\n   * using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\r\n  function sin(x) {\r\n    return new this(x).sin();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the hyperbolic sine of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\r\n  function sinh(x) {\r\n    return new this(x).sinh();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the square root of `x`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function sqrt(x) {\r\n    return new this(x).sqrt();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` minus `y`, rounded to `precision` significant digits\r\n   * using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal}\r\n   * y {number|string|Decimal}\r\n   *\r\n   */\r\n  function sub(x, y) {\r\n    return new this(x).sub(y);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the sum of the arguments, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * Only the result is rounded, not the intermediate calculations.\r\n   *\r\n   * arguments {number|string|Decimal}\r\n   *\r\n   */\r\n  function sum() {\r\n    var i = 0,\r\n      args = arguments,\r\n      x = new this(args[i]);\r\n\r\n    external = false;\r\n    for (; x.s && ++i < args.length;) x = x.plus(args[i]);\r\n    external = true;\r\n\r\n    return finalise(x, this.precision, this.rounding);\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the tangent of `x`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\r\n  function tan(x) {\r\n    return new this(x).tan();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is the hyperbolic tangent of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|Decimal} A value in radians.\r\n   *\r\n   */\r\n  function tanh(x) {\r\n    return new this(x).tanh();\r\n  }\r\n\r\n\r\n  /*\r\n   * Return a new Decimal whose value is `x` truncated to an integer.\r\n   *\r\n   * x {number|string|Decimal}\r\n   *\r\n   */\r\n  function trunc(x) {\r\n    return finalise(x = new this(x), x.e + 1, 1);\r\n  }\r\n\r\n\r\n  // Create and configure initial Decimal constructor.\r\n  Decimal = clone(DEFAULTS);\r\n  Decimal.prototype.constructor = Decimal;\r\n  Decimal['default'] = Decimal.Decimal = Decimal;\r\n\r\n  // Create the internal constants from their string values.\r\n  LN10 = new Decimal(LN10);\r\n  PI = new Decimal(PI);\r\n\r\n\r\n  // Export.\r\n\r\n\r\n  // AMD.\r\n  if (typeof define == 'function' && define.amd) {\r\n    define(function () {\r\n      return Decimal;\r\n    });\r\n\r\n  // Node and other environments that support module.exports.\r\n  } else if (typeof module != 'undefined' && module.exports) {\r\n    if (typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol') {\r\n      P[Symbol['for']('nodejs.util.inspect.custom')] = P.toString;\r\n      P[Symbol.toStringTag] = 'Decimal';\r\n    }\r\n\r\n    module.exports = Decimal;\r\n\r\n  // Browser.\r\n  } else {\r\n    if (!globalScope) {\r\n      globalScope = typeof self != 'undefined' && self && self.self == self ? self : window;\r\n    }\r\n\r\n    noConflict = globalScope.Decimal;\r\n    Decimal.noConflict = function () {\r\n      globalScope.Decimal = noConflict;\r\n      return Decimal;\r\n    };\r\n\r\n    globalScope.Decimal = Decimal;\r\n  }\r\n})(this);\r\n","/**\n* Fable Core Pre-initialization Service Base\n*\n* For a couple services, we need to be able to instantiate them before the Fable object is fully initialized.\n* This is a base class for those services.\n*\n* @author <steven@velozo.com>\n*/\n\nclass FableCoreServiceProviderBase\n{\n\tconstructor(pOptions, pServiceHash)\n\t{\n\t\tthis.fable = false;\n\n\t\tthis.options = (typeof(pOptions) === 'object') ? pOptions : {};\n\n\t\tthis.serviceType = 'Unknown';\n\n\t\t// The hash will be a non-standard UUID ... the UUID service uses this base class!\n\t\tthis.UUID = `CORESVC-${Math.floor((Math.random() * (99999 - 10000)) + 10000)}`;\n\n\t\tthis.Hash = (typeof(pServiceHash) === 'string') ? pServiceHash : `${this.UUID}`;\n\t}\n\n\n\tstatic isFableService = true;\n\n\t// After fable is initialized, it would be expected to be wired in as a normal service.\n\tconnectFable(pFable)\n\t{\n\t\tthis.fable = pFable;\n\n\t\treturn true;\n\t}\n}\n\nmodule.exports = FableCoreServiceProviderBase;\n","/**\n* Fable Service Base\n* @author <steven@velozo.com>\n*/\n\nclass FableServiceProviderBase\n{\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tthis.fable = pFable;\n\n\t\tthis.options = (typeof(pOptions) === 'object') ? pOptions\n\t\t\t\t\t\t: ((typeof(pFable) === 'object') && !pFable.isFable) ? pFable\n\t\t\t\t\t\t: {};\n\n\t\tthis.serviceType = 'Unknown';\n\n\t\tif (typeof(pFable.getUUID) == 'function')\n\t\t{\n\t\t\tthis.UUID = pFable.getUUID();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.UUID = `NoFABLESVC-${Math.floor((Math.random() * (99999 - 10000)) + 10000)}`\n\t\t}\n\n\t\tthis.Hash = (typeof(pServiceHash) === 'string') ? pServiceHash : `${this.UUID}`;\n\n\t\t// Pull back a few things\n\t\tthis.log = this.fable.log;\n\t\tthis.servicesMap = this.fable.serviceMap;\n\t\tthis.services = this.fable.services;\n\t}\n\n\tstatic isFableService = true;\n}\n\nmodule.exports = FableServiceProviderBase;\n\nmodule.exports.CoreServiceProviderBase = require('./Fable-ServiceProviderBase-Preinit.js');","/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\n\n/**\n* Instruction Set Bace Class.\n*\n* @class ElucidatorInstructionSet\n*/\nclass ElucidatorInstructionSet\n{\n    constructor(pElucidator)\n    {\n        this.elucidator = pElucidator;\n\n        this.namespace = 'default';\n    }\n\n    // Create an empty namespace for instructions and operations if either one doesn't exist\n    initializeNamespace(pNamespace)\n    {\n        if (typeof(pNamespace) == 'string')\n        {\n            this.namespace = pNamespace;\n        }\n        if (!this.elucidator.instructionSets.hasOwnProperty(this.namespace))\n        {\n            this.elucidator.instructionSets[this.namespace.toLowerCase()] = {};\n        }\n        if (!this.elucidator.operationSets.hasOwnProperty(this.namespace))\n        {\n            this.elucidator.operationSets[this.namespace.toLowerCase()] = {};\n        }\n    }\n\n    // Add an instruction to the set\n    addInstruction(pInstructionHash, fInstructionFunction)\n    {\n        if (typeof(pInstructionHash) != 'string')\n        {\n            this.elucidator.log.error(`Attempted to add an instruction with an invalid hash; expected a string but the instruction hash type was ${typeof(pInstructionHash)}`);\n            return false;\n        }\n        if (typeof(fInstructionFunction) != 'function')\n        {\n            this.elucidator.log.error(`Attempted to add an instruction with an invalid function; expected a function but type was ${typeof(fInstructionFunction)}`);\n            return false;\n        }\n\n        this.elucidator.instructionSets[this.namespace.toLowerCase()][pInstructionHash] = fInstructionFunction;\n        return true;\n    }\n\n    initializeInstructions()\n    {\n        // This is where we map in the instructions.\n        // If the extending class calls super it will inject a harmless noop into the scope.\n        // It isn't recommended to do these inline as lambdas, but this code is generally not expected to be called.\n        // Unless the developer wants a noop in their instruction set...........\n        this.addInstruction('noop', \n            (pOperation) =>\n            {\n                pOperation.log.info('Executing a no-operation operation.');\n                return true;\n            });\n\n        return true;\n    }\n\n    // Add an operation to the set\n    addOperation(pOperationHash, pOperation)\n    {\n        if (typeof(pOperationHash) != 'string')\n        {\n            this.elucidator.log.error(`Attempted to add an operation with an invalid hash; expected a string but the operation hash type was ${typeof(pOperationHash)}`, pOperation);\n            return false;\n        }\n        if (typeof(pOperation) != 'object')\n        {\n            this.elucidator.log.error(`Attempted to add an invalid operation; expected an object data type but the type was ${typeof(pOperation)}`, pOperation);\n            return false;\n        }\n        // Validate the Description subobject, which is key to functioning.\n        if (!pOperation.hasOwnProperty(\"Description\"))\n        {\n            this.elucidator.log.error(`Attempted to add an operation with an invalid description; no Description subobject set.`, pOperation);\n            return false;\n        }\n        if (typeof(pOperation.Description) != 'object')\n        {\n            this.elucidator.log.error(`Attempted to add an operation with an invalid description; Description subobject was not an object.  The type was ${typeof(pOperation.Description)}.`, pOperation);\n            return false;\n        }\n        if (typeof(pOperation.Description.Hash) != 'string')\n        {\n            if (typeof(pOperation.Description.Operation) == 'string')\n            {\n                // Use the \"Operation\" as the \"Hash\"\n                pOperation.Description.Hash = pOperation.Description.Operation;\n            }\n            else\n            {\n                this.elucidator.log.error(`Attempted to add an operation with an invalid description; Description subobject did not contain a valid Hash which is required to call the operation.`, pOperation);\n                return false;\n            }\n        }\n\n        // Now auto create data if it is missing or wrong in the Description\n        if ((typeof(pOperation.Description.Namespace) != 'string') || (pOperation.Description.Namespace != this.namespace))\n        {\n            pOperation.Description.Namespace = this.namespace;\n        }\n        if (typeof(pOperation.Description.Summary) != 'string')\n        {\n            pOperation.Description.Summary = `[${pOperation.Description.Namespace}] [${pOperation.Description.Hash}] operation.`;\n        }\n\n        // If there are no inputs, or outputs, or steps, add them.\n        if (!pOperation.hasOwnProperty('Inputs'))\n        {\n            pOperation.Inputs = {};\n        }\n        if (!pOperation.hasOwnProperty('Outputs'))\n        {\n            pOperation.Outputs = {};\n        }\n        if (!pOperation.hasOwnProperty('Steps'))\n        {\n            pOperation.Steps = [];\n        }\n\n        // If there are no inputs, or outputs, or steps, add them.\n        // TODO: Add a step where we try to load this into Manyfest and see that it's valid.\n        if (typeof(pOperation.Inputs) !== 'object')\n        {\n            this.elucidator.log.error(`Attempted to add an operation with an invalid Inputs object.`, pOperation);\n            return false;\n        }\n        // If there are no inputs, or outputs, or steps, add them.\n        // TODO: Add a step where we try to load this into Manyfest and see that it's valid.\n        if (typeof(pOperation.Outputs) !== 'object')\n        {\n            this.elucidator.log.error(`Attempted to add an operation with an invalid Outputs object.`, pOperation);\n            return false;\n        }\n        if (!Array.isArray(pOperation.Steps))\n        {\n            this.elucidator.log.error(`Attempted to add an operation with an invalid Steps array.`, pOperation);\n            return false;\n        }\n\n\n        this.elucidator.operationSets[this.namespace.toLowerCase()][pOperationHash.toLowerCase()] = pOperation;\n        return true;\n    }\n\n    initializeOperations()\n    {\n        this.addOperation('noop', \n            {\n                \"Description\":\n                {\n                    \"Operation\": \"noop\",\n                    \"Description\": \"No operation - no affect on any data.\"\n                }\n            });\n\n        return true;\n    }\n};\n\nmodule.exports = ElucidatorInstructionSet;","/**\n* @license MIT\n* @author <steven@velozo.com>\n*/\nconst libFableServiceProviderBase = require('fable-serviceproviderbase');\nconst libElucidatorInstructionSet = require('./Elucidator-InstructionSet.js');\n\n/**\n* Elucidator object address-based descriptions and manipulations.\n*\n* @class Elucidator\n*/\nclass Elucidator extends libFableServiceProviderBase\n{\n\tconstructor(pFable, pOptions, pServiceHash)\n\t{\n\t\tsuper(pFable, pOptions, pServiceHash);\n\n\t\t// Instructions are the basic building blocks for operations\n\t\tthis.instructionSets = {};\n\n\t\t// Operations are the solvers that can be called (instructions can't be called directly)\n\t\t// These can be added at run-time as well\n\t\tthis.operationSets = {};\n\n\t\t// Decide later how to make this truly unique.\n\t\tthis.UUID = 0;\n\n\t\tthis.loadDefaultInstructionSets();\n\n\t\tif (this.options.OperationSet)\n\t\t{\n\t\t\tlet tmpSolverHashes = Object.keys(this.options.OperationSet);\n\t\t\tfor (let i = 0; i < tmpSolverHashes.length; i++)\n\t\t\t{\n\t\t\t\tthis.addOperation('Custom',tmpSolverHashes[i], this.options.OperationSet[tmpSolverHashes[i]]);\n\t\t\t}\n\t\t}\n    }\n\n\t// Load an instruction set\n\tloadInstructionSet(cInstructionSet)\n\t{\n\t\tlet tmpInstructionSet = new cInstructionSet(this);\n\t\t// Setup the namespace\n\t\ttmpInstructionSet.initializeNamespace();\n\t\ttmpInstructionSet.initializeInstructions();\n\t\ttmpInstructionSet.initializeOperations();\n\t}\n\n\tloadDefaultInstructionSets()\n\t{\n\t\t// The javascript math instructions and operations\n\t\t// These provide the \"Math\" namespace\n\t\tthis.loadInstructionSet(require(`./InstructionSets/Math-Javascript.js`));\n\n\t\t// A precision javascript math library that is consistent across browsers, stable and without mantissa issues\n\t\t// Uses Decimal.js\n\t\t// These provide the \"PreciseMath\" namespace\n\t\tthis.loadInstructionSet(require(`./InstructionSets/PreciseMath-Decimal.js`));\n\n\t\t// The abstract geometry instructions and operations (rectangle area, circle area, etc.)\n\t\t// These provide the \"Geometry\" namespace\n\t\tthis.loadInstructionSet(require(`./InstructionSets/Geometry.js`));\n\n\t\t// The logic operations (if, execution of instructions, etc.)\n\t\t// These provide the \"Logic\" namespace\n\t\tthis.loadInstructionSet(require(`./InstructionSets/Logic.js`));\n\n\t\t// Basic string manipulation instructions and operations\n\t\t// These provide the \"String\" namespace\n\t\tthis.loadInstructionSet(require(`./InstructionSets/String.js`));\n\n\t\t// Basic set manipulation instructions and operations\n\t\t// These provide the \"Set\" namespace\n\t\tthis.loadInstructionSet(require(`./InstructionSets/Set.js`));\n\t}\n\n\toperationExists(pNamespace, pOperationHash)\n\t{\n\t\tif ((typeof(pNamespace) != 'string') || (typeof(pOperationHash) != 'string'))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\tlet tmpNamespace = pNamespace.toLowerCase();\n\t\treturn (this.operationSets.hasOwnProperty(tmpNamespace) && this.operationSets[tmpNamespace].hasOwnProperty(pOperationHash.toLowerCase()));\n\t}\n\n\taddOperation(pNamespace, pOperationHash, pOperation)\n\t{\n        if (typeof(pNamespace) != 'string')\n        {\n            this.log.error(`Attempted to add an operation at runtime via Elucidator.addOperation with an invalid namespace; expected a string but the type was ${typeof(pNamespace)}`, pOperation);\n            return false;\n        }\n\n\t\tlet tmpOperationInjector = new libElucidatorInstructionSet(this);\n\t\ttmpOperationInjector.initializeNamespace(pNamespace);\n\n\t\treturn tmpOperationInjector.addOperation(pOperationHash, pOperation);\n\t}\n\n\tsolveInternalOperation(pNamespace, pOperationHash, pInputObject, pOutputObject, pDescriptionManyfest, pInputAddressMapping, pOutputAddressMapping, pSolutionContext)\n\t{\n\t\tif (!this.operationExists(pNamespace, pOperationHash))\n\t\t{\n\t\t\tthis.log.error(`Attempted to solveInternalOperation for namespace ${pNamespace} operationHash ${pOperationHash} but the operation was not found.`);\n\t\t\t// TODO: Should this return something with an error log populated?\n\t\t\treturn false;\n\t\t}\n\t\tlet tmpOperation = this.operationSets[pNamespace.toLowerCase()][pOperationHash.toLowerCase()];\n\t\treturn this.solveOperation(tmpOperation, pInputObject, pOutputObject, pDescriptionManyfest, pInputAddressMapping, pOutputAddressMapping, pSolutionContext);\n\t}\n\n\tsolveOperation(pOperationObject, pInputObject, pOutputObject, pDescriptionManyfest, pInputAddressMapping, pOutputAddressMapping, pSolutionContext)\n\t{\n\t\tlet tmpOperation = JSON.parse(JSON.stringify(pOperationObject));\n\n\t\tif (typeof(pInputObject) != 'object')\n\t\t{\n            this.log.error(`Attempted to run a solve but the passed in Input was not an object.  The type was ${typeof(pInputObject)}.`);\n\t\t\treturn false;\n\t\t}\n\t\tlet tmpInputObject = pInputObject;\n\n\t\t// Default to reusing the input object as the output object.\n\t\tlet tmpOutputObject = tmpInputObject;\n\n\t\t// This is how recursive solutions bind their context together.\n\t\tlet tmpSolutionContext = pSolutionContext;\n\t\tif (typeof(tmpSolutionContext) === 'undefined')\n\t\t{\n\t\t\ttmpSolutionContext = (\n\t\t\t\t{\n\t\t\t\t\t\"SolutionGUID\": `Solution-${this.UUID++}`, \n\t\t\t\t\t\"SolutionBaseNamespace\": pOperationObject.Description.Namespace,\n\t\t\t\t\t\"SolutionBaseOperation\": pOperationObject.Description.Operation,\n\t\t\t\t\t\"SolutionLog\": []\n\t\t\t\t});\n\t\t\t\n\t\t\t// This is the root operation, see if there are Inputs and Outputs created ... if not, create them.\n\t\t\tif (!tmpOperation.hasOwnProperty('Inputs'))\n\t\t\t{\n\t\t\t\ttmpOperation.Inputs = {};\n\t\t\t}\n\t\t\tif (!tmpOperation.hasOwnProperty('Outputs'))\n\t\t\t{\n\t\t\t\ttmpOperation.Outputs = {};\n\t\t\t}\n\n\t\t\t// This is the root Operation, see if there is a hash translation available for either side (input or output)\n\t\t\tif (tmpOperation.hasOwnProperty('InputHashTranslationTable'))\n\t\t\t{\n\t\t\t\ttmpSolutionContext.InputHashMapping = JSON.parse(JSON.stringify(tmpOperation.InputHashTranslationTable));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttmpSolutionContext.InputHashMapping = {};\n\t\t\t}\n\n\t\t\tif (tmpOperation.hasOwnProperty('OutputHashTranslationTable'))\n\t\t\t{\n\t\t\t\ttmpSolutionContext.OutputHashMapping = JSON.parse(JSON.stringify(tmpOperation.OutputHashTranslationTable));\n\t\t\t}\n\n\t\t\tif ((typeof(pOutputObject) != 'object')\n\t\t\t\t&& (typeof(tmpOutputHashMapping) == 'undefined') \n\t\t\t\t&& (typeof(tmpInputHashMapping) != 'undefined'))\n\t\t\t{\n\t\t\t\t// Reuse the input hash mapping if:\n\t\t\t\t//   1) we auto-mapped the input hash mapping to the output because only an input object was supplied\n\t\t\t\t//   2) there *was not* an output hash mapping supplied\n\t\t\t\t//   3) there *was* an input hash mapping supplied\n\t\t\t\t//\n\t\t\t\t// This seems simple at first but exposes some really interesting behaviors in terms of\n\t\t\t\t// reusing the same object and schema for input and output, but having different hash\n\t\t\t\t// mappings for each of them.\n\t\t\t\ttmpSolutionContext.OutputHashMapping = tmpSolutionContext.InputHashMapping;\n\t\t\t}\n\t\t}\n\n\t\tif (typeof(pOutputObject) == 'object')\n\t\t{\n\t\t\t// If the call defined an explicit, different output object from the input object use that instead.\n\t\t\ttmpOutputObject = pOutputObject;\n\t\t}\n\n\t\tlet tmpDescriptionManyfest = false;\n\t\tif (typeof(pDescriptionManyfest) === 'undefined')\n\t\t{\n\t\t\t// We are going to use this for some clever schema manipulations, then recreate the object\n\t\t\ttmpDescriptionManyfest = this.fable.serviceManager.instantiateServiceProviderWithoutRegistration('Manifest');\n\t\t\t// Synthesize a manyfest from the Input and Output properties\n\t\t\tlet tmpManyfestSchema = (\n\t\t\t\t{\n\t\t\t\t\tScope: 'Solver Data Part Descriptions',\n\t\t\t\t\tDescriptors: tmpDescriptionManyfest.schemaManipulations.mergeAddressMappings(tmpOperation.Inputs, tmpOperation.Outputs)\n\t\t\t\t});\n\t\t\t}\n\t\telse\n\t\t{\n\t\t\t// Clone the passed-in manyfest, so mutations do not alter the upstream version\n\t\t\ttmpDescriptionManyfest = pDescriptionManyfest.clone();\n\t\t}\n\t\t// Now that the operation object has been created uniquely, apply any passed-in address-hash and hash-hash remappings\n\t\tif (pInputAddressMapping)\n\t\t{\n\t\t\ttmpDescriptionManyfest.schemaManipulations.resolveAddressMappings(tmpOperation.Inputs, pInputAddressMapping);\n\t\t}\n\t\tif (pOutputAddressMapping)\n\t\t{\n\t\t\ttmpDescriptionManyfest.schemaManipulations.resolveAddressMappings(tmpOperation.Inputs, pOutputAddressMapping);\n\t\t}\n\t\tif (tmpSolutionContext.InputHashMapping)\n\t\t{\n\t\t\ttmpDescriptionManyfest.hashTranslations.addTranslation(tmpSolutionContext.InputHashMapping);\n\t\t}\n\t\tif (tmpSolutionContext.OutputHashMapping)\n\t\t{\n\t\t\ttmpDescriptionManyfest.hashTranslations.addTranslation(tmpSolutionContext.OutputHashMapping);\t\t\t\n\t\t}\n\n\n\t\t// Set some kind of unique identifier for the operation\n\t\ttmpOperation.UUID = this.UUID++;\n\t\ttmpOperation.SolutionContext = tmpSolutionContext;\n\n\t\tif (tmpOperation.Description.Synopsys)\n\t\t{\n\t\t\ttmpSolutionContext.SolutionLog.push(`[${tmpOperation.UUID}]: Solver running operation ${tmpOperation.Description.Synopsys}`);\n\t\t}\n\n\t\tlet tmpPrecedent = this.fable.serviceManager.instantiateServiceProviderWithoutRegistration('MetaTemplate');\n\t\ttmpPrecedent.addPattern('{{Name:', '}}',\n\t\t\t(pHash)=>\n\t\t\t{\n\t\t\t\tlet tmpHash = pHash.trim();\n\t\t\t\tlet tmpDescriptor = tmpDescriptionManyfest.getDescriptorByHash(tmpHash)\n\n\t\t\t\t// Return a human readable value\n\t\t\t\tif ((typeof(tmpDescriptor) == 'object')  && tmpDescriptor.hasOwnProperty('Name'))\n\t\t\t\t{\n\t\t\t\t\treturn tmpDescriptor.Name;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treturn tmpHash;\n\t\t\t\t}\n\t\t\t});\n\t\ttmpPrecedent.addPattern('{{InputValue:', '}}',\n\t\t\t(pHash)=>\n\t\t\t{\n\t\t\t\tlet tmpHash = pHash.trim();\n\t\t\t\treturn tmpDescriptionManyfest.getValueByHash(tmpInputObject,tmpHash);\n\t\t\t});\n\t\ttmpPrecedent.addPattern('{{OutputValue:', '}}',\n\t\t\t(pHash)=>\n\t\t\t{\n\t\t\t\tlet tmpHash = pHash.trim();\n\t\t\t\treturn tmpDescriptionManyfest.getValueByHash(tmpOutputObject,tmpHash);\n\t\t\t});\n\n\t\tif (tmpOperation.hasOwnProperty('Log') && tmpOperation.Log.hasOwnProperty('PreOperation'))\n\t\t{\n\t\t\tif (typeof(tmpOperation.Log.PreOperation) == 'string')\n\t\t\t{\n\t\t\t\ttmpOperation.SolutionContext.SolutionLog.push(tmpPrecedent.parseString(tmpOperation.Log.PreOperation));\n\t\t\t}\n\t\t\telse if (Array.isArray(tmpOperation.Log.PreOperation))\n\t\t\t{\n\t\t\t\tfor (let i = 0; i < tmpOperation.Log.PreOperation.length; i++)\n\t\t\t\t{\n\t\t\t\t\tif ((typeof(tmpOperation.Log.PreOperation[i]) == 'string'))\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpOperation.SolutionContext.SolutionLog.push(tmpPrecedent.parseString(tmpOperation.Log.PreOperation[i]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Now step through each operation and solve\n\t\tfor (let i = 0; i < tmpOperation.Steps.length; i++)\n\t\t{\n\t\t\tlet tmpStep = tmpOperation.Steps[i];\n\n\t\t\t// Instructions are always endpoints -- they *do not* recurse.\n\t\t\tif (tmpStep.hasOwnProperty('Instruction'))\n\t\t\t{\n\t\t\t\tlet tmpInputSchema = (\n\t\t\t\t\t{\n\t\t\t\t\t\t\"Scope\": \"InputObject\",\n\t\t\t\t\t\t\"Descriptors\": JSON.parse(JSON.stringify(tmpOperation.Inputs))\n\t\t\t\t\t});\n\t\t\t\t// Perform step-specific address mappings.\n\t\t\t\ttmpDescriptionManyfest.schemaManipulations.resolveAddressMappings(tmpInputSchema.Descriptors, tmpStep.InputHashAddressMap);\n\t\t\t\tlet tmpInputManyfest = this.fable.serviceManager.instantiateServiceProviderWithoutRegistration('Manifest', tmpInputSchema);\n\t\t\t\tif (tmpSolutionContext.InputHashMapping)\n\t\t\t\t{\n\t\t\t\t\ttmpInputManyfest.hashTranslations.addTranslation(tmpSolutionContext.InputHashMapping);\n\t\t\t\t}\n\n\t\t\t\tlet tmpOutputSchema = (\n\t\t\t\t\t{\n\t\t\t\t\t\t\"Scope\": \"OutputObject\",\n\t\t\t\t\t\t\"Descriptors\": JSON.parse(JSON.stringify(tmpOperation.Outputs))\n\t\t\t\t\t});\n\t\t\t\t\ttmpDescriptionManyfest.schemaManipulations.resolveAddressMappings(tmpOutputSchema.Descriptors, tmpStep.OutputHashAddressMap);\n\t\t\t\tlet tmpOutputManyfest = this.fable.serviceManager.instantiateServiceProviderWithoutRegistration('Manifest', tmpOutputSchema);\n\t\t\t\tif (tmpSolutionContext.OutputHashMapping)\n\t\t\t\t{\n\t\t\t\t\ttmpOutputManyfest.hashTranslations.addTranslation(tmpSolutionContext.OutputHashMapping);\n\t\t\t\t}\n\t\n\t\t\t\t// Construct the instruction state object\n\t\t\t\tlet tmpInstructionState = (\n\t\t\t\t{\n\t\t\t\t\tElucidator: this,\n\n\t\t\t\t\tNamespace: tmpStep.Namespace.toLowerCase(),\n\t\t\t\t\tInstruction: tmpStep.Instruction.toLowerCase(),\n\n\t\t\t\t\tOperation: tmpOperation,\n\n\t\t\t\t\tSolutionContext: tmpSolutionContext,\n\n\t\t\t\t\tDescriptionManyfest: tmpDescriptionManyfest,\n\n\t\t\t\t\tInputObject: tmpInputObject,\n\t\t\t\t\tInputManyfest: tmpInputManyfest,\n\n\t\t\t\t\tOutputObject: tmpOutputObject,\n\t\t\t\t\tOutputManyfest: tmpOutputManyfest\n\t\t\t\t});\n\n\t\t\t\ttmpInstructionState.logError = \n\t\t\t\t\t(pMessage) => \n\t\t\t\t\t{\n\t\t\t\t\t\tlet tmpErrorMessage = `[Operation ${tmpInstructionState.Operation.Description.Namespace}:${tmpInstructionState.Operation.Description.Hash} - Step #${i}:${tmpStep.Namespace}:${tmpStep.Instruction}] ${pMessage}`;\n\t\t\t\t\t\tthis.log.error(tmpErrorMessage)\n\t\t\t\t\t\ttmpSolutionContext.SolutionLog.push(`[ERROR]${tmpErrorMessage}`)\n\t\t\t\t\t};\n\n\t\t\t\ttmpInstructionState.logInfo = \n\t\t\t\t\t(pMessage) => \n\t\t\t\t\t{\n\t\t\t\t\t\tlet tmpInfoMessage = `[Operation ${tmpInstructionState.Operation.Description.Namespace}:${tmpInstructionState.Operation.Description.Hash} - Step #${i}:${tmpStep.Namespace}:${tmpStep.Instruction}] ${pMessage}`;\n\t\t\t\t\t\ttmpSolutionContext.SolutionLog.push(`[INFO]${tmpInfoMessage}`)\n\t\t\t\t\t};\n\n\t\t\t\tif (this.instructionSets[tmpInstructionState.Namespace].hasOwnProperty(tmpInstructionState.Instruction))\n\t\t\t\t{\n\t\t\t\t\tlet fInstruction = this.instructionSets[tmpInstructionState.Namespace][tmpInstructionState.Instruction];\n\t\t\t\t\tfInstruction(tmpInstructionState);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Operations recurse.\n\t\t\tif (tmpStep.hasOwnProperty('Operation'))\n\t\t\t{\n\t\t\t\tif (typeof(tmpStep.Operation) == 'string')\n\t\t\t\t{\n\t\t\t\t\tthis.solveInternalOperation(tmpStep.Namespace, tmpStep.Operation, tmpInputObject, tmpOutputObject, tmpDescriptionManyfest, tmpStep.InputHashAddressMap, tmpStep.OutputHashAddressMap, tmpSolutionContext);\n\t\t\t\t}\n\t\t\t\telse if (typeof(tmpStep.Operation) == 'object')\n\t\t\t\t{\n\t\t\t\t\t// You can even define an inline object operation!  This gets crazy fast\n\t\t\t\t\tthis.solveOperation(tmpStep.Operation, tmpInputObject, tmpOutputObject, tmpDescriptionManyfest, tmpStep.InputHashAddressMap, tmpStep.OutputHashAddressMap, tmpSolutionContext);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (tmpOperation.hasOwnProperty('Log') && tmpOperation.Log.hasOwnProperty('PostOperation'))\n\t\t{\n\t\t\tif (typeof(tmpOperation.Log.PostOperation) == 'string')\n\t\t\t{\n\t\t\t\ttmpOperation.SolutionContext.SolutionLog.push(tmpPrecedent.parseString(tmpOperation.Log.PostOperation));\n\t\t\t}\n\t\t\telse if (Array.isArray(tmpOperation.Log.PreOperation))\n\t\t\t{\n\t\t\t\tfor (let i = 0; i < tmpOperation.Log.PostOperation.length; i++)\n\t\t\t\t{\n\t\t\t\t\tif ((typeof(tmpOperation.Log.PostOperation[i]) == 'string'))\n\t\t\t\t\t{\n\t\t\t\t\t\ttmpOperation.SolutionContext.SolutionLog.push(tmpPrecedent.parseString(tmpOperation.Log.PostOperation[i]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn tmpSolutionContext;\n\t}\n};\n\nmodule.exports = Elucidator;","// Solution providers are meant to be stateless, and not classes.\n// These solution providers are akin to drivers, connecting code libraries or \n// other types of behavior to mapping operations.\n\nlet libElucidatorInstructionSet = require('../Elucidator-InstructionSet.js');\n\nclass Geometry extends libElucidatorInstructionSet\n{\n    constructor(pElucidator)\n    {\n        super(pElucidator);\n        this.namespace = 'Geometry';\n    }\n\n    // Geometry provides no instructions\n    initializeInstructions()\n    {\n        return true;\n    }\n\n    initializeOperations()\n    {\n        this.addOperation('rectanglearea', require(`./Operations/Geometry-RectangleArea.json`));\n\n        return true;\n    }\n}\n\nmodule.exports = Geometry;","// Solution providers are meant to be stateless, and not classes.\n// These solution providers are akin to drivers, connecting code libraries or \n// other types of behavior to mapping operations.\n\nlet libElucidatorInstructionSet = require('../Elucidator-InstructionSet.js');\n\nconst ifInstruction = (pOperation) =>\n{\n    let tmpLeftValue = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'leftValue');\n    let tmpRightValue = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'rightValue');\n    let tmpComparator = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'comparator').toString().toLowerCase();\n\n    let tmpComparisonOperator = 'equal';\n\n    // This may eventually come from configuration; for now just leave it here.\n    let tmpComparisonOperatorMapping = (\n        {\n            '==':'equal',\n            'eq':'equal',\n            'equal':'equal',\n\n            '!=':'notequal',\n            'noteq':'notequal',\n            'notequal':'notequal',\n\n            '===':'identity',\n            'id':'identity',\n            'identity':'identity',\n\n            '>':'greaterthan',\n            'gt':'greaterthan',\n            'greaterthan':'greaterthan',\n\n            '>=':'greaterthanorequal',\n            'gte':'greaterthanorequal',\n            'greaterthanorequal':'greaterthanorequal',\n\n            '<':'lessthan',\n            'lt':'lessthan',\n            'lessthan':'lessthan',\n\n            '<=':'lessthanorequal',\n            'lte':'lessthanorequal',\n            'lessthanorequal':'lessthanorequal'\n        });\n\n    if (tmpComparisonOperatorMapping.hasOwnProperty(tmpComparator))\n    {\n        tmpComparisonOperator = tmpComparisonOperatorMapping[tmpComparator];\n    }\n\n    let tmpTrueNamespace = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'trueNamespace');\n    let tmpTrueOperation = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'trueOperation');\n\n    let tmpFalseNamespace = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'falseNamespace');\n    let tmpFalseOperation = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'falseOperation');\n\n    let tmpTruthiness = null;\n\n    switch(tmpComparisonOperator)\n    {\n        case 'equal':\n            tmpTruthiness = (tmpLeftValue == tmpRightValue);\n            break;\n        case 'identity':\n            tmpTruthiness = (tmpLeftValue === tmpRightValue);\n            break;\n        case 'notequal':\n            tmpTruthiness = (tmpLeftValue != tmpRightValue);\n            break;\n        case 'greaterthan':\n            tmpTruthiness = (tmpLeftValue > tmpRightValue);\n            break;\n        case 'greaterthanorequal':\n            tmpTruthiness = (tmpLeftValue >= tmpRightValue);\n            break;\n        case 'lessthan':\n            tmpTruthiness = (tmpLeftValue < tmpRightValue);\n            break;\n        case 'lessthanorequal':\n            tmpTruthiness = (tmpLeftValue <= tmpRightValue);\n            break;\n    }\n\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'truthinessResult', tmpTruthiness);\n\n    // Now execute the operations (unless it is a noop or a bunk operation)\n    // This is, frankly, kindof a mind-blowing amount of recursion possibility.\n    // Both of these are falling back on the base solution hash mapping.\n    // --> Not certain if this is the correct approach and the only way to tell will be through exercise of this\n    if (tmpTruthiness && (typeof(tmpTrueNamespace) == 'string') && (typeof(tmpTrueOperation) == 'string') && (tmpTrueOperation != 'noop'))\n    {\n        pOperation.Elucidator.solveInternalOperation(tmpTrueNamespace, tmpTrueOperation, pOperation.InputObject, pOperation.OutputObject, pOperation.DescriptionManyfest, pOperation.SolutionContext.InputHashMapping, pOperation.SolutionContext.OutputHashMapping, pOperation.SolutionContext);\n    }\n    else if ((typeof(tmpFalseNamespace) == 'string') &&  (typeof(tmpFalseOperation) == 'string') && (tmpFalseOperation != 'noop'))\n    {\n        pOperation.Elucidator.solveInternalOperation(tmpFalseNamespace, tmpFalseOperation, pOperation.InputObject, pOperation.OutputObject, pOperation.DescriptionManyfest, pOperation.SolutionContext.InputHashMapping, pOperation.SolutionContext.OutputHashMapping, pOperation.SolutionContext);\n    }\n\n    return true;\n};\n\nconst executeOperation = (pOperation) =>\n{\n    let tmpNamespace = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'namespace');\n    let tmpOperation = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'operation');\n\n    pOperation.Elucidator.solveInternalOperation(tmpNamespace, tmpOperation, pOperation.InputObject, pOperation.OutputObject, pOperation.DescriptionManyfest, pOperation.SolutionContext.InputHashMapping, pOperation.SolutionContext.OutputHashMapping, pOperation.SolutionContext);\n\n    return true;\n}\n\nclass Logic extends libElucidatorInstructionSet\n{\n    constructor(pElucidator)\n    {\n        super(pElucidator);\n        this.namespace = 'Logic';\n    }\n\n    initializeInstructions()\n    {\n        // Logic actually wants a noop instruction!\n        super.initializeInstructions();\n\n        this.addInstruction('if', ifInstruction);\n        this.addInstruction('execute', executeOperation);\n\n        return true;\n    }\n\n    initializeOperations()\n    {\n        this.addOperation('if', require(`./Operations/Logic-If.json`));\n        this.addOperation('execute', require(`./Operations/Logic-Execute.json`));\n\n        return true;\n    }\n}\n\nmodule.exports = Logic;","// Solution providers are meant to be stateless, and not classes.\n// These solution providers are akin to drivers, connecting code libraries or \n// other types of behavior to mapping operations.\n\nlet libElucidatorInstructionSet = require('../Elucidator-InstructionSet.js');\n\nlet add = (pOperation) =>\n{\n    // This could be done in one line, but, would be more difficult to comprehend.\n    let tmpA = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'a');\n    let tmpB = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'b');\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'x', tmpA + tmpB);\n    return true;\n};\n\nlet subtract = (pOperation) =>\n{\n    // This could be done in one line, but, would be more difficult to comprehend.\n    let tmpA = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'a');\n    let tmpB = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'b');\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'x', tmpA - tmpB);\n    return true;\n};\n\nlet multiply = (pOperation) =>\n{\n    // This could be done in one line, but, would be more difficult to comprehend.\n    let tmpA = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'a');\n    let tmpB = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'b');\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'x', tmpA * tmpB);\n    return true;\n};\n\nlet divide = (pOperation) =>\n{\n    // This could be done in one line, but, would be more difficult to comprehend.\n    let tmpA = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'a');\n    let tmpB = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'b');\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'x', tmpA / tmpB);\n    return true;\n};\n\nlet aggregate = (pOperation) =>\n{\n    let tmpA = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'a');\n\n    let tmpObjectType = typeof(tmpA);\n\n    let tmpAggregationValue = 0;\n\n    if (tmpObjectType == 'object')\n    {\n        if (Array.isArray(tmpA))\n        {\n            for (let i = 0; i < tmpA.length; i++)\n            {\n                // If this is an array, enumerate it and try to aggregate each number\n                let tmpValue = parseInt(tmpA[i]);\n\n                if (isNaN(tmpValue))\n                {\n                    pOperation.logError(`Array element index [${i}] could not be parsed as a number; skipping.  (${tmpA[i]})`);\n                }\n                else\n                {\n                    tmpAggregationValue += tmpValue;\n                    pOperation.logInfo(`Adding element [${i}] value ${tmpValue} totaling: ${tmpAggregationValue}`)\n                }\n            }\n        }\n        else\n        {\n            let tmpObjectKeys = Object.keys(tmpA);\n            for (let i = 0; i < tmpObjectKeys.length; i++)\n            {\n                let tmpValue = parseInt(tmpA[tmpObjectKeys[i]]);\n\n                if (isNaN(tmpValue))\n                {\n                    pOperation.logError(`Object property [${tmpObjectKeys[i]}] could not be parsed as a number; skipping.  (${tmpA[tmpObjectKeys[i]]})`);\n                }\n                else\n                {\n                    tmpAggregationValue += tmpValue;\n                    pOperation.logInfo(`Adding object property [${tmpObjectKeys[i]}] value ${tmpValue} totaling: ${tmpAggregationValue}`)\n                }\n            }\n        }\n    }\n    else\n    {\n        let tmpValue = parseInt(tmpA);\n\n        if (isNaN(tmpValue))\n        {\n            pOperation.logError(`Direct value could not be parsed as a number; skipping.  (${tmpA})`);\n        }\n        else\n        {\n            tmpAggregationValue += tmpValue;\n        }\n    }\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'x', tmpAggregationValue);\n    return true;\n};\n\nclass MathJavascript extends libElucidatorInstructionSet\n{\n    constructor(pElucidator)\n    {\n        super(pElucidator);\n        this.namespace = 'Math';\n    }\n\n    initializeInstructions()\n    {\n        this.addInstruction('add', add);\n\n        this.addInstruction('subtract', subtract);\n        this.addInstruction('sub', subtract);\n\n        this.addInstruction('multiply', multiply);\n        this.addInstruction('mul', multiply);\n\n        this.addInstruction('divide', divide);\n        this.addInstruction('div', divide);\n\n        this.addInstruction('aggregate', aggregate);\n\n        return true;\n    }\n\n    initializeOperations()\n    {\n        this.addOperation('add', require(`./Operations/Math-Add.json`));\n        this.addOperation('subtract', require(`./Operations/Math-Subtract.json`));\n        this.addOperation('multiply', require(`./Operations/Math-Multiply.json`));\n        this.addOperation('divide', require(`./Operations/Math-Divide.json`));\n\n        this.addOperation('aggregate', require(`./Operations/Math-Aggregate.json`));\n\n        return true;\n    }\n}\n\nmodule.exports = MathJavascript;","module.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"Geometry\",\n\t\t\"Operation\": \"RectangleArea\",\n\t\t\"Synopsis\": \"Solve for the area of a rectangle:  Area = Width * Height\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"Width\": { \"Hash\":\"Width\", \"Type\":\"Number\" },\n\t\t\"Height\": { \"Hash\":\"Height\", \"Type\":\"Number\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"Area\": { \"Hash\":\"Area\", \"Name\": \"Area of the Rectangle\"},\n\t\t\"Ratio\": { \"Hash\":\"Ratio\", \"Name\": \"The Ratio between the Width and the Height\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Solve for [ {{Name:Area}} ] based on [ {{Name:Width}} ] and [ {{Name:Height}} ].\",\n\t\t\"PostOperation\": \"Operation complete; [ {{Name:Area}} ] = {{InputValue:Width}} * {{InputValue:Height}} = {{OutputValue:Area}}\"\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"PreciseMath\",\n\t\t\t\"Instruction\": \"multiply\",\n\t\t\t\"InputHashAddressMap\": \n\t\t\t\t{\n\t\t\t\t\t\"a\": \"Width\",\n\t\t\t\t\t\"b\": \"Height\"\n\t\t\t\t},\n\t\t\t\"OutputHashAddressMap\":\n\t\t\t\t{\n\t\t\t\t\t\"x\": \"Area\"\n\t\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"Namespace\": \"PreciseMath\",\n\t\t\t\"Instruction\": \"divide\",\n\t\t\t\"InputHashAddressMap\": \n\t\t\t\t{\n\t\t\t\t\t\"a\": \"Width\",\n\t\t\t\t\t\"b\": \"Height\"\n\t\t\t\t},\n\t\t\t\"OutputHashAddressMap\":\n\t\t\t\t{\n\t\t\t\t\t\"x\": \"Ratio\"\n\t\t\t\t}\n\t\t}\n\t]\n}","module.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"Logic\",\n\t\t\"Operation\": \"Execute\",\n\t\t\"Synopsis\": \"Execute an operation based on namespace and operation.\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"namespace\": { \"Hash\": \"namespace\", \"Type\": \"string\", \"Default\":\"logic\" },\n\t\t\"operation\": { \"Hash\": \"operation\", \"Type\": \"string\", \"Default\":\"noop\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Execute the {{InputValue:operation}} operation in namespace {{InputValue:namespace}}.\",\n\t\t\"PostOperation\": \"Operation [{{InputValue:namespace}}:{{InputValue:operation}}] execution complete.\"\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"Logic\",\n\t\t\t\"Instruction\": \"execute\"\n\t\t}\n\t]\n}","module.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"Logic\",\n\t\t\"Operation\": \"If\",\n\t\t\"Synopsis\": \"Comparison-based if of leftValue and RightValue based on comparator.  Executes trueNamespace:trueOperation or falseNamespace:falseOperation based on truthiness of result.  Also outputs a true or false to truthinessResult.\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"leftValue\": { \"Hash\":\"leftValue\", \"Type\":\"Any\" },\n\t\t\"rightValue\": { \"Hash\":\"rightValue\", \"Type\":\"Any\", \"Default\": true },\n\t\t\"comparator\": { \"Hash\":\"comparator\", \"Type\":\"String\", \"Default\":\"==\" },\n\n\t\t\"trueNamespace\": {\"Hash\":\"trueNamespace\", \"Type\":\"String\", \"Default\":\"logic\" },\n\t\t\"trueOperation\": {\"Hash\":\"trueOperation\", \"Type\":\"String\", \"Default\":\"noop\" },\n\n\t\t\"falseNamespace\": {\"Hash\":\"falseNamespace\", \"Type\":\"String\", \"Default\":\"logic\" },\n\t\t\"falseOperation\": {\"Hash\":\"falseOperation\", \"Type\":\"String\", \"Default\":\"noop\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"truthinessResult\": { \"Hash\": \"truthinessResult\", \"Type\": \"Boolean\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Compare {{Name:leftValue}} and {{Name:rightValue}} with the {{InputValue:comparator}} operator, storing the truthiness in {{Name:truthinessResult}}.\",\n\t\t\"PostOperation\": \"Operation complete: {{InputValue:leftValue}} {{InputValue:comparator}} {{InputValue:rightValue}} evaluated to {{OutputValue:truthinessResult}}\"\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"Logic\",\n\t\t\t\"Instruction\": \"If\"\n\t\t}\n\t]\n}","module.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"Math\",\n\t\t\"Operation\": \"Add\",\n\t\t\"Synopsis\": \"Add two numbers:  x = a + b\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"a\": { \"Hash\": \"a\", \"Type\": \"Number\" },\n\t\t\"b\": { \"Hash\": \"b\", \"Type\": \"Number\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"x\": { \"Hash\": \"x\", \"Type\": \"Number\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Add {{Name:a}} and {{Name:b}}, storing the value in {{Name:x}}.\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:x}} = {{InputValue:a}} + {{InputValue:b}} = {{OutputValue:x}}\"\t\t\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"Math\",\n\t\t\t\"Instruction\": \"add\"\n\t\t}\n\t]\n}","module.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"Math\",\n\t\t\"Operation\": \"Aggregate\",\n\t\t\"Synopsis\": \"Aggregate a set of numbers (from array or object address):  x = a + b + ... + z\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"a\": { \"Hash\": \"a\", \"Type\": \"Set\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"x\": { \"Hash\": \"x\", \"Type\": \"Number\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Aggregate all numeric values in {{Name:a}}, storing the resultant in {{Name:x}}.\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:x}} = {{OutputValue:x}}\"\t\t\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"Math\",\n\t\t\t\"Instruction\": \"aggregate\"\n\t\t}\n\t]\n}","module.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"Math\",\n\t\t\"Operation\": \"Divide\",\n\t\t\"Synopsis\": \"Divide two numbers:  x = a / b\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"a\": { \"Hash\": \"a\", \"Type\": \"Number\" },\n\t\t\"b\": { \"Hash\": \"b\", \"Type\": \"Number\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"x\": { \"Hash\": \"x\", \"Type\": \"Number\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Divide {{Name:a}} over {{Name:b}}, storing the value in {{Name:x}}.\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:x}} = {{InputValue:a}} / {{InputValue:b}} = {{OutputValue:x}}\"\t\t\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"Math\",\n\t\t\t\"Instruction\": \"divide\"\n\t\t}\n\t]\n}","module.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"Math\",\n\t\t\"Operation\": \"Multiply\",\n\t\t\"Synopsis\": \"Multiply two numbers:  x = a * b\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"a\": { \"Hash\": \"a\", \"Type\": \"Number\" },\n\t\t\"b\": { \"Hash\": \"b\", \"Type\": \"Number\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"x\": { \"Hash\": \"x\", \"Type\": \"Number\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Multiply {{Name:a}} and {{Name:b}}, storing the value in {{Name:x}}.\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:x}} = {{InputValue:a}} * {{InputValue:b}} = {{OutputValue:x}}\"\t\t\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"Math\",\n\t\t\t\"Instruction\": \"multiply\"\n\t\t}\n\t]\n}","module.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"Math\",\n\t\t\"Operation\": \"Subtract\",\n\t\t\"Synopsis\": \"Subtract two numbers:  x = a - b\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"a\": { \"Hash\": \"a\", \"Type\": \"Number\" },\n\t\t\"b\": { \"Hash\": \"b\", \"Type\": \"Number\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"x\": { \"Hash\": \"x\", \"Type\": \"Number\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Subtract {{Name:a}} and {{Name:b}}, storing the value in {{Name:x}}.\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:x}} = {{InputValue:a}} - {{InputValue:b}} = {{OutputValue:x}}\"\t\t\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"Math\",\n\t\t\t\"Instruction\": \"subtract\"\n\t\t}\n\t]\n}","module.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"PreciseMath\",\n\t\t\"Operation\": \"Add\",\n\t\t\"Synopsis\": \"Precisely add two numbers:  x = a + b\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"a\": { \"Hash\": \"a\", \"Type\": \"Number\" },\n\t\t\"b\": { \"Hash\": \"b\", \"Type\": \"Number\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"x\": { \"Hash\": \"x\", \"Type\": \"Number\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Add {{Name:a}} and {{Name:b}}, storing the value in {{Name:x}}.\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:x}} = {{InputValue:a}} + {{InputValue:b}} = {{OutputValue:x}}\"\t\t\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"PreciseMath\",\n\t\t\t\"Instruction\": \"add\"\n\t\t}\n\t]\n}","module.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"PreciseMath\",\n\t\t\"Operation\": \"Aggregate\",\n\t\t\"Synopsis\": \"Precisely aggregate a set of numbers (from array or object address):  x = a + b + ... + z\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"a\": { \"Hash\": \"a\", \"Type\": \"Set\" },\n\t\t\"ValueNames\": { \"Hash\": \"ValueNames\", \"Type\": \"Set\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"x\": { \"Hash\": \"x\", \"Type\": \"Number\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Aggregate all numeric values in {{Name:a}}, storing the resultant in {{Name:x}}.\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:x}} = {{OutputValue:x}}\"\t\t\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"PreciseMath\",\n\t\t\t\"Instruction\": \"aggregate\"\n\t\t}\n\t]\n}","module.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"PreciseMath\",\n\t\t\"Operation\": \"Divide\",\n\t\t\"Synopsis\": \"Precisely divide two numbers:  x = a / b\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"a\": { \"Hash\": \"a\", \"Type\": \"Number\" },\n\t\t\"b\": { \"Hash\": \"b\", \"Type\": \"Number\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"x\": { \"Hash\": \"x\", \"Type\": \"Number\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Divide {{Name:a}} over {{Name:b}}, storing the value in {{Name:x}}.\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:x}} = {{InputValue:a}} / {{InputValue:b}} = {{OutputValue:x}}\"\t\t\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"PreciseMath\",\n\t\t\t\"Instruction\": \"divide\"\n\t\t}\n\t]\n}","module.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"PreciseMath\",\n\t\t\"Operation\": \"GroupValuesAndAggregate\",\n\t\t\"Synopsis\": \"Group values in a set and aggregate the set of numbers (from array or object addresses)\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"inputDataSet\": { \"Hash\":\"inputDataSet\", \"Type\":\"Set\" },\n\t\t\"groupByProperty\": { \"Hash\":\"groupByProperty\", \"Type\":\"Any\"},\n\t\t\"groupValueProperty\": { \"Hash\":\"groupValueProperty\", \"Type\":\"Any\"},\n\t\t\"recordIndicatorProperty\": { \"Hash\":\"recordIndicatorProperty\", \"Type\":\"String\", \"Default\":false}\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"outputDataSet\": { \"Hash\": \"outputDataSet\", \"Type\": \"Set\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Group {{Name:inputDataSet}} by {{Name:groupByProperty}} and create a map, storing the resultant in {{Name:outputDataSet}}.\",\n\t\t\"PostOperation\": \"Operation complete: Grouping {{Name:inputDataSet}} by {{Name:groupByProperty}} into aggregated values in {{Name:outputDataSet}}\"\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"PreciseMath\",\n\t\t\t\"Instruction\": \"groupvaluesandaggregate\"\n\t\t}\n\t]\n}","module.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"PreciseMath\",\n\t\t\"Operation\": \"Multiply\",\n\t\t\"Synopsis\": \"Precisely multiply two numbers:  x = a * b\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"a\": { \"Hash\": \"a\", \"Type\": \"Number\" },\n\t\t\"b\": { \"Hash\": \"b\", \"Type\": \"Number\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"x\": { \"Hash\": \"x\", \"Type\": \"Number\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Multiply {{Name:a}} and {{Name:b}}, storing the value in {{Name:x}}.\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:x}} = {{InputValue:a}} * {{InputValue:b}} = {{OutputValue:x}}\"\t\t\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"PreciseMath\",\n\t\t\t\"Instruction\": \"multiply\"\n\t\t}\n\t]\n}","module.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"PreciseMath\",\n\t\t\"Operation\": \"Round\",\n\t\t\"Synopsis\": \"Precisely round a number.\"\n\t},\n\n\t\"Inputs\":\n\t{\n\t\t\"a\": { \"Hash\": \"a\", \"Type\": \"Number\" },\n\t\t\"precision\": { \"Hash\": \"precision\", \"Type\": \"Number\" },\n\t\t\"roundingmode\": { \"Hash\": \"roundingmode\", \"Type\":\"String\" }\n\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"x\": { \"Hash\": \"x\", \"Type\": \"Number\" }\n\t},\n\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Round {{Name:a}}, storing the value in {{Name:x}}.\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:x}} = Round({{InputValue:a}}) = {{OutputValue:x}}\"\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"PreciseMath\",\n\t\t\t\"Instruction\": \"round\"\n\t\t}\n\t]\n}","module.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"PreciseMath\",\n\t\t\"Operation\": \"SetPrecision\",\n\t\t\"Synopsis\": \"Set the precision.\"\n\t},\n\n\t\"Inputs\":\n\t{\n\t\t\"precision\": { \"Hash\": \"precision\", \"Type\":\"Number\", \"Default\":2}\n\n\t},\n\n\t\"Outputs\":\n\t{\n\t},\n\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Set precision to {{InputValue:precision}}.\",\n\t\t\"PostOperation\": \"Operation complete: Default precision set to {{InputValue:precision}}.\"\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"PreciseMath\",\n\t\t\t\"Instruction\": \"setprecision\"\n\t\t}\n\t]\n}","module.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"PreciseMath\",\n\t\t\"Operation\": \"SetRoundingMode\",\n\t\t\"Synopsis\": \"Set the rounding mode.\"\n\t},\n\n\t\"Inputs\":\n\t{\n\t\t\"roundingmode\": { \"Hash\": \"roundingmode\", \"Type\":\"String\", \"Default\":\"ROUND_HALF_UP\"}\n\n\t},\n\n\t\"Outputs\":\n\t{\n\t},\n\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Set rounding mode to {{InputValue:roundingmode}}.\",\n\t\t\"PostOperation\": \"Operation complete: Default rounding mode set to {{InputValue:roundingmode}}.\"\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"PreciseMath\",\n\t\t\t\"Instruction\": \"setroundingmode\"\n\t\t}\n\t]\n}","module.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"PreciseMath\",\n\t\t\"Operation\": \"Subtract\",\n\t\t\"Synopsis\": \"Precisely subtract two numbers:  x = a - b\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"a\": { \"Hash\": \"a\", \"Type\": \"Number\" },\n\t\t\"b\": { \"Hash\": \"b\", \"Type\": \"Number\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"x\": { \"Hash\": \"x\", \"Type\": \"Number\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Subtract {{Name:a}} and {{Name:b}}, storing the value in {{Name:x}}.\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:x}} = {{InputValue:a}} - {{InputValue:b}} = {{OutputValue:x}}\"\t\t\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"PreciseMath\",\n\t\t\t\"Instruction\": \"subtract\"\n\t\t}\n\t]\n}","module.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"PreciseMath\",\n\t\t\"Operation\": \"ToDecimalPlaces\",\n\t\t\"Synopsis\": \"Precisely round a number to a certain number of decimal places.\"\n\t},\n\n\t\"Inputs\":\n\t{\n\t\t\"a\": { \"Hash\": \"a\", \"Type\": \"Number\" },\n\t\t\"decimalplaces\": { \"Hash\": \"decimalplaces\", \"Type\": \"Number\", \"Default\":2 },\n\t\t\"roundingmode\": { \"Hash\": \"roundingmode\", \"Type\":\"String\" }\n\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"x\": { \"Hash\": \"x\", \"Type\": \"Number\" }\n\t},\n\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Round {{Name:a}} to {{Value:decimalplaces}} decimal places, storing the value in {{Name:x}}.\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:x}} = Round({{InputValue:a}} TO {{Value:decimalplaces}} decimal places) = {{OutputValue:x}}\"\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"PreciseMath\",\n\t\t\t\"Instruction\": \"todecimalplaces\"\n\t\t}\n\t]\n}","module.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"PreciseMath\",\n\t\t\"Operation\": \"ToSignificantDigits\",\n\t\t\"Synopsis\": \"Precisely round a number to a specific number of significant digits.\"\n\t},\n\n\t\"Inputs\":\n\t{\n\t\t\"a\": { \"Hash\": \"a\", \"Type\": \"Number\" },\n\t\t\"digits\": { \"Hash\": \"digits\", \"Type\": \"Number\", \"Default\":12 },\n\t\t\"roundingmode\": { \"Hash\": \"roundingmode\", \"Type\":\"String\" }\n\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"x\": { \"Hash\": \"x\", \"Type\": \"Number\" }\n\t},\n\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Round {{Name:a}} to {{InputValue:digits}}, storing the value in {{Name:x}}.\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:x}} = Round({{InputValue:a}} TO {{InputValue:digits}}) = {{OutputValue:x}}\"\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"PreciseMath\",\n\t\t\t\"Instruction\": \"tosignificantdigits\"\n\t\t}\n\t]\n}","module.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"Set\",\n\t\t\"Operation\": \"GroupValuesBy\",\n\t\t\"Synopsis\": \"Group set of Sub object values by another property in the objects.\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"inputDataSet\": { \"Hash\":\"inputDataSet\", \"Type\":\"Set\" },\n\t\t\"groupByProperty\": { \"Hash\":\"groupByProperty\", \"Type\":\"Any\"},\n\t\t\"groupValueProperty\": { \"Hash\":\"groupValueProperty\", \"Type\":\"Any\"}\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"outputDataSet\": { \"Hash\": \"outputDataSet\", \"Type\": \"Set\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Group {{Name:inputDataSet}} by {{Name:groupByProperty}} and create a mapped result set into {{Name:outputDataSet}}.\",\n\t\t\"PostOperation\": \"Operation complete: Grouping {{Name:inputDataSet}} by {{Name:groupByProperty}} into {{Name:outputDataSet}}\"\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"Set\",\n\t\t\t\"Instruction\": \"GroupValuesBy\"\n\t\t}\n\t]\n}","module.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"String\",\n\t\t\"Operation\": \"Replace\",\n\t\t\"Synopsis\": \"Replace all instances of searchFor with replaceWith in inputString\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"inputString\": { \"Hash\": \"inputString\", \"Type\": \"String\" },\n\t\t\"searchFor\": { \"Hash\": \"searchFor\", \"Type\": \"String\" },\n\t\t\"replaceWith\": { \"Hash\": \"replaceWith\", \"Type\": \"String\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"outputString\": { \"Hash\": \"outputString\", \"Type\": \"String\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Search for [{{InputValue:searchFor}}] and replace it with [{{InputValue:replaceWith}}] in [{{InputValue:inputString}}].\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:outputString}} = [{{OutputValue:outputString}}] from [{{InputValue:inputString}}] replacing [{{InputValue:searchFor}}] with [{{InputValue:replaceWith}}].\"\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"String\",\n\t\t\t\"Instruction\": \"replace\"\n\t\t}\n\t]\n}","module.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"String\",\n\t\t\"Operation\": \"Substring\",\n\t\t\"Synopsis\": \"Get all characters between indexStart and indexEnd (optional) for a given inputString.\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"inputString\": { \"Hash\": \"inputString\", \"Type\": \"String\" },\n\t\t\"indexStart\": { \"Hash\": \"indexStart\", \"Type\": \"Number\", \"Default\":0 },\n\t\t\"indexEnd\": { \"Hash\": \"indexEnd\", \"Type\": \"String\", \"Default\":null }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"outputString\": { \"Hash\": \"outputString\", \"Type\": \"String\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Get all characters between {{InputValue:indexStart}} and {{InputValue:indexEnd}} in [{{InputValue:inputString}}].\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:outputString}} = [{{OutputValue:outputString}}] from [{{InputValue:inputString}}] between {{InputValue:indexStart}} and {{InputValue:indexEnd}}.\"\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"String\",\n\t\t\t\"Instruction\": \"substring\"\n\t\t}\n\t]\n}","module.exports={\n\t\"Description\":\n\t{\n\t\t\"Namespace\": \"String\",\n\t\t\"Operation\": \"Trim\",\n\t\t\"Synopsis\": \"Trim whitespace off the end of string in inputString, putting the result in outputString\"\n\t},\n\n\t\"Inputs\": \n\t{\n\t\t\"inputString\": { \"Hash\": \"inputString\", \"Type\": \"String\" }\n\t},\n\n\t\"Outputs\":\n\t{\n\t\t\"outputString\": { \"Hash\": \"outputString\", \"Type\": \"String\" }\n\t},\n\t\n\t\"Log\":\n\t{\n\t\t\"PreOperation\": \"Trim the whitespace from value [{{InputValue:inputString}}].\",\n\t\t\"PostOperation\": \"Operation complete: {{Name:outputString}} = [{{OutputValue:outputString}}] from [{{InputValue:inputString}}]\"\n\t},\n\n\t\"Steps\":\n\t[\n\t\t{\n\t\t\t\"Namespace\": \"String\",\n\t\t\t\"Instruction\": \"trim\"\n\t\t}\n\t]\n}","let libElucidatorInstructionSet = require('../Elucidator-InstructionSet.js');\n\nconst libDecimal = require('decimal.js');\n\nlet add = (pOperation) =>\n{\n\t// This could be done in one line, but, would be more difficult to comprehend.\n\tlet tmpA = new libDecimal(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'a'));\n\tlet tmpB = new libDecimal(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'b'));\n\tpOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'x', tmpA.plus(tmpB).toString());\n\treturn true;\n};\n\nlet subtract = (pOperation) =>\n{\n\t// This could be done in one line, but, would be more difficult to comprehend.\n\tlet tmpA = new libDecimal(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'a'));\n\tlet tmpB = new libDecimal(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'b'));\n\tpOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'x', tmpA.sub(tmpB).toString());\n\treturn true;\n};\n\nlet multiply = (pOperation) =>\n{\n\t// This could be done in one line, but, would be more difficult to comprehend.\n\tlet tmpA = new libDecimal(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'a'));\n\tlet tmpB = new libDecimal(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'b'));\n\tpOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'x', tmpA.mul(tmpB).toString());\n\treturn true;\n};\n\nlet divide = (pOperation) =>\n{\n\t// This could be done in one line, but, would be more difficult to comprehend.\n\tlet tmpA = new libDecimal(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'a'));\n\tlet tmpB = new libDecimal(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'b'));\n\tpOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'x', tmpA.div(tmpB).toString());\n\treturn true;\n};\n\nlet round = (pOperation) =>\n{\n\tlet tmpA = new libDecimal(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'a'));\n\n\tlet tmpPrecision = parseInt(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'precision'));\n\tlet tmpRoundingMode = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'roundingmode')\n\n\t// Eventually don't set this every time...\n\tif (tmpRoundingMode)\n\t{\n\t\tswitch (tmpRoundingMode.toString().toLowerCase())\n\t\t{\n\t\t\tcase 'round_up':\n\t\t\t\tlibDecimal.set({ rounding: libDecimal.ROUND_UP });\n\t\t\t\tbreak;\n\t\t\tcase 'round_down':\n\t\t\t\tlibDecimal.set({ rounding: libDecimal.ROUND_DOWN });\n\t\t\t\tbreak;\n\t\t\tcase 'round_ceil':\n\t\t\t\tlibDecimal.set({ rounding: libDecimal.ROUND_CEIL });\n\t\t\t\tbreak;\n\t\t\tcase 'round_floor':\n\t\t\t\tlibDecimal.set({ rounding: libDecimal.ROUND_FLOOR });\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\tcase 'round_half_up':\n\t\t\t\tlibDecimal.set({ rounding: libDecimal.ROUND_HALF_UP });\n\t\t\t\tbreak;\n\t\t\tcase 'round_half_down':\n\t\t\t\tlibDecimal.set({ rounding: libDecimal.ROUND_HALF_DOWN });\n\t\t\t\tbreak;\n\t\t\tcase 'round_half_even':\n\t\t\t\tlibDecimal.set({ rounding: libDecimal.ROUND_HALF_EVEN });\n\t\t\t\tbreak;\n\t\t\tcase 'round_half_ceil':\n\t\t\t\tlibDecimal.set({ rounding: libDecimal.ROUND_HALF_CEIL });\n\t\t\t\tbreak;\n\t\t\tcase 'round_half_floor':\n\t\t\t\tlibDecimal.set({ rounding: libDecimal.ROUND_HALF_FLOOR });\n\t\t\t\tbreak;\n\t\t\tcase 'euclid':\n\t\t\t\tlibDecimal.set({ rounding: libDecimal.EUCLID });\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!isNaN(tmpPrecision))\n\t{\n\t\tlibDecimal.set({ precision: tmpPrecision });\n\t}\n\n\tpOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'x', libDecimal.round(tmpA).toString());\n};\n\n\nlet tosignificantdigits = (pOperation) =>\n{\n\tlet tmpA = new libDecimal(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'a'));\n\n\tlet tmpDigits = parseInt(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'digits'));\n\tlet tmpRoundingMode = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'roundingmode')\n\n\t// Eventually don't set this every time...\n\tif (tmpRoundingMode)\n\t{\n\t\tswitch (tmpRoundingMode.toString().toLowerCase())\n\t\t{\n\t\t\tcase 'round_up':\n\t\t\t\tlibDecimal.set({ rounding: libDecimal.ROUND_UP });\n\t\t\t\tbreak;\n\t\t\tcase 'round_down':\n\t\t\t\tlibDecimal.set({ rounding: libDecimal.ROUND_DOWN });\n\t\t\t\tbreak;\n\t\t\tcase 'round_ceil':\n\t\t\t\tlibDecimal.set({ rounding: libDecimal.ROUND_CEIL });\n\t\t\t\tbreak;\n\t\t\tcase 'round_floor':\n\t\t\t\tlibDecimal.set({ rounding: libDecimal.ROUND_FLOOR });\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\tcase 'round_half_up':\n\t\t\t\tlibDecimal.set({ rounding: libDecimal.ROUND_HALF_UP });\n\t\t\t\tbreak;\n\t\t\tcase 'round_half_down':\n\t\t\t\tlibDecimal.set({ rounding: libDecimal.ROUND_HALF_DOWN });\n\t\t\t\tbreak;\n\t\t\tcase 'round_half_even':\n\t\t\t\tlibDecimal.set({ rounding: libDecimal.ROUND_HALF_EVEN });\n\t\t\t\tbreak;\n\t\t\tcase 'round_half_ceil':\n\t\t\t\tlibDecimal.set({ rounding: libDecimal.ROUND_HALF_CEIL });\n\t\t\t\tbreak;\n\t\t\tcase 'round_half_floor':\n\t\t\t\tlibDecimal.set({ rounding: libDecimal.ROUND_HALF_FLOOR });\n\t\t\t\tbreak;\n\t\t\tcase 'euclid':\n\t\t\t\tlibDecimal.set({ rounding: libDecimal.EUCLID });\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (isNaN(tmpDigits))\n\t{\n\t\ttmpDigits = 12;\n\t}\n\n\tpOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'x', tmpA.toSignificantDigits(tmpDigits).toString());\n};\n\nlet todecimalplaces = (pOperation) =>\n{\n\tlet tmpA = new libDecimal(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'a'));\n\n\tlet tmpDecimalPlaces = parseInt(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'decimalplaces'));\n\tlet tmpRoundingMode = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'roundingmode')\n\n\t// Eventually don't set this every time...\n\tif (tmpRoundingMode)\n\t{\n\t\tswitch (tmpRoundingMode.toString().toLowerCase())\n\t\t{\n\t\t\tcase 'round_up':\n\t\t\t\tlibDecimal.set({ rounding: libDecimal.ROUND_UP });\n\t\t\t\tbreak;\n\t\t\tcase 'round_down':\n\t\t\t\tlibDecimal.set({ rounding: libDecimal.ROUND_DOWN });\n\t\t\t\tbreak;\n\t\t\tcase 'round_ceil':\n\t\t\t\tlibDecimal.set({ rounding: libDecimal.ROUND_CEIL });\n\t\t\t\tbreak;\n\t\t\tcase 'round_floor':\n\t\t\t\tlibDecimal.set({ rounding: libDecimal.ROUND_FLOOR });\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\tcase 'round_half_up':\n\t\t\t\tlibDecimal.set({ rounding: libDecimal.ROUND_HALF_UP });\n\t\t\t\tbreak;\n\t\t\tcase 'round_half_down':\n\t\t\t\tlibDecimal.set({ rounding: libDecimal.ROUND_HALF_DOWN });\n\t\t\t\tbreak;\n\t\t\tcase 'round_half_even':\n\t\t\t\tlibDecimal.set({ rounding: libDecimal.ROUND_HALF_EVEN });\n\t\t\t\tbreak;\n\t\t\tcase 'round_half_ceil':\n\t\t\t\tlibDecimal.set({ rounding: libDecimal.ROUND_HALF_CEIL });\n\t\t\t\tbreak;\n\t\t\tcase 'round_half_floor':\n\t\t\t\tlibDecimal.set({ rounding: libDecimal.ROUND_HALF_FLOOR });\n\t\t\t\tbreak;\n\t\t\tcase 'euclid':\n\t\t\t\tlibDecimal.set({ rounding: libDecimal.EUCLID });\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (isNaN(tmpDecimalPlaces))\n\t{\n\t\ttmpDecimalPlaces = 2;\n\t}\n\n\tpOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'x', tmpA.toDecimalPlaces(tmpDecimalPlaces).toString());\n};\n\nlet setprecision = (pOperation) =>\n{\n\tlet tmpPrecision = parseInt(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'precision'));\n\n\tconsole.log(tmpPrecision)\n\tif (!isNaN(tmpPrecision))\n\t{\n\t\tlibDecimal.set({ precision: tmpPrecision });\n\t}\n};\n\nlet setroundingmode = (pOperation) =>\n{\n\tlet tmpRoundingMode = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'roundingmode')\n\n\t// Eventually don't set this every time...\n\tif (tmpRoundingMode)\n\t{\n\t\tswitch (tmpRoundingMode.toString().toLowerCase())\n\t\t{\n\t\t\tcase 'round_up':\n\t\t\t\tlibDecimal.set({ rounding: libDecimal.ROUND_UP });\n\t\t\t\tbreak;\n\t\t\tcase 'round_down':\n\t\t\t\tlibDecimal.set({ rounding: libDecimal.ROUND_DOWN });\n\t\t\t\tbreak;\n\t\t\tcase 'round_ceil':\n\t\t\t\tlibDecimal.set({ rounding: libDecimal.ROUND_CEIL });\n\t\t\t\tbreak;\n\t\t\tcase 'round_floor':\n\t\t\t\tlibDecimal.set({ rounding: libDecimal.ROUND_FLOOR });\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\tcase 'round_half_up':\n\t\t\t\tlibDecimal.set({ rounding: libDecimal.ROUND_HALF_UP });\n\t\t\t\tbreak;\n\t\t\tcase 'round_half_down':\n\t\t\t\tlibDecimal.set({ rounding: libDecimal.ROUND_HALF_DOWN });\n\t\t\t\tbreak;\n\t\t\tcase 'round_half_even':\n\t\t\t\tlibDecimal.set({ rounding: libDecimal.ROUND_HALF_EVEN });\n\t\t\t\tbreak;\n\t\t\tcase 'round_half_ceil':\n\t\t\t\tlibDecimal.set({ rounding: libDecimal.ROUND_HALF_CEIL });\n\t\t\t\tbreak;\n\t\t\tcase 'round_half_floor':\n\t\t\t\tlibDecimal.set({ rounding: libDecimal.ROUND_HALF_FLOOR });\n\t\t\t\tbreak;\n\t\t\tcase 'euclid':\n\t\t\t\tlibDecimal.set({ rounding: libDecimal.EUCLID });\n\t\t\t\tbreak;\n\t\t}\n\t}\n};\n\nlet aggregate = (pOperation) =>\n{\n\tlet tmpA = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'a');\n\n\tlet tmpObjectType = typeof (tmpA);\n\n\tlet tmpAggregationValue = new libDecimal(0);\n\n\tif (tmpObjectType == 'object')\n\t{\n\t\tif (Array.isArray(tmpA))\n\t\t{\n\t\t\tfor (let i = 0; i < tmpA.length; i++)\n\t\t\t{\n\t\t\t\t// If this is an array, enumerate it and try to aggregate each number\n\t\t\t\tlet tmpValue = new libDecimal(tmpA[i]);\n\n\t\t\t\tif (isNaN(tmpValue))\n\t\t\t\t{\n\t\t\t\t\tpOperation.logError(`Array element index [${i}] could not be parsed as a number by Decimal.js; skipping.  (${tmpA[i]})`);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttmpAggregationValue = tmpAggregationValue.plus(tmpValue);\n\t\t\t\t\tpOperation.logInfo(`Adding element [${i}] value ${tmpValue} totaling: ${tmpAggregationValue}`)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlet tmpObjectKeys = Object.keys(tmpA);\n\t\t\tfor (let i = 0; i < tmpObjectKeys.length; i++)\n\t\t\t{\n\t\t\t\tlet tmpValue = new libDecimal(tmpA[tmpObjectKeys[i]]);\n\n\t\t\t\tif (isNaN(tmpValue))\n\t\t\t\t{\n\t\t\t\t\tpOperation.logError(`Object property [${tmpObjectKeys[i]}] could not be parsed as a number; skipping.  (${tmpA[tmpObjectKeys[i]]})`);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttmpAggregationValue = tmpAggregationValue.plus(tmpValue);\n\t\t\t\t\tpOperation.logInfo(`Adding object property [${tmpObjectKeys[i]}] value ${tmpValue} totaling: ${tmpAggregationValue}`)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tlet tmpValue = new libDecimal(tmpA);\n\n\t\tif (isNaN(tmpValue))\n\t\t{\n\t\t\tpOperation.logError(`Direct value could not be parsed as a number; skipping.  (${tmpA})`);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttmpAggregationValue = tmpValue;\n\t\t}\n\t}\n\tpOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'x', tmpAggregationValue.toString());\n\treturn true;\n};\n\nconst groupValuesAndAggregate = (pOperation) =>\n{\n\tlet tmpInputDataSet = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'inputDataSet');\n\tlet tmpGroupByProperty = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'groupByProperty');\n\tlet tmpGroupValueProperty = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'groupValueProperty');\n\n\tlet tmpOutputDataSet = {};\n\tlet tmpProcessedOutputDataSet = {};\n\n\tlet tmpObjectType = typeof (tmpInputDataSet);\n\n\tif (tmpObjectType == 'object')\n\t{\n\t\tif (Array.isArray(tmpInputDataSet))\n\t\t{\n\t\t\tfor (let i = 0; i < tmpInputDataSet.length; i++)\n\t\t\t{\n\t\t\t\tif (typeof (tmpInputDataSet[i]) !== 'object')\n\t\t\t\t{\n\t\t\t\t\tpOperation.logInfo(`Element [${i}] was not an object; skipping group operation.`);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tlet tmpValue = tmpInputDataSet[i];\n\t\t\t\t\tlet tmpGroupByValue = tmpValue[tmpGroupByProperty];\n\t\t\t\t\tif (!tmpValue.hasOwnProperty(tmpGroupByProperty))\n\t\t\t\t\t{\n\t\t\t\t\t\tpOperation.logInfo(`Element [${i}] doesn't have the group by property [${tmpGroupByProperty}]; setting group to [__NO_GROUP].`);\n\t\t\t\t\t\ttmpGroupByValue = '__NO_GROUP';\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!tmpValue.hasOwnProperty(tmpGroupValueProperty))\n\t\t\t\t\t{\n\t\t\t\t\t\tpOperation.logInfo(`Element [${i}] doesn't have the group value property [${tmpGroupValueProperty}]; skipping group operation.`);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tlet tmpDecimalValue = new libDecimal(tmpValue[tmpGroupValueProperty]);\n\n\t\t\t\t\t\tif (isNaN(tmpDecimalValue))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpOperation.logError(`Object property [${i}] could not be parsed as a number; skipping.  (${tmpValue[tmpGroupValueProperty]})`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (!tmpOutputDataSet.hasOwnProperty(tmpGroupByValue))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttmpOutputDataSet[tmpGroupByValue] = tmpDecimalValue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttmpOutputDataSet[tmpGroupByValue] = tmpOutputDataSet[tmpGroupByValue].plus(tmpDecimalValue);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpOperation.logInfo(`Adding object property [${i}] value ${tmpDecimalValue} totaling: ${tmpOutputDataSet[tmpGroupByValue]}`)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlet tmpObjectKeys = Object.keys(tmpInputDataSet);\n\t\t\tfor (let i = 0; i < tmpObjectKeys.length; i++)\n\t\t\t{\n\t\t\t\tif (typeof (tmpInputDataSet[tmpObjectKeys[i]]) !== 'object')\n\t\t\t\t{\n\t\t\t\t\tpOperation.logInfo(`Element [${i}] was not an object; skipping group operation.`);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tlet tmpValue = tmpInputDataSet[tmpObjectKeys[i]];\n\t\t\t\t\tlet tmpGroupByValue = tmpValue[tmpGroupByProperty];\n\t\t\t\t\tif (!tmpValue.hasOwnProperty(tmpGroupByProperty))\n\t\t\t\t\t{\n\t\t\t\t\t\tpOperation.logInfo(`Element [${tmpObjectKeys[i]}][${i}] doesn't have the group by property [${tmpGroupByProperty}]; setting group to [__NO_GROUP].`);\n\t\t\t\t\t\ttmpGroupByValue = '__NO_GROUP';\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!tmpValue.hasOwnProperty(tmpGroupValueProperty))\n\t\t\t\t\t{\n\t\t\t\t\t\tpOperation.logInfo(`Element [${tmpObjectKeys[i]}][${i}] doesn't have the group value property [${tmpGroupValueProperty}]; skipping group operation.`);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tlet tmpDecimalValue = new libDecimal(tmpValue[tmpGroupValueProperty]);\n\n\t\t\t\t\t\tif (isNaN(tmpDecimalValue))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpOperation.logError(`Object property [${tmpObjectKeys[i]}][${i}] to group ${tmpGroupByValue} could not be parsed as a number; skipping.  (${tmpValue[tmpGroupValueProperty]})`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (!tmpOutputDataSet.hasOwnProperty(tmpGroupByValue))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttmpOutputDataSet[tmpGroupByValue] = tmpDecimalValue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttmpOutputDataSet[tmpGroupByValue] = tmpOutputDataSet[tmpGroupByValue].plus(tmpDecimalValue);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpOperation.logInfo(`Adding object property [${tmpObjectKeys[i]}][${i}] to group ${tmpGroupByValue} value ${tmpDecimalValue} totaling: ${tmpOutputDataSet[tmpGroupByValue]}`)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Now marshal the aggregated values\n\t\tlet tmpOutputGroups = Object.keys(tmpOutputDataSet);\n\t\tfor (let j = 0; j < tmpOutputGroups.length; j++)\n\t\t{\n\t\t\ttmpProcessedOutputDataSet[tmpOutputGroups[j]] = tmpOutputDataSet[tmpOutputGroups[j]].toString();\n\t\t}\n\t}\n\telse\n\t{\n\t\tpOperation.logError(`Input set is neither an Array nor an Object`);\n\t}\n\n\tpOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'outputDataSet', tmpProcessedOutputDataSet);\n\n\treturn true;\n}\n\nlet toFraction = (pOperation) =>\n{\n\t// This could be done in one line, but, would be more difficult to comprehend.\n\tlet tmpA = new libDecimal(pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'a'));\n\tpOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'x', tmpA.toFraction().toString());\n\treturn true;\n};\n\n\nclass PreciseMath extends libElucidatorInstructionSet\n{\n\tconstructor(pElucidator)\n\t{\n\t\tsuper(pElucidator);\n\t\tthis.namespace = 'PreciseMath';\n\t}\n\n\tinitializeInstructions()\n\t{\n\t\tthis.addInstruction('add', add);\n\n\t\tthis.addInstruction('subtract', subtract);\n\t\tthis.addInstruction('sub', subtract);\n\n\t\tthis.addInstruction('multiply', multiply);\n\t\tthis.addInstruction('mul', multiply);\n\n\t\tthis.addInstruction('divide', divide);\n\t\tthis.addInstruction('div', divide);\n\n\t\tthis.addInstruction('aggregate', aggregate);\n\t\tthis.addInstruction('groupvaluesandaggregate', groupValuesAndAggregate);\n\n\t\tthis.addInstruction('setprecision', setprecision);\n\t\tthis.addInstruction('setroundingmode', setroundingmode);\n\n\t\tthis.addInstruction('todecimalplaces', todecimalplaces);\n\t\tthis.addInstruction('tosignificantdigits', tosignificantdigits);\n\t\tthis.addInstruction('round', round);\n\t\tthis.addInstruction('tofraction', toFraction);\n\n\n\t\treturn true;\n\t}\n\n\tinitializeOperations()\n\t{\n\t\tthis.addOperation('add', require(`./Operations/PreciseMath-Add.json`));\n\t\tthis.addOperation('subtract', require(`./Operations/PreciseMath-Subtract.json`));\n\t\tthis.addOperation('multiply', require(`./Operations/PreciseMath-Multiply.json`));\n\t\tthis.addOperation('divide', require(`./Operations/PreciseMath-Divide.json`));\n\n\t\tthis.addOperation('aggregate', require('./Operations/PreciseMath-Aggregate.json'));\n\t\tthis.addOperation('groupvaluesandaggregate', require('./Operations/PreciseMath-GroupValuesAndAggregate.json'));\n\n\t\tthis.addOperation('setprecision', require('./Operations/PreciseMath-SetPrecision.json'));\n\t\tthis.addOperation('setroundingmode', require('./Operations/PreciseMath-SetRoundingMode.json'));\n\n\t\tthis.addOperation('tosignificantdigits', require('./Operations/PreciseMath-ToSignificantDigits.json'));\n\t\tthis.addOperation('todecimalplaces', require('./Operations/PreciseMath-ToDecimalPlaces.json'));\n\t\tthis.addOperation('round', require('./Operations/PreciseMath-Round.json'));\n\n\t\treturn true;\n\t}\n}\n\nmodule.exports = PreciseMath;","// Solution providers are meant to be stateless, and not classes.\n// These solution providers are akin to drivers, connecting code libraries or \n// other types of behavior to mapping operations.\n\nlet libElucidatorInstructionSet = require('../Elucidator-InstructionSet.js');\n\nconst groupValuesBy = (pOperation) =>\n{\n    let tmpInputDataSet = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'inputDataSet');\n    let tmpGroupByProperty = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'groupByProperty');\n    let tmpGroupValueProperty = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'groupValueProperty');\n\n    let tmpOutputDataSet = {};\n \n    let tmpObjectType = typeof(tmpInputDataSet);\n\n    if (tmpObjectType == 'object')\n    {\n        if (Array.isArray(tmpInputDataSet))\n        {\n            for (let i = 0; i < tmpInputDataSet.length; i++)\n            {\n                if (typeof(tmpInputDataSet[i]) !== 'object')\n                {\n                    pOperation.logInfo(`Element [${i}] was not an object; skipping group operation.`);\n                }\n                else\n                {\n                    let tmpValue = tmpInputDataSet[i];\n                    let tmpGroupByValue = tmpValue[tmpGroupByProperty];\n                    if (!tmpValue.hasOwnProperty(tmpGroupByProperty))\n                    {\n                        pOperation.logInfo(`Element [${i}] doesn't have the group by property [${tmpGroupByProperty}]; setting group to [__NO_GROUP].`);\n                        tmpGroupByValue = '__NO_GROUP';\n                    }\n\n                    if (!tmpValue.hasOwnProperty(tmpGroupValueProperty))\n                    {\n                        pOperation.logInfo(`Element [${i}] doesn't have the group value property [${tmpGroupValueProperty}]; skipping group operation.`);\n                    }\n                    else\n                    {\n                        if (!tmpOutputDataSet.hasOwnProperty(tmpGroupByValue))\n                        {\n                            // Create a new grouped value\n                            pOperation.logInfo(`Creating a new group [${tmpGroupByValue}] for element [${i}].`);\n                            tmpOutputDataSet[tmpGroupByValue] = [];\n                        }\n\n                        tmpOutputDataSet[tmpGroupByValue].push(tmpValue[tmpGroupValueProperty]);\n                    }\n                }\n            }\n        }\n        else\n        {\n            let tmpObjectKeys = Object.keys(tmpInputDataSet);\n            for (let i = 0; i < tmpObjectKeys.length; i++)\n            {\n                if (typeof(tmpInputDataSet[tmpObjectKeys[i]]) !== 'object')\n                {\n                    pOperation.logInfo(`Element [${i}] was not an object; skipping group operation.`);\n                }\n                else\n                {\n                    let tmpValue = tmpInputDataSet[tmpObjectKeys[i]];\n                    let tmpGroupByValue = tmpValue[tmpGroupByProperty];\n                    if (!tmpValue.hasOwnProperty(tmpGroupByProperty))\n                    {\n                        pOperation.logInfo(`Element [${tmpObjectKeys[i]}][${i}] doesn't have the group by property [${tmpGroupByProperty}]; setting group to [__NO_GROUP].`);\n                        tmpGroupByValue = '__NO_GROUP';\n                    }\n\n                    if (!tmpValue.hasOwnProperty(tmpGroupValueProperty))\n                    {\n                        pOperation.logInfo(`Element [${tmpObjectKeys[i]}][${i}] doesn't have the group value property [${tmpGroupValueProperty}]; skipping group operation.`);\n                    }\n                    else\n                    {\n                        if (!tmpOutputDataSet.hasOwnProperty(tmpGroupByValue))\n                        {\n                            // Create a new grouped value\n                            pOperation.logInfo(`Creating a new group [${tmpGroupByValue}] for element [${tmpObjectKeys[i]}][${i}].`);\n                            tmpOutputDataSet[tmpGroupByValue] = [];\n                        }\n\n                        tmpOutputDataSet[tmpGroupByValue].push(tmpValue[tmpGroupValueProperty]);\n                    }\n                }\n            }\n        }\n    }\n    else\n    {\n        pOperation.logError(`Input set is neither an Array nor an Object`);\n    }\n\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'outputDataSet', tmpOutputDataSet);\n\n    return true;\n}\n\nclass Set extends libElucidatorInstructionSet\n{\n    constructor(pElucidator)\n    {\n        super(pElucidator);\n        this.namespace = 'Set';\n    }\n\n    initializeInstructions()\n    {\n        // Logic actually wants a noop instruction!\n        super.initializeInstructions();\n\n        this.addInstruction('groupvaluesby', groupValuesBy);\n\n        return true;\n    }\n\n    initializeOperations()\n    {\n        this.addOperation('groupvaluesby', require(`./Operations/Set-GroupValuesBy.json`));\n\n        return true;\n    }\n}\n\nmodule.exports = Set;","// Solution providers are meant to be stateless, and not classes.\n// These solution providers are akin to drivers, connecting code libraries or \n// other types of behavior to mapping operations.\n\nlet libElucidatorInstructionSet = require('../Elucidator-InstructionSet.js');\n\nlet trim = (pOperation) =>\n{\n    let tmpInputString = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'inputString');\n\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'outputString', tmpInputString.trim());\n\n    return true;\n};\n\nlet replace = (pOperation) =>\n{\n    let tmpInputString = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'inputString');\n    let tmpSearchFor = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'searchFor');\n    let tmpReplaceWith = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'replaceWith');\n\n    pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'outputString', tmpInputString.replace(tmpSearchFor, tmpReplaceWith));\n\n    return true;\n};\n\nlet substring = (pOperation) =>\n{\n    let tmpInputString = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'inputString');\n    let indexStart = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'indexStart');\n    let indexEnd = pOperation.InputManyfest.getValueByHash(pOperation.InputObject, 'indexEnd');\n\n    if (indexEnd != null)\n    {\n        pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'outputString', tmpInputString.substring(indexStart, indexEnd));\n    }\n    else\n    {\n        pOperation.OutputManyfest.setValueByHash(pOperation.OutputObject, 'outputString', tmpInputString.substring(indexStart));\n    }\n\n    return true;\n};\n\nclass StringOperations extends libElucidatorInstructionSet\n{\n    constructor(pElucidator)\n    {\n        super(pElucidator);\n        this.namespace = 'String';\n    }\n\n    initializeInstructions()\n    {\n        this.addInstruction('trim', trim);\n        this.addInstruction('replace', replace);\n        this.addInstruction('substring', substring);\n\n        return true;\n    }\n\n    initializeOperations()\n    {\n        this.addOperation('trim', require(`./Operations/String-Trim.json`));\n        this.addOperation('replace', require(`./Operations/String-Replace.json`));\n        this.addOperation('substring', require(`./Operations/String-Substring.json`));\n\n        return true;\n    }\n}\n\nmodule.exports = StringOperations;"]}